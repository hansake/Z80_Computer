   1                    	;    1  /*  z80sdbt.c Boot and SD card test program.
   2                    	;    2   *
   3                    	;    3   *  Boot code for my DIY Z80 Computer. This
   4                    	;    4   *  program is compiled with Whitesmiths/COSMIC
   5                    	;    5   *  C compiler for Z80.
   6                    	;    6   *
   7                    	;    7   *  Initializes the hardware and detects the
   8                    	;    8   *  presence and partitioning of an attached SD card.
   9                    	;    9   *
  10                    	;   10   *  You are free to use, modify, and redistribute
  11                    	;   11   *  this source code. No warranties are given.
  12                    	;   12   *  Hastily Cobbled Together 2021 and 2022
  13                    	;   13   *  by Hans-Ake Lund
  14                    	;   14   *
  15                    	;   15   */
  16                    	;   16  
  17                    	;   17  #include <std.h>
  18                    	;   18  #include "z80computer.h"
  19                    	;   19  #include "builddate.h"
  20                    		.psect	_text
  21                    	_builddate:
  22    0000  62        		.byte	98
  23    0001  75        		.byte	117
  24    0002  69        		.byte	105
  25    0003  6C        		.byte	108
  26    0004  74        		.byte	116
  27    0005  20        		.byte	32
  28    0006  32        		.byte	50
  29    0007  30        		.byte	48
  30    0008  32        		.byte	50
  31    0009  32        		.byte	50
  32    000A  2D        		.byte	45
  33    000B  30        		.byte	48
  34    000C  32        		.byte	50
  35    000D  2D        		.byte	45
  36    000E  30        		.byte	48
  37    000F  32        		.byte	50
  38    0010  20        		.byte	32
  39    0011  31        		.byte	49
  40    0012  34        		.byte	52
  41    0013  3A        		.byte	58
  42    0014  31        		.byte	49
  43    0015  39        		.byte	57
  44    0016  00        		.byte	0
  45                    	;   20  
  46                    	;   21  /* Program name and version */
  47                    	;   22  #define PRGNAME "z80sdbt "
  48                    	;   23  #define VERSION "version 0.9, "
  49                    	;   24  /* Address in high RAM where to copy uploader */
  50                    	;   25  #define UPLADDR 0xf000
  51                    	;   26  
  52                    	;   27  /* This code should be cleaned up when
  53                    	;   28     remaining functions are implemented
  54                    	;   29   */
  55                    	;   30  #define PARTZRO 0  /* Empty partition entry */
  56                    	;   31  #define PARTMBR 1  /* MBR partition */
  57                    	;   32  #define PARTEBR 2  /* EBR logical partition */
  58                    	;   33  #define PARTGPT 3  /* GPT partition */
  59                    	;   34  #define EBRCONT 20 /* EBR container partition in MBR */
  60                    	;   35  
  61                    	;   36  struct partentry
  62                    	;   37      {
  63                    	;   38      char partype;
  64                    	;   39      char dskletter;
  65                    	;   40      int bootable;
  66                    	;   41      unsigned long dskstart;
  67                    	;   42      unsigned long dskend;
  68                    	;   43      unsigned long dsksize;
  69                    	;   44      unsigned char dsktype[16];
  70                    	;   45      } dskmap[16];
  71                    	;   46  
  72                    	;   47  unsigned char dsksign[4]; /* MBR/EBR disk signature */
  73                    	;   48  
  74                    	;   49  /* Function prototypes */
  75                    	;   50  void sdmbrpart(unsigned long);
  76                    	;   51  
  77                    	;   52  /* External data */
  78                    	;   53  extern const char upload[];
  79                    	;   54  extern const int upload_size;
  80                    	;   55  extern const int binsize;
  81                    	;   56  extern const int binstart;
  82                    	;   57  
  83                    	;   58  /* RAM/EPROM probe */
  84                    	;   59  const int ramprobe = 0;
  85                    	_ramprobe:
  86                    		.byte	[2]
  87                    	;   60  int *rampptr;
  88                    	;   61  
  89                    	;   62  /* Response length in bytes
  90                    	;   63   */
  91                    	;   64  #define R1_LEN 1
  92                    	;   65  #define R3_LEN 5
  93                    	;   66  #define R7_LEN 5
  94                    	;   67  
  95                    	;   68  /* The SD card commands (5 bytes) and a CRC7 byte as the last byte.
  96                    	;   69   * (The CRC7 byte in the tables below are only for information,
  97                    	;   70   * it is calculated by the sdcommand routine.)
  98                    	;   71   */
  99                    	;   72  const unsigned char cmd0[] = {0x40, 0x00, 0x00, 0x00, 0x00, 0x95};
 100                    	_cmd0:
 101    0019  40        		.byte	64
 102                    		.byte	[1]
 103                    		.byte	[1]
 104                    		.byte	[1]
 105                    		.byte	[1]
 106    001E  95        		.byte	149
 107                    	;   73  const unsigned char cmd8[] = {0x48, 0x00, 0x00, 0x01, 0xaa, 0x87};
 108                    	_cmd8:
 109    001F  48        		.byte	72
 110                    		.byte	[1]
 111                    		.byte	[1]
 112    0022  01        		.byte	1
 113    0023  AA        		.byte	170
 114    0024  87        		.byte	135
 115                    	;   74  const unsigned char cmd9[] = {0x49, 0x00, 0x00, 0x00, 0x00, 0xaf};
 116                    	_cmd9:
 117    0025  49        		.byte	73
 118                    		.byte	[1]
 119                    		.byte	[1]
 120                    		.byte	[1]
 121                    		.byte	[1]
 122    002A  AF        		.byte	175
 123                    	;   75  const unsigned char cmd10[] = {0x4a, 0x00, 0x00, 0x00, 0x00, 0x1b};
 124                    	_cmd10:
 125    002B  4A        		.byte	74
 126                    		.byte	[1]
 127                    		.byte	[1]
 128                    		.byte	[1]
 129                    		.byte	[1]
 130    0030  1B        		.byte	27
 131                    	;   76  const unsigned char cmd16[] = {0x50, 0x00, 0x00, 0x02, 0x00, 0x15};
 132                    	_cmd16:
 133    0031  50        		.byte	80
 134                    		.byte	[1]
 135                    		.byte	[1]
 136    0034  02        		.byte	2
 137                    		.byte	[1]
 138    0036  15        		.byte	21
 139                    	;   77  const unsigned char cmd17[] = {0x51, 0x00, 0x00, 0x00, 0x00, 0x55};
 140                    	_cmd17:
 141    0037  51        		.byte	81
 142                    		.byte	[1]
 143                    		.byte	[1]
 144                    		.byte	[1]
 145                    		.byte	[1]
 146    003C  55        		.byte	85
 147                    	;   78  const unsigned char cmd24[] = {0x58, 0x00, 0x00, 0x00, 0x00, 0x6f};
 148                    	_cmd24:
 149    003D  58        		.byte	88
 150                    		.byte	[1]
 151                    		.byte	[1]
 152                    		.byte	[1]
 153                    		.byte	[1]
 154    0042  6F        		.byte	111
 155                    	;   79  const unsigned char cmd55[] = {0x77, 0x00, 0x00, 0x00, 0x00, 0x65};
 156                    	_cmd55:
 157    0043  77        		.byte	119
 158                    		.byte	[1]
 159                    		.byte	[1]
 160                    		.byte	[1]
 161                    		.byte	[1]
 162    0048  65        		.byte	101
 163                    	;   80  const unsigned char cmd58[] = {0x7a, 0x00, 0x00, 0x00, 0x00, 0xfd};
 164                    	_cmd58:
 165    0049  7A        		.byte	122
 166                    		.byte	[1]
 167                    		.byte	[1]
 168                    		.byte	[1]
 169                    		.byte	[1]
 170    004E  FD        		.byte	253
 171                    	;   81  const unsigned char acmd41[] = {0x69, 0x40, 0x00, 0x01, 0xaa, 0x33};
 172                    	_acmd41:
 173    004F  69        		.byte	105
 174    0050  40        		.byte	64
 175                    		.byte	[1]
 176    0052  01        		.byte	1
 177    0053  AA        		.byte	170
 178    0054  33        		.byte	51
 179                    	;   82  
 180                    	;   83  /* Partition identifiers
 181                    	;   84   */
 182                    	;   85  /* For GPT I have decided that a CP/M partition
 183                    	;   86   * has GUID: AC7176FD-8D55-4FFF-86A5-A36D6368D0CB
 184                    	;   87   */
 185                    	;   88  const unsigned char gptcpm[] =
 186                    	;   89      {
 187                    	_gptcpm:
 188                    	;   90      0xfd, 0x76, 0x71, 0xac, 0x55, 0x8d, 0xff, 0x4f,
 189    0055  FD        		.byte	253
 190    0056  76        		.byte	118
 191    0057  71        		.byte	113
 192    0058  AC        		.byte	172
 193    0059  55        		.byte	85
 194    005A  8D        		.byte	141
 195    005B  FF        		.byte	255
 196    005C  4F        		.byte	79
 197                    	;   91      0x86, 0xa5, 0xa3, 0x6d, 0x63, 0x68, 0xd0, 0xcb
 198    005D  86        		.byte	134
 199    005E  A5        		.byte	165
 200    005F  A3        		.byte	163
 201    0060  6D        		.byte	109
 202    0061  63        		.byte	99
 203    0062  68        		.byte	104
 204    0063  D0        		.byte	208
 205                    	;   92      };
 206    0064  CB        		.byte	203
 207                    	;   93  /* For MBR/EBR the partition type for CP/M is 0x52
 208                    	;   94   * according to: https://en.wikipedia.org/wiki/Partition_type
 209                    	;   95   */
 210                    	;   96  const unsigned char mbrcpm = 0x52;    /* CP/M partition */
 211                    	_mbrcpm:
 212    0065  52        		.byte	82
 213                    	;   97  const unsigned char mbrexcode = 0x5f; /* Z80 executable code partition */
 214                    	_mbrexcode:
 215    0066  5F        		.byte	95
 216                    	;   98  /* has a special format that */
 217                    	;   99  /* includes number of sectors to */
 218                    	;  100  /* load and a signature, TBD */
 219                    	;  101  
 220                    	;  102  /* Buffers
 221                    	;  103   */
 222                    	;  104  unsigned char sdrdbuf[512];  /* recieved data from the SD card */
 223                    	;  105  
 224                    	;  106  unsigned char ocrreg[4];     /* SD card OCR register */
 225                    	;  107  unsigned char cidreg[16];    /* SD card CID register */
 226                    	;  108  unsigned char csdreg[16];    /* SD card CSD register */
 227                    	;  109  unsigned long ebrrecs[4];    /* detected EBR records to process */
 228                    	;  110  int ebrrecidx; /* how many EBR records that are populated */
 229                    	;  111  unsigned long ebrnext; /* next chained ebr record */
 230                    	;  112  
 231                    	;  113  /* Variables
 232                    	;  114   */
 233                    	;  115  int curblkok;  /* if YES curblockno is read into buffer */
 234                    	;  116  int partdsk;   /* partition/disk number, 0 = disk A */
 235                    	;  117  int sdinitok;  /* SD card initialized and ready */
 236                    	;  118  int sdver2;    /* SD card version 2 if YES, version 1 if NO */
 237                    	;  119  unsigned long blkmult;   /* block address multiplier */
 238                    	;  120  unsigned long curblkno;  /* block in buffer if curblkok == YES */
 239                    	;  121  
 240                    	;  122  /* debug bool */
 241                    	;  123  int sdtestflg;
 242                    	;  124  
 243                    	;  125  /* CRC routines from:
 244                    	;  126   * https://github.com/LonelyWolf/stm32/blob/master/stm32l-dosfs/sdcard.c
 245                    	;  127   */
 246                    	;  128  
 247                    	;  129  /*
 248                    	;  130  // Calculate CRC7
 249                    	;  131  // It's a 7 bit CRC with polynomial x^7 + x^3 + 1
 250                    	;  132  // input:
 251                    	;  133  //   crcIn - the CRC before (0 for first step)
 252                    	;  134  //   data - byte for CRC calculation
 253                    	;  135  // return: the new CRC7
 254                    	;  136  */
 255                    	;  137  unsigned char CRC7_one(unsigned char crcIn, unsigned char data)
 256                    	;  138      {
 257                    	_CRC7_one:
 258    0067  CD0000    		call	c.savs
 259    006A  F5        		push	af
 260    006B  F5        		push	af
 261    006C  F5        		push	af
 262    006D  F5        		push	af
 263                    	;  139      const unsigned char g = 0x89;
 264    006E  DD36F989  		ld	(ix-7),137
 265                    	;  140      unsigned char i;
 266                    	;  141  
 267                    	;  142      crcIn ^= data;
 268    0072  DD7E04    		ld	a,(ix+4)
 269    0075  DDAE06    		xor	(ix+6)
 270    0078  DD7704    		ld	(ix+4),a
 271    007B  DD7E05    		ld	a,(ix+5)
 272    007E  DDAE07    		xor	(ix+7)
 273    0081  DD7705    		ld	(ix+5),a
 274                    	;  143      for (i = 0; i < 8; i++)
 275    0084  DD36F800  		ld	(ix-8),0
 276                    	L1:
 277    0088  DD7EF8    		ld	a,(ix-8)
 278    008B  FE08      		cp	8
 279    008D  302F      		jr	nc,L11
 280                    	;  144          {
 281                    	;  145          if (crcIn & 0x80) crcIn ^= g;
 282    008F  DD6E04    		ld	l,(ix+4)
 283    0092  DD6605    		ld	h,(ix+5)
 284    0095  CB7D      		bit	7,l
 285    0097  2813      		jr	z,L14
 286    0099  DD6EF9    		ld	l,(ix-7)
 287    009C  97        		sub	a
 288    009D  67        		ld	h,a
 289    009E  DD7E04    		ld	a,(ix+4)
 290    00A1  AD        		xor	l
 291    00A2  DD7704    		ld	(ix+4),a
 292    00A5  DD7E05    		ld	a,(ix+5)
 293    00A8  AC        		xor	h
 294    00A9  DD7705    		ld	(ix+5),a
 295                    	L14:
 296                    	;  146          crcIn <<= 1;
 297    00AC  DD6E04    		ld	l,(ix+4)
 298    00AF  DD6605    		ld	h,(ix+5)
 299    00B2  29        		add	hl,hl
 300    00B3  DD7504    		ld	(ix+4),l
 301    00B6  DD7405    		ld	(ix+5),h
 302                    	;  147          }
 303    00B9  DD34F8    		inc	(ix-8)
 304    00BC  18CA      		jr	L1
 305                    	L11:
 306                    	;  148  
 307                    	;  149      return crcIn;
 308    00BE  DD6E04    		ld	l,(ix+4)
 309    00C1  DD6605    		ld	h,(ix+5)
 310    00C4  4D        		ld	c,l
 311    00C5  44        		ld	b,h
 312    00C6  C30000    		jp	c.rets
 313                    	;  150      }
 314                    	;  151  
 315                    	;  152  /*
 316                    	;  153  // Calculate CRC16 CCITT
 317                    	;  154  // It's a 16 bit CRC with polynomial x^16 + x^12 + x^5 + 1
 318                    	;  155  // input:
 319                    	;  156  //   crcIn - the CRC before (0 for rist step)
 320                    	;  157  //   data - byte for CRC calculation
 321                    	;  158  // return: the CRC16 value
 322                    	;  159  */
 323                    	;  160  unsigned int CRC16_one(unsigned int crcIn, unsigned char data)
 324                    	;  161      {
 325                    	_CRC16_one:
 326    00C9  CD0000    		call	c.savs
 327                    	;  162      crcIn  = (unsigned char)(crcIn >> 8)|(crcIn << 8);
 328    00CC  DD6E04    		ld	l,(ix+4)
 329    00CF  DD6605    		ld	h,(ix+5)
 330    00D2  E5        		push	hl
 331    00D3  210800    		ld	hl,8
 332    00D6  E5        		push	hl
 333    00D7  CD0000    		call	c.ursh
 334    00DA  E1        		pop	hl
 335    00DB  E5        		push	hl
 336    00DC  DD6E04    		ld	l,(ix+4)
 337    00DF  DD6605    		ld	h,(ix+5)
 338    00E2  29        		add	hl,hl
 339    00E3  29        		add	hl,hl
 340    00E4  29        		add	hl,hl
 341    00E5  29        		add	hl,hl
 342    00E6  29        		add	hl,hl
 343    00E7  29        		add	hl,hl
 344    00E8  29        		add	hl,hl
 345    00E9  29        		add	hl,hl
 346    00EA  C1        		pop	bc
 347    00EB  79        		ld	a,c
 348    00EC  B5        		or	l
 349    00ED  4F        		ld	c,a
 350    00EE  78        		ld	a,b
 351    00EF  B4        		or	h
 352    00F0  47        		ld	b,a
 353    00F1  DD7104    		ld	(ix+4),c
 354    00F4  DD7005    		ld	(ix+5),b
 355                    	;  163      crcIn ^=  data;
 356    00F7  DD7E04    		ld	a,(ix+4)
 357    00FA  DDAE06    		xor	(ix+6)
 358    00FD  DD7704    		ld	(ix+4),a
 359    0100  DD7E05    		ld	a,(ix+5)
 360    0103  DDAE07    		xor	(ix+7)
 361    0106  DD7705    		ld	(ix+5),a
 362                    	;  164      crcIn ^= (unsigned char)(crcIn & 0xff) >> 4;
 363    0109  DD6E04    		ld	l,(ix+4)
 364    010C  DD6605    		ld	h,(ix+5)
 365    010F  7D        		ld	a,l
 366    0110  E6FF      		and	255
 367    0112  6F        		ld	l,a
 368    0113  97        		sub	a
 369    0114  67        		ld	h,a
 370    0115  4D        		ld	c,l
 371    0116  97        		sub	a
 372    0117  47        		ld	b,a
 373    0118  C5        		push	bc
 374    0119  210400    		ld	hl,4
 375    011C  E5        		push	hl
 376    011D  CD0000    		call	c.irsh
 377    0120  E1        		pop	hl
 378    0121  DD7E04    		ld	a,(ix+4)
 379    0124  AD        		xor	l
 380    0125  DD7704    		ld	(ix+4),a
 381    0128  DD7E05    		ld	a,(ix+5)
 382    012B  AC        		xor	h
 383    012C  DD7705    		ld	(ix+5),a
 384                    	;  165      crcIn ^= (crcIn << 8) << 4;
 385    012F  DD6E04    		ld	l,(ix+4)
 386    0132  DD6605    		ld	h,(ix+5)
 387    0135  29        		add	hl,hl
 388    0136  29        		add	hl,hl
 389    0137  29        		add	hl,hl
 390    0138  29        		add	hl,hl
 391    0139  29        		add	hl,hl
 392    013A  29        		add	hl,hl
 393    013B  29        		add	hl,hl
 394    013C  29        		add	hl,hl
 395    013D  29        		add	hl,hl
 396    013E  29        		add	hl,hl
 397    013F  29        		add	hl,hl
 398    0140  29        		add	hl,hl
 399    0141  DD7E04    		ld	a,(ix+4)
 400    0144  AD        		xor	l
 401    0145  DD7704    		ld	(ix+4),a
 402    0148  DD7E05    		ld	a,(ix+5)
 403    014B  AC        		xor	h
 404    014C  DD7705    		ld	(ix+5),a
 405                    	;  166      crcIn ^= ((crcIn & 0xff) << 4) << 1;
 406    014F  DD6E04    		ld	l,(ix+4)
 407    0152  DD6605    		ld	h,(ix+5)
 408    0155  7D        		ld	a,l
 409    0156  E6FF      		and	255
 410    0158  6F        		ld	l,a
 411    0159  97        		sub	a
 412    015A  67        		ld	h,a
 413    015B  29        		add	hl,hl
 414    015C  29        		add	hl,hl
 415    015D  29        		add	hl,hl
 416    015E  29        		add	hl,hl
 417    015F  29        		add	hl,hl
 418    0160  DD7E04    		ld	a,(ix+4)
 419    0163  AD        		xor	l
 420    0164  DD7704    		ld	(ix+4),a
 421    0167  DD7E05    		ld	a,(ix+5)
 422    016A  AC        		xor	h
 423    016B  DD7705    		ld	(ix+5),a
 424                    	;  167  
 425                    	;  168      return crcIn;
 426    016E  DD4E04    		ld	c,(ix+4)
 427    0171  DD4605    		ld	b,(ix+5)
 428    0174  C30000    		jp	c.rets
 429                    	;  169      }
 430                    	;  170  
 431                    	;  171  /* Send command to SD card and recieve answer.
 432                    	;  172   * A command is 5 bytes long and is followed by
 433                    	;  173   * a CRC7 checksum byte.
 434                    	;  174   * Returns a pointer to the response
 435                    	;  175   * or 0 if no response start bit found.
 436                    	;  176   */
 437                    	;  177  unsigned char *sdcommand(unsigned char *sdcmdp,
 438                    	;  178                           unsigned char *recbuf, int recbytes)
 439                    	;  179      {
 440                    	_sdcommand:
 441    0177  CD0000    		call	c.savs
 442    017A  21F2FF    		ld	hl,65522
 443    017D  39        		add	hl,sp
 444    017E  F9        		ld	sp,hl
 445                    	;  180      int searchn;  /* byte counter to search for response */
 446                    	;  181      int sdcbytes; /* byte counter for bytes to send */
 447                    	;  182      unsigned char *retptr; /* pointer used to store response */
 448                    	;  183      unsigned char rbyte;   /* recieved byte */
 449                    	;  184      unsigned char crc = 0; /* calculated CRC7 */
 450    017F  DD36F200  		ld	(ix-14),0
 451                    	;  185  
 452                    	;  186      /* send 8*2 clockpules */
 453                    	;  187      spiio(0xff);
 454    0183  21FF00    		ld	hl,255
 455    0186  CD0000    		call	_spiio
 456                    	;  188      spiio(0xff);
 457    0189  21FF00    		ld	hl,255
 458    018C  CD0000    		call	_spiio
 459                    	;  189      for (sdcbytes = 5; 0 < sdcbytes; sdcbytes--) /* send bytes */
 460    018F  DD36F605  		ld	(ix-10),5
 461    0193  DD36F700  		ld	(ix-9),0
 462                    	L15:
 463    0197  97        		sub	a
 464    0198  DD96F6    		sub	(ix-10)
 465    019B  3E00      		ld	a,0
 466    019D  DD9EF7    		sbc	a,(ix-9)
 467    01A0  F2DC01    		jp	p,L16
 468                    	;  190          {
 469                    	;  191          crc = CRC7_one(crc, *sdcmdp);
 470    01A3  DD6E04    		ld	l,(ix+4)
 471    01A6  DD6605    		ld	h,(ix+5)
 472    01A9  6E        		ld	l,(hl)
 473    01AA  97        		sub	a
 474    01AB  67        		ld	h,a
 475    01AC  E5        		push	hl
 476    01AD  DD6EF2    		ld	l,(ix-14)
 477    01B0  97        		sub	a
 478    01B1  67        		ld	h,a
 479    01B2  CD6700    		call	_CRC7_one
 480    01B5  F1        		pop	af
 481    01B6  DD71F2    		ld	(ix-14),c
 482                    	;  192          spiio(*sdcmdp++);
 483    01B9  DD6E04    		ld	l,(ix+4)
 484    01BC  DD6605    		ld	h,(ix+5)
 485    01BF  DD3404    		inc	(ix+4)
 486    01C2  2003      		jr	nz,L01
 487    01C4  DD3405    		inc	(ix+5)
 488                    	L01:
 489    01C7  6E        		ld	l,(hl)
 490    01C8  97        		sub	a
 491    01C9  67        		ld	h,a
 492    01CA  CD0000    		call	_spiio
 493                    	;  193          }
 494    01CD  DD6EF6    		ld	l,(ix-10)
 495    01D0  DD66F7    		ld	h,(ix-9)
 496    01D3  2B        		dec	hl
 497    01D4  DD75F6    		ld	(ix-10),l
 498    01D7  DD74F7    		ld	(ix-9),h
 499    01DA  18BB      		jr	L15
 500                    	L16:
 501                    	;  194      spiio(crc | 0x01);
 502    01DC  DD6EF2    		ld	l,(ix-14)
 503    01DF  97        		sub	a
 504    01E0  67        		ld	h,a
 505    01E1  CBC5      		set	0,l
 506    01E3  CD0000    		call	_spiio
 507                    	;  195      /* search for recieved byte with start bit
 508                    	;  196         for a maximum of 10 recieved bytes  */
 509                    	;  197      for (searchn = 10; 0 < searchn; searchn--)
 510    01E6  DD36F80A  		ld	(ix-8),10
 511    01EA  DD36F900  		ld	(ix-7),0
 512                    	L111:
 513    01EE  97        		sub	a
 514    01EF  DD96F8    		sub	(ix-8)
 515    01F2  3E00      		ld	a,0
 516    01F4  DD9EF9    		sbc	a,(ix-7)
 517    01F7  F21902    		jp	p,L121
 518                    	;  198          {
 519                    	;  199          rbyte = spiio(0xff);
 520    01FA  21FF00    		ld	hl,255
 521    01FD  CD0000    		call	_spiio
 522    0200  DD71F3    		ld	(ix-13),c
 523                    	;  200          if ((rbyte & 0x80) == 0)
 524    0203  DD6EF3    		ld	l,(ix-13)
 525    0206  CB7D      		bit	7,l
 526    0208  280F      		jr	z,L121
 527                    	;  201              break;
 528                    	L131:
 529    020A  DD6EF8    		ld	l,(ix-8)
 530    020D  DD66F9    		ld	h,(ix-7)
 531    0210  2B        		dec	hl
 532    0211  DD75F8    		ld	(ix-8),l
 533    0214  DD74F9    		ld	(ix-7),h
 534    0217  18D5      		jr	L111
 535                    	L121:
 536                    	;  202          }
 537                    	;  203      if (searchn == 0) /* no start bit found */
 538    0219  DD7EF8    		ld	a,(ix-8)
 539    021C  DDB6F9    		or	(ix-7)
 540    021F  2006      		jr	nz,L161
 541                    	;  204          return (NO);
 542    0221  010000    		ld	bc,0
 543    0224  C30000    		jp	c.rets
 544                    	L161:
 545                    	;  205      retptr = recbuf;
 546    0227  DD7E06    		ld	a,(ix+6)
 547    022A  DD77F4    		ld	(ix-12),a
 548    022D  DD7E07    		ld	a,(ix+7)
 549    0230  DD77F5    		ld	(ix-11),a
 550                    	;  206      *retptr++ = rbyte;
 551    0233  DD6EF4    		ld	l,(ix-12)
 552    0236  DD66F5    		ld	h,(ix-11)
 553    0239  DD34F4    		inc	(ix-12)
 554    023C  2003      		jr	nz,L21
 555    023E  DD34F5    		inc	(ix-11)
 556                    	L21:
 557    0241  DD7EF3    		ld	a,(ix-13)
 558    0244  77        		ld	(hl),a
 559                    	L171:
 560                    	;  207      for (; 1 < recbytes; recbytes--) /* recieve bytes */
 561    0245  3E01      		ld	a,1
 562    0247  DD9608    		sub	(ix+8)
 563    024A  3E00      		ld	a,0
 564    024C  DD9E09    		sbc	a,(ix+9)
 565    024F  F27802    		jp	p,L102
 566                    	;  208          *retptr++ = spiio(0xff);
 567    0252  DD6EF4    		ld	l,(ix-12)
 568    0255  DD66F5    		ld	h,(ix-11)
 569    0258  DD34F4    		inc	(ix-12)
 570    025B  2003      		jr	nz,L41
 571    025D  DD34F5    		inc	(ix-11)
 572                    	L41:
 573    0260  E5        		push	hl
 574    0261  21FF00    		ld	hl,255
 575    0264  CD0000    		call	_spiio
 576    0267  E1        		pop	hl
 577    0268  71        		ld	(hl),c
 578    0269  DD6E08    		ld	l,(ix+8)
 579    026C  DD6609    		ld	h,(ix+9)
 580    026F  2B        		dec	hl
 581    0270  DD7508    		ld	(ix+8),l
 582    0273  DD7409    		ld	(ix+9),h
 583    0276  18CD      		jr	L171
 584                    	L102:
 585                    	;  209      return (recbuf);
 586    0278  DD4E06    		ld	c,(ix+6)
 587    027B  DD4607    		ld	b,(ix+7)
 588    027E  C30000    		jp	c.rets
 589                    	L51:
 590    0281  0A        		.byte	10
 591    0282  53        		.byte	83
 592    0283  65        		.byte	101
 593    0284  6E        		.byte	110
 594    0285  74        		.byte	116
 595    0286  20        		.byte	32
 596    0287  38        		.byte	56
 597    0288  2A        		.byte	42
 598    0289  38        		.byte	56
 599    028A  20        		.byte	32
 600    028B  28        		.byte	40
 601    028C  37        		.byte	55
 602    028D  32        		.byte	50
 603    028E  29        		.byte	41
 604    028F  20        		.byte	32
 605    0290  63        		.byte	99
 606    0291  6C        		.byte	108
 607    0292  6F        		.byte	111
 608    0293  63        		.byte	99
 609    0294  6B        		.byte	107
 610    0295  20        		.byte	32
 611    0296  70        		.byte	112
 612    0297  75        		.byte	117
 613    0298  6C        		.byte	108
 614    0299  73        		.byte	115
 615    029A  65        		.byte	101
 616    029B  73        		.byte	115
 617    029C  2C        		.byte	44
 618    029D  20        		.byte	32
 619    029E  73        		.byte	115
 620    029F  65        		.byte	101
 621    02A0  6C        		.byte	108
 622    02A1  65        		.byte	101
 623    02A2  63        		.byte	99
 624    02A3  74        		.byte	116
 625    02A4  20        		.byte	32
 626    02A5  6E        		.byte	110
 627    02A6  6F        		.byte	111
 628    02A7  74        		.byte	116
 629    02A8  20        		.byte	32
 630    02A9  61        		.byte	97
 631    02AA  63        		.byte	99
 632    02AB  74        		.byte	116
 633    02AC  69        		.byte	105
 634    02AD  76        		.byte	118
 635    02AE  65        		.byte	101
 636    02AF  0A        		.byte	10
 637    02B0  00        		.byte	0
 638                    	L52:
 639    02B1  43        		.byte	67
 640    02B2  4D        		.byte	77
 641    02B3  44        		.byte	68
 642    02B4  30        		.byte	48
 643    02B5  3A        		.byte	58
 644    02B6  20        		.byte	32
 645    02B7  6E        		.byte	110
 646    02B8  6F        		.byte	111
 647    02B9  20        		.byte	32
 648    02BA  72        		.byte	114
 649    02BB  65        		.byte	101
 650    02BC  73        		.byte	115
 651    02BD  70        		.byte	112
 652    02BE  6F        		.byte	111
 653    02BF  6E        		.byte	110
 654    02C0  73        		.byte	115
 655    02C1  65        		.byte	101
 656    02C2  0A        		.byte	10
 657    02C3  00        		.byte	0
 658                    	L53:
 659    02C4  43        		.byte	67
 660    02C5  4D        		.byte	77
 661    02C6  44        		.byte	68
 662    02C7  30        		.byte	48
 663    02C8  3A        		.byte	58
 664    02C9  20        		.byte	32
 665    02CA  47        		.byte	71
 666    02CB  4F        		.byte	79
 667    02CC  5F        		.byte	95
 668    02CD  49        		.byte	73
 669    02CE  44        		.byte	68
 670    02CF  4C        		.byte	76
 671    02D0  45        		.byte	69
 672    02D1  5F        		.byte	95
 673    02D2  53        		.byte	83
 674    02D3  54        		.byte	84
 675    02D4  41        		.byte	65
 676    02D5  54        		.byte	84
 677    02D6  45        		.byte	69
 678    02D7  2C        		.byte	44
 679    02D8  20        		.byte	32
 680    02D9  52        		.byte	82
 681    02DA  31        		.byte	49
 682    02DB  20        		.byte	32
 683    02DC  72        		.byte	114
 684    02DD  65        		.byte	101
 685    02DE  73        		.byte	115
 686    02DF  70        		.byte	112
 687    02E0  6F        		.byte	111
 688    02E1  6E        		.byte	110
 689    02E2  73        		.byte	115
 690    02E3  65        		.byte	101
 691    02E4  20        		.byte	32
 692    02E5  5B        		.byte	91
 693    02E6  25        		.byte	37
 694    02E7  30        		.byte	48
 695    02E8  32        		.byte	50
 696    02E9  78        		.byte	120
 697    02EA  5D        		.byte	93
 698    02EB  0A        		.byte	10
 699    02EC  00        		.byte	0
 700                    	L54:
 701    02ED  43        		.byte	67
 702    02EE  4D        		.byte	77
 703    02EF  44        		.byte	68
 704    02F0  38        		.byte	56
 705    02F1  3A        		.byte	58
 706    02F2  20        		.byte	32
 707    02F3  6E        		.byte	110
 708    02F4  6F        		.byte	111
 709    02F5  20        		.byte	32
 710    02F6  72        		.byte	114
 711    02F7  65        		.byte	101
 712    02F8  73        		.byte	115
 713    02F9  70        		.byte	112
 714    02FA  6F        		.byte	111
 715    02FB  6E        		.byte	110
 716    02FC  73        		.byte	115
 717    02FD  65        		.byte	101
 718    02FE  0A        		.byte	10
 719    02FF  00        		.byte	0
 720                    	L55:
 721    0300  43        		.byte	67
 722    0301  4D        		.byte	77
 723    0302  44        		.byte	68
 724    0303  38        		.byte	56
 725    0304  3A        		.byte	58
 726    0305  20        		.byte	32
 727    0306  53        		.byte	83
 728    0307  45        		.byte	69
 729    0308  4E        		.byte	78
 730    0309  44        		.byte	68
 731    030A  5F        		.byte	95
 732    030B  49        		.byte	73
 733    030C  46        		.byte	70
 734    030D  5F        		.byte	95
 735    030E  43        		.byte	67
 736    030F  4F        		.byte	79
 737    0310  4E        		.byte	78
 738    0311  44        		.byte	68
 739    0312  2C        		.byte	44
 740    0313  20        		.byte	32
 741    0314  52        		.byte	82
 742    0315  37        		.byte	55
 743    0316  20        		.byte	32
 744    0317  72        		.byte	114
 745    0318  65        		.byte	101
 746    0319  73        		.byte	115
 747    031A  70        		.byte	112
 748    031B  6F        		.byte	111
 749    031C  6E        		.byte	110
 750    031D  73        		.byte	115
 751    031E  65        		.byte	101
 752    031F  20        		.byte	32
 753    0320  5B        		.byte	91
 754    0321  25        		.byte	37
 755    0322  30        		.byte	48
 756    0323  32        		.byte	50
 757    0324  78        		.byte	120
 758    0325  20        		.byte	32
 759    0326  25        		.byte	37
 760    0327  30        		.byte	48
 761    0328  32        		.byte	50
 762    0329  78        		.byte	120
 763    032A  20        		.byte	32
 764    032B  25        		.byte	37
 765    032C  30        		.byte	48
 766    032D  32        		.byte	50
 767    032E  78        		.byte	120
 768    032F  20        		.byte	32
 769    0330  25        		.byte	37
 770    0331  30        		.byte	48
 771    0332  32        		.byte	50
 772    0333  78        		.byte	120
 773    0334  20        		.byte	32
 774    0335  25        		.byte	37
 775    0336  30        		.byte	48
 776    0337  32        		.byte	50
 777    0338  78        		.byte	120
 778    0339  5D        		.byte	93
 779    033A  2C        		.byte	44
 780    033B  20        		.byte	32
 781    033C  00        		.byte	0
 782                    	L56:
 783    033D  65        		.byte	101
 784    033E  63        		.byte	99
 785    033F  68        		.byte	104
 786    0340  6F        		.byte	111
 787    0341  20        		.byte	32
 788    0342  62        		.byte	98
 789    0343  61        		.byte	97
 790    0344  63        		.byte	99
 791    0345  6B        		.byte	107
 792    0346  20        		.byte	32
 793    0347  6F        		.byte	111
 794    0348  6B        		.byte	107
 795    0349  2C        		.byte	44
 796    034A  20        		.byte	32
 797    034B  00        		.byte	0
 798                    	L57:
 799    034C  69        		.byte	105
 800    034D  6E        		.byte	110
 801    034E  76        		.byte	118
 802    034F  61        		.byte	97
 803    0350  6C        		.byte	108
 804    0351  69        		.byte	105
 805    0352  64        		.byte	100
 806    0353  20        		.byte	32
 807    0354  65        		.byte	101
 808    0355  63        		.byte	99
 809    0356  68        		.byte	104
 810    0357  6F        		.byte	111
 811    0358  20        		.byte	32
 812    0359  62        		.byte	98
 813    035A  61        		.byte	97
 814    035B  63        		.byte	99
 815    035C  6B        		.byte	107
 816    035D  0A        		.byte	10
 817    035E  00        		.byte	0
 818                    	L501:
 819    035F  70        		.byte	112
 820    0360  72        		.byte	114
 821    0361  6F        		.byte	111
 822    0362  62        		.byte	98
 823    0363  61        		.byte	97
 824    0364  62        		.byte	98
 825    0365  6C        		.byte	108
 826    0366  79        		.byte	121
 827    0367  20        		.byte	32
 828    0368  53        		.byte	83
 829    0369  44        		.byte	68
 830    036A  20        		.byte	32
 831    036B  76        		.byte	118
 832    036C  65        		.byte	101
 833    036D  72        		.byte	114
 834    036E  2E        		.byte	46
 835    036F  20        		.byte	32
 836    0370  31        		.byte	49
 837    0371  0A        		.byte	10
 838    0372  00        		.byte	0
 839                    	L511:
 840    0373  53        		.byte	83
 841    0374  44        		.byte	68
 842    0375  20        		.byte	32
 843    0376  76        		.byte	118
 844    0377  65        		.byte	101
 845    0378  72        		.byte	114
 846    0379  20        		.byte	32
 847    037A  32        		.byte	50
 848    037B  0A        		.byte	10
 849    037C  00        		.byte	0
 850                    	L521:
 851    037D  43        		.byte	67
 852    037E  4D        		.byte	77
 853    037F  44        		.byte	68
 854    0380  35        		.byte	53
 855    0381  35        		.byte	53
 856    0382  3A        		.byte	58
 857    0383  20        		.byte	32
 858    0384  6E        		.byte	110
 859    0385  6F        		.byte	111
 860    0386  20        		.byte	32
 861    0387  72        		.byte	114
 862    0388  65        		.byte	101
 863    0389  73        		.byte	115
 864    038A  70        		.byte	112
 865    038B  6F        		.byte	111
 866    038C  6E        		.byte	110
 867    038D  73        		.byte	115
 868    038E  65        		.byte	101
 869    038F  0A        		.byte	10
 870    0390  00        		.byte	0
 871                    	L531:
 872    0391  43        		.byte	67
 873    0392  4D        		.byte	77
 874    0393  44        		.byte	68
 875    0394  35        		.byte	53
 876    0395  35        		.byte	53
 877    0396  3A        		.byte	58
 878    0397  20        		.byte	32
 879    0398  41        		.byte	65
 880    0399  50        		.byte	80
 881    039A  50        		.byte	80
 882    039B  5F        		.byte	95
 883    039C  43        		.byte	67
 884    039D  4D        		.byte	77
 885    039E  44        		.byte	68
 886    039F  2C        		.byte	44
 887    03A0  20        		.byte	32
 888    03A1  52        		.byte	82
 889    03A2  31        		.byte	49
 890    03A3  20        		.byte	32
 891    03A4  72        		.byte	114
 892    03A5  65        		.byte	101
 893    03A6  73        		.byte	115
 894    03A7  70        		.byte	112
 895    03A8  6F        		.byte	111
 896    03A9  6E        		.byte	110
 897    03AA  73        		.byte	115
 898    03AB  65        		.byte	101
 899    03AC  20        		.byte	32
 900    03AD  5B        		.byte	91
 901    03AE  25        		.byte	37
 902    03AF  30        		.byte	48
 903    03B0  32        		.byte	50
 904    03B1  78        		.byte	120
 905    03B2  5D        		.byte	93
 906    03B3  0A        		.byte	10
 907    03B4  00        		.byte	0
 908                    	L541:
 909    03B5  41        		.byte	65
 910    03B6  43        		.byte	67
 911    03B7  4D        		.byte	77
 912    03B8  44        		.byte	68
 913    03B9  34        		.byte	52
 914    03BA  31        		.byte	49
 915    03BB  3A        		.byte	58
 916    03BC  20        		.byte	32
 917    03BD  6E        		.byte	110
 918    03BE  6F        		.byte	111
 919    03BF  20        		.byte	32
 920    03C0  72        		.byte	114
 921    03C1  65        		.byte	101
 922    03C2  73        		.byte	115
 923    03C3  70        		.byte	112
 924    03C4  6F        		.byte	111
 925    03C5  6E        		.byte	110
 926    03C6  73        		.byte	115
 927    03C7  65        		.byte	101
 928    03C8  0A        		.byte	10
 929    03C9  00        		.byte	0
 930                    	L571:
 931                    		.byte	[1]
 932                    	L561:
 933    03CB  20        		.byte	32
 934    03CC  2D        		.byte	45
 935    03CD  20        		.byte	32
 936    03CE  72        		.byte	114
 937    03CF  65        		.byte	101
 938    03D0  61        		.byte	97
 939    03D1  64        		.byte	100
 940    03D2  79        		.byte	121
 941    03D3  00        		.byte	0
 942                    	L551:
 943    03D4  41        		.byte	65
 944    03D5  43        		.byte	67
 945    03D6  4D        		.byte	77
 946    03D7  44        		.byte	68
 947    03D8  34        		.byte	52
 948    03D9  31        		.byte	49
 949    03DA  3A        		.byte	58
 950    03DB  20        		.byte	32
 951    03DC  53        		.byte	83
 952    03DD  45        		.byte	69
 953    03DE  4E        		.byte	78
 954    03DF  44        		.byte	68
 955    03E0  5F        		.byte	95
 956    03E1  4F        		.byte	79
 957    03E2  50        		.byte	80
 958    03E3  5F        		.byte	95
 959    03E4  43        		.byte	67
 960    03E5  4F        		.byte	79
 961    03E6  4E        		.byte	78
 962    03E7  44        		.byte	68
 963    03E8  2C        		.byte	44
 964    03E9  20        		.byte	32
 965    03EA  52        		.byte	82
 966    03EB  31        		.byte	49
 967    03EC  20        		.byte	32
 968    03ED  72        		.byte	114
 969    03EE  65        		.byte	101
 970    03EF  73        		.byte	115
 971    03F0  70        		.byte	112
 972    03F1  6F        		.byte	111
 973    03F2  6E        		.byte	110
 974    03F3  73        		.byte	115
 975    03F4  65        		.byte	101
 976    03F5  20        		.byte	32
 977    03F6  5B        		.byte	91
 978    03F7  25        		.byte	37
 979    03F8  30        		.byte	48
 980    03F9  32        		.byte	50
 981    03FA  78        		.byte	120
 982    03FB  5D        		.byte	93
 983    03FC  25        		.byte	37
 984    03FD  73        		.byte	115
 985    03FE  0A        		.byte	10
 986    03FF  00        		.byte	0
 987                    	L502:
 988    0400  43        		.byte	67
 989    0401  4D        		.byte	77
 990    0402  44        		.byte	68
 991    0403  35        		.byte	53
 992    0404  38        		.byte	56
 993    0405  3A        		.byte	58
 994    0406  20        		.byte	32
 995    0407  6E        		.byte	110
 996    0408  6F        		.byte	111
 997    0409  20        		.byte	32
 998    040A  72        		.byte	114
 999    040B  65        		.byte	101
1000    040C  73        		.byte	115
1001    040D  70        		.byte	112
1002    040E  6F        		.byte	111
1003    040F  6E        		.byte	110
1004    0410  73        		.byte	115
1005    0411  65        		.byte	101
1006    0412  0A        		.byte	10
1007    0413  00        		.byte	0
1008                    	L512:
1009    0414  43        		.byte	67
1010    0415  4D        		.byte	77
1011    0416  44        		.byte	68
1012    0417  35        		.byte	53
1013    0418  38        		.byte	56
1014    0419  3A        		.byte	58
1015    041A  20        		.byte	32
1016    041B  52        		.byte	82
1017    041C  45        		.byte	69
1018    041D  41        		.byte	65
1019    041E  44        		.byte	68
1020    041F  5F        		.byte	95
1021    0420  4F        		.byte	79
1022    0421  43        		.byte	67
1023    0422  52        		.byte	82
1024    0423  2C        		.byte	44
1025    0424  20        		.byte	32
1026    0425  52        		.byte	82
1027    0426  33        		.byte	51
1028    0427  20        		.byte	32
1029    0428  72        		.byte	114
1030    0429  65        		.byte	101
1031    042A  73        		.byte	115
1032    042B  70        		.byte	112
1033    042C  6F        		.byte	111
1034    042D  6E        		.byte	110
1035    042E  73        		.byte	115
1036    042F  65        		.byte	101
1037    0430  20        		.byte	32
1038    0431  5B        		.byte	91
1039    0432  25        		.byte	37
1040    0433  30        		.byte	48
1041    0434  32        		.byte	50
1042    0435  78        		.byte	120
1043    0436  20        		.byte	32
1044    0437  25        		.byte	37
1045    0438  30        		.byte	48
1046    0439  32        		.byte	50
1047    043A  78        		.byte	120
1048    043B  20        		.byte	32
1049    043C  25        		.byte	37
1050    043D  30        		.byte	48
1051    043E  32        		.byte	50
1052    043F  78        		.byte	120
1053    0440  20        		.byte	32
1054    0441  25        		.byte	37
1055    0442  30        		.byte	48
1056    0443  32        		.byte	50
1057    0444  78        		.byte	120
1058    0445  20        		.byte	32
1059    0446  25        		.byte	37
1060    0447  30        		.byte	48
1061    0448  32        		.byte	50
1062    0449  78        		.byte	120
1063    044A  5D        		.byte	93
1064    044B  0A        		.byte	10
1065    044C  00        		.byte	0
1066                    	L522:
1067    044D  43        		.byte	67
1068    044E  4D        		.byte	77
1069    044F  44        		.byte	68
1070    0450  31        		.byte	49
1071    0451  36        		.byte	54
1072    0452  3A        		.byte	58
1073    0453  20        		.byte	32
1074    0454  6E        		.byte	110
1075    0455  6F        		.byte	111
1076    0456  20        		.byte	32
1077    0457  72        		.byte	114
1078    0458  65        		.byte	101
1079    0459  73        		.byte	115
1080    045A  70        		.byte	112
1081    045B  6F        		.byte	111
1082    045C  6E        		.byte	110
1083    045D  73        		.byte	115
1084    045E  65        		.byte	101
1085    045F  0A        		.byte	10
1086    0460  00        		.byte	0
1087                    	L532:
1088    0461  43        		.byte	67
1089    0462  4D        		.byte	77
1090    0463  44        		.byte	68
1091    0464  31        		.byte	49
1092    0465  36        		.byte	54
1093    0466  3A        		.byte	58
1094    0467  20        		.byte	32
1095    0468  53        		.byte	83
1096    0469  45        		.byte	69
1097    046A  54        		.byte	84
1098    046B  5F        		.byte	95
1099    046C  42        		.byte	66
1100    046D  4C        		.byte	76
1101    046E  4F        		.byte	79
1102    046F  43        		.byte	67
1103    0470  4B        		.byte	75
1104    0471  4C        		.byte	76
1105    0472  45        		.byte	69
1106    0473  4E        		.byte	78
1107    0474  20        		.byte	32
1108    0475  28        		.byte	40
1109    0476  74        		.byte	116
1110    0477  6F        		.byte	111
1111    0478  20        		.byte	32
1112    0479  35        		.byte	53
1113    047A  31        		.byte	49
1114    047B  32        		.byte	50
1115    047C  20        		.byte	32
1116    047D  62        		.byte	98
1117    047E  79        		.byte	121
1118    047F  74        		.byte	116
1119    0480  65        		.byte	101
1120    0481  73        		.byte	115
1121    0482  29        		.byte	41
1122    0483  2C        		.byte	44
1123    0484  20        		.byte	32
1124    0485  52        		.byte	82
1125    0486  31        		.byte	49
1126    0487  20        		.byte	32
1127    0488  72        		.byte	114
1128    0489  65        		.byte	101
1129    048A  73        		.byte	115
1130    048B  70        		.byte	112
1131    048C  6F        		.byte	111
1132    048D  6E        		.byte	110
1133    048E  73        		.byte	115
1134    048F  65        		.byte	101
1135    0490  20        		.byte	32
1136    0491  5B        		.byte	91
1137    0492  25        		.byte	37
1138    0493  30        		.byte	48
1139    0494  32        		.byte	50
1140    0495  78        		.byte	120
1141    0496  5D        		.byte	93
1142    0497  0A        		.byte	10
1143    0498  00        		.byte	0
1144                    	L542:
1145    0499  43        		.byte	67
1146    049A  4D        		.byte	77
1147    049B  44        		.byte	68
1148    049C  31        		.byte	49
1149    049D  30        		.byte	48
1150    049E  3A        		.byte	58
1151    049F  20        		.byte	32
1152    04A0  6E        		.byte	110
1153    04A1  6F        		.byte	111
1154    04A2  20        		.byte	32
1155    04A3  72        		.byte	114
1156    04A4  65        		.byte	101
1157    04A5  73        		.byte	115
1158    04A6  70        		.byte	112
1159    04A7  6F        		.byte	111
1160    04A8  6E        		.byte	110
1161    04A9  73        		.byte	115
1162    04AA  65        		.byte	101
1163    04AB  0A        		.byte	10
1164    04AC  00        		.byte	0
1165                    	L552:
1166    04AD  43        		.byte	67
1167    04AE  4D        		.byte	77
1168    04AF  44        		.byte	68
1169    04B0  31        		.byte	49
1170    04B1  30        		.byte	48
1171    04B2  3A        		.byte	58
1172    04B3  20        		.byte	32
1173    04B4  53        		.byte	83
1174    04B5  45        		.byte	69
1175    04B6  4E        		.byte	78
1176    04B7  44        		.byte	68
1177    04B8  5F        		.byte	95
1178    04B9  43        		.byte	67
1179    04BA  49        		.byte	73
1180    04BB  44        		.byte	68
1181    04BC  2C        		.byte	44
1182    04BD  20        		.byte	32
1183    04BE  52        		.byte	82
1184    04BF  31        		.byte	49
1185    04C0  20        		.byte	32
1186    04C1  72        		.byte	114
1187    04C2  65        		.byte	101
1188    04C3  73        		.byte	115
1189    04C4  70        		.byte	112
1190    04C5  6F        		.byte	111
1191    04C6  6E        		.byte	110
1192    04C7  73        		.byte	115
1193    04C8  65        		.byte	101
1194    04C9  20        		.byte	32
1195    04CA  5B        		.byte	91
1196    04CB  25        		.byte	37
1197    04CC  30        		.byte	48
1198    04CD  32        		.byte	50
1199    04CE  78        		.byte	120
1200    04CF  5D        		.byte	93
1201    04D0  0A        		.byte	10
1202    04D1  00        		.byte	0
1203                    	L562:
1204    04D2  20        		.byte	32
1205    04D3  20        		.byte	32
1206    04D4  4E        		.byte	78
1207    04D5  6F        		.byte	111
1208    04D6  20        		.byte	32
1209    04D7  64        		.byte	100
1210    04D8  61        		.byte	97
1211    04D9  74        		.byte	116
1212    04DA  61        		.byte	97
1213    04DB  20        		.byte	32
1214    04DC  66        		.byte	102
1215    04DD  6F        		.byte	111
1216    04DE  75        		.byte	117
1217    04DF  6E        		.byte	110
1218    04E0  64        		.byte	100
1219    04E1  0A        		.byte	10
1220    04E2  00        		.byte	0
1221                    	L572:
1222    04E3  20        		.byte	32
1223    04E4  20        		.byte	32
1224    04E5  43        		.byte	67
1225    04E6  49        		.byte	73
1226    04E7  44        		.byte	68
1227    04E8  3A        		.byte	58
1228    04E9  20        		.byte	32
1229    04EA  5B        		.byte	91
1230    04EB  00        		.byte	0
1231                    	L503:
1232    04EC  25        		.byte	37
1233    04ED  30        		.byte	48
1234    04EE  32        		.byte	50
1235    04EF  78        		.byte	120
1236    04F0  20        		.byte	32
1237    04F1  00        		.byte	0
1238                    	L513:
1239    04F2  08        		.byte	8
1240    04F3  5D        		.byte	93
1241    04F4  20        		.byte	32
1242    04F5  7C        		.byte	124
1243    04F6  00        		.byte	0
1244                    	L523:
1245    04F7  7C        		.byte	124
1246    04F8  0A        		.byte	10
1247    04F9  00        		.byte	0
1248                    	L533:
1249    04FA  43        		.byte	67
1250    04FB  52        		.byte	82
1251    04FC  43        		.byte	67
1252    04FD  37        		.byte	55
1253    04FE  20        		.byte	32
1254    04FF  6F        		.byte	111
1255    0500  6B        		.byte	107
1256    0501  3A        		.byte	58
1257    0502  20        		.byte	32
1258    0503  5B        		.byte	91
1259    0504  25        		.byte	37
1260    0505  30        		.byte	48
1261    0506  32        		.byte	50
1262    0507  78        		.byte	120
1263    0508  5D        		.byte	93
1264    0509  0A        		.byte	10
1265    050A  00        		.byte	0
1266                    	L543:
1267    050B  43        		.byte	67
1268    050C  52        		.byte	82
1269    050D  43        		.byte	67
1270    050E  37        		.byte	55
1271    050F  20        		.byte	32
1272    0510  65        		.byte	101
1273    0511  72        		.byte	114
1274    0512  72        		.byte	114
1275    0513  6F        		.byte	111
1276    0514  72        		.byte	114
1277    0515  2C        		.byte	44
1278    0516  20        		.byte	32
1279    0517  63        		.byte	99
1280    0518  61        		.byte	97
1281    0519  6C        		.byte	108
1282    051A  63        		.byte	99
1283    051B  75        		.byte	117
1284    051C  6C        		.byte	108
1285    051D  61        		.byte	97
1286    051E  74        		.byte	116
1287    051F  65        		.byte	101
1288    0520  64        		.byte	100
1289    0521  3A        		.byte	58
1290    0522  20        		.byte	32
1291    0523  5B        		.byte	91
1292    0524  25        		.byte	37
1293    0525  30        		.byte	48
1294    0526  32        		.byte	50
1295    0527  78        		.byte	120
1296    0528  5D        		.byte	93
1297    0529  2C        		.byte	44
1298    052A  20        		.byte	32
1299    052B  72        		.byte	114
1300    052C  65        		.byte	101
1301    052D  63        		.byte	99
1302    052E  69        		.byte	105
1303    052F  65        		.byte	101
1304    0530  76        		.byte	118
1305    0531  65        		.byte	101
1306    0532  64        		.byte	100
1307    0533  3A        		.byte	58
1308    0534  20        		.byte	32
1309    0535  5B        		.byte	91
1310    0536  25        		.byte	37
1311    0537  30        		.byte	48
1312    0538  32        		.byte	50
1313    0539  78        		.byte	120
1314    053A  5D        		.byte	93
1315    053B  0A        		.byte	10
1316    053C  00        		.byte	0
1317                    	L553:
1318    053D  43        		.byte	67
1319    053E  4D        		.byte	77
1320    053F  44        		.byte	68
1321    0540  39        		.byte	57
1322    0541  3A        		.byte	58
1323    0542  20        		.byte	32
1324    0543  6E        		.byte	110
1325    0544  6F        		.byte	111
1326    0545  20        		.byte	32
1327    0546  72        		.byte	114
1328    0547  65        		.byte	101
1329    0548  73        		.byte	115
1330    0549  70        		.byte	112
1331    054A  6F        		.byte	111
1332    054B  6E        		.byte	110
1333    054C  73        		.byte	115
1334    054D  65        		.byte	101
1335    054E  0A        		.byte	10
1336    054F  00        		.byte	0
1337                    	L563:
1338    0550  43        		.byte	67
1339    0551  4D        		.byte	77
1340    0552  44        		.byte	68
1341    0553  39        		.byte	57
1342    0554  3A        		.byte	58
1343    0555  20        		.byte	32
1344    0556  53        		.byte	83
1345    0557  45        		.byte	69
1346    0558  4E        		.byte	78
1347    0559  44        		.byte	68
1348    055A  5F        		.byte	95
1349    055B  43        		.byte	67
1350    055C  53        		.byte	83
1351    055D  44        		.byte	68
1352    055E  2C        		.byte	44
1353    055F  20        		.byte	32
1354    0560  52        		.byte	82
1355    0561  31        		.byte	49
1356    0562  20        		.byte	32
1357    0563  72        		.byte	114
1358    0564  65        		.byte	101
1359    0565  73        		.byte	115
1360    0566  70        		.byte	112
1361    0567  6F        		.byte	111
1362    0568  6E        		.byte	110
1363    0569  73        		.byte	115
1364    056A  65        		.byte	101
1365    056B  20        		.byte	32
1366    056C  5B        		.byte	91
1367    056D  25        		.byte	37
1368    056E  30        		.byte	48
1369    056F  32        		.byte	50
1370    0570  78        		.byte	120
1371    0571  5D        		.byte	93
1372    0572  0A        		.byte	10
1373    0573  00        		.byte	0
1374                    	L573:
1375    0574  20        		.byte	32
1376    0575  20        		.byte	32
1377    0576  4E        		.byte	78
1378    0577  6F        		.byte	111
1379    0578  20        		.byte	32
1380    0579  64        		.byte	100
1381    057A  61        		.byte	97
1382    057B  74        		.byte	116
1383    057C  61        		.byte	97
1384    057D  20        		.byte	32
1385    057E  66        		.byte	102
1386    057F  6F        		.byte	111
1387    0580  75        		.byte	117
1388    0581  6E        		.byte	110
1389    0582  64        		.byte	100
1390    0583  0A        		.byte	10
1391    0584  00        		.byte	0
1392                    	L504:
1393    0585  20        		.byte	32
1394    0586  20        		.byte	32
1395    0587  43        		.byte	67
1396    0588  53        		.byte	83
1397    0589  44        		.byte	68
1398    058A  3A        		.byte	58
1399    058B  20        		.byte	32
1400    058C  5B        		.byte	91
1401    058D  00        		.byte	0
1402                    	L514:
1403    058E  25        		.byte	37
1404    058F  30        		.byte	48
1405    0590  32        		.byte	50
1406    0591  78        		.byte	120
1407    0592  20        		.byte	32
1408    0593  00        		.byte	0
1409                    	L524:
1410    0594  08        		.byte	8
1411    0595  5D        		.byte	93
1412    0596  20        		.byte	32
1413    0597  7C        		.byte	124
1414    0598  00        		.byte	0
1415                    	L534:
1416    0599  7C        		.byte	124
1417    059A  0A        		.byte	10
1418    059B  00        		.byte	0
1419                    	L544:
1420    059C  43        		.byte	67
1421    059D  52        		.byte	82
1422    059E  43        		.byte	67
1423    059F  37        		.byte	55
1424    05A0  20        		.byte	32
1425    05A1  6F        		.byte	111
1426    05A2  6B        		.byte	107
1427    05A3  3A        		.byte	58
1428    05A4  20        		.byte	32
1429    05A5  5B        		.byte	91
1430    05A6  25        		.byte	37
1431    05A7  30        		.byte	48
1432    05A8  32        		.byte	50
1433    05A9  78        		.byte	120
1434    05AA  5D        		.byte	93
1435    05AB  0A        		.byte	10
1436    05AC  00        		.byte	0
1437                    	L554:
1438    05AD  43        		.byte	67
1439    05AE  52        		.byte	82
1440    05AF  43        		.byte	67
1441    05B0  37        		.byte	55
1442    05B1  20        		.byte	32
1443    05B2  65        		.byte	101
1444    05B3  72        		.byte	114
1445    05B4  72        		.byte	114
1446    05B5  6F        		.byte	111
1447    05B6  72        		.byte	114
1448    05B7  2C        		.byte	44
1449    05B8  20        		.byte	32
1450    05B9  63        		.byte	99
1451    05BA  61        		.byte	97
1452    05BB  6C        		.byte	108
1453    05BC  63        		.byte	99
1454    05BD  75        		.byte	117
1455    05BE  6C        		.byte	108
1456    05BF  61        		.byte	97
1457    05C0  74        		.byte	116
1458    05C1  65        		.byte	101
1459    05C2  64        		.byte	100
1460    05C3  3A        		.byte	58
1461    05C4  20        		.byte	32
1462    05C5  5B        		.byte	91
1463    05C6  25        		.byte	37
1464    05C7  30        		.byte	48
1465    05C8  32        		.byte	50
1466    05C9  78        		.byte	120
1467    05CA  5D        		.byte	93
1468    05CB  2C        		.byte	44
1469    05CC  20        		.byte	32
1470    05CD  72        		.byte	114
1471    05CE  65        		.byte	101
1472    05CF  63        		.byte	99
1473    05D0  69        		.byte	105
1474    05D1  65        		.byte	101
1475    05D2  76        		.byte	118
1476    05D3  65        		.byte	101
1477    05D4  64        		.byte	100
1478    05D5  3A        		.byte	58
1479    05D6  20        		.byte	32
1480    05D7  5B        		.byte	91
1481    05D8  25        		.byte	37
1482    05D9  30        		.byte	48
1483    05DA  32        		.byte	50
1484    05DB  78        		.byte	120
1485    05DC  5D        		.byte	93
1486    05DD  0A        		.byte	10
1487    05DE  00        		.byte	0
1488                    	L564:
1489    05DF  53        		.byte	83
1490    05E0  65        		.byte	101
1491    05E1  6E        		.byte	110
1492    05E2  74        		.byte	116
1493    05E3  20        		.byte	32
1494    05E4  39        		.byte	57
1495    05E5  2A        		.byte	42
1496    05E6  38        		.byte	56
1497    05E7  20        		.byte	32
1498    05E8  28        		.byte	40
1499    05E9  37        		.byte	55
1500    05EA  32        		.byte	50
1501    05EB  29        		.byte	41
1502    05EC  20        		.byte	32
1503    05ED  63        		.byte	99
1504    05EE  6C        		.byte	108
1505    05EF  6F        		.byte	111
1506    05F0  63        		.byte	99
1507    05F1  6B        		.byte	107
1508    05F2  20        		.byte	32
1509    05F3  70        		.byte	112
1510    05F4  75        		.byte	117
1511    05F5  6C        		.byte	108
1512    05F6  73        		.byte	115
1513    05F7  65        		.byte	101
1514    05F8  73        		.byte	115
1515    05F9  2C        		.byte	44
1516    05FA  20        		.byte	32
1517    05FB  73        		.byte	115
1518    05FC  65        		.byte	101
1519    05FD  6C        		.byte	108
1520    05FE  65        		.byte	101
1521    05FF  63        		.byte	99
1522    0600  74        		.byte	116
1523    0601  20        		.byte	32
1524    0602  61        		.byte	97
1525    0603  63        		.byte	99
1526    0604  74        		.byte	116
1527    0605  69        		.byte	105
1528    0606  76        		.byte	118
1529    0607  65        		.byte	101
1530    0608  0A        		.byte	10
1531    0609  00        		.byte	0
1532                    	;  210      }
1533                    	;  211  
1534                    	;  212  /* Initialise SD card interface
1535                    	;  213   *
1536                    	;  214   * returns YES if ok and NO if not ok
1537                    	;  215   *
1538                    	;  216   * References:
1539                    	;  217   *   https://www.sdcard.org/downloads/pls/
1540                    	;  218   *      Physical Layer Simplified Specification version 8.0
1541                    	;  219   *
1542                    	;  220   * A nice flowchart how to initialize:
1543                    	;  221   *   https://www.totalphase.com/blog/2018/08/set-sdc-mmc-cards-spi-mode-verify-files-successfully-programmed/
1544                    	;  222   *
1545                    	;  223   */
1546                    	;  224  int sdinit()
1547                    	;  225      {
1548                    	_sdinit:
1549    060A  CD0000    		call	c.savs0
1550    060D  21E4FF    		ld	hl,65508
1551    0610  39        		add	hl,sp
1552    0611  F9        		ld	sp,hl
1553                    	;  226      int nbytes;  /* byte counter */
1554                    	;  227      int tries;   /* tries to get to active state or searching for data  */
1555                    	;  228      int wtloop;  /* timer loop when trying to enter active state */
1556                    	;  229      unsigned char cmdbuf[5];   /* buffer to build command in */
1557                    	;  230      unsigned char rstatbuf[5]; /* buffer to recieve status in */
1558                    	;  231      unsigned char *statptr;    /* pointer to returned status from SD command */
1559                    	;  232      unsigned char crc;         /* crc register for CID and CSD */
1560                    	;  233      unsigned char rbyte;       /* recieved byte */
1561                    	;  234      unsigned char *prtptr;     /* for debug printing */
1562                    	;  235  
1563                    	;  236      ledon();
1564    0612  CD0000    		call	_ledon
1565                    	;  237      spideselect();
1566    0615  CD0000    		call	_spideselect
1567                    	;  238      sdinitok = NO;
1568    0618  210000    		ld	hl,0
1569    061B  220C00    		ld	(_sdinitok),hl
1570                    	;  239  
1571                    	;  240      /* start to generate 9*8 clock pulses with not selected SD card */
1572                    	;  241      for (nbytes = 9; 0 < nbytes; nbytes--)
1573    061E  DD36F809  		ld	(ix-8),9
1574    0622  DD36F900  		ld	(ix-7),0
1575                    	L132:
1576    0626  97        		sub	a
1577    0627  DD96F8    		sub	(ix-8)
1578    062A  3E00      		ld	a,0
1579    062C  DD9EF9    		sbc	a,(ix-7)
1580    062F  F24706    		jp	p,L142
1581                    	;  242          spiio(0xff);
1582    0632  21FF00    		ld	hl,255
1583    0635  CD0000    		call	_spiio
1584    0638  DD6EF8    		ld	l,(ix-8)
1585    063B  DD66F9    		ld	h,(ix-7)
1586    063E  2B        		dec	hl
1587    063F  DD75F8    		ld	(ix-8),l
1588    0642  DD74F9    		ld	(ix-7),h
1589    0645  18DF      		jr	L132
1590                    	L142:
1591                    	;  243      if (sdtestflg)
1592    0647  2A0000    		ld	hl,(_sdtestflg)
1593    064A  7C        		ld	a,h
1594    064B  B5        		or	l
1595    064C  2806      		jr	z,L172
1596                    	;  244          {
1597                    	;  245          printf("\nSent 8*8 (72) clock pulses, select not active\n");
1598    064E  218102    		ld	hl,L51
1599    0651  CD0000    		call	_printf
1600                    	L172:
1601                    	;  246          } /* sdtestflg */
1602                    	;  247      spiselect();
1603    0654  CD0000    		call	_spiselect
1604                    	;  248  
1605                    	;  249      /* CMD0: GO_IDLE_STATE */
1606                    	;  250      for (tries = 0; tries < 10; tries++)
1607    0657  DD36F600  		ld	(ix-10),0
1608    065B  DD36F700  		ld	(ix-9),0
1609                    	L103:
1610    065F  DD7EF6    		ld	a,(ix-10)
1611    0662  D60A      		sub	10
1612    0664  DD7EF7    		ld	a,(ix-9)
1613    0667  DE00      		sbc	a,0
1614    0669  F21F07    		jp	p,L113
1615                    	;  251          {
1616                    	;  252          memcpy(cmdbuf, cmd0, 5);
1617    066C  210500    		ld	hl,5
1618    066F  E5        		push	hl
1619    0670  211900    		ld	hl,_cmd0
1620    0673  E5        		push	hl
1621    0674  DDE5      		push	ix
1622    0676  C1        		pop	bc
1623    0677  21EFFF    		ld	hl,65519
1624    067A  09        		add	hl,bc
1625    067B  CD0000    		call	_memcpy
1626    067E  F1        		pop	af
1627    067F  F1        		pop	af
1628                    	;  253          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1629    0680  210100    		ld	hl,1
1630    0683  E5        		push	hl
1631    0684  DDE5      		push	ix
1632    0686  C1        		pop	bc
1633    0687  21EAFF    		ld	hl,65514
1634    068A  09        		add	hl,bc
1635    068B  E5        		push	hl
1636    068C  DDE5      		push	ix
1637    068E  C1        		pop	bc
1638    068F  21EFFF    		ld	hl,65519
1639    0692  09        		add	hl,bc
1640    0693  CD7701    		call	_sdcommand
1641    0696  F1        		pop	af
1642    0697  F1        		pop	af
1643    0698  DD71E8    		ld	(ix-24),c
1644    069B  DD70E9    		ld	(ix-23),b
1645                    	;  254          if (sdtestflg)
1646    069E  2A0000    		ld	hl,(_sdtestflg)
1647    06A1  7C        		ld	a,h
1648    06A2  B5        		or	l
1649    06A3  282C      		jr	z,L143
1650                    	;  255              {
1651                    	;  256              if (!statptr)
1652    06A5  DD7EE8    		ld	a,(ix-24)
1653    06A8  DDB6E9    		or	(ix-23)
1654    06AB  2013      		jr	nz,L153
1655                    	;  257                  printf("CMD0: no response\n");
1656    06AD  21B102    		ld	hl,L52
1657    06B0  CD0000    		call	_printf
1658                    	;  258              else
1659    06B3  181C      		jr	L143
1660                    	L123:
1661    06B5  DD34F6    		inc	(ix-10)
1662    06B8  2003      		jr	nz,L02
1663    06BA  DD34F7    		inc	(ix-9)
1664                    	L02:
1665    06BD  C35F06    		jp	L103
1666                    	L153:
1667                    	;  259                  printf("CMD0: GO_IDLE_STATE, R1 response [%02x]\n", statptr[0]);
1668    06C0  DD6EE8    		ld	l,(ix-24)
1669    06C3  DD66E9    		ld	h,(ix-23)
1670    06C6  4E        		ld	c,(hl)
1671    06C7  97        		sub	a
1672    06C8  47        		ld	b,a
1673    06C9  C5        		push	bc
1674    06CA  21C402    		ld	hl,L53
1675    06CD  CD0000    		call	_printf
1676    06D0  F1        		pop	af
1677                    	L143:
1678                    	;  260              } /* sdtestflg */
1679                    	;  261          if (!statptr)
1680    06D1  DD7EE8    		ld	a,(ix-24)
1681    06D4  DDB6E9    		or	(ix-23)
1682    06D7  200C      		jr	nz,L173
1683                    	;  262              {
1684                    	;  263              spideselect();
1685    06D9  CD0000    		call	_spideselect
1686                    	;  264              ledoff();
1687    06DC  CD0000    		call	_ledoff
1688                    	;  265              return (NO);
1689    06DF  010000    		ld	bc,0
1690    06E2  C30000    		jp	c.rets0
1691                    	L173:
1692                    	;  266              }
1693                    	;  267          if (statptr[0] == 0x01)
1694    06E5  DD6EE8    		ld	l,(ix-24)
1695    06E8  DD66E9    		ld	h,(ix-23)
1696    06EB  7E        		ld	a,(hl)
1697    06EC  FE01      		cp	1
1698    06EE  282F      		jr	z,L113
1699                    	;  268              break;
1700                    	;  269          for (wtloop = 0; wtloop < tries * 10; wtloop++)
1701    06F0  DD36F400  		ld	(ix-12),0
1702    06F4  DD36F500  		ld	(ix-11),0
1703                    	L114:
1704    06F8  DD6EF6    		ld	l,(ix-10)
1705    06FB  DD66F7    		ld	h,(ix-9)
1706    06FE  4D        		ld	c,l
1707    06FF  44        		ld	b,h
1708    0700  29        		add	hl,hl
1709    0701  29        		add	hl,hl
1710    0702  09        		add	hl,bc
1711    0703  29        		add	hl,hl
1712    0704  DD7EF4    		ld	a,(ix-12)
1713    0707  95        		sub	l
1714    0708  DD7EF5    		ld	a,(ix-11)
1715    070B  9C        		sbc	a,h
1716    070C  F2B506    		jp	p,L123
1717                    	;  270              {
1718                    	;  271              /* wait loop, time increasing for each try */
1719                    	;  272              spiio(0xff);
1720    070F  21FF00    		ld	hl,255
1721    0712  CD0000    		call	_spiio
1722                    	;  273              }
1723    0715  DD34F4    		inc	(ix-12)
1724    0718  2003      		jr	nz,L22
1725    071A  DD34F5    		inc	(ix-11)
1726                    	L22:
1727    071D  18D9      		jr	L114
1728                    	L113:
1729                    	;  274          }
1730                    	;  275  
1731                    	;  276      /* CMD8: SEND_IF_COND */
1732                    	;  277      memcpy(cmdbuf, cmd8, 5);
1733    071F  210500    		ld	hl,5
1734    0722  E5        		push	hl
1735    0723  211F00    		ld	hl,_cmd8
1736    0726  E5        		push	hl
1737    0727  DDE5      		push	ix
1738    0729  C1        		pop	bc
1739    072A  21EFFF    		ld	hl,65519
1740    072D  09        		add	hl,bc
1741    072E  CD0000    		call	_memcpy
1742    0731  F1        		pop	af
1743    0732  F1        		pop	af
1744                    	;  278      statptr = sdcommand(cmdbuf, rstatbuf, R7_LEN);
1745    0733  210500    		ld	hl,5
1746    0736  E5        		push	hl
1747    0737  DDE5      		push	ix
1748    0739  C1        		pop	bc
1749    073A  21EAFF    		ld	hl,65514
1750    073D  09        		add	hl,bc
1751    073E  E5        		push	hl
1752    073F  DDE5      		push	ix
1753    0741  C1        		pop	bc
1754    0742  21EFFF    		ld	hl,65519
1755    0745  09        		add	hl,bc
1756    0746  CD7701    		call	_sdcommand
1757    0749  F1        		pop	af
1758    074A  F1        		pop	af
1759    074B  DD71E8    		ld	(ix-24),c
1760    074E  DD70E9    		ld	(ix-23),b
1761                    	;  279      if (sdtestflg)
1762    0751  2A0000    		ld	hl,(_sdtestflg)
1763    0754  7C        		ld	a,h
1764    0755  B5        		or	l
1765    0756  CADD07    		jp	z,L154
1766                    	;  280          {
1767                    	;  281          if (!statptr)
1768    0759  DD7EE8    		ld	a,(ix-24)
1769    075C  DDB6E9    		or	(ix-23)
1770    075F  2009      		jr	nz,L164
1771                    	;  282              printf("CMD8: no response\n");
1772    0761  21ED02    		ld	hl,L54
1773    0764  CD0000    		call	_printf
1774                    	;  283          else
1775    0767  C3DD07    		jp	L154
1776                    	L164:
1777                    	;  284              {
1778                    	;  285              printf("CMD8: SEND_IF_COND, R7 response [%02x %02x %02x %02x %02x], ",
1779                    	;  286                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
1780    076A  DD6EE8    		ld	l,(ix-24)
1781    076D  DD66E9    		ld	h,(ix-23)
1782    0770  23        		inc	hl
1783    0771  23        		inc	hl
1784    0772  23        		inc	hl
1785    0773  23        		inc	hl
1786    0774  4E        		ld	c,(hl)
1787    0775  97        		sub	a
1788    0776  47        		ld	b,a
1789    0777  C5        		push	bc
1790    0778  DD6EE8    		ld	l,(ix-24)
1791    077B  DD66E9    		ld	h,(ix-23)
1792    077E  23        		inc	hl
1793    077F  23        		inc	hl
1794    0780  23        		inc	hl
1795    0781  4E        		ld	c,(hl)
1796    0782  97        		sub	a
1797    0783  47        		ld	b,a
1798    0784  C5        		push	bc
1799    0785  DD6EE8    		ld	l,(ix-24)
1800    0788  DD66E9    		ld	h,(ix-23)
1801    078B  23        		inc	hl
1802    078C  23        		inc	hl
1803    078D  4E        		ld	c,(hl)
1804    078E  97        		sub	a
1805    078F  47        		ld	b,a
1806    0790  C5        		push	bc
1807    0791  DD6EE8    		ld	l,(ix-24)
1808    0794  DD66E9    		ld	h,(ix-23)
1809    0797  23        		inc	hl
1810    0798  4E        		ld	c,(hl)
1811    0799  97        		sub	a
1812    079A  47        		ld	b,a
1813    079B  C5        		push	bc
1814    079C  DD6EE8    		ld	l,(ix-24)
1815    079F  DD66E9    		ld	h,(ix-23)
1816    07A2  4E        		ld	c,(hl)
1817    07A3  97        		sub	a
1818    07A4  47        		ld	b,a
1819    07A5  C5        		push	bc
1820    07A6  210003    		ld	hl,L55
1821    07A9  CD0000    		call	_printf
1822    07AC  210A00    		ld	hl,10
1823    07AF  39        		add	hl,sp
1824    07B0  F9        		ld	sp,hl
1825                    	;  287              if (!(statptr[0] & 0xfe)) /* no error */
1826    07B1  DD6EE8    		ld	l,(ix-24)
1827    07B4  DD66E9    		ld	h,(ix-23)
1828    07B7  6E        		ld	l,(hl)
1829    07B8  97        		sub	a
1830    07B9  67        		ld	h,a
1831    07BA  CB85      		res	0,l
1832    07BC  7D        		ld	a,l
1833    07BD  B4        		or	h
1834    07BE  201D      		jr	nz,L154
1835                    	;  288                  {
1836                    	;  289                  if (statptr[4] == 0xaa)
1837    07C0  DD6EE8    		ld	l,(ix-24)
1838    07C3  DD66E9    		ld	h,(ix-23)
1839    07C6  23        		inc	hl
1840    07C7  23        		inc	hl
1841    07C8  23        		inc	hl
1842    07C9  23        		inc	hl
1843    07CA  7E        		ld	a,(hl)
1844    07CB  FEAA      		cp	170
1845    07CD  2008      		jr	nz,L115
1846                    	;  290                      printf("echo back ok, ");
1847    07CF  213D03    		ld	hl,L56
1848    07D2  CD0000    		call	_printf
1849                    	;  291                  else
1850    07D5  1806      		jr	L154
1851                    	L115:
1852                    	;  292                      printf("invalid echo back\n");
1853    07D7  214C03    		ld	hl,L57
1854    07DA  CD0000    		call	_printf
1855                    	L154:
1856                    	;  293                  }
1857                    	;  294              }
1858                    	;  295          } /* sdtestflg */
1859                    	;  296      if (!statptr || (statptr[0] & 0xfe)) /* if no answer or error */
1860    07DD  DD7EE8    		ld	a,(ix-24)
1861    07E0  DDB6E9    		or	(ix-23)
1862    07E3  280F      		jr	z,L145
1863    07E5  DD6EE8    		ld	l,(ix-24)
1864    07E8  DD66E9    		ld	h,(ix-23)
1865    07EB  6E        		ld	l,(hl)
1866    07EC  97        		sub	a
1867    07ED  67        		ld	h,a
1868    07EE  CB85      		res	0,l
1869    07F0  7D        		ld	a,l
1870    07F1  B4        		or	h
1871    07F2  2815      		jr	z,L135
1872                    	L145:
1873                    	;  297          {
1874                    	;  298          sdver2 = NO;
1875    07F4  210000    		ld	hl,0
1876    07F7  220A00    		ld	(_sdver2),hl
1877                    	;  299          if (sdtestflg)
1878    07FA  2A0000    		ld	hl,(_sdtestflg)
1879    07FD  7C        		ld	a,h
1880    07FE  B5        		or	l
1881    07FF  2836      		jr	z,L165
1882                    	;  300              {
1883                    	;  301              printf("probably SD ver. 1\n");
1884    0801  215F03    		ld	hl,L501
1885    0804  CD0000    		call	_printf
1886    0807  182E      		jr	L165
1887                    	L135:
1888                    	;  302              } /* sdtestflg */
1889                    	;  303          }
1890                    	;  304      else
1891                    	;  305          {
1892                    	;  306          sdver2 = YES;
1893    0809  210100    		ld	hl,1
1894    080C  220A00    		ld	(_sdver2),hl
1895                    	;  307          if (statptr[4] != 0xaa) /* but invalid echo back */
1896    080F  DD6EE8    		ld	l,(ix-24)
1897    0812  DD66E9    		ld	h,(ix-23)
1898    0815  23        		inc	hl
1899    0816  23        		inc	hl
1900    0817  23        		inc	hl
1901    0818  23        		inc	hl
1902    0819  7E        		ld	a,(hl)
1903    081A  FEAA      		cp	170
1904    081C  280C      		jr	z,L175
1905                    	;  308              {
1906                    	;  309              spideselect();
1907    081E  CD0000    		call	_spideselect
1908                    	;  310              ledoff();
1909    0821  CD0000    		call	_ledoff
1910                    	;  311              return (NO);
1911    0824  010000    		ld	bc,0
1912    0827  C30000    		jp	c.rets0
1913                    	L175:
1914                    	;  312              }
1915                    	;  313          if (sdtestflg)
1916    082A  2A0000    		ld	hl,(_sdtestflg)
1917    082D  7C        		ld	a,h
1918    082E  B5        		or	l
1919    082F  2806      		jr	z,L165
1920                    	;  314              {
1921                    	;  315              printf("SD ver 2\n");
1922    0831  217303    		ld	hl,L511
1923    0834  CD0000    		call	_printf
1924                    	L165:
1925                    	;  316              } /* sdtestflg */
1926                    	;  317          }
1927                    	;  318  
1928                    	;  319      /* CMD55: APP_CMD followed by ACMD41: SEND_OP_COND until status is 0x00 */
1929                    	;  320      for (tries = 0; tries < 20; tries++)
1930    0837  DD36F600  		ld	(ix-10),0
1931    083B  DD36F700  		ld	(ix-9),0
1932                    	L116:
1933    083F  DD7EF6    		ld	a,(ix-10)
1934    0842  D614      		sub	20
1935    0844  DD7EF7    		ld	a,(ix-9)
1936    0847  DE00      		sbc	a,0
1937    0849  F29109    		jp	p,L126
1938                    	;  321          {
1939                    	;  322          memcpy(cmdbuf, cmd55, 5);
1940    084C  210500    		ld	hl,5
1941    084F  E5        		push	hl
1942    0850  214300    		ld	hl,_cmd55
1943    0853  E5        		push	hl
1944    0854  DDE5      		push	ix
1945    0856  C1        		pop	bc
1946    0857  21EFFF    		ld	hl,65519
1947    085A  09        		add	hl,bc
1948    085B  CD0000    		call	_memcpy
1949    085E  F1        		pop	af
1950    085F  F1        		pop	af
1951                    	;  323          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1952    0860  210100    		ld	hl,1
1953    0863  E5        		push	hl
1954    0864  DDE5      		push	ix
1955    0866  C1        		pop	bc
1956    0867  21EAFF    		ld	hl,65514
1957    086A  09        		add	hl,bc
1958    086B  E5        		push	hl
1959    086C  DDE5      		push	ix
1960    086E  C1        		pop	bc
1961    086F  21EFFF    		ld	hl,65519
1962    0872  09        		add	hl,bc
1963    0873  CD7701    		call	_sdcommand
1964    0876  F1        		pop	af
1965    0877  F1        		pop	af
1966    0878  DD71E8    		ld	(ix-24),c
1967    087B  DD70E9    		ld	(ix-23),b
1968                    	;  324          if (sdtestflg)
1969    087E  2A0000    		ld	hl,(_sdtestflg)
1970    0881  7C        		ld	a,h
1971    0882  B5        		or	l
1972    0883  282C      		jr	z,L156
1973                    	;  325              {
1974                    	;  326              if (!statptr)
1975    0885  DD7EE8    		ld	a,(ix-24)
1976    0888  DDB6E9    		or	(ix-23)
1977    088B  2013      		jr	nz,L166
1978                    	;  327                  printf("CMD55: no response\n");
1979    088D  217D03    		ld	hl,L521
1980    0890  CD0000    		call	_printf
1981                    	;  328              else
1982    0893  181C      		jr	L156
1983                    	L136:
1984    0895  DD34F6    		inc	(ix-10)
1985    0898  2003      		jr	nz,L42
1986    089A  DD34F7    		inc	(ix-9)
1987                    	L42:
1988    089D  C33F08    		jp	L116
1989                    	L166:
1990                    	;  329                  printf("CMD55: APP_CMD, R1 response [%02x]\n", statptr[0]);
1991    08A0  DD6EE8    		ld	l,(ix-24)
1992    08A3  DD66E9    		ld	h,(ix-23)
1993    08A6  4E        		ld	c,(hl)
1994    08A7  97        		sub	a
1995    08A8  47        		ld	b,a
1996    08A9  C5        		push	bc
1997    08AA  219103    		ld	hl,L531
1998    08AD  CD0000    		call	_printf
1999    08B0  F1        		pop	af
2000                    	L156:
2001                    	;  330              } /* sdtestflg */
2002                    	;  331          if (!statptr)
2003    08B1  DD7EE8    		ld	a,(ix-24)
2004    08B4  DDB6E9    		or	(ix-23)
2005    08B7  200C      		jr	nz,L107
2006                    	;  332              {
2007                    	;  333              spideselect();
2008    08B9  CD0000    		call	_spideselect
2009                    	;  334              ledoff();
2010    08BC  CD0000    		call	_ledoff
2011                    	;  335              return (NO);
2012    08BF  010000    		ld	bc,0
2013    08C2  C30000    		jp	c.rets0
2014                    	L107:
2015                    	;  336              }
2016                    	;  337          memcpy(cmdbuf, acmd41, 5);
2017    08C5  210500    		ld	hl,5
2018    08C8  E5        		push	hl
2019    08C9  214F00    		ld	hl,_acmd41
2020    08CC  E5        		push	hl
2021    08CD  DDE5      		push	ix
2022    08CF  C1        		pop	bc
2023    08D0  21EFFF    		ld	hl,65519
2024    08D3  09        		add	hl,bc
2025    08D4  CD0000    		call	_memcpy
2026    08D7  F1        		pop	af
2027    08D8  F1        		pop	af
2028                    	;  338          if (sdver2)
2029    08D9  2A0A00    		ld	hl,(_sdver2)
2030    08DC  7C        		ld	a,h
2031    08DD  B5        		or	l
2032    08DE  2806      		jr	z,L117
2033                    	;  339              cmdbuf[1] = 0x40;
2034    08E0  DD36F040  		ld	(ix-16),64
2035                    	;  340          else
2036    08E4  1804      		jr	L127
2037                    	L117:
2038                    	;  341              cmdbuf[1] = 0x00;
2039    08E6  DD36F000  		ld	(ix-16),0
2040                    	L127:
2041                    	;  342          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2042    08EA  210100    		ld	hl,1
2043    08ED  E5        		push	hl
2044    08EE  DDE5      		push	ix
2045    08F0  C1        		pop	bc
2046    08F1  21EAFF    		ld	hl,65514
2047    08F4  09        		add	hl,bc
2048    08F5  E5        		push	hl
2049    08F6  DDE5      		push	ix
2050    08F8  C1        		pop	bc
2051    08F9  21EFFF    		ld	hl,65519
2052    08FC  09        		add	hl,bc
2053    08FD  CD7701    		call	_sdcommand
2054    0900  F1        		pop	af
2055    0901  F1        		pop	af
2056    0902  DD71E8    		ld	(ix-24),c
2057    0905  DD70E9    		ld	(ix-23),b
2058                    	;  343          if (sdtestflg)
2059    0908  2A0000    		ld	hl,(_sdtestflg)
2060    090B  7C        		ld	a,h
2061    090C  B5        		or	l
2062    090D  2835      		jr	z,L137
2063                    	;  344              {
2064                    	;  345              if (!statptr)
2065    090F  DD7EE8    		ld	a,(ix-24)
2066    0912  DDB6E9    		or	(ix-23)
2067    0915  2008      		jr	nz,L147
2068                    	;  346                  printf("ACMD41: no response\n");
2069    0917  21B503    		ld	hl,L541
2070    091A  CD0000    		call	_printf
2071                    	;  347              else
2072    091D  1825      		jr	L137
2073                    	L147:
2074                    	;  348                  printf("ACMD41: SEND_OP_COND, R1 response [%02x]%s\n",
2075                    	;  349                         statptr[0], (statptr[0] == 0x00) ? " - ready" : "");
2076    091F  DD6EE8    		ld	l,(ix-24)
2077    0922  DD66E9    		ld	h,(ix-23)
2078    0925  7E        		ld	a,(hl)
2079    0926  B7        		or	a
2080    0927  2005      		jr	nz,L62
2081    0929  01CB03    		ld	bc,L561
2082    092C  1803      		jr	L03
2083                    	L62:
2084    092E  01CA03    		ld	bc,L571
2085                    	L03:
2086    0931  C5        		push	bc
2087    0932  DD6EE8    		ld	l,(ix-24)
2088    0935  DD66E9    		ld	h,(ix-23)
2089    0938  4E        		ld	c,(hl)
2090    0939  97        		sub	a
2091    093A  47        		ld	b,a
2092    093B  C5        		push	bc
2093    093C  21D403    		ld	hl,L551
2094    093F  CD0000    		call	_printf
2095    0942  F1        		pop	af
2096    0943  F1        		pop	af
2097                    	L137:
2098                    	;  350              } /* sdtestflg */
2099                    	;  351          if (!statptr)
2100    0944  DD7EE8    		ld	a,(ix-24)
2101    0947  DDB6E9    		or	(ix-23)
2102    094A  200C      		jr	nz,L167
2103                    	;  352              {
2104                    	;  353              spideselect();
2105    094C  CD0000    		call	_spideselect
2106                    	;  354              ledoff();
2107    094F  CD0000    		call	_ledoff
2108                    	;  355              return (NO);
2109    0952  010000    		ld	bc,0
2110    0955  C30000    		jp	c.rets0
2111                    	L167:
2112                    	;  356              }
2113                    	;  357          if (statptr[0] == 0x00) /* now the SD card is ready */
2114    0958  DD6EE8    		ld	l,(ix-24)
2115    095B  DD66E9    		ld	h,(ix-23)
2116    095E  7E        		ld	a,(hl)
2117    095F  B7        		or	a
2118    0960  282F      		jr	z,L126
2119                    	;  358              {
2120                    	;  359              break;
2121                    	;  360              }
2122                    	;  361          for (wtloop = 0; wtloop < tries * 10; wtloop++)
2123    0962  DD36F400  		ld	(ix-12),0
2124    0966  DD36F500  		ld	(ix-11),0
2125                    	L1001:
2126    096A  DD6EF6    		ld	l,(ix-10)
2127    096D  DD66F7    		ld	h,(ix-9)
2128    0970  4D        		ld	c,l
2129    0971  44        		ld	b,h
2130    0972  29        		add	hl,hl
2131    0973  29        		add	hl,hl
2132    0974  09        		add	hl,bc
2133    0975  29        		add	hl,hl
2134    0976  DD7EF4    		ld	a,(ix-12)
2135    0979  95        		sub	l
2136    097A  DD7EF5    		ld	a,(ix-11)
2137    097D  9C        		sbc	a,h
2138    097E  F29508    		jp	p,L136
2139                    	;  362              {
2140                    	;  363              /* wait loop, time increasing for each try */
2141                    	;  364              spiio(0xff);
2142    0981  21FF00    		ld	hl,255
2143    0984  CD0000    		call	_spiio
2144                    	;  365              }
2145    0987  DD34F4    		inc	(ix-12)
2146    098A  2003      		jr	nz,L23
2147    098C  DD34F5    		inc	(ix-11)
2148                    	L23:
2149    098F  18D9      		jr	L1001
2150                    	L126:
2151                    	;  366          }
2152                    	;  367  
2153                    	;  368      /* CMD58: READ_OCR */
2154                    	;  369      /* According to the flow chart this should not work
2155                    	;  370         for SD ver. 1 but the response is ok anyway
2156                    	;  371         all tested SD cards  */
2157                    	;  372      memcpy(cmdbuf, cmd58, 5);
2158    0991  210500    		ld	hl,5
2159    0994  E5        		push	hl
2160    0995  214900    		ld	hl,_cmd58
2161    0998  E5        		push	hl
2162    0999  DDE5      		push	ix
2163    099B  C1        		pop	bc
2164    099C  21EFFF    		ld	hl,65519
2165    099F  09        		add	hl,bc
2166    09A0  CD0000    		call	_memcpy
2167    09A3  F1        		pop	af
2168    09A4  F1        		pop	af
2169                    	;  373      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
2170    09A5  210500    		ld	hl,5
2171    09A8  E5        		push	hl
2172    09A9  DDE5      		push	ix
2173    09AB  C1        		pop	bc
2174    09AC  21EAFF    		ld	hl,65514
2175    09AF  09        		add	hl,bc
2176    09B0  E5        		push	hl
2177    09B1  DDE5      		push	ix
2178    09B3  C1        		pop	bc
2179    09B4  21EFFF    		ld	hl,65519
2180    09B7  09        		add	hl,bc
2181    09B8  CD7701    		call	_sdcommand
2182    09BB  F1        		pop	af
2183    09BC  F1        		pop	af
2184    09BD  DD71E8    		ld	(ix-24),c
2185    09C0  DD70E9    		ld	(ix-23),b
2186                    	;  374      if (sdtestflg)
2187    09C3  2A0000    		ld	hl,(_sdtestflg)
2188    09C6  7C        		ld	a,h
2189    09C7  B5        		or	l
2190    09C8  CA230A    		jp	z,L1401
2191                    	;  375          {
2192                    	;  376          if (!statptr)
2193    09CB  DD7EE8    		ld	a,(ix-24)
2194    09CE  DDB6E9    		or	(ix-23)
2195    09D1  2009      		jr	nz,L1501
2196                    	;  377              printf("CMD58: no response\n");
2197    09D3  210004    		ld	hl,L502
2198    09D6  CD0000    		call	_printf
2199                    	;  378          else
2200    09D9  C3230A    		jp	L1401
2201                    	L1501:
2202                    	;  379              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
2203                    	;  380                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
2204    09DC  DD6EE8    		ld	l,(ix-24)
2205    09DF  DD66E9    		ld	h,(ix-23)
2206    09E2  23        		inc	hl
2207    09E3  23        		inc	hl
2208    09E4  23        		inc	hl
2209    09E5  23        		inc	hl
2210    09E6  4E        		ld	c,(hl)
2211    09E7  97        		sub	a
2212    09E8  47        		ld	b,a
2213    09E9  C5        		push	bc
2214    09EA  DD6EE8    		ld	l,(ix-24)
2215    09ED  DD66E9    		ld	h,(ix-23)
2216    09F0  23        		inc	hl
2217    09F1  23        		inc	hl
2218    09F2  23        		inc	hl
2219    09F3  4E        		ld	c,(hl)
2220    09F4  97        		sub	a
2221    09F5  47        		ld	b,a
2222    09F6  C5        		push	bc
2223    09F7  DD6EE8    		ld	l,(ix-24)
2224    09FA  DD66E9    		ld	h,(ix-23)
2225    09FD  23        		inc	hl
2226    09FE  23        		inc	hl
2227    09FF  4E        		ld	c,(hl)
2228    0A00  97        		sub	a
2229    0A01  47        		ld	b,a
2230    0A02  C5        		push	bc
2231    0A03  DD6EE8    		ld	l,(ix-24)
2232    0A06  DD66E9    		ld	h,(ix-23)
2233    0A09  23        		inc	hl
2234    0A0A  4E        		ld	c,(hl)
2235    0A0B  97        		sub	a
2236    0A0C  47        		ld	b,a
2237    0A0D  C5        		push	bc
2238    0A0E  DD6EE8    		ld	l,(ix-24)
2239    0A11  DD66E9    		ld	h,(ix-23)
2240    0A14  4E        		ld	c,(hl)
2241    0A15  97        		sub	a
2242    0A16  47        		ld	b,a
2243    0A17  C5        		push	bc
2244    0A18  211404    		ld	hl,L512
2245    0A1B  CD0000    		call	_printf
2246    0A1E  210A00    		ld	hl,10
2247    0A21  39        		add	hl,sp
2248    0A22  F9        		ld	sp,hl
2249                    	L1401:
2250                    	;  381          } /* sdtestflg */
2251                    	;  382      if (!statptr)
2252    0A23  DD7EE8    		ld	a,(ix-24)
2253    0A26  DDB6E9    		or	(ix-23)
2254    0A29  200C      		jr	nz,L1701
2255                    	;  383          {
2256                    	;  384          spideselect();
2257    0A2B  CD0000    		call	_spideselect
2258                    	;  385          ledoff();
2259    0A2E  CD0000    		call	_ledoff
2260                    	;  386          return (NO);
2261    0A31  010000    		ld	bc,0
2262    0A34  C30000    		jp	c.rets0
2263                    	L1701:
2264                    	;  387          }
2265                    	;  388      memcpy(&ocrreg[0], &statptr[1], sizeof (ocrreg));
2266    0A37  210400    		ld	hl,4
2267    0A3A  E5        		push	hl
2268    0A3B  DD6EE8    		ld	l,(ix-24)
2269    0A3E  DD66E9    		ld	h,(ix-23)
2270    0A41  23        		inc	hl
2271    0A42  E5        		push	hl
2272    0A43  214800    		ld	hl,_ocrreg
2273    0A46  CD0000    		call	_memcpy
2274    0A49  F1        		pop	af
2275    0A4A  F1        		pop	af
2276                    	;  389      blkmult = 1; /* assume block address */
2277    0A4B  3E01      		ld	a,1
2278    0A4D  320800    		ld	(_blkmult+2),a
2279    0A50  87        		add	a,a
2280    0A51  9F        		sbc	a,a
2281    0A52  320900    		ld	(_blkmult+3),a
2282    0A55  320700    		ld	(_blkmult+1),a
2283    0A58  320600    		ld	(_blkmult),a
2284                    	;  390      if (ocrreg[0] & 0x80)
2285    0A5B  3A4800    		ld	a,(_ocrreg)
2286    0A5E  CB7F      		bit	7,a
2287    0A60  6F        		ld	l,a
2288    0A61  2817      		jr	z,L1011
2289                    	;  391          {
2290                    	;  392          /* SD Ver.2+ */
2291                    	;  393          if (!(ocrreg[0] & 0x40))
2292    0A63  3A4800    		ld	a,(_ocrreg)
2293    0A66  CB77      		bit	6,a
2294    0A68  6F        		ld	l,a
2295    0A69  200F      		jr	nz,L1011
2296                    	;  394              {
2297                    	;  395              /* SD Ver.2+, Byte address */
2298                    	;  396              blkmult = 512;
2299    0A6B  97        		sub	a
2300    0A6C  320600    		ld	(_blkmult),a
2301    0A6F  320700    		ld	(_blkmult+1),a
2302    0A72  320800    		ld	(_blkmult+2),a
2303    0A75  3E02      		ld	a,2
2304    0A77  320900    		ld	(_blkmult+3),a
2305                    	L1011:
2306                    	;  397              }
2307                    	;  398          }
2308                    	;  399  
2309                    	;  400      /* CMD 16: SET_BLOCKLEN, only if Byte addressing */
2310                    	;  401      if (blkmult == 512)
2311    0A7A  210600    		ld	hl,_blkmult
2312    0A7D  E5        		push	hl
2313    0A7E  97        		sub	a
2314    0A7F  320000    		ld	(c.r0),a
2315    0A82  320100    		ld	(c.r0+1),a
2316    0A85  320200    		ld	(c.r0+2),a
2317    0A88  3E02      		ld	a,2
2318    0A8A  320300    		ld	(c.r0+3),a
2319    0A8D  210000    		ld	hl,c.r0
2320    0A90  E5        		push	hl
2321    0A91  CD0000    		call	c.lcmp
2322    0A94  C2050B    		jp	nz,L1211
2323                    	;  402          {
2324                    	;  403          memcpy(cmdbuf, cmd16, 5);
2325    0A97  210500    		ld	hl,5
2326    0A9A  E5        		push	hl
2327    0A9B  213100    		ld	hl,_cmd16
2328    0A9E  E5        		push	hl
2329    0A9F  DDE5      		push	ix
2330    0AA1  C1        		pop	bc
2331    0AA2  21EFFF    		ld	hl,65519
2332    0AA5  09        		add	hl,bc
2333    0AA6  CD0000    		call	_memcpy
2334    0AA9  F1        		pop	af
2335    0AAA  F1        		pop	af
2336                    	;  404          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2337    0AAB  210100    		ld	hl,1
2338    0AAE  E5        		push	hl
2339    0AAF  DDE5      		push	ix
2340    0AB1  C1        		pop	bc
2341    0AB2  21EAFF    		ld	hl,65514
2342    0AB5  09        		add	hl,bc
2343    0AB6  E5        		push	hl
2344    0AB7  DDE5      		push	ix
2345    0AB9  C1        		pop	bc
2346    0ABA  21EFFF    		ld	hl,65519
2347    0ABD  09        		add	hl,bc
2348    0ABE  CD7701    		call	_sdcommand
2349    0AC1  F1        		pop	af
2350    0AC2  F1        		pop	af
2351    0AC3  DD71E8    		ld	(ix-24),c
2352    0AC6  DD70E9    		ld	(ix-23),b
2353                    	;  405          if (sdtestflg)
2354    0AC9  2A0000    		ld	hl,(_sdtestflg)
2355    0ACC  7C        		ld	a,h
2356    0ACD  B5        		or	l
2357    0ACE  2821      		jr	z,L1311
2358                    	;  406              {
2359                    	;  407              if (!statptr)
2360    0AD0  DD7EE8    		ld	a,(ix-24)
2361    0AD3  DDB6E9    		or	(ix-23)
2362    0AD6  2008      		jr	nz,L1411
2363                    	;  408                  printf("CMD16: no response\n");
2364    0AD8  214D04    		ld	hl,L522
2365    0ADB  CD0000    		call	_printf
2366                    	;  409              else
2367    0ADE  1811      		jr	L1311
2368                    	L1411:
2369                    	;  410                  printf("CMD16: SET_BLOCKLEN (to 512 bytes), R1 response [%02x]\n",
2370                    	;  411                         statptr[0]);
2371    0AE0  DD6EE8    		ld	l,(ix-24)
2372    0AE3  DD66E9    		ld	h,(ix-23)
2373    0AE6  4E        		ld	c,(hl)
2374    0AE7  97        		sub	a
2375    0AE8  47        		ld	b,a
2376    0AE9  C5        		push	bc
2377    0AEA  216104    		ld	hl,L532
2378    0AED  CD0000    		call	_printf
2379    0AF0  F1        		pop	af
2380                    	L1311:
2381                    	;  412              } /* sdtestflg */
2382                    	;  413          if (!statptr)
2383    0AF1  DD7EE8    		ld	a,(ix-24)
2384    0AF4  DDB6E9    		or	(ix-23)
2385    0AF7  200C      		jr	nz,L1211
2386                    	;  414              {
2387                    	;  415              spideselect();
2388    0AF9  CD0000    		call	_spideselect
2389                    	;  416              ledoff();
2390    0AFC  CD0000    		call	_ledoff
2391                    	;  417              return (NO);
2392    0AFF  010000    		ld	bc,0
2393    0B02  C30000    		jp	c.rets0
2394                    	L1211:
2395                    	;  418              }
2396                    	;  419          }
2397                    	;  420      /* Register information:
2398                    	;  421       *   https://www.cameramemoryspeed.com/sd-memory-card-faq/reading-sd-card-cid-serial-psn-internal-numbers/
2399                    	;  422       */
2400                    	;  423  
2401                    	;  424      /* CMD10: SEND_CID */
2402                    	;  425      memcpy(cmdbuf, cmd10, 5);
2403    0B05  210500    		ld	hl,5
2404    0B08  E5        		push	hl
2405    0B09  212B00    		ld	hl,_cmd10
2406    0B0C  E5        		push	hl
2407    0B0D  DDE5      		push	ix
2408    0B0F  C1        		pop	bc
2409    0B10  21EFFF    		ld	hl,65519
2410    0B13  09        		add	hl,bc
2411    0B14  CD0000    		call	_memcpy
2412    0B17  F1        		pop	af
2413    0B18  F1        		pop	af
2414                    	;  426      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2415    0B19  210100    		ld	hl,1
2416    0B1C  E5        		push	hl
2417    0B1D  DDE5      		push	ix
2418    0B1F  C1        		pop	bc
2419    0B20  21EAFF    		ld	hl,65514
2420    0B23  09        		add	hl,bc
2421    0B24  E5        		push	hl
2422    0B25  DDE5      		push	ix
2423    0B27  C1        		pop	bc
2424    0B28  21EFFF    		ld	hl,65519
2425    0B2B  09        		add	hl,bc
2426    0B2C  CD7701    		call	_sdcommand
2427    0B2F  F1        		pop	af
2428    0B30  F1        		pop	af
2429    0B31  DD71E8    		ld	(ix-24),c
2430    0B34  DD70E9    		ld	(ix-23),b
2431                    	;  427      if (sdtestflg)
2432    0B37  2A0000    		ld	hl,(_sdtestflg)
2433    0B3A  7C        		ld	a,h
2434    0B3B  B5        		or	l
2435    0B3C  2821      		jr	z,L1711
2436                    	;  428          {
2437                    	;  429          if (!statptr)
2438    0B3E  DD7EE8    		ld	a,(ix-24)
2439    0B41  DDB6E9    		or	(ix-23)
2440    0B44  2008      		jr	nz,L1021
2441                    	;  430              printf("CMD10: no response\n");
2442    0B46  219904    		ld	hl,L542
2443    0B49  CD0000    		call	_printf
2444                    	;  431          else
2445    0B4C  1811      		jr	L1711
2446                    	L1021:
2447                    	;  432              printf("CMD10: SEND_CID, R1 response [%02x]\n", statptr[0]);
2448    0B4E  DD6EE8    		ld	l,(ix-24)
2449    0B51  DD66E9    		ld	h,(ix-23)
2450    0B54  4E        		ld	c,(hl)
2451    0B55  97        		sub	a
2452    0B56  47        		ld	b,a
2453    0B57  C5        		push	bc
2454    0B58  21AD04    		ld	hl,L552
2455    0B5B  CD0000    		call	_printf
2456    0B5E  F1        		pop	af
2457                    	L1711:
2458                    	;  433          } /* sdtestflg */
2459                    	;  434      if (!statptr)
2460    0B5F  DD7EE8    		ld	a,(ix-24)
2461    0B62  DDB6E9    		or	(ix-23)
2462    0B65  200C      		jr	nz,L1221
2463                    	;  435          {
2464                    	;  436          spideselect();
2465    0B67  CD0000    		call	_spideselect
2466                    	;  437          ledoff();
2467    0B6A  CD0000    		call	_ledoff
2468                    	;  438          return (NO);
2469    0B6D  010000    		ld	bc,0
2470    0B70  C30000    		jp	c.rets0
2471                    	L1221:
2472                    	;  439          }
2473                    	;  440      /* looking for 0xfe that is the byte before data */
2474                    	;  441      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
2475    0B73  DD36F614  		ld	(ix-10),20
2476    0B77  DD36F700  		ld	(ix-9),0
2477                    	L1321:
2478    0B7B  97        		sub	a
2479    0B7C  DD96F6    		sub	(ix-10)
2480    0B7F  3E00      		ld	a,0
2481    0B81  DD9EF7    		sbc	a,(ix-9)
2482    0B84  F2A60B    		jp	p,L1421
2483    0B87  21FF00    		ld	hl,255
2484    0B8A  CD0000    		call	_spiio
2485    0B8D  79        		ld	a,c
2486    0B8E  FEFE      		cp	254
2487    0B90  2003      		jr	nz,L43
2488    0B92  78        		ld	a,b
2489    0B93  FE00      		cp	0
2490                    	L43:
2491    0B95  280F      		jr	z,L1421
2492                    	L1521:
2493    0B97  DD6EF6    		ld	l,(ix-10)
2494    0B9A  DD66F7    		ld	h,(ix-9)
2495    0B9D  2B        		dec	hl
2496    0B9E  DD75F6    		ld	(ix-10),l
2497    0BA1  DD74F7    		ld	(ix-9),h
2498    0BA4  18D5      		jr	L1321
2499                    	L1421:
2500                    	;  442          ;
2501                    	;  443      if (tries == 0) /* tried too many times */
2502    0BA6  DD7EF6    		ld	a,(ix-10)
2503    0BA9  DDB6F7    		or	(ix-9)
2504    0BAC  2019      		jr	nz,L1721
2505                    	;  444          {
2506                    	;  445          if (sdtestflg)
2507    0BAE  2A0000    		ld	hl,(_sdtestflg)
2508    0BB1  7C        		ld	a,h
2509    0BB2  B5        		or	l
2510    0BB3  2806      		jr	z,L1031
2511                    	;  446              {
2512                    	;  447              printf("  No data found\n");
2513    0BB5  21D204    		ld	hl,L562
2514    0BB8  CD0000    		call	_printf
2515                    	L1031:
2516                    	;  448              } /* sdtestflg */
2517                    	;  449          spideselect();
2518    0BBB  CD0000    		call	_spideselect
2519                    	;  450          ledoff();
2520    0BBE  CD0000    		call	_ledoff
2521                    	;  451          return (NO);
2522    0BC1  010000    		ld	bc,0
2523    0BC4  C30000    		jp	c.rets0
2524                    	L1721:
2525                    	;  452          }
2526                    	;  453      else
2527                    	;  454          {
2528                    	;  455          crc = 0;
2529    0BC7  DD36E700  		ld	(ix-25),0
2530                    	;  456          for (nbytes = 0; nbytes < 15; nbytes++)
2531    0BCB  DD36F800  		ld	(ix-8),0
2532    0BCF  DD36F900  		ld	(ix-7),0
2533                    	L1231:
2534    0BD3  DD7EF8    		ld	a,(ix-8)
2535    0BD6  D60F      		sub	15
2536    0BD8  DD7EF9    		ld	a,(ix-7)
2537    0BDB  DE00      		sbc	a,0
2538    0BDD  F2130C    		jp	p,L1331
2539                    	;  457              {
2540                    	;  458              rbyte = spiio(0xff);
2541    0BE0  21FF00    		ld	hl,255
2542    0BE3  CD0000    		call	_spiio
2543    0BE6  DD71E6    		ld	(ix-26),c
2544                    	;  459              cidreg[nbytes] = rbyte;
2545    0BE9  213800    		ld	hl,_cidreg
2546    0BEC  DD4EF8    		ld	c,(ix-8)
2547    0BEF  DD46F9    		ld	b,(ix-7)
2548    0BF2  09        		add	hl,bc
2549    0BF3  DD7EE6    		ld	a,(ix-26)
2550    0BF6  77        		ld	(hl),a
2551                    	;  460              crc = CRC7_one(crc, rbyte);
2552    0BF7  DD6EE6    		ld	l,(ix-26)
2553    0BFA  97        		sub	a
2554    0BFB  67        		ld	h,a
2555    0BFC  E5        		push	hl
2556    0BFD  DD6EE7    		ld	l,(ix-25)
2557    0C00  97        		sub	a
2558    0C01  67        		ld	h,a
2559    0C02  CD6700    		call	_CRC7_one
2560    0C05  F1        		pop	af
2561    0C06  DD71E7    		ld	(ix-25),c
2562                    	;  461              }
2563    0C09  DD34F8    		inc	(ix-8)
2564    0C0C  2003      		jr	nz,L63
2565    0C0E  DD34F9    		inc	(ix-7)
2566                    	L63:
2567    0C11  18C0      		jr	L1231
2568                    	L1331:
2569                    	;  462          cidreg[15] = spiio(0xff);
2570    0C13  21FF00    		ld	hl,255
2571    0C16  CD0000    		call	_spiio
2572    0C19  79        		ld	a,c
2573    0C1A  324700    		ld	(_cidreg+15),a
2574                    	;  463          crc |= 0x01;
2575    0C1D  DDCBE7C6  		set	0,(ix-25)
2576                    	;  464          /* some SD cards need additional clock pulses */
2577                    	;  465          for (nbytes = 9; 0 < nbytes; nbytes--)
2578    0C21  DD36F809  		ld	(ix-8),9
2579    0C25  DD36F900  		ld	(ix-7),0
2580                    	L1631:
2581    0C29  97        		sub	a
2582    0C2A  DD96F8    		sub	(ix-8)
2583    0C2D  3E00      		ld	a,0
2584    0C2F  DD9EF9    		sbc	a,(ix-7)
2585    0C32  F24A0C    		jp	p,L1731
2586                    	;  466              spiio(0xff);
2587    0C35  21FF00    		ld	hl,255
2588    0C38  CD0000    		call	_spiio
2589    0C3B  DD6EF8    		ld	l,(ix-8)
2590    0C3E  DD66F9    		ld	h,(ix-7)
2591    0C41  2B        		dec	hl
2592    0C42  DD75F8    		ld	(ix-8),l
2593    0C45  DD74F9    		ld	(ix-7),h
2594    0C48  18DF      		jr	L1631
2595                    	L1731:
2596                    	;  467          if (sdtestflg)
2597    0C4A  2A0000    		ld	hl,(_sdtestflg)
2598    0C4D  7C        		ld	a,h
2599    0C4E  B5        		or	l
2600    0C4F  CA2C0D    		jp	z,L1131
2601                    	;  468              {
2602                    	;  469              prtptr = &cidreg[0];
2603    0C52  213800    		ld	hl,_cidreg
2604    0C55  DD75E4    		ld	(ix-28),l
2605    0C58  DD74E5    		ld	(ix-27),h
2606                    	;  470              printf("  CID: [");
2607    0C5B  21E304    		ld	hl,L572
2608    0C5E  CD0000    		call	_printf
2609                    	;  471              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
2610    0C61  DD36F800  		ld	(ix-8),0
2611    0C65  DD36F900  		ld	(ix-7),0
2612                    	L1341:
2613    0C69  DD7EF8    		ld	a,(ix-8)
2614    0C6C  D610      		sub	16
2615    0C6E  DD7EF9    		ld	a,(ix-7)
2616    0C71  DE00      		sbc	a,0
2617    0C73  F2990C    		jp	p,L1441
2618                    	;  472                  printf("%02x ", *prtptr);
2619    0C76  DD6EE4    		ld	l,(ix-28)
2620    0C79  DD66E5    		ld	h,(ix-27)
2621    0C7C  4E        		ld	c,(hl)
2622    0C7D  97        		sub	a
2623    0C7E  47        		ld	b,a
2624    0C7F  C5        		push	bc
2625    0C80  21EC04    		ld	hl,L503
2626    0C83  CD0000    		call	_printf
2627    0C86  F1        		pop	af
2628    0C87  DD34F8    		inc	(ix-8)
2629    0C8A  2003      		jr	nz,L04
2630    0C8C  DD34F9    		inc	(ix-7)
2631                    	L04:
2632    0C8F  DD34E4    		inc	(ix-28)
2633    0C92  2003      		jr	nz,L24
2634    0C94  DD34E5    		inc	(ix-27)
2635                    	L24:
2636    0C97  18D0      		jr	L1341
2637                    	L1441:
2638                    	;  473              prtptr = &cidreg[0];
2639    0C99  213800    		ld	hl,_cidreg
2640    0C9C  DD75E4    		ld	(ix-28),l
2641    0C9F  DD74E5    		ld	(ix-27),h
2642                    	;  474              printf("\b] |");
2643    0CA2  21F204    		ld	hl,L513
2644    0CA5  CD0000    		call	_printf
2645                    	;  475              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
2646    0CA8  DD36F800  		ld	(ix-8),0
2647    0CAC  DD36F900  		ld	(ix-7),0
2648                    	L1741:
2649    0CB0  DD7EF8    		ld	a,(ix-8)
2650    0CB3  D610      		sub	16
2651    0CB5  DD7EF9    		ld	a,(ix-7)
2652    0CB8  DE00      		sbc	a,0
2653    0CBA  F2F90C    		jp	p,L1051
2654                    	;  476                  {
2655                    	;  477                  if ((' ' <= *prtptr) && (*prtptr < 127))
2656    0CBD  DD6EE4    		ld	l,(ix-28)
2657    0CC0  DD66E5    		ld	h,(ix-27)
2658    0CC3  7E        		ld	a,(hl)
2659    0CC4  FE20      		cp	32
2660    0CC6  3819      		jr	c,L1351
2661    0CC8  DD6EE4    		ld	l,(ix-28)
2662    0CCB  DD66E5    		ld	h,(ix-27)
2663    0CCE  7E        		ld	a,(hl)
2664    0CCF  FE7F      		cp	127
2665    0CD1  300E      		jr	nc,L1351
2666                    	;  478                      putchar(*prtptr);
2667    0CD3  DD6EE4    		ld	l,(ix-28)
2668    0CD6  DD66E5    		ld	h,(ix-27)
2669    0CD9  6E        		ld	l,(hl)
2670    0CDA  97        		sub	a
2671    0CDB  67        		ld	h,a
2672    0CDC  CD0000    		call	_putchar
2673                    	;  479                  else
2674    0CDF  1806      		jr	L1151
2675                    	L1351:
2676                    	;  480                      putchar('.');
2677    0CE1  212E00    		ld	hl,46
2678    0CE4  CD0000    		call	_putchar
2679                    	L1151:
2680    0CE7  DD34F8    		inc	(ix-8)
2681    0CEA  2003      		jr	nz,L44
2682    0CEC  DD34F9    		inc	(ix-7)
2683                    	L44:
2684    0CEF  DD34E4    		inc	(ix-28)
2685    0CF2  2003      		jr	nz,L64
2686    0CF4  DD34E5    		inc	(ix-27)
2687                    	L64:
2688    0CF7  18B7      		jr	L1741
2689                    	L1051:
2690                    	;  481                  }
2691                    	;  482              printf("|\n");
2692    0CF9  21F704    		ld	hl,L523
2693    0CFC  CD0000    		call	_printf
2694                    	;  483              if (crc == cidreg[15])
2695    0CFF  214700    		ld	hl,_cidreg+15
2696    0D02  DD7EE7    		ld	a,(ix-25)
2697    0D05  BE        		cp	(hl)
2698    0D06  200F      		jr	nz,L1551
2699                    	;  484                  {
2700                    	;  485                  printf("CRC7 ok: [%02x]\n", crc);
2701    0D08  DD4EE7    		ld	c,(ix-25)
2702    0D0B  97        		sub	a
2703    0D0C  47        		ld	b,a
2704    0D0D  C5        		push	bc
2705    0D0E  21FA04    		ld	hl,L533
2706    0D11  CD0000    		call	_printf
2707    0D14  F1        		pop	af
2708                    	;  486                  }
2709                    	;  487              else
2710    0D15  1815      		jr	L1131
2711                    	L1551:
2712                    	;  488                  {
2713                    	;  489                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
2714                    	;  490                         crc, cidreg[15]);
2715    0D17  3A4700    		ld	a,(_cidreg+15)
2716    0D1A  4F        		ld	c,a
2717    0D1B  97        		sub	a
2718    0D1C  47        		ld	b,a
2719    0D1D  C5        		push	bc
2720    0D1E  DD4EE7    		ld	c,(ix-25)
2721    0D21  97        		sub	a
2722    0D22  47        		ld	b,a
2723    0D23  C5        		push	bc
2724    0D24  210B05    		ld	hl,L543
2725    0D27  CD0000    		call	_printf
2726    0D2A  F1        		pop	af
2727    0D2B  F1        		pop	af
2728                    	L1131:
2729                    	;  491                  /* could maybe return failure here */
2730                    	;  492                  }
2731                    	;  493              } /* sdtestflg */
2732                    	;  494          }
2733                    	;  495  
2734                    	;  496      /* CMD9: SEND_CSD */
2735                    	;  497      memcpy(cmdbuf, cmd9, 5);
2736    0D2C  210500    		ld	hl,5
2737    0D2F  E5        		push	hl
2738    0D30  212500    		ld	hl,_cmd9
2739    0D33  E5        		push	hl
2740    0D34  DDE5      		push	ix
2741    0D36  C1        		pop	bc
2742    0D37  21EFFF    		ld	hl,65519
2743    0D3A  09        		add	hl,bc
2744    0D3B  CD0000    		call	_memcpy
2745    0D3E  F1        		pop	af
2746    0D3F  F1        		pop	af
2747                    	;  498      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2748    0D40  210100    		ld	hl,1
2749    0D43  E5        		push	hl
2750    0D44  DDE5      		push	ix
2751    0D46  C1        		pop	bc
2752    0D47  21EAFF    		ld	hl,65514
2753    0D4A  09        		add	hl,bc
2754    0D4B  E5        		push	hl
2755    0D4C  DDE5      		push	ix
2756    0D4E  C1        		pop	bc
2757    0D4F  21EFFF    		ld	hl,65519
2758    0D52  09        		add	hl,bc
2759    0D53  CD7701    		call	_sdcommand
2760    0D56  F1        		pop	af
2761    0D57  F1        		pop	af
2762    0D58  DD71E8    		ld	(ix-24),c
2763    0D5B  DD70E9    		ld	(ix-23),b
2764                    	;  499      if (sdtestflg)
2765    0D5E  2A0000    		ld	hl,(_sdtestflg)
2766    0D61  7C        		ld	a,h
2767    0D62  B5        		or	l
2768    0D63  2821      		jr	z,L1751
2769                    	;  500          {
2770                    	;  501          if (!statptr)
2771    0D65  DD7EE8    		ld	a,(ix-24)
2772    0D68  DDB6E9    		or	(ix-23)
2773    0D6B  2008      		jr	nz,L1061
2774                    	;  502              printf("CMD9: no response\n");
2775    0D6D  213D05    		ld	hl,L553
2776    0D70  CD0000    		call	_printf
2777                    	;  503          else
2778    0D73  1811      		jr	L1751
2779                    	L1061:
2780                    	;  504              printf("CMD9: SEND_CSD, R1 response [%02x]\n", statptr[0]);
2781    0D75  DD6EE8    		ld	l,(ix-24)
2782    0D78  DD66E9    		ld	h,(ix-23)
2783    0D7B  4E        		ld	c,(hl)
2784    0D7C  97        		sub	a
2785    0D7D  47        		ld	b,a
2786    0D7E  C5        		push	bc
2787    0D7F  215005    		ld	hl,L563
2788    0D82  CD0000    		call	_printf
2789    0D85  F1        		pop	af
2790                    	L1751:
2791                    	;  505          } /* sdtestflg */
2792                    	;  506      if (!statptr)
2793    0D86  DD7EE8    		ld	a,(ix-24)
2794    0D89  DDB6E9    		or	(ix-23)
2795    0D8C  200C      		jr	nz,L1261
2796                    	;  507          {
2797                    	;  508          spideselect();
2798    0D8E  CD0000    		call	_spideselect
2799                    	;  509          ledoff();
2800    0D91  CD0000    		call	_ledoff
2801                    	;  510          return (NO);
2802    0D94  010000    		ld	bc,0
2803    0D97  C30000    		jp	c.rets0
2804                    	L1261:
2805                    	;  511          }
2806                    	;  512      /* looking for 0xfe that is the byte before data */
2807                    	;  513      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
2808    0D9A  DD36F614  		ld	(ix-10),20
2809    0D9E  DD36F700  		ld	(ix-9),0
2810                    	L1361:
2811    0DA2  97        		sub	a
2812    0DA3  DD96F6    		sub	(ix-10)
2813    0DA6  3E00      		ld	a,0
2814    0DA8  DD9EF7    		sbc	a,(ix-9)
2815    0DAB  F2CD0D    		jp	p,L1461
2816    0DAE  21FF00    		ld	hl,255
2817    0DB1  CD0000    		call	_spiio
2818    0DB4  79        		ld	a,c
2819    0DB5  FEFE      		cp	254
2820    0DB7  2003      		jr	nz,L05
2821    0DB9  78        		ld	a,b
2822    0DBA  FE00      		cp	0
2823                    	L05:
2824    0DBC  280F      		jr	z,L1461
2825                    	L1561:
2826    0DBE  DD6EF6    		ld	l,(ix-10)
2827    0DC1  DD66F7    		ld	h,(ix-9)
2828    0DC4  2B        		dec	hl
2829    0DC5  DD75F6    		ld	(ix-10),l
2830    0DC8  DD74F7    		ld	(ix-9),h
2831    0DCB  18D5      		jr	L1361
2832                    	L1461:
2833                    	;  514          ;
2834                    	;  515      if (tries == 0) /* tried too many times */
2835    0DCD  DD7EF6    		ld	a,(ix-10)
2836    0DD0  DDB6F7    		or	(ix-9)
2837    0DD3  2013      		jr	nz,L1761
2838                    	;  516          {
2839                    	;  517          if (sdtestflg)
2840    0DD5  2A0000    		ld	hl,(_sdtestflg)
2841    0DD8  7C        		ld	a,h
2842    0DD9  B5        		or	l
2843    0DDA  2806      		jr	z,L1071
2844                    	;  518              {
2845                    	;  519              printf("  No data found\n");
2846    0DDC  217405    		ld	hl,L573
2847    0DDF  CD0000    		call	_printf
2848                    	L1071:
2849                    	;  520              } /* sdtestflg */
2850                    	;  521          return (NO);
2851    0DE2  010000    		ld	bc,0
2852    0DE5  C30000    		jp	c.rets0
2853                    	L1761:
2854                    	;  522          }
2855                    	;  523      else
2856                    	;  524          {
2857                    	;  525          crc = 0;
2858    0DE8  DD36E700  		ld	(ix-25),0
2859                    	;  526          for (nbytes = 0; nbytes < 15; nbytes++)
2860    0DEC  DD36F800  		ld	(ix-8),0
2861    0DF0  DD36F900  		ld	(ix-7),0
2862                    	L1271:
2863    0DF4  DD7EF8    		ld	a,(ix-8)
2864    0DF7  D60F      		sub	15
2865    0DF9  DD7EF9    		ld	a,(ix-7)
2866    0DFC  DE00      		sbc	a,0
2867    0DFE  F2340E    		jp	p,L1371
2868                    	;  527              {
2869                    	;  528              rbyte = spiio(0xff);
2870    0E01  21FF00    		ld	hl,255
2871    0E04  CD0000    		call	_spiio
2872    0E07  DD71E6    		ld	(ix-26),c
2873                    	;  529              csdreg[nbytes] = rbyte;
2874    0E0A  212800    		ld	hl,_csdreg
2875    0E0D  DD4EF8    		ld	c,(ix-8)
2876    0E10  DD46F9    		ld	b,(ix-7)
2877    0E13  09        		add	hl,bc
2878    0E14  DD7EE6    		ld	a,(ix-26)
2879    0E17  77        		ld	(hl),a
2880                    	;  530              crc = CRC7_one(crc, rbyte);
2881    0E18  DD6EE6    		ld	l,(ix-26)
2882    0E1B  97        		sub	a
2883    0E1C  67        		ld	h,a
2884    0E1D  E5        		push	hl
2885    0E1E  DD6EE7    		ld	l,(ix-25)
2886    0E21  97        		sub	a
2887    0E22  67        		ld	h,a
2888    0E23  CD6700    		call	_CRC7_one
2889    0E26  F1        		pop	af
2890    0E27  DD71E7    		ld	(ix-25),c
2891                    	;  531              }
2892    0E2A  DD34F8    		inc	(ix-8)
2893    0E2D  2003      		jr	nz,L25
2894    0E2F  DD34F9    		inc	(ix-7)
2895                    	L25:
2896    0E32  18C0      		jr	L1271
2897                    	L1371:
2898                    	;  532          csdreg[15] = spiio(0xff);
2899    0E34  21FF00    		ld	hl,255
2900    0E37  CD0000    		call	_spiio
2901    0E3A  79        		ld	a,c
2902    0E3B  323700    		ld	(_csdreg+15),a
2903                    	;  533          crc |= 0x01;
2904    0E3E  DDCBE7C6  		set	0,(ix-25)
2905                    	;  534          /* some SD cards need additional clock pulses */
2906                    	;  535          for (nbytes = 9; 0 < nbytes; nbytes--)
2907    0E42  DD36F809  		ld	(ix-8),9
2908    0E46  DD36F900  		ld	(ix-7),0
2909                    	L1671:
2910    0E4A  97        		sub	a
2911    0E4B  DD96F8    		sub	(ix-8)
2912    0E4E  3E00      		ld	a,0
2913    0E50  DD9EF9    		sbc	a,(ix-7)
2914    0E53  F26B0E    		jp	p,L1771
2915                    	;  536              spiio(0xff);
2916    0E56  21FF00    		ld	hl,255
2917    0E59  CD0000    		call	_spiio
2918    0E5C  DD6EF8    		ld	l,(ix-8)
2919    0E5F  DD66F9    		ld	h,(ix-7)
2920    0E62  2B        		dec	hl
2921    0E63  DD75F8    		ld	(ix-8),l
2922    0E66  DD74F9    		ld	(ix-7),h
2923    0E69  18DF      		jr	L1671
2924                    	L1771:
2925                    	;  537          if (sdtestflg)
2926    0E6B  2A0000    		ld	hl,(_sdtestflg)
2927    0E6E  7C        		ld	a,h
2928    0E6F  B5        		or	l
2929    0E70  CA4D0F    		jp	z,L1171
2930                    	;  538              {
2931                    	;  539              prtptr = &csdreg[0];
2932    0E73  212800    		ld	hl,_csdreg
2933    0E76  DD75E4    		ld	(ix-28),l
2934    0E79  DD74E5    		ld	(ix-27),h
2935                    	;  540              printf("  CSD: [");
2936    0E7C  218505    		ld	hl,L504
2937    0E7F  CD0000    		call	_printf
2938                    	;  541              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
2939    0E82  DD36F800  		ld	(ix-8),0
2940    0E86  DD36F900  		ld	(ix-7),0
2941                    	L1302:
2942    0E8A  DD7EF8    		ld	a,(ix-8)
2943    0E8D  D610      		sub	16
2944    0E8F  DD7EF9    		ld	a,(ix-7)
2945    0E92  DE00      		sbc	a,0
2946    0E94  F2BA0E    		jp	p,L1402
2947                    	;  542                  printf("%02x ", *prtptr);
2948    0E97  DD6EE4    		ld	l,(ix-28)
2949    0E9A  DD66E5    		ld	h,(ix-27)
2950    0E9D  4E        		ld	c,(hl)
2951    0E9E  97        		sub	a
2952    0E9F  47        		ld	b,a
2953    0EA0  C5        		push	bc
2954    0EA1  218E05    		ld	hl,L514
2955    0EA4  CD0000    		call	_printf
2956    0EA7  F1        		pop	af
2957    0EA8  DD34F8    		inc	(ix-8)
2958    0EAB  2003      		jr	nz,L45
2959    0EAD  DD34F9    		inc	(ix-7)
2960                    	L45:
2961    0EB0  DD34E4    		inc	(ix-28)
2962    0EB3  2003      		jr	nz,L65
2963    0EB5  DD34E5    		inc	(ix-27)
2964                    	L65:
2965    0EB8  18D0      		jr	L1302
2966                    	L1402:
2967                    	;  543              prtptr = &csdreg[0];
2968    0EBA  212800    		ld	hl,_csdreg
2969    0EBD  DD75E4    		ld	(ix-28),l
2970    0EC0  DD74E5    		ld	(ix-27),h
2971                    	;  544              printf("\b] |");
2972    0EC3  219405    		ld	hl,L524
2973    0EC6  CD0000    		call	_printf
2974                    	;  545              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
2975    0EC9  DD36F800  		ld	(ix-8),0
2976    0ECD  DD36F900  		ld	(ix-7),0
2977                    	L1702:
2978    0ED1  DD7EF8    		ld	a,(ix-8)
2979    0ED4  D610      		sub	16
2980    0ED6  DD7EF9    		ld	a,(ix-7)
2981    0ED9  DE00      		sbc	a,0
2982    0EDB  F21A0F    		jp	p,L1012
2983                    	;  546                  {
2984                    	;  547                  if ((' ' <= *prtptr) && (*prtptr < 127))
2985    0EDE  DD6EE4    		ld	l,(ix-28)
2986    0EE1  DD66E5    		ld	h,(ix-27)
2987    0EE4  7E        		ld	a,(hl)
2988    0EE5  FE20      		cp	32
2989    0EE7  3819      		jr	c,L1312
2990    0EE9  DD6EE4    		ld	l,(ix-28)
2991    0EEC  DD66E5    		ld	h,(ix-27)
2992    0EEF  7E        		ld	a,(hl)
2993    0EF0  FE7F      		cp	127
2994    0EF2  300E      		jr	nc,L1312
2995                    	;  548                      putchar(*prtptr);
2996    0EF4  DD6EE4    		ld	l,(ix-28)
2997    0EF7  DD66E5    		ld	h,(ix-27)
2998    0EFA  6E        		ld	l,(hl)
2999    0EFB  97        		sub	a
3000    0EFC  67        		ld	h,a
3001    0EFD  CD0000    		call	_putchar
3002                    	;  549                  else
3003    0F00  1806      		jr	L1112
3004                    	L1312:
3005                    	;  550                      putchar('.');
3006    0F02  212E00    		ld	hl,46
3007    0F05  CD0000    		call	_putchar
3008                    	L1112:
3009    0F08  DD34F8    		inc	(ix-8)
3010    0F0B  2003      		jr	nz,L06
3011    0F0D  DD34F9    		inc	(ix-7)
3012                    	L06:
3013    0F10  DD34E4    		inc	(ix-28)
3014    0F13  2003      		jr	nz,L26
3015    0F15  DD34E5    		inc	(ix-27)
3016                    	L26:
3017    0F18  18B7      		jr	L1702
3018                    	L1012:
3019                    	;  551                  }
3020                    	;  552              printf("|\n");
3021    0F1A  219905    		ld	hl,L534
3022    0F1D  CD0000    		call	_printf
3023                    	;  553              if (crc == csdreg[15])
3024    0F20  213700    		ld	hl,_csdreg+15
3025    0F23  DD7EE7    		ld	a,(ix-25)
3026    0F26  BE        		cp	(hl)
3027    0F27  200F      		jr	nz,L1512
3028                    	;  554                  {
3029                    	;  555                  printf("CRC7 ok: [%02x]\n", crc);
3030    0F29  DD4EE7    		ld	c,(ix-25)
3031    0F2C  97        		sub	a
3032    0F2D  47        		ld	b,a
3033    0F2E  C5        		push	bc
3034    0F2F  219C05    		ld	hl,L544
3035    0F32  CD0000    		call	_printf
3036    0F35  F1        		pop	af
3037                    	;  556                  }
3038                    	;  557              else
3039    0F36  1815      		jr	L1171
3040                    	L1512:
3041                    	;  558                  {
3042                    	;  559                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
3043                    	;  560                         crc, csdreg[15]);
3044    0F38  3A3700    		ld	a,(_csdreg+15)
3045    0F3B  4F        		ld	c,a
3046    0F3C  97        		sub	a
3047    0F3D  47        		ld	b,a
3048    0F3E  C5        		push	bc
3049    0F3F  DD4EE7    		ld	c,(ix-25)
3050    0F42  97        		sub	a
3051    0F43  47        		ld	b,a
3052    0F44  C5        		push	bc
3053    0F45  21AD05    		ld	hl,L554
3054    0F48  CD0000    		call	_printf
3055    0F4B  F1        		pop	af
3056    0F4C  F1        		pop	af
3057                    	L1171:
3058                    	;  561                  /* could maybe return failure here */
3059                    	;  562                  }
3060                    	;  563              } /* sdtestflg */
3061                    	;  564          }
3062                    	;  565  
3063                    	;  566      for (nbytes = 9; 0 < nbytes; nbytes--)
3064    0F4D  DD36F809  		ld	(ix-8),9
3065    0F51  DD36F900  		ld	(ix-7),0
3066                    	L1712:
3067    0F55  97        		sub	a
3068    0F56  DD96F8    		sub	(ix-8)
3069    0F59  3E00      		ld	a,0
3070    0F5B  DD9EF9    		sbc	a,(ix-7)
3071    0F5E  F2760F    		jp	p,L1022
3072                    	;  567          spiio(0xff);
3073    0F61  21FF00    		ld	hl,255
3074    0F64  CD0000    		call	_spiio
3075    0F67  DD6EF8    		ld	l,(ix-8)
3076    0F6A  DD66F9    		ld	h,(ix-7)
3077    0F6D  2B        		dec	hl
3078    0F6E  DD75F8    		ld	(ix-8),l
3079    0F71  DD74F9    		ld	(ix-7),h
3080    0F74  18DF      		jr	L1712
3081                    	L1022:
3082                    	;  568      if (sdtestflg)
3083    0F76  2A0000    		ld	hl,(_sdtestflg)
3084    0F79  7C        		ld	a,h
3085    0F7A  B5        		or	l
3086    0F7B  2806      		jr	z,L1322
3087                    	;  569          {
3088                    	;  570          printf("Sent 9*8 (72) clock pulses, select active\n");
3089    0F7D  21DF05    		ld	hl,L564
3090    0F80  CD0000    		call	_printf
3091                    	L1322:
3092                    	;  571          } /* sdtestflg */
3093                    	;  572  
3094                    	;  573      sdinitok = YES;
3095    0F83  210100    		ld	hl,1
3096    0F86  220C00    		ld	(_sdinitok),hl
3097                    	;  574  
3098                    	;  575      spideselect();
3099    0F89  CD0000    		call	_spideselect
3100                    	;  576      ledoff();
3101    0F8C  CD0000    		call	_ledoff
3102                    	;  577  
3103                    	;  578      return (YES);
3104    0F8F  010100    		ld	bc,1
3105    0F92  C30000    		jp	c.rets0
3106                    	L574:
3107    0F95  43        		.byte	67
3108    0F96  4D        		.byte	77
3109    0F97  44        		.byte	68
3110    0F98  35        		.byte	53
3111    0F99  38        		.byte	56
3112    0F9A  3A        		.byte	58
3113    0F9B  20        		.byte	32
3114    0F9C  6E        		.byte	110
3115    0F9D  6F        		.byte	111
3116    0F9E  20        		.byte	32
3117    0F9F  72        		.byte	114
3118    0FA0  65        		.byte	101
3119    0FA1  73        		.byte	115
3120    0FA2  70        		.byte	112
3121    0FA3  6F        		.byte	111
3122    0FA4  6E        		.byte	110
3123    0FA5  73        		.byte	115
3124    0FA6  65        		.byte	101
3125    0FA7  0A        		.byte	10
3126    0FA8  00        		.byte	0
3127                    	L505:
3128    0FA9  43        		.byte	67
3129    0FAA  4D        		.byte	77
3130    0FAB  44        		.byte	68
3131    0FAC  35        		.byte	53
3132    0FAD  38        		.byte	56
3133    0FAE  3A        		.byte	58
3134    0FAF  20        		.byte	32
3135    0FB0  52        		.byte	82
3136    0FB1  45        		.byte	69
3137    0FB2  41        		.byte	65
3138    0FB3  44        		.byte	68
3139    0FB4  5F        		.byte	95
3140    0FB5  4F        		.byte	79
3141    0FB6  43        		.byte	67
3142    0FB7  52        		.byte	82
3143    0FB8  2C        		.byte	44
3144    0FB9  20        		.byte	32
3145    0FBA  52        		.byte	82
3146    0FBB  33        		.byte	51
3147    0FBC  20        		.byte	32
3148    0FBD  72        		.byte	114
3149    0FBE  65        		.byte	101
3150    0FBF  73        		.byte	115
3151    0FC0  70        		.byte	112
3152    0FC1  6F        		.byte	111
3153    0FC2  6E        		.byte	110
3154    0FC3  73        		.byte	115
3155    0FC4  65        		.byte	101
3156    0FC5  20        		.byte	32
3157    0FC6  5B        		.byte	91
3158    0FC7  25        		.byte	37
3159    0FC8  30        		.byte	48
3160    0FC9  32        		.byte	50
3161    0FCA  78        		.byte	120
3162    0FCB  20        		.byte	32
3163    0FCC  25        		.byte	37
3164    0FCD  30        		.byte	48
3165    0FCE  32        		.byte	50
3166    0FCF  78        		.byte	120
3167    0FD0  20        		.byte	32
3168    0FD1  25        		.byte	37
3169    0FD2  30        		.byte	48
3170    0FD3  32        		.byte	50
3171    0FD4  78        		.byte	120
3172    0FD5  20        		.byte	32
3173    0FD6  25        		.byte	37
3174    0FD7  30        		.byte	48
3175    0FD8  32        		.byte	50
3176    0FD9  78        		.byte	120
3177    0FDA  20        		.byte	32
3178    0FDB  25        		.byte	37
3179    0FDC  30        		.byte	48
3180    0FDD  32        		.byte	50
3181    0FDE  78        		.byte	120
3182    0FDF  5D        		.byte	93
3183    0FE0  0A        		.byte	10
3184    0FE1  00        		.byte	0
3185                    	L515:
3186    0FE2  53        		.byte	83
3187    0FE3  44        		.byte	68
3188    0FE4  20        		.byte	32
3189    0FE5  63        		.byte	99
3190    0FE6  61        		.byte	97
3191    0FE7  72        		.byte	114
3192    0FE8  64        		.byte	100
3193    0FE9  20        		.byte	32
3194    0FEA  6E        		.byte	110
3195    0FEB  6F        		.byte	111
3196    0FEC  74        		.byte	116
3197    0FED  20        		.byte	32
3198    0FEE  69        		.byte	105
3199    0FEF  6E        		.byte	110
3200    0FF0  73        		.byte	115
3201    0FF1  65        		.byte	101
3202    0FF2  72        		.byte	114
3203    0FF3  74        		.byte	116
3204    0FF4  65        		.byte	101
3205    0FF5  64        		.byte	100
3206    0FF6  20        		.byte	32
3207    0FF7  6F        		.byte	111
3208    0FF8  72        		.byte	114
3209    0FF9  20        		.byte	32
3210    0FFA  6E        		.byte	110
3211    0FFB  6F        		.byte	111
3212    0FFC  74        		.byte	116
3213    0FFD  20        		.byte	32
3214    0FFE  69        		.byte	105
3215    0FFF  6E        		.byte	110
3216    1000  69        		.byte	105
3217    1001  74        		.byte	116
3218    1002  69        		.byte	105
3219    1003  61        		.byte	97
3220    1004  6C        		.byte	108
3221    1005  69        		.byte	105
3222    1006  7A        		.byte	122
3223    1007  65        		.byte	101
3224    1008  64        		.byte	100
3225    1009  0A        		.byte	10
3226    100A  00        		.byte	0
3227                    	;  579      }
3228                    	;  580  
3229                    	;  581  int sdprobe()
3230                    	;  582      {
3231                    	_sdprobe:
3232    100B  CD0000    		call	c.savs0
3233    100E  21EAFF    		ld	hl,65514
3234    1011  39        		add	hl,sp
3235    1012  F9        		ld	sp,hl
3236                    	;  583      unsigned char cmdbuf[5];   /* buffer to build command in */
3237                    	;  584      unsigned char rstatbuf[5]; /* buffer to recieve status in */
3238                    	;  585      unsigned char *statptr;    /* pointer to returned status from SD command */
3239                    	;  586      int nbytes;  /* byte counter */
3240                    	;  587      int allzero = YES;
3241    1013  DD36EA01  		ld	(ix-22),1
3242    1017  DD36EB00  		ld	(ix-21),0
3243                    	;  588  
3244                    	;  589      ledon();
3245    101B  CD0000    		call	_ledon
3246                    	;  590      spiselect();
3247    101E  CD0000    		call	_spiselect
3248                    	;  591  
3249                    	;  592      /* CMD58: READ_OCR */
3250                    	;  593      memcpy(cmdbuf, cmd58, 5);
3251    1021  210500    		ld	hl,5
3252    1024  E5        		push	hl
3253    1025  214900    		ld	hl,_cmd58
3254    1028  E5        		push	hl
3255    1029  DDE5      		push	ix
3256    102B  C1        		pop	bc
3257    102C  21F5FF    		ld	hl,65525
3258    102F  09        		add	hl,bc
3259    1030  CD0000    		call	_memcpy
3260    1033  F1        		pop	af
3261    1034  F1        		pop	af
3262                    	;  594      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
3263    1035  210500    		ld	hl,5
3264    1038  E5        		push	hl
3265    1039  DDE5      		push	ix
3266    103B  C1        		pop	bc
3267    103C  21F0FF    		ld	hl,65520
3268    103F  09        		add	hl,bc
3269    1040  E5        		push	hl
3270    1041  DDE5      		push	ix
3271    1043  C1        		pop	bc
3272    1044  21F5FF    		ld	hl,65525
3273    1047  09        		add	hl,bc
3274    1048  CD7701    		call	_sdcommand
3275    104B  F1        		pop	af
3276    104C  F1        		pop	af
3277    104D  DD71EE    		ld	(ix-18),c
3278    1050  DD70EF    		ld	(ix-17),b
3279                    	;  595      for (nbytes = 0; nbytes < 5; nbytes++)
3280    1053  DD36EC00  		ld	(ix-20),0
3281    1057  DD36ED00  		ld	(ix-19),0
3282                    	L1422:
3283    105B  DD7EEC    		ld	a,(ix-20)
3284    105E  D605      		sub	5
3285    1060  DD7EED    		ld	a,(ix-19)
3286    1063  DE00      		sbc	a,0
3287    1065  F28B10    		jp	p,L1522
3288                    	;  596          {
3289                    	;  597          if (statptr[nbytes] != 0)
3290    1068  DD6EEE    		ld	l,(ix-18)
3291    106B  DD66EF    		ld	h,(ix-17)
3292    106E  DD4EEC    		ld	c,(ix-20)
3293    1071  DD46ED    		ld	b,(ix-19)
3294    1074  09        		add	hl,bc
3295    1075  7E        		ld	a,(hl)
3296    1076  B7        		or	a
3297    1077  2808      		jr	z,L1622
3298                    	;  598              allzero = NO;
3299    1079  DD36EA00  		ld	(ix-22),0
3300    107D  DD36EB00  		ld	(ix-21),0
3301                    	L1622:
3302    1081  DD34EC    		inc	(ix-20)
3303    1084  2003      		jr	nz,L66
3304    1086  DD34ED    		inc	(ix-19)
3305                    	L66:
3306    1089  18D0      		jr	L1422
3307                    	L1522:
3308                    	;  599          }
3309                    	;  600      if (sdtestflg)
3310    108B  2A0000    		ld	hl,(_sdtestflg)
3311    108E  7C        		ld	a,h
3312    108F  B5        		or	l
3313    1090  CAF910    		jp	z,L1132
3314                    	;  601          {
3315                    	;  602          if (!statptr)
3316    1093  DD7EEE    		ld	a,(ix-18)
3317    1096  DDB6EF    		or	(ix-17)
3318    1099  2009      		jr	nz,L1232
3319                    	;  603              printf("CMD58: no response\n");
3320    109B  21950F    		ld	hl,L574
3321    109E  CD0000    		call	_printf
3322                    	;  604          else
3323    10A1  C3F910    		jp	L1132
3324                    	L1232:
3325                    	;  605              {
3326                    	;  606              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
3327                    	;  607                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
3328    10A4  DD6EEE    		ld	l,(ix-18)
3329    10A7  DD66EF    		ld	h,(ix-17)
3330    10AA  23        		inc	hl
3331    10AB  23        		inc	hl
3332    10AC  23        		inc	hl
3333    10AD  23        		inc	hl
3334    10AE  4E        		ld	c,(hl)
3335    10AF  97        		sub	a
3336    10B0  47        		ld	b,a
3337    10B1  C5        		push	bc
3338    10B2  DD6EEE    		ld	l,(ix-18)
3339    10B5  DD66EF    		ld	h,(ix-17)
3340    10B8  23        		inc	hl
3341    10B9  23        		inc	hl
3342    10BA  23        		inc	hl
3343    10BB  4E        		ld	c,(hl)
3344    10BC  97        		sub	a
3345    10BD  47        		ld	b,a
3346    10BE  C5        		push	bc
3347    10BF  DD6EEE    		ld	l,(ix-18)
3348    10C2  DD66EF    		ld	h,(ix-17)
3349    10C5  23        		inc	hl
3350    10C6  23        		inc	hl
3351    10C7  4E        		ld	c,(hl)
3352    10C8  97        		sub	a
3353    10C9  47        		ld	b,a
3354    10CA  C5        		push	bc
3355    10CB  DD6EEE    		ld	l,(ix-18)
3356    10CE  DD66EF    		ld	h,(ix-17)
3357    10D1  23        		inc	hl
3358    10D2  4E        		ld	c,(hl)
3359    10D3  97        		sub	a
3360    10D4  47        		ld	b,a
3361    10D5  C5        		push	bc
3362    10D6  DD6EEE    		ld	l,(ix-18)
3363    10D9  DD66EF    		ld	h,(ix-17)
3364    10DC  4E        		ld	c,(hl)
3365    10DD  97        		sub	a
3366    10DE  47        		ld	b,a
3367    10DF  C5        		push	bc
3368    10E0  21A90F    		ld	hl,L505
3369    10E3  CD0000    		call	_printf
3370    10E6  210A00    		ld	hl,10
3371    10E9  39        		add	hl,sp
3372    10EA  F9        		ld	sp,hl
3373                    	;  608              if (allzero)
3374    10EB  DD7EEA    		ld	a,(ix-22)
3375    10EE  DDB6EB    		or	(ix-21)
3376    10F1  2806      		jr	z,L1132
3377                    	;  609                  printf("SD card not inserted or not initialized\n");
3378    10F3  21E20F    		ld	hl,L515
3379    10F6  CD0000    		call	_printf
3380                    	L1132:
3381                    	;  610              }
3382                    	;  611          } /* sdtestflg */
3383                    	;  612      if (!statptr || allzero)
3384    10F9  DD7EEE    		ld	a,(ix-18)
3385    10FC  DDB6EF    		or	(ix-17)
3386    10FF  2808      		jr	z,L1632
3387    1101  DD7EEA    		ld	a,(ix-22)
3388    1104  DDB6EB    		or	(ix-21)
3389    1107  2812      		jr	z,L1532
3390                    	L1632:
3391                    	;  613          {
3392                    	;  614          sdinitok = NO;
3393    1109  210000    		ld	hl,0
3394    110C  220C00    		ld	(_sdinitok),hl
3395                    	;  615          spideselect();
3396    110F  CD0000    		call	_spideselect
3397                    	;  616          ledoff();
3398    1112  CD0000    		call	_ledoff
3399                    	;  617          return (NO);
3400    1115  010000    		ld	bc,0
3401    1118  C30000    		jp	c.rets0
3402                    	L1532:
3403                    	;  618          }
3404                    	;  619  
3405                    	;  620      spideselect();
3406    111B  CD0000    		call	_spideselect
3407                    	;  621      ledoff();
3408    111E  CD0000    		call	_ledoff
3409                    	;  622  
3410                    	;  623      return (YES);
3411    1121  010100    		ld	bc,1
3412    1124  C30000    		jp	c.rets0
3413                    	L525:
3414    1127  53        		.byte	83
3415    1128  44        		.byte	68
3416    1129  20        		.byte	32
3417    112A  63        		.byte	99
3418    112B  61        		.byte	97
3419    112C  72        		.byte	114
3420    112D  64        		.byte	100
3421    112E  20        		.byte	32
3422    112F  6E        		.byte	110
3423    1130  6F        		.byte	111
3424    1131  74        		.byte	116
3425    1132  20        		.byte	32
3426    1133  69        		.byte	105
3427    1134  6E        		.byte	110
3428    1135  69        		.byte	105
3429    1136  74        		.byte	116
3430    1137  69        		.byte	105
3431    1138  61        		.byte	97
3432    1139  6C        		.byte	108
3433    113A  69        		.byte	105
3434    113B  7A        		.byte	122
3435    113C  65        		.byte	101
3436    113D  64        		.byte	100
3437    113E  0A        		.byte	10
3438    113F  00        		.byte	0
3439                    	L535:
3440    1140  53        		.byte	83
3441    1141  44        		.byte	68
3442    1142  20        		.byte	32
3443    1143  63        		.byte	99
3444    1144  61        		.byte	97
3445    1145  72        		.byte	114
3446    1146  64        		.byte	100
3447    1147  20        		.byte	32
3448    1148  69        		.byte	105
3449    1149  6E        		.byte	110
3450    114A  66        		.byte	102
3451    114B  6F        		.byte	111
3452    114C  72        		.byte	114
3453    114D  6D        		.byte	109
3454    114E  61        		.byte	97
3455    114F  74        		.byte	116
3456    1150  69        		.byte	105
3457    1151  6F        		.byte	111
3458    1152  6E        		.byte	110
3459    1153  3A        		.byte	58
3460    1154  00        		.byte	0
3461                    	L545:
3462    1155  20        		.byte	32
3463    1156  20        		.byte	32
3464    1157  53        		.byte	83
3465    1158  44        		.byte	68
3466    1159  20        		.byte	32
3467    115A  63        		.byte	99
3468    115B  61        		.byte	97
3469    115C  72        		.byte	114
3470    115D  64        		.byte	100
3471    115E  20        		.byte	32
3472    115F  76        		.byte	118
3473    1160  65        		.byte	101
3474    1161  72        		.byte	114
3475    1162  2E        		.byte	46
3476    1163  20        		.byte	32
3477    1164  32        		.byte	50
3478    1165  2B        		.byte	43
3479    1166  2C        		.byte	44
3480    1167  20        		.byte	32
3481    1168  42        		.byte	66
3482    1169  6C        		.byte	108
3483    116A  6F        		.byte	111
3484    116B  63        		.byte	99
3485    116C  6B        		.byte	107
3486    116D  20        		.byte	32
3487    116E  61        		.byte	97
3488    116F  64        		.byte	100
3489    1170  64        		.byte	100
3490    1171  72        		.byte	114
3491    1172  65        		.byte	101
3492    1173  73        		.byte	115
3493    1174  73        		.byte	115
3494    1175  0A        		.byte	10
3495    1176  00        		.byte	0
3496                    	L555:
3497    1177  20        		.byte	32
3498    1178  20        		.byte	32
3499    1179  53        		.byte	83
3500    117A  44        		.byte	68
3501    117B  20        		.byte	32
3502    117C  63        		.byte	99
3503    117D  61        		.byte	97
3504    117E  72        		.byte	114
3505    117F  64        		.byte	100
3506    1180  20        		.byte	32
3507    1181  76        		.byte	118
3508    1182  65        		.byte	101
3509    1183  72        		.byte	114
3510    1184  2E        		.byte	46
3511    1185  20        		.byte	32
3512    1186  32        		.byte	50
3513    1187  2B        		.byte	43
3514    1188  2C        		.byte	44
3515    1189  20        		.byte	32
3516    118A  42        		.byte	66
3517    118B  79        		.byte	121
3518    118C  74        		.byte	116
3519    118D  65        		.byte	101
3520    118E  20        		.byte	32
3521    118F  61        		.byte	97
3522    1190  64        		.byte	100
3523    1191  64        		.byte	100
3524    1192  72        		.byte	114
3525    1193  65        		.byte	101
3526    1194  73        		.byte	115
3527    1195  73        		.byte	115
3528    1196  0A        		.byte	10
3529    1197  00        		.byte	0
3530                    	L565:
3531    1198  20        		.byte	32
3532    1199  20        		.byte	32
3533    119A  53        		.byte	83
3534    119B  44        		.byte	68
3535    119C  20        		.byte	32
3536    119D  63        		.byte	99
3537    119E  61        		.byte	97
3538    119F  72        		.byte	114
3539    11A0  64        		.byte	100
3540    11A1  20        		.byte	32
3541    11A2  76        		.byte	118
3542    11A3  65        		.byte	101
3543    11A4  72        		.byte	114
3544    11A5  2E        		.byte	46
3545    11A6  20        		.byte	32
3546    11A7  31        		.byte	49
3547    11A8  2C        		.byte	44
3548    11A9  20        		.byte	32
3549    11AA  42        		.byte	66
3550    11AB  79        		.byte	121
3551    11AC  74        		.byte	116
3552    11AD  65        		.byte	101
3553    11AE  20        		.byte	32
3554    11AF  61        		.byte	97
3555    11B0  64        		.byte	100
3556    11B1  64        		.byte	100
3557    11B2  72        		.byte	114
3558    11B3  65        		.byte	101
3559    11B4  73        		.byte	115
3560    11B5  73        		.byte	115
3561    11B6  0A        		.byte	10
3562    11B7  00        		.byte	0
3563                    	L575:
3564    11B8  20        		.byte	32
3565    11B9  20        		.byte	32
3566    11BA  4D        		.byte	77
3567    11BB  61        		.byte	97
3568    11BC  6E        		.byte	110
3569    11BD  75        		.byte	117
3570    11BE  66        		.byte	102
3571    11BF  61        		.byte	97
3572    11C0  63        		.byte	99
3573    11C1  74        		.byte	116
3574    11C2  75        		.byte	117
3575    11C3  72        		.byte	114
3576    11C4  65        		.byte	101
3577    11C5  72        		.byte	114
3578    11C6  20        		.byte	32
3579    11C7  49        		.byte	73
3580    11C8  44        		.byte	68
3581    11C9  3A        		.byte	58
3582    11CA  20        		.byte	32
3583    11CB  30        		.byte	48
3584    11CC  78        		.byte	120
3585    11CD  25        		.byte	37
3586    11CE  30        		.byte	48
3587    11CF  32        		.byte	50
3588    11D0  78        		.byte	120
3589    11D1  2C        		.byte	44
3590    11D2  20        		.byte	32
3591    11D3  00        		.byte	0
3592                    	L506:
3593    11D4  4F        		.byte	79
3594    11D5  45        		.byte	69
3595    11D6  4D        		.byte	77
3596    11D7  20        		.byte	32
3597    11D8  49        		.byte	73
3598    11D9  44        		.byte	68
3599    11DA  3A        		.byte	58
3600    11DB  20        		.byte	32
3601    11DC  25        		.byte	37
3602    11DD  2E        		.byte	46
3603    11DE  32        		.byte	50
3604    11DF  73        		.byte	115
3605    11E0  2C        		.byte	44
3606    11E1  20        		.byte	32
3607    11E2  00        		.byte	0
3608                    	L516:
3609    11E3  50        		.byte	80
3610    11E4  72        		.byte	114
3611    11E5  6F        		.byte	111
3612    11E6  64        		.byte	100
3613    11E7  75        		.byte	117
3614    11E8  63        		.byte	99
3615    11E9  74        		.byte	116
3616    11EA  20        		.byte	32
3617    11EB  6E        		.byte	110
3618    11EC  61        		.byte	97
3619    11ED  6D        		.byte	109
3620    11EE  65        		.byte	101
3621    11EF  3A        		.byte	58
3622    11F0  20        		.byte	32
3623    11F1  25        		.byte	37
3624    11F2  2E        		.byte	46
3625    11F3  35        		.byte	53
3626    11F4  73        		.byte	115
3627    11F5  0A        		.byte	10
3628    11F6  00        		.byte	0
3629                    	L526:
3630    11F7  20        		.byte	32
3631    11F8  20        		.byte	32
3632    11F9  50        		.byte	80
3633    11FA  72        		.byte	114
3634    11FB  6F        		.byte	111
3635    11FC  64        		.byte	100
3636    11FD  75        		.byte	117
3637    11FE  63        		.byte	99
3638    11FF  74        		.byte	116
3639    1200  20        		.byte	32
3640    1201  72        		.byte	114
3641    1202  65        		.byte	101
3642    1203  76        		.byte	118
3643    1204  69        		.byte	105
3644    1205  73        		.byte	115
3645    1206  69        		.byte	105
3646    1207  6F        		.byte	111
3647    1208  6E        		.byte	110
3648    1209  3A        		.byte	58
3649    120A  20        		.byte	32
3650    120B  25        		.byte	37
3651    120C  64        		.byte	100
3652    120D  2E        		.byte	46
3653    120E  25        		.byte	37
3654    120F  64        		.byte	100
3655    1210  2C        		.byte	44
3656    1211  20        		.byte	32
3657    1212  00        		.byte	0
3658                    	L536:
3659    1213  53        		.byte	83
3660    1214  65        		.byte	101
3661    1215  72        		.byte	114
3662    1216  69        		.byte	105
3663    1217  61        		.byte	97
3664    1218  6C        		.byte	108
3665    1219  20        		.byte	32
3666    121A  6E        		.byte	110
3667    121B  75        		.byte	117
3668    121C  6D        		.byte	109
3669    121D  62        		.byte	98
3670    121E  65        		.byte	101
3671    121F  72        		.byte	114
3672    1220  3A        		.byte	58
3673    1221  20        		.byte	32
3674    1222  25        		.byte	37
3675    1223  6C        		.byte	108
3676    1224  75        		.byte	117
3677    1225  0A        		.byte	10
3678    1226  00        		.byte	0
3679                    	L546:
3680    1227  20        		.byte	32
3681    1228  20        		.byte	32
3682    1229  4D        		.byte	77
3683    122A  61        		.byte	97
3684    122B  6E        		.byte	110
3685    122C  75        		.byte	117
3686    122D  66        		.byte	102
3687    122E  61        		.byte	97
3688    122F  63        		.byte	99
3689    1230  74        		.byte	116
3690    1231  75        		.byte	117
3691    1232  72        		.byte	114
3692    1233  69        		.byte	105
3693    1234  6E        		.byte	110
3694    1235  67        		.byte	103
3695    1236  20        		.byte	32
3696    1237  64        		.byte	100
3697    1238  61        		.byte	97
3698    1239  74        		.byte	116
3699    123A  65        		.byte	101
3700    123B  3A        		.byte	58
3701    123C  20        		.byte	32
3702    123D  25        		.byte	37
3703    123E  64        		.byte	100
3704    123F  2D        		.byte	45
3705    1240  25        		.byte	37
3706    1241  64        		.byte	100
3707    1242  2C        		.byte	44
3708    1243  20        		.byte	32
3709    1244  00        		.byte	0
3710                    	L556:
3711    1245  44        		.byte	68
3712    1246  65        		.byte	101
3713    1247  76        		.byte	118
3714    1248  69        		.byte	105
3715    1249  63        		.byte	99
3716    124A  65        		.byte	101
3717    124B  20        		.byte	32
3718    124C  63        		.byte	99
3719    124D  61        		.byte	97
3720    124E  70        		.byte	112
3721    124F  61        		.byte	97
3722    1250  63        		.byte	99
3723    1251  69        		.byte	105
3724    1252  74        		.byte	116
3725    1253  79        		.byte	121
3726    1254  3A        		.byte	58
3727    1255  20        		.byte	32
3728    1256  25        		.byte	37
3729    1257  6C        		.byte	108
3730    1258  75        		.byte	117
3731    1259  20        		.byte	32
3732    125A  4D        		.byte	77
3733    125B  42        		.byte	66
3734    125C  79        		.byte	121
3735    125D  74        		.byte	116
3736    125E  65        		.byte	101
3737    125F  0A        		.byte	10
3738    1260  00        		.byte	0
3739                    	L566:
3740    1261  44        		.byte	68
3741    1262  65        		.byte	101
3742    1263  76        		.byte	118
3743    1264  69        		.byte	105
3744    1265  63        		.byte	99
3745    1266  65        		.byte	101
3746    1267  20        		.byte	32
3747    1268  63        		.byte	99
3748    1269  61        		.byte	97
3749    126A  70        		.byte	112
3750    126B  61        		.byte	97
3751    126C  63        		.byte	99
3752    126D  69        		.byte	105
3753    126E  74        		.byte	116
3754    126F  79        		.byte	121
3755    1270  3A        		.byte	58
3756    1271  20        		.byte	32
3757    1272  25        		.byte	37
3758    1273  6C        		.byte	108
3759    1274  75        		.byte	117
3760    1275  20        		.byte	32
3761    1276  4D        		.byte	77
3762    1277  42        		.byte	66
3763    1278  79        		.byte	121
3764    1279  74        		.byte	116
3765    127A  65        		.byte	101
3766    127B  0A        		.byte	10
3767    127C  00        		.byte	0
3768                    	L576:
3769    127D  44        		.byte	68
3770    127E  65        		.byte	101
3771    127F  76        		.byte	118
3772    1280  69        		.byte	105
3773    1281  63        		.byte	99
3774    1282  65        		.byte	101
3775    1283  20        		.byte	32
3776    1284  75        		.byte	117
3777    1285  6C        		.byte	108
3778    1286  74        		.byte	116
3779    1287  72        		.byte	114
3780    1288  61        		.byte	97
3781    1289  20        		.byte	32
3782    128A  63        		.byte	99
3783    128B  61        		.byte	97
3784    128C  70        		.byte	112
3785    128D  61        		.byte	97
3786    128E  63        		.byte	99
3787    128F  69        		.byte	105
3788    1290  74        		.byte	116
3789    1291  79        		.byte	121
3790    1292  3A        		.byte	58
3791    1293  20        		.byte	32
3792    1294  25        		.byte	37
3793    1295  6C        		.byte	108
3794    1296  75        		.byte	117
3795    1297  20        		.byte	32
3796    1298  4D        		.byte	77
3797    1299  42        		.byte	66
3798    129A  79        		.byte	121
3799    129B  74        		.byte	116
3800    129C  65        		.byte	101
3801    129D  0A        		.byte	10
3802    129E  00        		.byte	0
3803                    	L507:
3804    129F  2D        		.byte	45
3805    12A0  2D        		.byte	45
3806    12A1  2D        		.byte	45
3807    12A2  2D        		.byte	45
3808    12A3  2D        		.byte	45
3809    12A4  2D        		.byte	45
3810    12A5  2D        		.byte	45
3811    12A6  2D        		.byte	45
3812    12A7  2D        		.byte	45
3813    12A8  2D        		.byte	45
3814    12A9  2D        		.byte	45
3815    12AA  2D        		.byte	45
3816    12AB  2D        		.byte	45
3817    12AC  2D        		.byte	45
3818    12AD  2D        		.byte	45
3819    12AE  2D        		.byte	45
3820    12AF  2D        		.byte	45
3821    12B0  2D        		.byte	45
3822    12B1  2D        		.byte	45
3823    12B2  2D        		.byte	45
3824    12B3  2D        		.byte	45
3825    12B4  2D        		.byte	45
3826    12B5  2D        		.byte	45
3827    12B6  2D        		.byte	45
3828    12B7  2D        		.byte	45
3829    12B8  2D        		.byte	45
3830    12B9  2D        		.byte	45
3831    12BA  2D        		.byte	45
3832    12BB  2D        		.byte	45
3833    12BC  2D        		.byte	45
3834    12BD  2D        		.byte	45
3835    12BE  2D        		.byte	45
3836    12BF  2D        		.byte	45
3837    12C0  2D        		.byte	45
3838    12C1  2D        		.byte	45
3839    12C2  2D        		.byte	45
3840    12C3  2D        		.byte	45
3841    12C4  2D        		.byte	45
3842    12C5  0A        		.byte	10
3843    12C6  00        		.byte	0
3844                    	L517:
3845    12C7  4F        		.byte	79
3846    12C8  43        		.byte	67
3847    12C9  52        		.byte	82
3848    12CA  20        		.byte	32
3849    12CB  72        		.byte	114
3850    12CC  65        		.byte	101
3851    12CD  67        		.byte	103
3852    12CE  69        		.byte	105
3853    12CF  73        		.byte	115
3854    12D0  74        		.byte	116
3855    12D1  65        		.byte	101
3856    12D2  72        		.byte	114
3857    12D3  3A        		.byte	58
3858    12D4  0A        		.byte	10
3859    12D5  00        		.byte	0
3860                    	L527:
3861    12D6  32        		.byte	50
3862    12D7  2E        		.byte	46
3863    12D8  37        		.byte	55
3864    12D9  2D        		.byte	45
3865    12DA  32        		.byte	50
3866    12DB  2E        		.byte	46
3867    12DC  38        		.byte	56
3868    12DD  56        		.byte	86
3869    12DE  20        		.byte	32
3870    12DF  28        		.byte	40
3871    12E0  62        		.byte	98
3872    12E1  69        		.byte	105
3873    12E2  74        		.byte	116
3874    12E3  20        		.byte	32
3875    12E4  31        		.byte	49
3876    12E5  35        		.byte	53
3877    12E6  29        		.byte	41
3878    12E7  20        		.byte	32
3879    12E8  00        		.byte	0
3880                    	L537:
3881    12E9  32        		.byte	50
3882    12EA  2E        		.byte	46
3883    12EB  38        		.byte	56
3884    12EC  2D        		.byte	45
3885    12ED  32        		.byte	50
3886    12EE  2E        		.byte	46
3887    12EF  39        		.byte	57
3888    12F0  56        		.byte	86
3889    12F1  20        		.byte	32
3890    12F2  28        		.byte	40
3891    12F3  62        		.byte	98
3892    12F4  69        		.byte	105
3893    12F5  74        		.byte	116
3894    12F6  20        		.byte	32
3895    12F7  31        		.byte	49
3896    12F8  36        		.byte	54
3897    12F9  29        		.byte	41
3898    12FA  20        		.byte	32
3899    12FB  00        		.byte	0
3900                    	L547:
3901    12FC  32        		.byte	50
3902    12FD  2E        		.byte	46
3903    12FE  39        		.byte	57
3904    12FF  2D        		.byte	45
3905    1300  33        		.byte	51
3906    1301  2E        		.byte	46
3907    1302  30        		.byte	48
3908    1303  56        		.byte	86
3909    1304  20        		.byte	32
3910    1305  28        		.byte	40
3911    1306  62        		.byte	98
3912    1307  69        		.byte	105
3913    1308  74        		.byte	116
3914    1309  20        		.byte	32
3915    130A  31        		.byte	49
3916    130B  37        		.byte	55
3917    130C  29        		.byte	41
3918    130D  20        		.byte	32
3919    130E  00        		.byte	0
3920                    	L557:
3921    130F  33        		.byte	51
3922    1310  2E        		.byte	46
3923    1311  30        		.byte	48
3924    1312  2D        		.byte	45
3925    1313  33        		.byte	51
3926    1314  2E        		.byte	46
3927    1315  31        		.byte	49
3928    1316  56        		.byte	86
3929    1317  20        		.byte	32
3930    1318  28        		.byte	40
3931    1319  62        		.byte	98
3932    131A  69        		.byte	105
3933    131B  74        		.byte	116
3934    131C  20        		.byte	32
3935    131D  31        		.byte	49
3936    131E  38        		.byte	56
3937    131F  29        		.byte	41
3938    1320  20        		.byte	32
3939    1321  0A        		.byte	10
3940    1322  00        		.byte	0
3941                    	L567:
3942    1323  33        		.byte	51
3943    1324  2E        		.byte	46
3944    1325  31        		.byte	49
3945    1326  2D        		.byte	45
3946    1327  33        		.byte	51
3947    1328  2E        		.byte	46
3948    1329  32        		.byte	50
3949    132A  56        		.byte	86
3950    132B  20        		.byte	32
3951    132C  28        		.byte	40
3952    132D  62        		.byte	98
3953    132E  69        		.byte	105
3954    132F  74        		.byte	116
3955    1330  20        		.byte	32
3956    1331  31        		.byte	49
3957    1332  39        		.byte	57
3958    1333  29        		.byte	41
3959    1334  20        		.byte	32
3960    1335  00        		.byte	0
3961                    	L577:
3962    1336  33        		.byte	51
3963    1337  2E        		.byte	46
3964    1338  32        		.byte	50
3965    1339  2D        		.byte	45
3966    133A  33        		.byte	51
3967    133B  2E        		.byte	46
3968    133C  33        		.byte	51
3969    133D  56        		.byte	86
3970    133E  20        		.byte	32
3971    133F  28        		.byte	40
3972    1340  62        		.byte	98
3973    1341  69        		.byte	105
3974    1342  74        		.byte	116
3975    1343  20        		.byte	32
3976    1344  32        		.byte	50
3977    1345  30        		.byte	48
3978    1346  29        		.byte	41
3979    1347  20        		.byte	32
3980    1348  00        		.byte	0
3981                    	L5001:
3982    1349  33        		.byte	51
3983    134A  2E        		.byte	46
3984    134B  33        		.byte	51
3985    134C  2D        		.byte	45
3986    134D  33        		.byte	51
3987    134E  2E        		.byte	46
3988    134F  34        		.byte	52
3989    1350  56        		.byte	86
3990    1351  20        		.byte	32
3991    1352  28        		.byte	40
3992    1353  62        		.byte	98
3993    1354  69        		.byte	105
3994    1355  74        		.byte	116
3995    1356  20        		.byte	32
3996    1357  32        		.byte	50
3997    1358  31        		.byte	49
3998    1359  29        		.byte	41
3999    135A  20        		.byte	32
4000    135B  00        		.byte	0
4001                    	L5101:
4002    135C  33        		.byte	51
4003    135D  2E        		.byte	46
4004    135E  34        		.byte	52
4005    135F  2D        		.byte	45
4006    1360  33        		.byte	51
4007    1361  2E        		.byte	46
4008    1362  35        		.byte	53
4009    1363  56        		.byte	86
4010    1364  20        		.byte	32
4011    1365  28        		.byte	40
4012    1366  62        		.byte	98
4013    1367  69        		.byte	105
4014    1368  74        		.byte	116
4015    1369  20        		.byte	32
4016    136A  32        		.byte	50
4017    136B  32        		.byte	50
4018    136C  29        		.byte	41
4019    136D  20        		.byte	32
4020    136E  0A        		.byte	10
4021    136F  00        		.byte	0
4022                    	L5201:
4023    1370  33        		.byte	51
4024    1371  2E        		.byte	46
4025    1372  35        		.byte	53
4026    1373  2D        		.byte	45
4027    1374  33        		.byte	51
4028    1375  2E        		.byte	46
4029    1376  36        		.byte	54
4030    1377  56        		.byte	86
4031    1378  20        		.byte	32
4032    1379  28        		.byte	40
4033    137A  62        		.byte	98
4034    137B  69        		.byte	105
4035    137C  74        		.byte	116
4036    137D  20        		.byte	32
4037    137E  32        		.byte	50
4038    137F  33        		.byte	51
4039    1380  29        		.byte	41
4040    1381  20        		.byte	32
4041    1382  0A        		.byte	10
4042    1383  00        		.byte	0
4043                    	L5301:
4044    1384  53        		.byte	83
4045    1385  77        		.byte	119
4046    1386  69        		.byte	105
4047    1387  74        		.byte	116
4048    1388  63        		.byte	99
4049    1389  68        		.byte	104
4050    138A  69        		.byte	105
4051    138B  6E        		.byte	110
4052    138C  67        		.byte	103
4053    138D  20        		.byte	32
4054    138E  74        		.byte	116
4055    138F  6F        		.byte	111
4056    1390  20        		.byte	32
4057    1391  31        		.byte	49
4058    1392  2E        		.byte	46
4059    1393  38        		.byte	56
4060    1394  56        		.byte	86
4061    1395  20        		.byte	32
4062    1396  41        		.byte	65
4063    1397  63        		.byte	99
4064    1398  63        		.byte	99
4065    1399  65        		.byte	101
4066    139A  70        		.byte	112
4067    139B  74        		.byte	116
4068    139C  65        		.byte	101
4069    139D  64        		.byte	100
4070    139E  20        		.byte	32
4071    139F  28        		.byte	40
4072    13A0  53        		.byte	83
4073    13A1  31        		.byte	49
4074    13A2  38        		.byte	56
4075    13A3  41        		.byte	65
4076    13A4  29        		.byte	41
4077    13A5  20        		.byte	32
4078    13A6  28        		.byte	40
4079    13A7  62        		.byte	98
4080    13A8  69        		.byte	105
4081    13A9  74        		.byte	116
4082    13AA  20        		.byte	32
4083    13AB  32        		.byte	50
4084    13AC  34        		.byte	52
4085    13AD  29        		.byte	41
4086    13AE  20        		.byte	32
4087    13AF  73        		.byte	115
4088    13B0  65        		.byte	101
4089    13B1  74        		.byte	116
4090    13B2  20        		.byte	32
4091    13B3  00        		.byte	0
4092                    	L5401:
4093    13B4  4F        		.byte	79
4094    13B5  76        		.byte	118
4095    13B6  65        		.byte	101
   0    13B7  72        		.byte	114
   1    13B8  20        		.byte	32
   2    13B9  32        		.byte	50
   3    13BA  54        		.byte	84
   4    13BB  42        		.byte	66
   5    13BC  20        		.byte	32
   6    13BD  73        		.byte	115
   7    13BE  75        		.byte	117
   8    13BF  70        		.byte	112
   9    13C0  70        		.byte	112
  10    13C1  6F        		.byte	111
  11    13C2  72        		.byte	114
  12    13C3  74        		.byte	116
  13    13C4  20        		.byte	32
  14    13C5  53        		.byte	83
  15    13C6  74        		.byte	116
  16    13C7  61        		.byte	97
  17    13C8  74        		.byte	116
  18    13C9  75        		.byte	117
  19    13CA  73        		.byte	115
  20    13CB  20        		.byte	32
  21    13CC  28        		.byte	40
  22    13CD  43        		.byte	67
  23    13CE  4F        		.byte	79
  24    13CF  32        		.byte	50
  25    13D0  54        		.byte	84
  26    13D1  29        		.byte	41
  27    13D2  20        		.byte	32
  28    13D3  28        		.byte	40
  29    13D4  62        		.byte	98
  30    13D5  69        		.byte	105
  31    13D6  74        		.byte	116
  32    13D7  20        		.byte	32
  33    13D8  32        		.byte	50
  34    13D9  37        		.byte	55
  35    13DA  29        		.byte	41
  36    13DB  20        		.byte	32
  37    13DC  73        		.byte	115
  38    13DD  65        		.byte	101
  39    13DE  74        		.byte	116
  40    13DF  0A        		.byte	10
  41    13E0  00        		.byte	0
  42                    	L5501:
  43    13E1  55        		.byte	85
  44    13E2  48        		.byte	72
  45    13E3  53        		.byte	83
  46    13E4  2D        		.byte	45
  47    13E5  49        		.byte	73
  48    13E6  49        		.byte	73
  49    13E7  20        		.byte	32
  50    13E8  43        		.byte	67
  51    13E9  61        		.byte	97
  52    13EA  72        		.byte	114
  53    13EB  64        		.byte	100
  54    13EC  20        		.byte	32
  55    13ED  53        		.byte	83
  56    13EE  74        		.byte	116
  57    13EF  61        		.byte	97
  58    13F0  74        		.byte	116
  59    13F1  75        		.byte	117
  60    13F2  73        		.byte	115
  61    13F3  20        		.byte	32
  62    13F4  28        		.byte	40
  63    13F5  62        		.byte	98
  64    13F6  69        		.byte	105
  65    13F7  74        		.byte	116
  66    13F8  20        		.byte	32
  67    13F9  32        		.byte	50
  68    13FA  39        		.byte	57
  69    13FB  29        		.byte	41
  70    13FC  20        		.byte	32
  71    13FD  73        		.byte	115
  72    13FE  65        		.byte	101
  73    13FF  74        		.byte	116
  74    1400  20        		.byte	32
  75    1401  00        		.byte	0
  76                    	L5601:
  77    1402  43        		.byte	67
  78    1403  61        		.byte	97
  79    1404  72        		.byte	114
  80    1405  64        		.byte	100
  81    1406  20        		.byte	32
  82    1407  43        		.byte	67
  83    1408  61        		.byte	97
  84    1409  70        		.byte	112
  85    140A  61        		.byte	97
  86    140B  63        		.byte	99
  87    140C  69        		.byte	105
  88    140D  74        		.byte	116
  89    140E  79        		.byte	121
  90    140F  20        		.byte	32
  91    1410  53        		.byte	83
  92    1411  74        		.byte	116
  93    1412  61        		.byte	97
  94    1413  74        		.byte	116
  95    1414  75        		.byte	117
  96    1415  73        		.byte	115
  97    1416  20        		.byte	32
  98    1417  28        		.byte	40
  99    1418  43        		.byte	67
 100    1419  43        		.byte	67
 101    141A  53        		.byte	83
 102    141B  29        		.byte	41
 103    141C  20        		.byte	32
 104    141D  28        		.byte	40
 105    141E  62        		.byte	98
 106    141F  69        		.byte	105
 107    1420  74        		.byte	116
 108    1421  20        		.byte	32
 109    1422  33        		.byte	51
 110    1423  30        		.byte	48
 111    1424  29        		.byte	41
 112    1425  20        		.byte	32
 113    1426  73        		.byte	115
 114    1427  65        		.byte	101
 115    1428  74        		.byte	116
 116    1429  0A        		.byte	10
 117    142A  00        		.byte	0
 118                    	L5701:
 119    142B  20        		.byte	32
 120    142C  20        		.byte	32
 121    142D  53        		.byte	83
 122    142E  44        		.byte	68
 123    142F  20        		.byte	32
 124    1430  56        		.byte	86
 125    1431  65        		.byte	101
 126    1432  72        		.byte	114
 127    1433  2E        		.byte	46
 128    1434  32        		.byte	50
 129    1435  2B        		.byte	43
 130    1436  2C        		.byte	44
 131    1437  20        		.byte	32
 132    1438  42        		.byte	66
 133    1439  6C        		.byte	108
 134    143A  6F        		.byte	111
 135    143B  63        		.byte	99
 136    143C  6B        		.byte	107
 137    143D  20        		.byte	32
 138    143E  61        		.byte	97
 139    143F  64        		.byte	100
 140    1440  64        		.byte	100
 141    1441  72        		.byte	114
 142    1442  65        		.byte	101
 143    1443  73        		.byte	115
 144    1444  73        		.byte	115
 145    1445  00        		.byte	0
 146                    	L5011:
 147    1446  43        		.byte	67
 148    1447  61        		.byte	97
 149    1448  72        		.byte	114
 150    1449  64        		.byte	100
 151    144A  20        		.byte	32
 152    144B  43        		.byte	67
 153    144C  61        		.byte	97
 154    144D  70        		.byte	112
 155    144E  61        		.byte	97
 156    144F  63        		.byte	99
 157    1450  69        		.byte	105
 158    1451  74        		.byte	116
 159    1452  79        		.byte	121
 160    1453  20        		.byte	32
 161    1454  53        		.byte	83
 162    1455  74        		.byte	116
 163    1456  61        		.byte	97
 164    1457  74        		.byte	116
 165    1458  75        		.byte	117
 166    1459  73        		.byte	115
 167    145A  20        		.byte	32
 168    145B  28        		.byte	40
 169    145C  43        		.byte	67
 170    145D  43        		.byte	67
 171    145E  53        		.byte	83
 172    145F  29        		.byte	41
 173    1460  20        		.byte	32
 174    1461  28        		.byte	40
 175    1462  62        		.byte	98
 176    1463  69        		.byte	105
 177    1464  74        		.byte	116
 178    1465  20        		.byte	32
 179    1466  33        		.byte	51
 180    1467  30        		.byte	48
 181    1468  29        		.byte	41
 182    1469  20        		.byte	32
 183    146A  6E        		.byte	110
 184    146B  6F        		.byte	111
 185    146C  74        		.byte	116
 186    146D  20        		.byte	32
 187    146E  73        		.byte	115
 188    146F  65        		.byte	101
 189    1470  74        		.byte	116
 190    1471  0A        		.byte	10
 191    1472  00        		.byte	0
 192                    	L5111:
 193    1473  20        		.byte	32
 194    1474  20        		.byte	32
 195    1475  53        		.byte	83
 196    1476  44        		.byte	68
 197    1477  20        		.byte	32
 198    1478  56        		.byte	86
 199    1479  65        		.byte	101
 200    147A  72        		.byte	114
 201    147B  2E        		.byte	46
 202    147C  32        		.byte	50
 203    147D  2B        		.byte	43
 204    147E  2C        		.byte	44
 205    147F  20        		.byte	32
 206    1480  42        		.byte	66
 207    1481  79        		.byte	121
 208    1482  74        		.byte	116
 209    1483  65        		.byte	101
 210    1484  20        		.byte	32
 211    1485  61        		.byte	97
 212    1486  64        		.byte	100
 213    1487  64        		.byte	100
 214    1488  72        		.byte	114
 215    1489  65        		.byte	101
 216    148A  73        		.byte	115
 217    148B  73        		.byte	115
 218    148C  00        		.byte	0
 219                    	L5211:
 220    148D  20        		.byte	32
 221    148E  20        		.byte	32
 222    148F  53        		.byte	83
 223    1490  44        		.byte	68
 224    1491  20        		.byte	32
 225    1492  56        		.byte	86
 226    1493  65        		.byte	101
 227    1494  72        		.byte	114
 228    1495  2E        		.byte	46
 229    1496  31        		.byte	49
 230    1497  2C        		.byte	44
 231    1498  20        		.byte	32
 232    1499  42        		.byte	66
 233    149A  79        		.byte	121
 234    149B  74        		.byte	116
 235    149C  65        		.byte	101
 236    149D  20        		.byte	32
 237    149E  61        		.byte	97
 238    149F  64        		.byte	100
 239    14A0  64        		.byte	100
 240    14A1  72        		.byte	114
 241    14A2  65        		.byte	101
 242    14A3  73        		.byte	115
 243    14A4  73        		.byte	115
 244    14A5  00        		.byte	0
 245                    	L5311:
 246    14A6  0A        		.byte	10
 247    14A7  43        		.byte	67
 248    14A8  61        		.byte	97
 249    14A9  72        		.byte	114
 250    14AA  64        		.byte	100
 251    14AB  20        		.byte	32
 252    14AC  70        		.byte	112
 253    14AD  6F        		.byte	111
 254    14AE  77        		.byte	119
 255    14AF  65        		.byte	101
 256    14B0  72        		.byte	114
 257    14B1  20        		.byte	32
 258    14B2  75        		.byte	117
 259    14B3  70        		.byte	112
 260    14B4  20        		.byte	32
 261    14B5  73        		.byte	115
 262    14B6  74        		.byte	116
 263    14B7  61        		.byte	97
 264    14B8  74        		.byte	116
 265    14B9  75        		.byte	117
 266    14BA  73        		.byte	115
 267    14BB  20        		.byte	32
 268    14BC  62        		.byte	98
 269    14BD  69        		.byte	105
 270    14BE  74        		.byte	116
 271    14BF  20        		.byte	32
 272    14C0  28        		.byte	40
 273    14C1  62        		.byte	98
 274    14C2  75        		.byte	117
 275    14C3  73        		.byte	115
 276    14C4  79        		.byte	121
 277    14C5  29        		.byte	41
 278    14C6  20        		.byte	32
 279    14C7  28        		.byte	40
 280    14C8  62        		.byte	98
 281    14C9  69        		.byte	105
 282    14CA  74        		.byte	116
 283    14CB  20        		.byte	32
 284    14CC  33        		.byte	51
 285    14CD  31        		.byte	49
 286    14CE  29        		.byte	41
 287    14CF  20        		.byte	32
 288    14D0  73        		.byte	115
 289    14D1  65        		.byte	101
 290    14D2  74        		.byte	116
 291    14D3  0A        		.byte	10
 292    14D4  00        		.byte	0
 293                    	L5411:
 294    14D5  0A        		.byte	10
 295    14D6  43        		.byte	67
 296    14D7  61        		.byte	97
 297    14D8  72        		.byte	114
 298    14D9  64        		.byte	100
 299    14DA  20        		.byte	32
 300    14DB  70        		.byte	112
 301    14DC  6F        		.byte	111
 302    14DD  77        		.byte	119
 303    14DE  65        		.byte	101
 304    14DF  72        		.byte	114
 305    14E0  20        		.byte	32
 306    14E1  75        		.byte	117
 307    14E2  70        		.byte	112
 308    14E3  20        		.byte	32
 309    14E4  73        		.byte	115
 310    14E5  74        		.byte	116
 311    14E6  61        		.byte	97
 312    14E7  74        		.byte	116
 313    14E8  75        		.byte	117
 314    14E9  73        		.byte	115
 315    14EA  20        		.byte	32
 316    14EB  62        		.byte	98
 317    14EC  69        		.byte	105
 318    14ED  74        		.byte	116
 319    14EE  20        		.byte	32
 320    14EF  28        		.byte	40
 321    14F0  62        		.byte	98
 322    14F1  75        		.byte	117
 323    14F2  73        		.byte	115
 324    14F3  79        		.byte	121
 325    14F4  29        		.byte	41
 326    14F5  20        		.byte	32
 327    14F6  28        		.byte	40
 328    14F7  62        		.byte	98
 329    14F8  69        		.byte	105
 330    14F9  74        		.byte	116
 331    14FA  20        		.byte	32
 332    14FB  33        		.byte	51
 333    14FC  31        		.byte	49
 334    14FD  29        		.byte	41
 335    14FE  20        		.byte	32
 336    14FF  6E        		.byte	110
 337    1500  6F        		.byte	111
 338    1501  74        		.byte	116
 339    1502  20        		.byte	32
 340    1503  73        		.byte	115
 341    1504  65        		.byte	101
 342    1505  74        		.byte	116
 343    1506  2E        		.byte	46
 344    1507  0A        		.byte	10
 345    1508  00        		.byte	0
 346                    	L5511:
 347    1509  20        		.byte	32
 348    150A  20        		.byte	32
 349    150B  54        		.byte	84
 350    150C  68        		.byte	104
 351    150D  69        		.byte	105
 352    150E  73        		.byte	115
 353    150F  20        		.byte	32
 354    1510  62        		.byte	98
 355    1511  69        		.byte	105
 356    1512  74        		.byte	116
 357    1513  20        		.byte	32
 358    1514  69        		.byte	105
 359    1515  73        		.byte	115
 360    1516  20        		.byte	32
 361    1517  6E        		.byte	110
 362    1518  6F        		.byte	111
 363    1519  74        		.byte	116
 364    151A  20        		.byte	32
 365    151B  73        		.byte	115
 366    151C  65        		.byte	101
 367    151D  74        		.byte	116
 368    151E  20        		.byte	32
 369    151F  69        		.byte	105
 370    1520  66        		.byte	102
 371    1521  20        		.byte	32
 372    1522  74        		.byte	116
 373    1523  68        		.byte	104
 374    1524  65        		.byte	101
 375    1525  20        		.byte	32
 376    1526  63        		.byte	99
 377    1527  61        		.byte	97
 378    1528  72        		.byte	114
 379    1529  64        		.byte	100
 380    152A  20        		.byte	32
 381    152B  68        		.byte	104
 382    152C  61        		.byte	97
 383    152D  73        		.byte	115
 384    152E  20        		.byte	32
 385    152F  6E        		.byte	110
 386    1530  6F        		.byte	111
 387    1531  74        		.byte	116
 388    1532  20        		.byte	32
 389    1533  66        		.byte	102
 390    1534  69        		.byte	105
 391    1535  6E        		.byte	110
 392    1536  69        		.byte	105
 393    1537  73        		.byte	115
 394    1538  68        		.byte	104
 395    1539  65        		.byte	101
 396    153A  64        		.byte	100
 397    153B  20        		.byte	32
 398    153C  74        		.byte	116
 399    153D  68        		.byte	104
 400    153E  65        		.byte	101
 401    153F  20        		.byte	32
 402    1540  70        		.byte	112
 403    1541  6F        		.byte	111
 404    1542  77        		.byte	119
 405    1543  65        		.byte	101
 406    1544  72        		.byte	114
 407    1545  20        		.byte	32
 408    1546  75        		.byte	117
 409    1547  70        		.byte	112
 410    1548  20        		.byte	32
 411    1549  72        		.byte	114
 412    154A  6F        		.byte	111
 413    154B  75        		.byte	117
 414    154C  74        		.byte	116
 415    154D  69        		.byte	105
 416    154E  6E        		.byte	110
 417    154F  65        		.byte	101
 418    1550  2E        		.byte	46
 419    1551  0A        		.byte	10
 420    1552  00        		.byte	0
 421                    	L5611:
 422    1553  2D        		.byte	45
 423    1554  2D        		.byte	45
 424    1555  2D        		.byte	45
 425    1556  2D        		.byte	45
 426    1557  2D        		.byte	45
 427    1558  2D        		.byte	45
 428    1559  2D        		.byte	45
 429    155A  2D        		.byte	45
 430    155B  2D        		.byte	45
 431    155C  2D        		.byte	45
 432    155D  2D        		.byte	45
 433    155E  2D        		.byte	45
 434    155F  2D        		.byte	45
 435    1560  2D        		.byte	45
 436    1561  2D        		.byte	45
 437    1562  2D        		.byte	45
 438    1563  2D        		.byte	45
 439    1564  2D        		.byte	45
 440    1565  2D        		.byte	45
 441    1566  2D        		.byte	45
 442    1567  2D        		.byte	45
 443    1568  2D        		.byte	45
 444    1569  2D        		.byte	45
 445    156A  2D        		.byte	45
 446    156B  2D        		.byte	45
 447    156C  2D        		.byte	45
 448    156D  2D        		.byte	45
 449    156E  2D        		.byte	45
 450    156F  2D        		.byte	45
 451    1570  2D        		.byte	45
 452    1571  2D        		.byte	45
 453    1572  2D        		.byte	45
 454    1573  2D        		.byte	45
 455    1574  2D        		.byte	45
 456    1575  2D        		.byte	45
 457    1576  2D        		.byte	45
 458    1577  2D        		.byte	45
 459    1578  2D        		.byte	45
 460    1579  0A        		.byte	10
 461    157A  00        		.byte	0
 462                    	L5711:
 463    157B  43        		.byte	67
 464    157C  49        		.byte	73
 465    157D  44        		.byte	68
 466    157E  20        		.byte	32
 467    157F  72        		.byte	114
 468    1580  65        		.byte	101
 469    1581  67        		.byte	103
 470    1582  69        		.byte	105
 471    1583  73        		.byte	115
 472    1584  74        		.byte	116
 473    1585  65        		.byte	101
 474    1586  72        		.byte	114
 475    1587  3A        		.byte	58
 476    1588  0A        		.byte	10
 477    1589  00        		.byte	0
 478                    	L5021:
 479    158A  4D        		.byte	77
 480    158B  49        		.byte	73
 481    158C  44        		.byte	68
 482    158D  3A        		.byte	58
 483    158E  20        		.byte	32
 484    158F  30        		.byte	48
 485    1590  78        		.byte	120
 486    1591  25        		.byte	37
 487    1592  30        		.byte	48
 488    1593  32        		.byte	50
 489    1594  78        		.byte	120
 490    1595  2C        		.byte	44
 491    1596  20        		.byte	32
 492    1597  00        		.byte	0
 493                    	L5121:
 494    1598  4F        		.byte	79
 495    1599  49        		.byte	73
 496    159A  44        		.byte	68
 497    159B  3A        		.byte	58
 498    159C  20        		.byte	32
 499    159D  25        		.byte	37
 500    159E  2E        		.byte	46
 501    159F  32        		.byte	50
 502    15A0  73        		.byte	115
 503    15A1  2C        		.byte	44
 504    15A2  20        		.byte	32
 505    15A3  00        		.byte	0
 506                    	L5221:
 507    15A4  50        		.byte	80
 508    15A5  4E        		.byte	78
 509    15A6  4D        		.byte	77
 510    15A7  3A        		.byte	58
 511    15A8  20        		.byte	32
 512    15A9  25        		.byte	37
 513    15AA  2E        		.byte	46
 514    15AB  35        		.byte	53
 515    15AC  73        		.byte	115
 516    15AD  2C        		.byte	44
 517    15AE  20        		.byte	32
 518    15AF  00        		.byte	0
 519                    	L5321:
 520    15B0  50        		.byte	80
 521    15B1  52        		.byte	82
 522    15B2  56        		.byte	86
 523    15B3  3A        		.byte	58
 524    15B4  20        		.byte	32
 525    15B5  25        		.byte	37
 526    15B6  64        		.byte	100
 527    15B7  2E        		.byte	46
 528    15B8  25        		.byte	37
 529    15B9  64        		.byte	100
 530    15BA  2C        		.byte	44
 531    15BB  20        		.byte	32
 532    15BC  00        		.byte	0
 533                    	L5421:
 534    15BD  50        		.byte	80
 535    15BE  53        		.byte	83
 536    15BF  4E        		.byte	78
 537    15C0  3A        		.byte	58
 538    15C1  20        		.byte	32
 539    15C2  25        		.byte	37
 540    15C3  6C        		.byte	108
 541    15C4  75        		.byte	117
 542    15C5  2C        		.byte	44
 543    15C6  20        		.byte	32
 544    15C7  00        		.byte	0
 545                    	L5521:
 546    15C8  4D        		.byte	77
 547    15C9  44        		.byte	68
 548    15CA  54        		.byte	84
 549    15CB  3A        		.byte	58
 550    15CC  20        		.byte	32
 551    15CD  25        		.byte	37
 552    15CE  64        		.byte	100
 553    15CF  2D        		.byte	45
 554    15D0  25        		.byte	37
 555    15D1  64        		.byte	100
 556    15D2  0A        		.byte	10
 557    15D3  00        		.byte	0
 558                    	L5621:
 559    15D4  2D        		.byte	45
 560    15D5  2D        		.byte	45
 561    15D6  2D        		.byte	45
 562    15D7  2D        		.byte	45
 563    15D8  2D        		.byte	45
 564    15D9  2D        		.byte	45
 565    15DA  2D        		.byte	45
 566    15DB  2D        		.byte	45
 567    15DC  2D        		.byte	45
 568    15DD  2D        		.byte	45
 569    15DE  2D        		.byte	45
 570    15DF  2D        		.byte	45
 571    15E0  2D        		.byte	45
 572    15E1  2D        		.byte	45
 573    15E2  2D        		.byte	45
 574    15E3  2D        		.byte	45
 575    15E4  2D        		.byte	45
 576    15E5  2D        		.byte	45
 577    15E6  2D        		.byte	45
 578    15E7  2D        		.byte	45
 579    15E8  2D        		.byte	45
 580    15E9  2D        		.byte	45
 581    15EA  2D        		.byte	45
 582    15EB  2D        		.byte	45
 583    15EC  2D        		.byte	45
 584    15ED  2D        		.byte	45
 585    15EE  2D        		.byte	45
 586    15EF  2D        		.byte	45
 587    15F0  2D        		.byte	45
 588    15F1  2D        		.byte	45
 589    15F2  2D        		.byte	45
 590    15F3  2D        		.byte	45
 591    15F4  2D        		.byte	45
 592    15F5  2D        		.byte	45
 593    15F6  2D        		.byte	45
 594    15F7  2D        		.byte	45
 595    15F8  2D        		.byte	45
 596    15F9  2D        		.byte	45
 597    15FA  0A        		.byte	10
 598    15FB  00        		.byte	0
 599                    	L5721:
 600    15FC  43        		.byte	67
 601    15FD  53        		.byte	83
 602    15FE  44        		.byte	68
 603    15FF  20        		.byte	32
 604    1600  72        		.byte	114
 605    1601  65        		.byte	101
 606    1602  67        		.byte	103
 607    1603  69        		.byte	105
 608    1604  73        		.byte	115
 609    1605  74        		.byte	116
 610    1606  65        		.byte	101
 611    1607  72        		.byte	114
 612    1608  3A        		.byte	58
 613    1609  0A        		.byte	10
 614    160A  00        		.byte	0
 615                    	L5031:
 616    160B  43        		.byte	67
 617    160C  53        		.byte	83
 618    160D  44        		.byte	68
 619    160E  20        		.byte	32
 620    160F  56        		.byte	86
 621    1610  65        		.byte	101
 622    1611  72        		.byte	114
 623    1612  73        		.byte	115
 624    1613  69        		.byte	105
 625    1614  6F        		.byte	111
 626    1615  6E        		.byte	110
 627    1616  20        		.byte	32
 628    1617  31        		.byte	49
 629    1618  2E        		.byte	46
 630    1619  30        		.byte	48
 631    161A  2C        		.byte	44
 632    161B  20        		.byte	32
 633    161C  53        		.byte	83
 634    161D  74        		.byte	116
 635    161E  61        		.byte	97
 636    161F  6E        		.byte	110
 637    1620  64        		.byte	100
 638    1621  61        		.byte	97
 639    1622  72        		.byte	114
 640    1623  64        		.byte	100
 641    1624  20        		.byte	32
 642    1625  43        		.byte	67
 643    1626  61        		.byte	97
 644    1627  70        		.byte	112
 645    1628  61        		.byte	97
 646    1629  63        		.byte	99
 647    162A  69        		.byte	105
 648    162B  74        		.byte	116
 649    162C  79        		.byte	121
 650    162D  0A        		.byte	10
 651    162E  00        		.byte	0
 652                    	L5131:
 653    162F  20        		.byte	32
 654    1630  44        		.byte	68
 655    1631  65        		.byte	101
 656    1632  76        		.byte	118
 657    1633  69        		.byte	105
 658    1634  63        		.byte	99
 659    1635  65        		.byte	101
 660    1636  20        		.byte	32
 661    1637  63        		.byte	99
 662    1638  61        		.byte	97
 663    1639  70        		.byte	112
 664    163A  61        		.byte	97
 665    163B  63        		.byte	99
 666    163C  69        		.byte	105
 667    163D  74        		.byte	116
 668    163E  79        		.byte	121
 669    163F  3A        		.byte	58
 670    1640  20        		.byte	32
 671    1641  25        		.byte	37
 672    1642  6C        		.byte	108
 673    1643  75        		.byte	117
 674    1644  20        		.byte	32
 675    1645  4B        		.byte	75
 676    1646  42        		.byte	66
 677    1647  79        		.byte	121
 678    1648  74        		.byte	116
 679    1649  65        		.byte	101
 680    164A  2C        		.byte	44
 681    164B  20        		.byte	32
 682    164C  25        		.byte	37
 683    164D  6C        		.byte	108
 684    164E  75        		.byte	117
 685    164F  20        		.byte	32
 686    1650  4D        		.byte	77
 687    1651  42        		.byte	66
 688    1652  79        		.byte	121
 689    1653  74        		.byte	116
 690    1654  65        		.byte	101
 691    1655  0A        		.byte	10
 692    1656  00        		.byte	0
 693                    	L5231:
 694    1657  43        		.byte	67
 695    1658  53        		.byte	83
 696    1659  44        		.byte	68
 697    165A  20        		.byte	32
 698    165B  56        		.byte	86
 699    165C  65        		.byte	101
 700    165D  72        		.byte	114
 701    165E  73        		.byte	115
 702    165F  69        		.byte	105
 703    1660  6F        		.byte	111
 704    1661  6E        		.byte	110
 705    1662  20        		.byte	32
 706    1663  32        		.byte	50
 707    1664  2E        		.byte	46
 708    1665  30        		.byte	48
 709    1666  2C        		.byte	44
 710    1667  20        		.byte	32
 711    1668  48        		.byte	72
 712    1669  69        		.byte	105
 713    166A  67        		.byte	103
 714    166B  68        		.byte	104
 715    166C  20        		.byte	32
 716    166D  43        		.byte	67
 717    166E  61        		.byte	97
 718    166F  70        		.byte	112
 719    1670  61        		.byte	97
 720    1671  63        		.byte	99
 721    1672  69        		.byte	105
 722    1673  74        		.byte	116
 723    1674  79        		.byte	121
 724    1675  20        		.byte	32
 725    1676  61        		.byte	97
 726    1677  6E        		.byte	110
 727    1678  64        		.byte	100
 728    1679  20        		.byte	32
 729    167A  45        		.byte	69
 730    167B  78        		.byte	120
 731    167C  74        		.byte	116
 732    167D  65        		.byte	101
 733    167E  6E        		.byte	110
 734    167F  64        		.byte	100
 735    1680  65        		.byte	101
 736    1681  64        		.byte	100
 737    1682  20        		.byte	32
 738    1683  43        		.byte	67
 739    1684  61        		.byte	97
 740    1685  70        		.byte	112
 741    1686  61        		.byte	97
 742    1687  63        		.byte	99
 743    1688  69        		.byte	105
 744    1689  74        		.byte	116
 745    168A  79        		.byte	121
 746    168B  0A        		.byte	10
 747    168C  00        		.byte	0
 748                    	L5331:
 749    168D  20        		.byte	32
 750    168E  44        		.byte	68
 751    168F  65        		.byte	101
 752    1690  76        		.byte	118
 753    1691  69        		.byte	105
 754    1692  63        		.byte	99
 755    1693  65        		.byte	101
 756    1694  20        		.byte	32
 757    1695  63        		.byte	99
 758    1696  61        		.byte	97
 759    1697  70        		.byte	112
 760    1698  61        		.byte	97
 761    1699  63        		.byte	99
 762    169A  69        		.byte	105
 763    169B  74        		.byte	116
 764    169C  79        		.byte	121
 765    169D  3A        		.byte	58
 766    169E  20        		.byte	32
 767    169F  25        		.byte	37
 768    16A0  6C        		.byte	108
 769    16A1  75        		.byte	117
 770    16A2  20        		.byte	32
 771    16A3  4B        		.byte	75
 772    16A4  42        		.byte	66
 773    16A5  79        		.byte	121
 774    16A6  74        		.byte	116
 775    16A7  65        		.byte	101
 776    16A8  2C        		.byte	44
 777    16A9  20        		.byte	32
 778    16AA  25        		.byte	37
 779    16AB  6C        		.byte	108
 780    16AC  75        		.byte	117
 781    16AD  20        		.byte	32
 782    16AE  4D        		.byte	77
 783    16AF  42        		.byte	66
 784    16B0  79        		.byte	121
 785    16B1  74        		.byte	116
 786    16B2  65        		.byte	101
 787    16B3  0A        		.byte	10
 788    16B4  00        		.byte	0
 789                    	L5431:
 790    16B5  43        		.byte	67
 791    16B6  53        		.byte	83
 792    16B7  44        		.byte	68
 793    16B8  20        		.byte	32
 794    16B9  56        		.byte	86
 795    16BA  65        		.byte	101
 796    16BB  72        		.byte	114
 797    16BC  73        		.byte	115
 798    16BD  69        		.byte	105
 799    16BE  6F        		.byte	111
 800    16BF  6E        		.byte	110
 801    16C0  20        		.byte	32
 802    16C1  33        		.byte	51
 803    16C2  2E        		.byte	46
 804    16C3  30        		.byte	48
 805    16C4  2C        		.byte	44
 806    16C5  20        		.byte	32
 807    16C6  55        		.byte	85
 808    16C7  6C        		.byte	108
 809    16C8  74        		.byte	116
 810    16C9  72        		.byte	114
 811    16CA  61        		.byte	97
 812    16CB  20        		.byte	32
 813    16CC  43        		.byte	67
 814    16CD  61        		.byte	97
 815    16CE  70        		.byte	112
 816    16CF  61        		.byte	97
 817    16D0  63        		.byte	99
 818    16D1  69        		.byte	105
 819    16D2  74        		.byte	116
 820    16D3  79        		.byte	121
 821    16D4  20        		.byte	32
 822    16D5  28        		.byte	40
 823    16D6  53        		.byte	83
 824    16D7  44        		.byte	68
 825    16D8  55        		.byte	85
 826    16D9  43        		.byte	67
 827    16DA  29        		.byte	41
 828    16DB  0A        		.byte	10
 829    16DC  00        		.byte	0
 830                    	L5531:
 831    16DD  20        		.byte	32
 832    16DE  44        		.byte	68
 833    16DF  65        		.byte	101
 834    16E0  76        		.byte	118
 835    16E1  69        		.byte	105
 836    16E2  63        		.byte	99
 837    16E3  65        		.byte	101
 838    16E4  20        		.byte	32
 839    16E5  63        		.byte	99
 840    16E6  61        		.byte	97
 841    16E7  70        		.byte	112
 842    16E8  61        		.byte	97
 843    16E9  63        		.byte	99
 844    16EA  69        		.byte	105
 845    16EB  74        		.byte	116
 846    16EC  79        		.byte	121
 847    16ED  3A        		.byte	58
 848    16EE  20        		.byte	32
 849    16EF  25        		.byte	37
 850    16F0  6C        		.byte	108
 851    16F1  75        		.byte	117
 852    16F2  20        		.byte	32
 853    16F3  4B        		.byte	75
 854    16F4  42        		.byte	66
 855    16F5  79        		.byte	121
 856    16F6  74        		.byte	116
 857    16F7  65        		.byte	101
 858    16F8  2C        		.byte	44
 859    16F9  20        		.byte	32
 860    16FA  25        		.byte	37
 861    16FB  6C        		.byte	108
 862    16FC  75        		.byte	117
 863    16FD  20        		.byte	32
 864    16FE  4D        		.byte	77
 865    16FF  42        		.byte	66
 866    1700  79        		.byte	121
 867    1701  74        		.byte	116
 868    1702  65        		.byte	101
 869    1703  0A        		.byte	10
 870    1704  00        		.byte	0
 871                    	L5631:
 872    1705  2D        		.byte	45
 873    1706  2D        		.byte	45
 874    1707  2D        		.byte	45
 875    1708  2D        		.byte	45
 876    1709  2D        		.byte	45
 877    170A  2D        		.byte	45
 878    170B  2D        		.byte	45
 879    170C  2D        		.byte	45
 880    170D  2D        		.byte	45
 881    170E  2D        		.byte	45
 882    170F  2D        		.byte	45
 883    1710  2D        		.byte	45
 884    1711  2D        		.byte	45
 885    1712  2D        		.byte	45
 886    1713  2D        		.byte	45
 887    1714  2D        		.byte	45
 888    1715  2D        		.byte	45
 889    1716  2D        		.byte	45
 890    1717  2D        		.byte	45
 891    1718  2D        		.byte	45
 892    1719  2D        		.byte	45
 893    171A  2D        		.byte	45
 894    171B  2D        		.byte	45
 895    171C  2D        		.byte	45
 896    171D  2D        		.byte	45
 897    171E  2D        		.byte	45
 898    171F  2D        		.byte	45
 899    1720  2D        		.byte	45
 900    1721  2D        		.byte	45
 901    1722  2D        		.byte	45
 902    1723  2D        		.byte	45
 903    1724  2D        		.byte	45
 904    1725  2D        		.byte	45
 905    1726  2D        		.byte	45
 906    1727  2D        		.byte	45
 907    1728  2D        		.byte	45
 908    1729  2D        		.byte	45
 909    172A  2D        		.byte	45
 910    172B  0A        		.byte	10
 911    172C  00        		.byte	0
 912                    	;  624      }
 913                    	;  625  
 914                    	;  626  /* print OCR, CID and CSD registers*/
 915                    	;  627  void sdprtreg()
 916                    	;  628      {
 917                    	_sdprtreg:
 918    172D  CD0000    		call	c.savs0
 919    1730  21EEFF    		ld	hl,65518
 920    1733  39        		add	hl,sp
 921    1734  F9        		ld	sp,hl
 922                    	;  629      unsigned int n;
 923                    	;  630      unsigned int csize;
 924                    	;  631      unsigned long devsize;
 925                    	;  632      unsigned long capacity;
 926                    	;  633  
 927                    	;  634      if (!sdinitok)
 928    1735  2A0C00    		ld	hl,(_sdinitok)
 929    1738  7C        		ld	a,h
 930    1739  B5        		or	l
 931    173A  2009      		jr	nz,L1732
 932                    	;  635          {
 933                    	;  636          printf("SD card not initialized\n");
 934    173C  212711    		ld	hl,L525
 935    173F  CD0000    		call	_printf
 936                    	;  637          return;
 937    1742  C30000    		jp	c.rets0
 938                    	L1732:
 939                    	;  638          }
 940                    	;  639      printf("SD card information:");
 941    1745  214011    		ld	hl,L535
 942    1748  CD0000    		call	_printf
 943                    	;  640      if (ocrreg[0] & 0x80)
 944    174B  3A4800    		ld	a,(_ocrreg)
 945    174E  CB7F      		bit	7,a
 946    1750  6F        		ld	l,a
 947    1751  2825      		jr	z,L1042
 948                    	;  641          {
 949                    	;  642          if (ocrreg[0] & 0x40)
 950    1753  3A4800    		ld	a,(_ocrreg)
 951    1756  CB77      		bit	6,a
 952    1758  6F        		ld	l,a
 953    1759  2808      		jr	z,L1142
 954                    	;  643              printf("  SD card ver. 2+, Block address\n");
 955    175B  215511    		ld	hl,L545
 956    175E  CD0000    		call	_printf
 957                    	;  644          else
 958    1761  1815      		jr	L1042
 959                    	L1142:
 960                    	;  645              {
 961                    	;  646              if (sdver2)
 962    1763  2A0A00    		ld	hl,(_sdver2)
 963    1766  7C        		ld	a,h
 964    1767  B5        		or	l
 965    1768  2808      		jr	z,L1342
 966                    	;  647                  printf("  SD card ver. 2+, Byte address\n");
 967    176A  217711    		ld	hl,L555
 968    176D  CD0000    		call	_printf
 969                    	;  648              else
 970    1770  1806      		jr	L1042
 971                    	L1342:
 972                    	;  649                  printf("  SD card ver. 1, Byte address\n");
 973    1772  219811    		ld	hl,L565
 974    1775  CD0000    		call	_printf
 975                    	L1042:
 976                    	;  650              }
 977                    	;  651          }
 978                    	;  652      printf("  Manufacturer ID: 0x%02x, ", cidreg[0]);
 979    1778  3A3800    		ld	a,(_cidreg)
 980    177B  4F        		ld	c,a
 981    177C  97        		sub	a
 982    177D  47        		ld	b,a
 983    177E  C5        		push	bc
 984    177F  21B811    		ld	hl,L575
 985    1782  CD0000    		call	_printf
 986    1785  F1        		pop	af
 987                    	;  653      printf("OEM ID: %.2s, ", &cidreg[1]);
 988    1786  213900    		ld	hl,_cidreg+1
 989    1789  E5        		push	hl
 990    178A  21D411    		ld	hl,L506
 991    178D  CD0000    		call	_printf
 992    1790  F1        		pop	af
 993                    	;  654      printf("Product name: %.5s\n", &cidreg[3]);
 994    1791  213B00    		ld	hl,_cidreg+3
 995    1794  E5        		push	hl
 996    1795  21E311    		ld	hl,L516
 997    1798  CD0000    		call	_printf
 998    179B  F1        		pop	af
 999                    	;  655      printf("  Product revision: %d.%d, ",
1000                    	;  656             (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
1001    179C  3A4000    		ld	a,(_cidreg+8)
1002    179F  6F        		ld	l,a
1003    17A0  97        		sub	a
1004    17A1  67        		ld	h,a
1005    17A2  7D        		ld	a,l
1006    17A3  E60F      		and	15
1007    17A5  6F        		ld	l,a
1008    17A6  97        		sub	a
1009    17A7  67        		ld	h,a
1010    17A8  E5        		push	hl
1011    17A9  3A4000    		ld	a,(_cidreg+8)
1012    17AC  4F        		ld	c,a
1013    17AD  97        		sub	a
1014    17AE  47        		ld	b,a
1015    17AF  C5        		push	bc
1016    17B0  210400    		ld	hl,4
1017    17B3  E5        		push	hl
1018    17B4  CD0000    		call	c.irsh
1019    17B7  E1        		pop	hl
1020    17B8  7D        		ld	a,l
1021    17B9  E60F      		and	15
1022    17BB  6F        		ld	l,a
1023    17BC  97        		sub	a
1024    17BD  67        		ld	h,a
1025    17BE  E5        		push	hl
1026    17BF  21F711    		ld	hl,L526
1027    17C2  CD0000    		call	_printf
1028    17C5  F1        		pop	af
1029    17C6  F1        		pop	af
1030                    	;  657      printf("Serial number: %lu\n",
1031                    	;  658             (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
1032    17C7  3A4100    		ld	a,(_cidreg+9)
1033    17CA  4F        		ld	c,a
1034    17CB  97        		sub	a
1035    17CC  47        		ld	b,a
1036    17CD  C5        		push	bc
1037    17CE  211800    		ld	hl,24
1038    17D1  E5        		push	hl
1039    17D2  CD0000    		call	c.ilsh
1040    17D5  E1        		pop	hl
1041    17D6  E5        		push	hl
1042    17D7  3A4200    		ld	a,(_cidreg+10)
1043    17DA  4F        		ld	c,a
1044    17DB  97        		sub	a
1045    17DC  47        		ld	b,a
1046    17DD  C5        		push	bc
1047    17DE  211000    		ld	hl,16
1048    17E1  E5        		push	hl
1049    17E2  CD0000    		call	c.ilsh
1050    17E5  E1        		pop	hl
1051    17E6  E3        		ex	(sp),hl
1052    17E7  C1        		pop	bc
1053    17E8  09        		add	hl,bc
1054    17E9  E5        		push	hl
1055    17EA  3A4300    		ld	a,(_cidreg+11)
1056    17ED  6F        		ld	l,a
1057    17EE  97        		sub	a
1058    17EF  67        		ld	h,a
1059    17F0  29        		add	hl,hl
1060    17F1  29        		add	hl,hl
1061    17F2  29        		add	hl,hl
1062    17F3  29        		add	hl,hl
1063    17F4  29        		add	hl,hl
1064    17F5  29        		add	hl,hl
1065    17F6  29        		add	hl,hl
1066    17F7  29        		add	hl,hl
1067    17F8  E3        		ex	(sp),hl
1068    17F9  C1        		pop	bc
1069    17FA  09        		add	hl,bc
1070    17FB  E5        		push	hl
1071    17FC  3A4400    		ld	a,(_cidreg+12)
1072    17FF  6F        		ld	l,a
1073    1800  97        		sub	a
1074    1801  67        		ld	h,a
1075    1802  E3        		ex	(sp),hl
1076    1803  C1        		pop	bc
1077    1804  09        		add	hl,bc
1078    1805  E5        		push	hl
1079    1806  211312    		ld	hl,L536
1080    1809  CD0000    		call	_printf
1081    180C  F1        		pop	af
1082                    	;  659      printf("  Manufacturing date: %d-%d, ",
1083                    	;  660             2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
1084    180D  3A4600    		ld	a,(_cidreg+14)
1085    1810  6F        		ld	l,a
1086    1811  97        		sub	a
1087    1812  67        		ld	h,a
1088    1813  7D        		ld	a,l
1089    1814  E60F      		and	15
1090    1816  6F        		ld	l,a
1091    1817  97        		sub	a
1092    1818  67        		ld	h,a
1093    1819  E5        		push	hl
1094    181A  3A4500    		ld	a,(_cidreg+13)
1095    181D  6F        		ld	l,a
1096    181E  97        		sub	a
1097    181F  67        		ld	h,a
1098    1820  7D        		ld	a,l
1099    1821  E60F      		and	15
1100    1823  6F        		ld	l,a
1101    1824  97        		sub	a
1102    1825  67        		ld	h,a
1103    1826  29        		add	hl,hl
1104    1827  29        		add	hl,hl
1105    1828  29        		add	hl,hl
1106    1829  29        		add	hl,hl
1107    182A  01D007    		ld	bc,2000
1108    182D  09        		add	hl,bc
1109    182E  E5        		push	hl
1110    182F  3A4600    		ld	a,(_cidreg+14)
1111    1832  4F        		ld	c,a
1112    1833  97        		sub	a
1113    1834  47        		ld	b,a
1114    1835  C5        		push	bc
1115    1836  210400    		ld	hl,4
1116    1839  E5        		push	hl
1117    183A  CD0000    		call	c.irsh
1118    183D  E1        		pop	hl
1119    183E  E3        		ex	(sp),hl
1120    183F  C1        		pop	bc
1121    1840  09        		add	hl,bc
1122    1841  E5        		push	hl
1123    1842  212712    		ld	hl,L546
1124    1845  CD0000    		call	_printf
1125    1848  F1        		pop	af
1126    1849  F1        		pop	af
1127                    	;  661      if ((csdreg[0] & 0xc0) == 0x00) /* CSD version 1 */
1128    184A  3A2800    		ld	a,(_csdreg)
1129    184D  E6C0      		and	192
1130    184F  C22D19    		jp	nz,L1542
1131                    	;  662          {
1132                    	;  663          n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
1133    1852  3A2D00    		ld	a,(_csdreg+5)
1134    1855  6F        		ld	l,a
1135    1856  97        		sub	a
1136    1857  67        		ld	h,a
1137    1858  7D        		ld	a,l
1138    1859  E60F      		and	15
1139    185B  6F        		ld	l,a
1140    185C  97        		sub	a
1141    185D  67        		ld	h,a
1142    185E  E5        		push	hl
1143    185F  3A3200    		ld	a,(_csdreg+10)
1144    1862  6F        		ld	l,a
1145    1863  97        		sub	a
1146    1864  67        		ld	h,a
1147    1865  7D        		ld	a,l
1148    1866  E680      		and	128
1149    1868  6F        		ld	l,a
1150    1869  97        		sub	a
1151    186A  67        		ld	h,a
1152    186B  E5        		push	hl
1153    186C  210700    		ld	hl,7
1154    186F  E5        		push	hl
1155    1870  CD0000    		call	c.irsh
1156    1873  E1        		pop	hl
1157    1874  E3        		ex	(sp),hl
1158    1875  C1        		pop	bc
1159    1876  09        		add	hl,bc
1160    1877  E5        		push	hl
1161    1878  3A3100    		ld	a,(_csdreg+9)
1162    187B  6F        		ld	l,a
1163    187C  97        		sub	a
1164    187D  67        		ld	h,a
1165    187E  7D        		ld	a,l
1166    187F  E603      		and	3
1167    1881  6F        		ld	l,a
1168    1882  97        		sub	a
1169    1883  67        		ld	h,a
1170    1884  29        		add	hl,hl
1171    1885  E3        		ex	(sp),hl
1172    1886  C1        		pop	bc
1173    1887  09        		add	hl,bc
1174    1888  23        		inc	hl
1175    1889  23        		inc	hl
1176    188A  DD75F8    		ld	(ix-8),l
1177    188D  DD74F9    		ld	(ix-7),h
1178                    	;  664          csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
1179                    	;  665                  ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
1180    1890  3A3000    		ld	a,(_csdreg+8)
1181    1893  4F        		ld	c,a
1182    1894  97        		sub	a
1183    1895  47        		ld	b,a
1184    1896  C5        		push	bc
1185    1897  210600    		ld	hl,6
1186    189A  E5        		push	hl
1187    189B  CD0000    		call	c.irsh
1188    189E  E1        		pop	hl
1189    189F  E5        		push	hl
1190    18A0  3A2F00    		ld	a,(_csdreg+7)
1191    18A3  6F        		ld	l,a
1192    18A4  97        		sub	a
1193    18A5  67        		ld	h,a
1194    18A6  29        		add	hl,hl
1195    18A7  29        		add	hl,hl
1196    18A8  E3        		ex	(sp),hl
1197    18A9  C1        		pop	bc
1198    18AA  09        		add	hl,bc
1199    18AB  E5        		push	hl
1200    18AC  3A2E00    		ld	a,(_csdreg+6)
1201    18AF  6F        		ld	l,a
1202    18B0  97        		sub	a
1203    18B1  67        		ld	h,a
1204    18B2  7D        		ld	a,l
1205    18B3  E603      		and	3
1206    18B5  6F        		ld	l,a
1207    18B6  97        		sub	a
1208    18B7  67        		ld	h,a
1209    18B8  E5        		push	hl
1210    18B9  210A00    		ld	hl,10
1211    18BC  E5        		push	hl
1212    18BD  CD0000    		call	c.ilsh
1213    18C0  E1        		pop	hl
1214    18C1  E3        		ex	(sp),hl
1215    18C2  C1        		pop	bc
1216    18C3  09        		add	hl,bc
1217    18C4  23        		inc	hl
1218    18C5  DD75F6    		ld	(ix-10),l
1219    18C8  DD74F7    		ld	(ix-9),h
1220                    	;  666          capacity = (unsigned long) csize << (n-10);
1221    18CB  DDE5      		push	ix
1222    18CD  C1        		pop	bc
1223    18CE  21EEFF    		ld	hl,65518
1224    18D1  09        		add	hl,bc
1225    18D2  E5        		push	hl
1226    18D3  DDE5      		push	ix
1227    18D5  C1        		pop	bc
1228    18D6  21F6FF    		ld	hl,65526
1229    18D9  09        		add	hl,bc
1230    18DA  4D        		ld	c,l
1231    18DB  44        		ld	b,h
1232    18DC  97        		sub	a
1233    18DD  320000    		ld	(c.r0),a
1234    18E0  320100    		ld	(c.r0+1),a
1235    18E3  0A        		ld	a,(bc)
1236    18E4  320200    		ld	(c.r0+2),a
1237    18E7  03        		inc	bc
1238    18E8  0A        		ld	a,(bc)
1239    18E9  320300    		ld	(c.r0+3),a
1240    18EC  210000    		ld	hl,c.r0
1241    18EF  E5        		push	hl
1242    18F0  DD6EF8    		ld	l,(ix-8)
1243    18F3  DD66F9    		ld	h,(ix-7)
1244    18F6  01F6FF    		ld	bc,65526
1245    18F9  09        		add	hl,bc
1246    18FA  E5        		push	hl
1247    18FB  CD0000    		call	c.llsh
1248    18FE  CD0000    		call	c.mvl
1249    1901  F1        		pop	af
1250                    	;  667          printf("Device capacity: %lu MByte\n", capacity >> 10);
1251    1902  DDE5      		push	ix
1252    1904  C1        		pop	bc
1253    1905  21EEFF    		ld	hl,65518
1254    1908  09        		add	hl,bc
1255    1909  CD0000    		call	c.0mvf
1256    190C  210000    		ld	hl,c.r0
1257    190F  E5        		push	hl
1258    1910  210A00    		ld	hl,10
1259    1913  E5        		push	hl
1260    1914  CD0000    		call	c.ulrsh
1261    1917  E1        		pop	hl
1262    1918  23        		inc	hl
1263    1919  23        		inc	hl
1264    191A  4E        		ld	c,(hl)
1265    191B  23        		inc	hl
1266    191C  46        		ld	b,(hl)
1267    191D  C5        		push	bc
1268    191E  2B        		dec	hl
1269    191F  2B        		dec	hl
1270    1920  2B        		dec	hl
1271    1921  4E        		ld	c,(hl)
1272    1922  23        		inc	hl
1273    1923  46        		ld	b,(hl)
1274    1924  C5        		push	bc
1275    1925  214512    		ld	hl,L556
1276    1928  CD0000    		call	_printf
1277    192B  F1        		pop	af
1278    192C  F1        		pop	af
1279                    	L1542:
1280                    	;  668          }
1281                    	;  669      if ((csdreg[0] & 0xc0) == 0x40) /* CSD version 2 */
1282    192D  3A2800    		ld	a,(_csdreg)
1283    1930  6F        		ld	l,a
1284    1931  97        		sub	a
1285    1932  67        		ld	h,a
1286    1933  7D        		ld	a,l
1287    1934  E6C0      		and	192
1288    1936  6F        		ld	l,a
1289    1937  97        		sub	a
1290    1938  67        		ld	h,a
1291    1939  7D        		ld	a,l
1292    193A  FE40      		cp	64
1293    193C  2003      		jr	nz,L27
1294    193E  7C        		ld	a,h
1295    193F  FE00      		cp	0
1296                    	L27:
1297    1941  C2141A    		jp	nz,L1642
1298                    	;  670          {
1299                    	;  671          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
1300                    	;  672                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
1301    1944  DDE5      		push	ix
1302    1946  C1        		pop	bc
1303    1947  21F2FF    		ld	hl,65522
1304    194A  09        		add	hl,bc
1305    194B  E5        		push	hl
1306    194C  97        		sub	a
1307    194D  320000    		ld	(c.r0),a
1308    1950  320100    		ld	(c.r0+1),a
1309    1953  3A3000    		ld	a,(_csdreg+8)
1310    1956  320200    		ld	(c.r0+2),a
1311    1959  97        		sub	a
1312    195A  320300    		ld	(c.r0+3),a
1313    195D  210000    		ld	hl,c.r0
1314    1960  E5        		push	hl
1315    1961  210800    		ld	hl,8
1316    1964  E5        		push	hl
1317    1965  CD0000    		call	c.llsh
1318    1968  97        		sub	a
1319    1969  320000    		ld	(c.r1),a
1320    196C  320100    		ld	(c.r1+1),a
1321    196F  3A3100    		ld	a,(_csdreg+9)
1322    1972  320200    		ld	(c.r1+2),a
1323    1975  97        		sub	a
1324    1976  320300    		ld	(c.r1+3),a
1325    1979  210000    		ld	hl,c.r1
1326    197C  E5        		push	hl
1327    197D  CD0000    		call	c.ladd
1328    1980  3A2F00    		ld	a,(_csdreg+7)
1329    1983  6F        		ld	l,a
1330    1984  97        		sub	a
1331    1985  67        		ld	h,a
1332    1986  7D        		ld	a,l
1333    1987  E63F      		and	63
1334    1989  6F        		ld	l,a
1335    198A  97        		sub	a
1336    198B  67        		ld	h,a
1337    198C  4D        		ld	c,l
1338    198D  44        		ld	b,h
1339    198E  78        		ld	a,b
1340    198F  87        		add	a,a
1341    1990  9F        		sbc	a,a
1342    1991  320000    		ld	(c.r1),a
1343    1994  320100    		ld	(c.r1+1),a
1344    1997  78        		ld	a,b
1345    1998  320300    		ld	(c.r1+3),a
1346    199B  79        		ld	a,c
1347    199C  320200    		ld	(c.r1+2),a
1348    199F  210000    		ld	hl,c.r1
1349    19A2  E5        		push	hl
1350    19A3  211000    		ld	hl,16
1351    19A6  E5        		push	hl
1352    19A7  CD0000    		call	c.llsh
1353    19AA  CD0000    		call	c.ladd
1354    19AD  3E01      		ld	a,1
1355    19AF  320200    		ld	(c.r1+2),a
1356    19B2  87        		add	a,a
1357    19B3  9F        		sbc	a,a
1358    19B4  320300    		ld	(c.r1+3),a
1359    19B7  320100    		ld	(c.r1+1),a
1360    19BA  320000    		ld	(c.r1),a
1361    19BD  210000    		ld	hl,c.r1
1362    19C0  E5        		push	hl
1363    19C1  CD0000    		call	c.ladd
1364    19C4  CD0000    		call	c.mvl
1365    19C7  F1        		pop	af
1366                    	;  673          capacity = devsize << 9;
1367    19C8  DDE5      		push	ix
1368    19CA  C1        		pop	bc
1369    19CB  21EEFF    		ld	hl,65518
1370    19CE  09        		add	hl,bc
1371    19CF  E5        		push	hl
1372    19D0  DDE5      		push	ix
1373    19D2  C1        		pop	bc
1374    19D3  21F2FF    		ld	hl,65522
1375    19D6  09        		add	hl,bc
1376    19D7  CD0000    		call	c.0mvf
1377    19DA  210000    		ld	hl,c.r0
1378    19DD  E5        		push	hl
1379    19DE  210900    		ld	hl,9
1380    19E1  E5        		push	hl
1381    19E2  CD0000    		call	c.llsh
1382    19E5  CD0000    		call	c.mvl
1383    19E8  F1        		pop	af
1384                    	;  674          printf("Device capacity: %lu MByte\n", capacity >> 10);
1385    19E9  DDE5      		push	ix
1386    19EB  C1        		pop	bc
1387    19EC  21EEFF    		ld	hl,65518
1388    19EF  09        		add	hl,bc
1389    19F0  CD0000    		call	c.0mvf
1390    19F3  210000    		ld	hl,c.r0
1391    19F6  E5        		push	hl
1392    19F7  210A00    		ld	hl,10
1393    19FA  E5        		push	hl
1394    19FB  CD0000    		call	c.ulrsh
1395    19FE  E1        		pop	hl
1396    19FF  23        		inc	hl
1397    1A00  23        		inc	hl
1398    1A01  4E        		ld	c,(hl)
1399    1A02  23        		inc	hl
1400    1A03  46        		ld	b,(hl)
1401    1A04  C5        		push	bc
1402    1A05  2B        		dec	hl
1403    1A06  2B        		dec	hl
1404    1A07  2B        		dec	hl
1405    1A08  4E        		ld	c,(hl)
1406    1A09  23        		inc	hl
1407    1A0A  46        		ld	b,(hl)
1408    1A0B  C5        		push	bc
1409    1A0C  216112    		ld	hl,L566
1410    1A0F  CD0000    		call	_printf
1411    1A12  F1        		pop	af
1412    1A13  F1        		pop	af
1413                    	L1642:
1414                    	;  675          }
1415                    	;  676      if ((csdreg[0] & 0xc0) == 0x80) /* CSD version 3 */
1416    1A14  3A2800    		ld	a,(_csdreg)
1417    1A17  6F        		ld	l,a
1418    1A18  97        		sub	a
1419    1A19  67        		ld	h,a
1420    1A1A  7D        		ld	a,l
1421    1A1B  E6C0      		and	192
1422    1A1D  6F        		ld	l,a
1423    1A1E  97        		sub	a
1424    1A1F  67        		ld	h,a
1425    1A20  7D        		ld	a,l
1426    1A21  FE80      		cp	128
1427    1A23  2003      		jr	nz,L47
1428    1A25  7C        		ld	a,h
1429    1A26  FE00      		cp	0
1430                    	L47:
1431    1A28  C2FB1A    		jp	nz,L1742
1432                    	;  677          {
1433                    	;  678          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
1434                    	;  679                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
1435    1A2B  DDE5      		push	ix
1436    1A2D  C1        		pop	bc
1437    1A2E  21F2FF    		ld	hl,65522
1438    1A31  09        		add	hl,bc
1439    1A32  E5        		push	hl
1440    1A33  97        		sub	a
1441    1A34  320000    		ld	(c.r0),a
1442    1A37  320100    		ld	(c.r0+1),a
1443    1A3A  3A3000    		ld	a,(_csdreg+8)
1444    1A3D  320200    		ld	(c.r0+2),a
1445    1A40  97        		sub	a
1446    1A41  320300    		ld	(c.r0+3),a
1447    1A44  210000    		ld	hl,c.r0
1448    1A47  E5        		push	hl
1449    1A48  210800    		ld	hl,8
1450    1A4B  E5        		push	hl
1451    1A4C  CD0000    		call	c.llsh
1452    1A4F  97        		sub	a
1453    1A50  320000    		ld	(c.r1),a
1454    1A53  320100    		ld	(c.r1+1),a
1455    1A56  3A3100    		ld	a,(_csdreg+9)
1456    1A59  320200    		ld	(c.r1+2),a
1457    1A5C  97        		sub	a
1458    1A5D  320300    		ld	(c.r1+3),a
1459    1A60  210000    		ld	hl,c.r1
1460    1A63  E5        		push	hl
1461    1A64  CD0000    		call	c.ladd
1462    1A67  3A2F00    		ld	a,(_csdreg+7)
1463    1A6A  6F        		ld	l,a
1464    1A6B  97        		sub	a
1465    1A6C  67        		ld	h,a
1466    1A6D  7D        		ld	a,l
1467    1A6E  E63F      		and	63
1468    1A70  6F        		ld	l,a
1469    1A71  97        		sub	a
1470    1A72  67        		ld	h,a
1471    1A73  4D        		ld	c,l
1472    1A74  44        		ld	b,h
1473    1A75  78        		ld	a,b
1474    1A76  87        		add	a,a
1475    1A77  9F        		sbc	a,a
1476    1A78  320000    		ld	(c.r1),a
1477    1A7B  320100    		ld	(c.r1+1),a
1478    1A7E  78        		ld	a,b
1479    1A7F  320300    		ld	(c.r1+3),a
1480    1A82  79        		ld	a,c
1481    1A83  320200    		ld	(c.r1+2),a
1482    1A86  210000    		ld	hl,c.r1
1483    1A89  E5        		push	hl
1484    1A8A  211000    		ld	hl,16
1485    1A8D  E5        		push	hl
1486    1A8E  CD0000    		call	c.llsh
1487    1A91  CD0000    		call	c.ladd
1488    1A94  3E01      		ld	a,1
1489    1A96  320200    		ld	(c.r1+2),a
1490    1A99  87        		add	a,a
1491    1A9A  9F        		sbc	a,a
1492    1A9B  320300    		ld	(c.r1+3),a
1493    1A9E  320100    		ld	(c.r1+1),a
1494    1AA1  320000    		ld	(c.r1),a
1495    1AA4  210000    		ld	hl,c.r1
1496    1AA7  E5        		push	hl
1497    1AA8  CD0000    		call	c.ladd
1498    1AAB  CD0000    		call	c.mvl
1499    1AAE  F1        		pop	af
1500                    	;  680          capacity = devsize << 9;
1501    1AAF  DDE5      		push	ix
1502    1AB1  C1        		pop	bc
1503    1AB2  21EEFF    		ld	hl,65518
1504    1AB5  09        		add	hl,bc
1505    1AB6  E5        		push	hl
1506    1AB7  DDE5      		push	ix
1507    1AB9  C1        		pop	bc
1508    1ABA  21F2FF    		ld	hl,65522
1509    1ABD  09        		add	hl,bc
1510    1ABE  CD0000    		call	c.0mvf
1511    1AC1  210000    		ld	hl,c.r0
1512    1AC4  E5        		push	hl
1513    1AC5  210900    		ld	hl,9
1514    1AC8  E5        		push	hl
1515    1AC9  CD0000    		call	c.llsh
1516    1ACC  CD0000    		call	c.mvl
1517    1ACF  F1        		pop	af
1518                    	;  681          printf("Device ultra capacity: %lu MByte\n", capacity >> 10);
1519    1AD0  DDE5      		push	ix
1520    1AD2  C1        		pop	bc
1521    1AD3  21EEFF    		ld	hl,65518
1522    1AD6  09        		add	hl,bc
1523    1AD7  CD0000    		call	c.0mvf
1524    1ADA  210000    		ld	hl,c.r0
1525    1ADD  E5        		push	hl
1526    1ADE  210A00    		ld	hl,10
1527    1AE1  E5        		push	hl
1528    1AE2  CD0000    		call	c.ulrsh
1529    1AE5  E1        		pop	hl
1530    1AE6  23        		inc	hl
1531    1AE7  23        		inc	hl
1532    1AE8  4E        		ld	c,(hl)
1533    1AE9  23        		inc	hl
1534    1AEA  46        		ld	b,(hl)
1535    1AEB  C5        		push	bc
1536    1AEC  2B        		dec	hl
1537    1AED  2B        		dec	hl
1538    1AEE  2B        		dec	hl
1539    1AEF  4E        		ld	c,(hl)
1540    1AF0  23        		inc	hl
1541    1AF1  46        		ld	b,(hl)
1542    1AF2  C5        		push	bc
1543    1AF3  217D12    		ld	hl,L576
1544    1AF6  CD0000    		call	_printf
1545    1AF9  F1        		pop	af
1546    1AFA  F1        		pop	af
1547                    	L1742:
1548                    	;  682          }
1549                    	;  683  
1550                    	;  684      if (sdtestflg)
1551    1AFB  2A0000    		ld	hl,(_sdtestflg)
1552    1AFE  7C        		ld	a,h
1553    1AFF  B5        		or	l
1554    1B00  CAE71F    		jp	z,L1052
1555                    	;  685          {
1556                    	;  686  
1557                    	;  687          printf("--------------------------------------\n");
1558    1B03  219F12    		ld	hl,L507
1559    1B06  CD0000    		call	_printf
1560                    	;  688          printf("OCR register:\n");
1561    1B09  21C712    		ld	hl,L517
1562    1B0C  CD0000    		call	_printf
1563                    	;  689          if (ocrreg[2] & 0x80)
1564    1B0F  3A4A00    		ld	a,(_ocrreg+2)
1565    1B12  CB7F      		bit	7,a
1566    1B14  6F        		ld	l,a
1567    1B15  2806      		jr	z,L1152
1568                    	;  690              printf("2.7-2.8V (bit 15) ");
1569    1B17  21D612    		ld	hl,L527
1570    1B1A  CD0000    		call	_printf
1571                    	L1152:
1572                    	;  691          if (ocrreg[1] & 0x01)
1573    1B1D  3A4900    		ld	a,(_ocrreg+1)
1574    1B20  CB47      		bit	0,a
1575    1B22  6F        		ld	l,a
1576    1B23  2806      		jr	z,L1252
1577                    	;  692              printf("2.8-2.9V (bit 16) ");
1578    1B25  21E912    		ld	hl,L537
1579    1B28  CD0000    		call	_printf
1580                    	L1252:
1581                    	;  693          if (ocrreg[1] & 0x02)
1582    1B2B  3A4900    		ld	a,(_ocrreg+1)
1583    1B2E  CB4F      		bit	1,a
1584    1B30  6F        		ld	l,a
1585    1B31  2806      		jr	z,L1352
1586                    	;  694              printf("2.9-3.0V (bit 17) ");
1587    1B33  21FC12    		ld	hl,L547
1588    1B36  CD0000    		call	_printf
1589                    	L1352:
1590                    	;  695          if (ocrreg[1] & 0x04)
1591    1B39  3A4900    		ld	a,(_ocrreg+1)
1592    1B3C  CB57      		bit	2,a
1593    1B3E  6F        		ld	l,a
1594    1B3F  2806      		jr	z,L1452
1595                    	;  696              printf("3.0-3.1V (bit 18) \n");
1596    1B41  210F13    		ld	hl,L557
1597    1B44  CD0000    		call	_printf
1598                    	L1452:
1599                    	;  697          if (ocrreg[1] & 0x08)
1600    1B47  3A4900    		ld	a,(_ocrreg+1)
1601    1B4A  CB5F      		bit	3,a
1602    1B4C  6F        		ld	l,a
1603    1B4D  2806      		jr	z,L1552
1604                    	;  698              printf("3.1-3.2V (bit 19) ");
1605    1B4F  212313    		ld	hl,L567
1606    1B52  CD0000    		call	_printf
1607                    	L1552:
1608                    	;  699          if (ocrreg[1] & 0x10)
1609    1B55  3A4900    		ld	a,(_ocrreg+1)
1610    1B58  CB67      		bit	4,a
1611    1B5A  6F        		ld	l,a
1612    1B5B  2806      		jr	z,L1652
1613                    	;  700              printf("3.2-3.3V (bit 20) ");
1614    1B5D  213613    		ld	hl,L577
1615    1B60  CD0000    		call	_printf
1616                    	L1652:
1617                    	;  701          if (ocrreg[1] & 0x20)
1618    1B63  3A4900    		ld	a,(_ocrreg+1)
1619    1B66  CB6F      		bit	5,a
1620    1B68  6F        		ld	l,a
1621    1B69  2806      		jr	z,L1752
1622                    	;  702              printf("3.3-3.4V (bit 21) ");
1623    1B6B  214913    		ld	hl,L5001
1624    1B6E  CD0000    		call	_printf
1625                    	L1752:
1626                    	;  703          if (ocrreg[1] & 0x40)
1627    1B71  3A4900    		ld	a,(_ocrreg+1)
1628    1B74  CB77      		bit	6,a
1629    1B76  6F        		ld	l,a
1630    1B77  2806      		jr	z,L1062
1631                    	;  704              printf("3.4-3.5V (bit 22) \n");
1632    1B79  215C13    		ld	hl,L5101
1633    1B7C  CD0000    		call	_printf
1634                    	L1062:
1635                    	;  705          if (ocrreg[1] & 0x80)
1636    1B7F  3A4900    		ld	a,(_ocrreg+1)
1637    1B82  CB7F      		bit	7,a
1638    1B84  6F        		ld	l,a
1639    1B85  2806      		jr	z,L1162
1640                    	;  706              printf("3.5-3.6V (bit 23) \n");
1641    1B87  217013    		ld	hl,L5201
1642    1B8A  CD0000    		call	_printf
1643                    	L1162:
1644                    	;  707          if (ocrreg[0] & 0x01)
1645    1B8D  3A4800    		ld	a,(_ocrreg)
1646    1B90  CB47      		bit	0,a
1647    1B92  6F        		ld	l,a
1648    1B93  2806      		jr	z,L1262
1649                    	;  708              printf("Switching to 1.8V Accepted (S18A) (bit 24) set ");
1650    1B95  218413    		ld	hl,L5301
1651    1B98  CD0000    		call	_printf
1652                    	L1262:
1653                    	;  709          if (ocrreg[0] & 0x08)
1654    1B9B  3A4800    		ld	a,(_ocrreg)
1655    1B9E  CB5F      		bit	3,a
1656    1BA0  6F        		ld	l,a
1657    1BA1  2806      		jr	z,L1362
1658                    	;  710              printf("Over 2TB support Status (CO2T) (bit 27) set\n");
1659    1BA3  21B413    		ld	hl,L5401
1660    1BA6  CD0000    		call	_printf
1661                    	L1362:
1662                    	;  711          if (ocrreg[0] & 0x20)
1663    1BA9  3A4800    		ld	a,(_ocrreg)
1664    1BAC  CB6F      		bit	5,a
1665    1BAE  6F        		ld	l,a
1666    1BAF  2806      		jr	z,L1462
1667                    	;  712              printf("UHS-II Card Status (bit 29) set ");
1668    1BB1  21E113    		ld	hl,L5501
1669    1BB4  CD0000    		call	_printf
1670                    	L1462:
1671                    	;  713          if (ocrreg[0] & 0x80)
1672    1BB7  3A4800    		ld	a,(_ocrreg)
1673    1BBA  CB7F      		bit	7,a
1674    1BBC  6F        		ld	l,a
1675    1BBD  2839      		jr	z,L1562
1676                    	;  714              {
1677                    	;  715              if (ocrreg[0] & 0x40)
1678    1BBF  3A4800    		ld	a,(_ocrreg)
1679    1BC2  CB77      		bit	6,a
1680    1BC4  6F        		ld	l,a
1681    1BC5  280E      		jr	z,L1662
1682                    	;  716                  {
1683                    	;  717                  printf("Card Capacity Status (CCS) (bit 30) set\n");
1684    1BC7  210214    		ld	hl,L5601
1685    1BCA  CD0000    		call	_printf
1686                    	;  718                  printf("  SD Ver.2+, Block address");
1687    1BCD  212B14    		ld	hl,L5701
1688    1BD0  CD0000    		call	_printf
1689                    	;  719                  }
1690                    	;  720              else
1691    1BD3  181B      		jr	L1762
1692                    	L1662:
1693                    	;  721                  {
1694                    	;  722                  printf("Card Capacity Status (CCS) (bit 30) not set\n");
1695    1BD5  214614    		ld	hl,L5011
1696    1BD8  CD0000    		call	_printf
1697                    	;  723                  if (sdver2)
1698    1BDB  2A0A00    		ld	hl,(_sdver2)
1699    1BDE  7C        		ld	a,h
1700    1BDF  B5        		or	l
1701    1BE0  2808      		jr	z,L1072
1702                    	;  724                      printf("  SD Ver.2+, Byte address");
1703    1BE2  217314    		ld	hl,L5111
1704    1BE5  CD0000    		call	_printf
1705                    	;  725                  else
1706    1BE8  1806      		jr	L1762
1707                    	L1072:
1708                    	;  726                      printf("  SD Ver.1, Byte address");
1709    1BEA  218D14    		ld	hl,L5211
1710    1BED  CD0000    		call	_printf
1711                    	L1762:
1712                    	;  727                  }
1713                    	;  728              printf("\nCard power up status bit (busy) (bit 31) set\n");
1714    1BF0  21A614    		ld	hl,L5311
1715    1BF3  CD0000    		call	_printf
1716                    	;  729              }
1717                    	;  730          else
1718    1BF6  180C      		jr	L1272
1719                    	L1562:
1720                    	;  731              {
1721                    	;  732              printf("\nCard power up status bit (busy) (bit 31) not set.\n");
1722    1BF8  21D514    		ld	hl,L5411
1723    1BFB  CD0000    		call	_printf
1724                    	;  733              printf("  This bit is not set if the card has not finished the power up routine.\n");
1725    1BFE  210915    		ld	hl,L5511
1726    1C01  CD0000    		call	_printf
1727                    	L1272:
1728                    	;  734              }
1729                    	;  735          printf("--------------------------------------\n");
1730    1C04  215315    		ld	hl,L5611
1731    1C07  CD0000    		call	_printf
1732                    	;  736          printf("CID register:\n");
1733    1C0A  217B15    		ld	hl,L5711
1734    1C0D  CD0000    		call	_printf
1735                    	;  737          printf("MID: 0x%02x, ", cidreg[0]);
1736    1C10  3A3800    		ld	a,(_cidreg)
1737    1C13  4F        		ld	c,a
1738    1C14  97        		sub	a
1739    1C15  47        		ld	b,a
1740    1C16  C5        		push	bc
1741    1C17  218A15    		ld	hl,L5021
1742    1C1A  CD0000    		call	_printf
1743    1C1D  F1        		pop	af
1744                    	;  738          printf("OID: %.2s, ", &cidreg[1]);
1745    1C1E  213900    		ld	hl,_cidreg+1
1746    1C21  E5        		push	hl
1747    1C22  219815    		ld	hl,L5121
1748    1C25  CD0000    		call	_printf
1749    1C28  F1        		pop	af
1750                    	;  739          printf("PNM: %.5s, ", &cidreg[3]);
1751    1C29  213B00    		ld	hl,_cidreg+3
1752    1C2C  E5        		push	hl
1753    1C2D  21A415    		ld	hl,L5221
1754    1C30  CD0000    		call	_printf
1755    1C33  F1        		pop	af
1756                    	;  740          printf("PRV: %d.%d, ",
1757                    	;  741                 (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
1758    1C34  3A4000    		ld	a,(_cidreg+8)
1759    1C37  6F        		ld	l,a
1760    1C38  97        		sub	a
1761    1C39  67        		ld	h,a
1762    1C3A  7D        		ld	a,l
1763    1C3B  E60F      		and	15
1764    1C3D  6F        		ld	l,a
1765    1C3E  97        		sub	a
1766    1C3F  67        		ld	h,a
1767    1C40  E5        		push	hl
1768    1C41  3A4000    		ld	a,(_cidreg+8)
1769    1C44  4F        		ld	c,a
1770    1C45  97        		sub	a
1771    1C46  47        		ld	b,a
1772    1C47  C5        		push	bc
1773    1C48  210400    		ld	hl,4
1774    1C4B  E5        		push	hl
1775    1C4C  CD0000    		call	c.irsh
1776    1C4F  E1        		pop	hl
1777    1C50  7D        		ld	a,l
1778    1C51  E60F      		and	15
1779    1C53  6F        		ld	l,a
1780    1C54  97        		sub	a
1781    1C55  67        		ld	h,a
1782    1C56  E5        		push	hl
1783    1C57  21B015    		ld	hl,L5321
1784    1C5A  CD0000    		call	_printf
1785    1C5D  F1        		pop	af
1786    1C5E  F1        		pop	af
1787                    	;  742          printf("PSN: %lu, ",
1788                    	;  743                 (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
1789    1C5F  3A4100    		ld	a,(_cidreg+9)
1790    1C62  4F        		ld	c,a
1791    1C63  97        		sub	a
1792    1C64  47        		ld	b,a
1793    1C65  C5        		push	bc
1794    1C66  211800    		ld	hl,24
1795    1C69  E5        		push	hl
1796    1C6A  CD0000    		call	c.ilsh
1797    1C6D  E1        		pop	hl
1798    1C6E  E5        		push	hl
1799    1C6F  3A4200    		ld	a,(_cidreg+10)
1800    1C72  4F        		ld	c,a
1801    1C73  97        		sub	a
1802    1C74  47        		ld	b,a
1803    1C75  C5        		push	bc
1804    1C76  211000    		ld	hl,16
1805    1C79  E5        		push	hl
1806    1C7A  CD0000    		call	c.ilsh
1807    1C7D  E1        		pop	hl
1808    1C7E  E3        		ex	(sp),hl
1809    1C7F  C1        		pop	bc
1810    1C80  09        		add	hl,bc
1811    1C81  E5        		push	hl
1812    1C82  3A4300    		ld	a,(_cidreg+11)
1813    1C85  6F        		ld	l,a
1814    1C86  97        		sub	a
1815    1C87  67        		ld	h,a
1816    1C88  29        		add	hl,hl
1817    1C89  29        		add	hl,hl
1818    1C8A  29        		add	hl,hl
1819    1C8B  29        		add	hl,hl
1820    1C8C  29        		add	hl,hl
1821    1C8D  29        		add	hl,hl
1822    1C8E  29        		add	hl,hl
1823    1C8F  29        		add	hl,hl
1824    1C90  E3        		ex	(sp),hl
1825    1C91  C1        		pop	bc
1826    1C92  09        		add	hl,bc
1827    1C93  E5        		push	hl
1828    1C94  3A4400    		ld	a,(_cidreg+12)
1829    1C97  6F        		ld	l,a
1830    1C98  97        		sub	a
1831    1C99  67        		ld	h,a
1832    1C9A  E3        		ex	(sp),hl
1833    1C9B  C1        		pop	bc
1834    1C9C  09        		add	hl,bc
1835    1C9D  E5        		push	hl
1836    1C9E  21BD15    		ld	hl,L5421
1837    1CA1  CD0000    		call	_printf
1838    1CA4  F1        		pop	af
1839                    	;  744          printf("MDT: %d-%d\n",
1840                    	;  745                 2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
1841    1CA5  3A4600    		ld	a,(_cidreg+14)
1842    1CA8  6F        		ld	l,a
1843    1CA9  97        		sub	a
1844    1CAA  67        		ld	h,a
1845    1CAB  7D        		ld	a,l
1846    1CAC  E60F      		and	15
1847    1CAE  6F        		ld	l,a
1848    1CAF  97        		sub	a
1849    1CB0  67        		ld	h,a
1850    1CB1  E5        		push	hl
1851    1CB2  3A4500    		ld	a,(_cidreg+13)
1852    1CB5  6F        		ld	l,a
1853    1CB6  97        		sub	a
1854    1CB7  67        		ld	h,a
1855    1CB8  7D        		ld	a,l
1856    1CB9  E60F      		and	15
1857    1CBB  6F        		ld	l,a
1858    1CBC  97        		sub	a
1859    1CBD  67        		ld	h,a
1860    1CBE  29        		add	hl,hl
1861    1CBF  29        		add	hl,hl
1862    1CC0  29        		add	hl,hl
1863    1CC1  29        		add	hl,hl
1864    1CC2  01D007    		ld	bc,2000
1865    1CC5  09        		add	hl,bc
1866    1CC6  E5        		push	hl
1867    1CC7  3A4600    		ld	a,(_cidreg+14)
1868    1CCA  4F        		ld	c,a
1869    1CCB  97        		sub	a
1870    1CCC  47        		ld	b,a
1871    1CCD  C5        		push	bc
1872    1CCE  210400    		ld	hl,4
1873    1CD1  E5        		push	hl
1874    1CD2  CD0000    		call	c.irsh
1875    1CD5  E1        		pop	hl
1876    1CD6  E3        		ex	(sp),hl
1877    1CD7  C1        		pop	bc
1878    1CD8  09        		add	hl,bc
1879    1CD9  E5        		push	hl
1880    1CDA  21C815    		ld	hl,L5521
1881    1CDD  CD0000    		call	_printf
1882    1CE0  F1        		pop	af
1883    1CE1  F1        		pop	af
1884                    	;  746          printf("--------------------------------------\n");
1885    1CE2  21D415    		ld	hl,L5621
1886    1CE5  CD0000    		call	_printf
1887                    	;  747          printf("CSD register:\n");
1888    1CE8  21FC15    		ld	hl,L5721
1889    1CEB  CD0000    		call	_printf
1890                    	;  748          if ((csdreg[0] & 0xc0) == 0x00)
1891    1CEE  3A2800    		ld	a,(_csdreg)
1892    1CF1  E6C0      		and	192
1893    1CF3  C2E71D    		jp	nz,L1372
1894                    	;  749              {
1895                    	;  750              printf("CSD Version 1.0, Standard Capacity\n");
1896    1CF6  210B16    		ld	hl,L5031
1897    1CF9  CD0000    		call	_printf
1898                    	;  751              n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
1899    1CFC  3A2D00    		ld	a,(_csdreg+5)
1900    1CFF  6F        		ld	l,a
1901    1D00  97        		sub	a
1902    1D01  67        		ld	h,a
1903    1D02  7D        		ld	a,l
1904    1D03  E60F      		and	15
1905    1D05  6F        		ld	l,a
1906    1D06  97        		sub	a
1907    1D07  67        		ld	h,a
1908    1D08  E5        		push	hl
1909    1D09  3A3200    		ld	a,(_csdreg+10)
1910    1D0C  6F        		ld	l,a
1911    1D0D  97        		sub	a
1912    1D0E  67        		ld	h,a
1913    1D0F  7D        		ld	a,l
1914    1D10  E680      		and	128
1915    1D12  6F        		ld	l,a
1916    1D13  97        		sub	a
1917    1D14  67        		ld	h,a
1918    1D15  E5        		push	hl
1919    1D16  210700    		ld	hl,7
1920    1D19  E5        		push	hl
1921    1D1A  CD0000    		call	c.irsh
1922    1D1D  E1        		pop	hl
1923    1D1E  E3        		ex	(sp),hl
1924    1D1F  C1        		pop	bc
1925    1D20  09        		add	hl,bc
1926    1D21  E5        		push	hl
1927    1D22  3A3100    		ld	a,(_csdreg+9)
1928    1D25  6F        		ld	l,a
1929    1D26  97        		sub	a
1930    1D27  67        		ld	h,a
1931    1D28  7D        		ld	a,l
1932    1D29  E603      		and	3
1933    1D2B  6F        		ld	l,a
1934    1D2C  97        		sub	a
1935    1D2D  67        		ld	h,a
1936    1D2E  29        		add	hl,hl
1937    1D2F  E3        		ex	(sp),hl
1938    1D30  C1        		pop	bc
1939    1D31  09        		add	hl,bc
1940    1D32  23        		inc	hl
1941    1D33  23        		inc	hl
1942    1D34  DD75F8    		ld	(ix-8),l
1943    1D37  DD74F9    		ld	(ix-7),h
1944                    	;  752              csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
1945                    	;  753                      ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
1946    1D3A  3A3000    		ld	a,(_csdreg+8)
1947    1D3D  4F        		ld	c,a
1948    1D3E  97        		sub	a
1949    1D3F  47        		ld	b,a
1950    1D40  C5        		push	bc
1951    1D41  210600    		ld	hl,6
1952    1D44  E5        		push	hl
1953    1D45  CD0000    		call	c.irsh
1954    1D48  E1        		pop	hl
1955    1D49  E5        		push	hl
1956    1D4A  3A2F00    		ld	a,(_csdreg+7)
1957    1D4D  6F        		ld	l,a
1958    1D4E  97        		sub	a
1959    1D4F  67        		ld	h,a
1960    1D50  29        		add	hl,hl
1961    1D51  29        		add	hl,hl
1962    1D52  E3        		ex	(sp),hl
1963    1D53  C1        		pop	bc
1964    1D54  09        		add	hl,bc
1965    1D55  E5        		push	hl
1966    1D56  3A2E00    		ld	a,(_csdreg+6)
1967    1D59  6F        		ld	l,a
1968    1D5A  97        		sub	a
1969    1D5B  67        		ld	h,a
1970    1D5C  7D        		ld	a,l
1971    1D5D  E603      		and	3
1972    1D5F  6F        		ld	l,a
1973    1D60  97        		sub	a
1974    1D61  67        		ld	h,a
1975    1D62  E5        		push	hl
1976    1D63  210A00    		ld	hl,10
1977    1D66  E5        		push	hl
1978    1D67  CD0000    		call	c.ilsh
1979    1D6A  E1        		pop	hl
1980    1D6B  E3        		ex	(sp),hl
1981    1D6C  C1        		pop	bc
1982    1D6D  09        		add	hl,bc
1983    1D6E  23        		inc	hl
1984    1D6F  DD75F6    		ld	(ix-10),l
1985    1D72  DD74F7    		ld	(ix-9),h
1986                    	;  754              capacity = (unsigned long) csize << (n-10);
1987    1D75  DDE5      		push	ix
1988    1D77  C1        		pop	bc
1989    1D78  21EEFF    		ld	hl,65518
1990    1D7B  09        		add	hl,bc
1991    1D7C  E5        		push	hl
1992    1D7D  DDE5      		push	ix
1993    1D7F  C1        		pop	bc
1994    1D80  21F6FF    		ld	hl,65526
1995    1D83  09        		add	hl,bc
1996    1D84  4D        		ld	c,l
1997    1D85  44        		ld	b,h
1998    1D86  97        		sub	a
1999    1D87  320000    		ld	(c.r0),a
2000    1D8A  320100    		ld	(c.r0+1),a
2001    1D8D  0A        		ld	a,(bc)
2002    1D8E  320200    		ld	(c.r0+2),a
2003    1D91  03        		inc	bc
2004    1D92  0A        		ld	a,(bc)
2005    1D93  320300    		ld	(c.r0+3),a
2006    1D96  210000    		ld	hl,c.r0
2007    1D99  E5        		push	hl
2008    1D9A  DD6EF8    		ld	l,(ix-8)
2009    1D9D  DD66F9    		ld	h,(ix-7)
2010    1DA0  01F6FF    		ld	bc,65526
2011    1DA3  09        		add	hl,bc
2012    1DA4  E5        		push	hl
2013    1DA5  CD0000    		call	c.llsh
2014    1DA8  CD0000    		call	c.mvl
2015    1DAB  F1        		pop	af
2016                    	;  755              printf(" Device capacity: %lu KByte, %lu MByte\n",
2017                    	;  756                     capacity, capacity >> 10);
2018    1DAC  DDE5      		push	ix
2019    1DAE  C1        		pop	bc
2020    1DAF  21EEFF    		ld	hl,65518
2021    1DB2  09        		add	hl,bc
2022    1DB3  CD0000    		call	c.0mvf
2023    1DB6  210000    		ld	hl,c.r0
2024    1DB9  E5        		push	hl
2025    1DBA  210A00    		ld	hl,10
2026    1DBD  E5        		push	hl
2027    1DBE  CD0000    		call	c.ulrsh
2028    1DC1  E1        		pop	hl
2029    1DC2  23        		inc	hl
2030    1DC3  23        		inc	hl
2031    1DC4  4E        		ld	c,(hl)
2032    1DC5  23        		inc	hl
2033    1DC6  46        		ld	b,(hl)
2034    1DC7  C5        		push	bc
2035    1DC8  2B        		dec	hl
2036    1DC9  2B        		dec	hl
2037    1DCA  2B        		dec	hl
2038    1DCB  4E        		ld	c,(hl)
2039    1DCC  23        		inc	hl
2040    1DCD  46        		ld	b,(hl)
2041    1DCE  C5        		push	bc
2042    1DCF  DD66F1    		ld	h,(ix-15)
2043    1DD2  DD6EF0    		ld	l,(ix-16)
2044    1DD5  E5        		push	hl
2045    1DD6  DD66EF    		ld	h,(ix-17)
2046    1DD9  DD6EEE    		ld	l,(ix-18)
2047    1DDC  E5        		push	hl
2048    1DDD  212F16    		ld	hl,L5131
2049    1DE0  CD0000    		call	_printf
2050    1DE3  F1        		pop	af
2051    1DE4  F1        		pop	af
2052    1DE5  F1        		pop	af
2053    1DE6  F1        		pop	af
2054                    	L1372:
2055                    	;  757              }
2056                    	;  758          if ((csdreg[0] & 0xc0) == 0x40)
2057    1DE7  3A2800    		ld	a,(_csdreg)
2058    1DEA  6F        		ld	l,a
2059    1DEB  97        		sub	a
2060    1DEC  67        		ld	h,a
2061    1DED  7D        		ld	a,l
2062    1DEE  E6C0      		and	192
2063    1DF0  6F        		ld	l,a
2064    1DF1  97        		sub	a
2065    1DF2  67        		ld	h,a
2066    1DF3  7D        		ld	a,l
2067    1DF4  FE40      		cp	64
2068    1DF6  2003      		jr	nz,L67
2069    1DF8  7C        		ld	a,h
2070    1DF9  FE00      		cp	0
2071                    	L67:
2072    1DFB  C2E41E    		jp	nz,L1472
2073                    	;  759              {
2074                    	;  760              printf("CSD Version 2.0, High Capacity and Extended Capacity\n");
2075    1DFE  215716    		ld	hl,L5231
2076    1E01  CD0000    		call	_printf
2077                    	;  761              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
2078                    	;  762                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
2079    1E04  DDE5      		push	ix
2080    1E06  C1        		pop	bc
2081    1E07  21F2FF    		ld	hl,65522
2082    1E0A  09        		add	hl,bc
2083    1E0B  E5        		push	hl
2084    1E0C  97        		sub	a
2085    1E0D  320000    		ld	(c.r0),a
2086    1E10  320100    		ld	(c.r0+1),a
2087    1E13  3A3000    		ld	a,(_csdreg+8)
2088    1E16  320200    		ld	(c.r0+2),a
2089    1E19  97        		sub	a
2090    1E1A  320300    		ld	(c.r0+3),a
2091    1E1D  210000    		ld	hl,c.r0
2092    1E20  E5        		push	hl
2093    1E21  210800    		ld	hl,8
2094    1E24  E5        		push	hl
2095    1E25  CD0000    		call	c.llsh
2096    1E28  97        		sub	a
2097    1E29  320000    		ld	(c.r1),a
2098    1E2C  320100    		ld	(c.r1+1),a
2099    1E2F  3A3100    		ld	a,(_csdreg+9)
2100    1E32  320200    		ld	(c.r1+2),a
2101    1E35  97        		sub	a
2102    1E36  320300    		ld	(c.r1+3),a
2103    1E39  210000    		ld	hl,c.r1
2104    1E3C  E5        		push	hl
2105    1E3D  CD0000    		call	c.ladd
2106    1E40  3A2F00    		ld	a,(_csdreg+7)
2107    1E43  6F        		ld	l,a
2108    1E44  97        		sub	a
2109    1E45  67        		ld	h,a
2110    1E46  7D        		ld	a,l
2111    1E47  E63F      		and	63
2112    1E49  6F        		ld	l,a
2113    1E4A  97        		sub	a
2114    1E4B  67        		ld	h,a
2115    1E4C  4D        		ld	c,l
2116    1E4D  44        		ld	b,h
2117    1E4E  78        		ld	a,b
2118    1E4F  87        		add	a,a
2119    1E50  9F        		sbc	a,a
2120    1E51  320000    		ld	(c.r1),a
2121    1E54  320100    		ld	(c.r1+1),a
2122    1E57  78        		ld	a,b
2123    1E58  320300    		ld	(c.r1+3),a
2124    1E5B  79        		ld	a,c
2125    1E5C  320200    		ld	(c.r1+2),a
2126    1E5F  210000    		ld	hl,c.r1
2127    1E62  E5        		push	hl
2128    1E63  211000    		ld	hl,16
2129    1E66  E5        		push	hl
2130    1E67  CD0000    		call	c.llsh
2131    1E6A  CD0000    		call	c.ladd
2132    1E6D  3E01      		ld	a,1
2133    1E6F  320200    		ld	(c.r1+2),a
2134    1E72  87        		add	a,a
2135    1E73  9F        		sbc	a,a
2136    1E74  320300    		ld	(c.r1+3),a
2137    1E77  320100    		ld	(c.r1+1),a
2138    1E7A  320000    		ld	(c.r1),a
2139    1E7D  210000    		ld	hl,c.r1
2140    1E80  E5        		push	hl
2141    1E81  CD0000    		call	c.ladd
2142    1E84  CD0000    		call	c.mvl
2143    1E87  F1        		pop	af
2144                    	;  763              capacity = devsize << 9;
2145    1E88  DDE5      		push	ix
2146    1E8A  C1        		pop	bc
2147    1E8B  21EEFF    		ld	hl,65518
2148    1E8E  09        		add	hl,bc
2149    1E8F  E5        		push	hl
2150    1E90  DDE5      		push	ix
2151    1E92  C1        		pop	bc
2152    1E93  21F2FF    		ld	hl,65522
2153    1E96  09        		add	hl,bc
2154    1E97  CD0000    		call	c.0mvf
2155    1E9A  210000    		ld	hl,c.r0
2156    1E9D  E5        		push	hl
2157    1E9E  210900    		ld	hl,9
2158    1EA1  E5        		push	hl
2159    1EA2  CD0000    		call	c.llsh
2160    1EA5  CD0000    		call	c.mvl
2161    1EA8  F1        		pop	af
2162                    	;  764              printf(" Device capacity: %lu KByte, %lu MByte\n",
2163                    	;  765                     capacity, capacity >> 10);
2164    1EA9  DDE5      		push	ix
2165    1EAB  C1        		pop	bc
2166    1EAC  21EEFF    		ld	hl,65518
2167    1EAF  09        		add	hl,bc
2168    1EB0  CD0000    		call	c.0mvf
2169    1EB3  210000    		ld	hl,c.r0
2170    1EB6  E5        		push	hl
2171    1EB7  210A00    		ld	hl,10
2172    1EBA  E5        		push	hl
2173    1EBB  CD0000    		call	c.ulrsh
2174    1EBE  E1        		pop	hl
2175    1EBF  23        		inc	hl
2176    1EC0  23        		inc	hl
2177    1EC1  4E        		ld	c,(hl)
2178    1EC2  23        		inc	hl
2179    1EC3  46        		ld	b,(hl)
2180    1EC4  C5        		push	bc
2181    1EC5  2B        		dec	hl
2182    1EC6  2B        		dec	hl
2183    1EC7  2B        		dec	hl
2184    1EC8  4E        		ld	c,(hl)
2185    1EC9  23        		inc	hl
2186    1ECA  46        		ld	b,(hl)
2187    1ECB  C5        		push	bc
2188    1ECC  DD66F1    		ld	h,(ix-15)
2189    1ECF  DD6EF0    		ld	l,(ix-16)
2190    1ED2  E5        		push	hl
2191    1ED3  DD66EF    		ld	h,(ix-17)
2192    1ED6  DD6EEE    		ld	l,(ix-18)
2193    1ED9  E5        		push	hl
2194    1EDA  218D16    		ld	hl,L5331
2195    1EDD  CD0000    		call	_printf
2196    1EE0  F1        		pop	af
2197    1EE1  F1        		pop	af
2198    1EE2  F1        		pop	af
2199    1EE3  F1        		pop	af
2200                    	L1472:
2201                    	;  766              }
2202                    	;  767          if ((csdreg[0] & 0xc0) == 0x80)
2203    1EE4  3A2800    		ld	a,(_csdreg)
2204    1EE7  6F        		ld	l,a
2205    1EE8  97        		sub	a
2206    1EE9  67        		ld	h,a
2207    1EEA  7D        		ld	a,l
2208    1EEB  E6C0      		and	192
2209    1EED  6F        		ld	l,a
2210    1EEE  97        		sub	a
2211    1EEF  67        		ld	h,a
2212    1EF0  7D        		ld	a,l
2213    1EF1  FE80      		cp	128
2214    1EF3  2003      		jr	nz,L001
2215    1EF5  7C        		ld	a,h
2216    1EF6  FE00      		cp	0
2217                    	L001:
2218    1EF8  C2E11F    		jp	nz,L1572
2219                    	;  768              {
2220                    	;  769              printf("CSD Version 3.0, Ultra Capacity (SDUC)\n");
2221    1EFB  21B516    		ld	hl,L5431
2222    1EFE  CD0000    		call	_printf
2223                    	;  770              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
2224                    	;  771                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
2225    1F01  DDE5      		push	ix
2226    1F03  C1        		pop	bc
2227    1F04  21F2FF    		ld	hl,65522
2228    1F07  09        		add	hl,bc
2229    1F08  E5        		push	hl
2230    1F09  97        		sub	a
2231    1F0A  320000    		ld	(c.r0),a
2232    1F0D  320100    		ld	(c.r0+1),a
2233    1F10  3A3000    		ld	a,(_csdreg+8)
2234    1F13  320200    		ld	(c.r0+2),a
2235    1F16  97        		sub	a
2236    1F17  320300    		ld	(c.r0+3),a
2237    1F1A  210000    		ld	hl,c.r0
2238    1F1D  E5        		push	hl
2239    1F1E  210800    		ld	hl,8
2240    1F21  E5        		push	hl
2241    1F22  CD0000    		call	c.llsh
2242    1F25  97        		sub	a
2243    1F26  320000    		ld	(c.r1),a
2244    1F29  320100    		ld	(c.r1+1),a
2245    1F2C  3A3100    		ld	a,(_csdreg+9)
2246    1F2F  320200    		ld	(c.r1+2),a
2247    1F32  97        		sub	a
2248    1F33  320300    		ld	(c.r1+3),a
2249    1F36  210000    		ld	hl,c.r1
2250    1F39  E5        		push	hl
2251    1F3A  CD0000    		call	c.ladd
2252    1F3D  3A2F00    		ld	a,(_csdreg+7)
2253    1F40  6F        		ld	l,a
2254    1F41  97        		sub	a
2255    1F42  67        		ld	h,a
2256    1F43  7D        		ld	a,l
2257    1F44  E63F      		and	63
2258    1F46  6F        		ld	l,a
2259    1F47  97        		sub	a
2260    1F48  67        		ld	h,a
2261    1F49  4D        		ld	c,l
2262    1F4A  44        		ld	b,h
2263    1F4B  78        		ld	a,b
2264    1F4C  87        		add	a,a
2265    1F4D  9F        		sbc	a,a
2266    1F4E  320000    		ld	(c.r1),a
2267    1F51  320100    		ld	(c.r1+1),a
2268    1F54  78        		ld	a,b
2269    1F55  320300    		ld	(c.r1+3),a
2270    1F58  79        		ld	a,c
2271    1F59  320200    		ld	(c.r1+2),a
2272    1F5C  210000    		ld	hl,c.r1
2273    1F5F  E5        		push	hl
2274    1F60  211000    		ld	hl,16
2275    1F63  E5        		push	hl
2276    1F64  CD0000    		call	c.llsh
2277    1F67  CD0000    		call	c.ladd
2278    1F6A  3E01      		ld	a,1
2279    1F6C  320200    		ld	(c.r1+2),a
2280    1F6F  87        		add	a,a
2281    1F70  9F        		sbc	a,a
2282    1F71  320300    		ld	(c.r1+3),a
2283    1F74  320100    		ld	(c.r1+1),a
2284    1F77  320000    		ld	(c.r1),a
2285    1F7A  210000    		ld	hl,c.r1
2286    1F7D  E5        		push	hl
2287    1F7E  CD0000    		call	c.ladd
2288    1F81  CD0000    		call	c.mvl
2289    1F84  F1        		pop	af
2290                    	;  772              capacity = devsize << 9;
2291    1F85  DDE5      		push	ix
2292    1F87  C1        		pop	bc
2293    1F88  21EEFF    		ld	hl,65518
2294    1F8B  09        		add	hl,bc
2295    1F8C  E5        		push	hl
2296    1F8D  DDE5      		push	ix
2297    1F8F  C1        		pop	bc
2298    1F90  21F2FF    		ld	hl,65522
2299    1F93  09        		add	hl,bc
2300    1F94  CD0000    		call	c.0mvf
2301    1F97  210000    		ld	hl,c.r0
2302    1F9A  E5        		push	hl
2303    1F9B  210900    		ld	hl,9
2304    1F9E  E5        		push	hl
2305    1F9F  CD0000    		call	c.llsh
2306    1FA2  CD0000    		call	c.mvl
2307    1FA5  F1        		pop	af
2308                    	;  773              printf(" Device capacity: %lu KByte, %lu MByte\n",
2309                    	;  774                     capacity, capacity >> 10);
2310    1FA6  DDE5      		push	ix
2311    1FA8  C1        		pop	bc
2312    1FA9  21EEFF    		ld	hl,65518
2313    1FAC  09        		add	hl,bc
2314    1FAD  CD0000    		call	c.0mvf
2315    1FB0  210000    		ld	hl,c.r0
2316    1FB3  E5        		push	hl
2317    1FB4  210A00    		ld	hl,10
2318    1FB7  E5        		push	hl
2319    1FB8  CD0000    		call	c.ulrsh
2320    1FBB  E1        		pop	hl
2321    1FBC  23        		inc	hl
2322    1FBD  23        		inc	hl
2323    1FBE  4E        		ld	c,(hl)
2324    1FBF  23        		inc	hl
2325    1FC0  46        		ld	b,(hl)
2326    1FC1  C5        		push	bc
2327    1FC2  2B        		dec	hl
2328    1FC3  2B        		dec	hl
2329    1FC4  2B        		dec	hl
2330    1FC5  4E        		ld	c,(hl)
2331    1FC6  23        		inc	hl
2332    1FC7  46        		ld	b,(hl)
2333    1FC8  C5        		push	bc
2334    1FC9  DD66F1    		ld	h,(ix-15)
2335    1FCC  DD6EF0    		ld	l,(ix-16)
2336    1FCF  E5        		push	hl
2337    1FD0  DD66EF    		ld	h,(ix-17)
2338    1FD3  DD6EEE    		ld	l,(ix-18)
2339    1FD6  E5        		push	hl
2340    1FD7  21DD16    		ld	hl,L5531
2341    1FDA  CD0000    		call	_printf
2342    1FDD  F1        		pop	af
2343    1FDE  F1        		pop	af
2344    1FDF  F1        		pop	af
2345    1FE0  F1        		pop	af
2346                    	L1572:
2347                    	;  775              }
2348                    	;  776          printf("--------------------------------------\n");
2349    1FE1  210517    		ld	hl,L5631
2350    1FE4  CD0000    		call	_printf
2351                    	L1052:
2352                    	;  777  
2353                    	;  778          } /* sdtestflg */ /* SDTEST */
2354                    	;  779  
2355                    	;  780      }
2356    1FE7  C30000    		jp	c.rets0
2357                    	L5731:
2358    1FEA  53        		.byte	83
2359    1FEB  44        		.byte	68
2360    1FEC  20        		.byte	32
2361    1FED  63        		.byte	99
2362    1FEE  61        		.byte	97
2363    1FEF  72        		.byte	114
2364    1FF0  64        		.byte	100
2365    1FF1  20        		.byte	32
2366    1FF2  6E        		.byte	110
2367    1FF3  6F        		.byte	111
2368    1FF4  74        		.byte	116
2369    1FF5  20        		.byte	32
2370    1FF6  69        		.byte	105
2371    1FF7  6E        		.byte	110
2372    1FF8  69        		.byte	105
2373    1FF9  74        		.byte	116
2374    1FFA  69        		.byte	105
2375    1FFB  61        		.byte	97
2376    1FFC  6C        		.byte	108
2377    1FFD  69        		.byte	105
2378    1FFE  7A        		.byte	122
2379    1FFF  65        		.byte	101
2380    2000  64        		.byte	100
2381    2001  0A        		.byte	10
2382    2002  00        		.byte	0
2383                    	L5041:
2384    2003  0A        		.byte	10
2385    2004  43        		.byte	67
2386    2005  4D        		.byte	77
2387    2006  44        		.byte	68
2388    2007  31        		.byte	49
2389    2008  37        		.byte	55
2390    2009  3A        		.byte	58
2391    200A  20        		.byte	32
2392    200B  52        		.byte	82
2393    200C  45        		.byte	69
2394    200D  41        		.byte	65
2395    200E  44        		.byte	68
2396    200F  5F        		.byte	95
2397    2010  53        		.byte	83
2398    2011  49        		.byte	73
2399    2012  4E        		.byte	78
2400    2013  47        		.byte	71
2401    2014  4C        		.byte	76
2402    2015  45        		.byte	69
2403    2016  5F        		.byte	95
2404    2017  42        		.byte	66
2405    2018  4C        		.byte	76
2406    2019  4F        		.byte	79
2407    201A  43        		.byte	67
2408    201B  4B        		.byte	75
2409    201C  2C        		.byte	44
2410    201D  20        		.byte	32
2411    201E  63        		.byte	99
2412    201F  6F        		.byte	111
2413    2020  6D        		.byte	109
2414    2021  6D        		.byte	109
2415    2022  61        		.byte	97
2416    2023  6E        		.byte	110
2417    2024  64        		.byte	100
2418    2025  20        		.byte	32
2419    2026  5B        		.byte	91
2420    2027  25        		.byte	37
2421    2028  30        		.byte	48
2422    2029  32        		.byte	50
2423    202A  78        		.byte	120
2424    202B  20        		.byte	32
2425    202C  25        		.byte	37
2426    202D  30        		.byte	48
2427    202E  32        		.byte	50
2428    202F  78        		.byte	120
2429    2030  20        		.byte	32
2430    2031  25        		.byte	37
2431    2032  30        		.byte	48
2432    2033  32        		.byte	50
2433    2034  78        		.byte	120
2434    2035  20        		.byte	32
2435    2036  25        		.byte	37
2436    2037  30        		.byte	48
2437    2038  32        		.byte	50
2438    2039  78        		.byte	120
2439    203A  20        		.byte	32
2440    203B  25        		.byte	37
2441    203C  30        		.byte	48
2442    203D  32        		.byte	50
2443    203E  78        		.byte	120
2444    203F  5D        		.byte	93
2445    2040  0A        		.byte	10
2446    2041  00        		.byte	0
2447                    	L5141:
2448    2042  43        		.byte	67
2449    2043  4D        		.byte	77
2450    2044  44        		.byte	68
2451    2045  31        		.byte	49
2452    2046  37        		.byte	55
2453    2047  20        		.byte	32
2454    2048  52        		.byte	82
2455    2049  31        		.byte	49
2456    204A  20        		.byte	32
2457    204B  72        		.byte	114
2458    204C  65        		.byte	101
2459    204D  73        		.byte	115
2460    204E  70        		.byte	112
2461    204F  6F        		.byte	111
2462    2050  6E        		.byte	110
2463    2051  73        		.byte	115
2464    2052  65        		.byte	101
2465    2053  20        		.byte	32
2466    2054  5B        		.byte	91
2467    2055  25        		.byte	37
2468    2056  30        		.byte	48
2469    2057  32        		.byte	50
2470    2058  78        		.byte	120
2471    2059  5D        		.byte	93
2472    205A  0A        		.byte	10
2473    205B  00        		.byte	0
2474                    	L5241:
2475    205C  20        		.byte	32
2476    205D  20        		.byte	32
2477    205E  63        		.byte	99
2478    205F  6F        		.byte	111
2479    2060  75        		.byte	117
2480    2061  6C        		.byte	108
2481    2062  64        		.byte	100
2482    2063  20        		.byte	32
2483    2064  6E        		.byte	110
2484    2065  6F        		.byte	111
2485    2066  74        		.byte	116
2486    2067  20        		.byte	32
2487    2068  72        		.byte	114
2488    2069  65        		.byte	101
2489    206A  61        		.byte	97
2490    206B  64        		.byte	100
2491    206C  20        		.byte	32
2492    206D  62        		.byte	98
2493    206E  6C        		.byte	108
2494    206F  6F        		.byte	111
2495    2070  63        		.byte	99
2496    2071  6B        		.byte	107
2497    2072  0A        		.byte	10
2498    2073  00        		.byte	0
2499                    	L5341:
2500    2074  20        		.byte	32
2501    2075  20        		.byte	32
2502    2076  72        		.byte	114
2503    2077  65        		.byte	101
2504    2078  61        		.byte	97
2505    2079  64        		.byte	100
2506    207A  20        		.byte	32
2507    207B  65        		.byte	101
2508    207C  72        		.byte	114
2509    207D  72        		.byte	114
2510    207E  6F        		.byte	111
2511    207F  72        		.byte	114
2512    2080  3A        		.byte	58
2513    2081  20        		.byte	32
2514    2082  5B        		.byte	91
2515    2083  25        		.byte	37
2516    2084  30        		.byte	48
2517    2085  32        		.byte	50
2518    2086  78        		.byte	120
2519    2087  5D        		.byte	93
2520    2088  0A        		.byte	10
2521    2089  00        		.byte	0
2522                    	L5441:
2523    208A  20        		.byte	32
2524    208B  20        		.byte	32
2525    208C  6E        		.byte	110
2526    208D  6F        		.byte	111
2527    208E  20        		.byte	32
2528    208F  64        		.byte	100
2529    2090  61        		.byte	97
2530    2091  74        		.byte	116
2531    2092  61        		.byte	97
2532    2093  20        		.byte	32
2533    2094  66        		.byte	102
2534    2095  6F        		.byte	111
2535    2096  75        		.byte	117
2536    2097  6E        		.byte	110
2537    2098  64        		.byte	100
2538    2099  0A        		.byte	10
2539    209A  00        		.byte	0
2540                    	L5541:
2541    209B  20        		.byte	32
2542    209C  20        		.byte	32
2543    209D  72        		.byte	114
2544    209E  65        		.byte	101
2545    209F  61        		.byte	97
2546    20A0  64        		.byte	100
2547    20A1  20        		.byte	32
2548    20A2  64        		.byte	100
2549    20A3  61        		.byte	97
2550    20A4  74        		.byte	116
2551    20A5  61        		.byte	97
2552    20A6  20        		.byte	32
2553    20A7  62        		.byte	98
2554    20A8  6C        		.byte	108
2555    20A9  6F        		.byte	111
2556    20AA  63        		.byte	99
2557    20AB  6B        		.byte	107
2558    20AC  20        		.byte	32
2559    20AD  25        		.byte	37
2560    20AE  6C        		.byte	108
2561    20AF  64        		.byte	100
2562    20B0  3A        		.byte	58
2563    20B1  0A        		.byte	10
2564    20B2  00        		.byte	0
2565                    	L5641:
2566    20B3  20        		.byte	32
2567    20B4  20        		.byte	32
2568    20B5  43        		.byte	67
2569    20B6  52        		.byte	82
2570    20B7  43        		.byte	67
2571    20B8  31        		.byte	49
2572    20B9  36        		.byte	54
2573    20BA  20        		.byte	32
2574    20BB  65        		.byte	101
2575    20BC  72        		.byte	114
2576    20BD  72        		.byte	114
2577    20BE  6F        		.byte	111
2578    20BF  72        		.byte	114
2579    20C0  2C        		.byte	44
2580    20C1  20        		.byte	32
2581    20C2  72        		.byte	114
2582    20C3  65        		.byte	101
2583    20C4  63        		.byte	99
2584    20C5  69        		.byte	105
2585    20C6  65        		.byte	101
2586    20C7  76        		.byte	118
2587    20C8  65        		.byte	101
2588    20C9  64        		.byte	100
2589    20CA  3A        		.byte	58
2590    20CB  20        		.byte	32
2591    20CC  30        		.byte	48
2592    20CD  78        		.byte	120
2593    20CE  25        		.byte	37
2594    20CF  30        		.byte	48
2595    20D0  34        		.byte	52
2596    20D1  78        		.byte	120
2597    20D2  2C        		.byte	44
2598    20D3  20        		.byte	32
2599    20D4  63        		.byte	99
2600    20D5  61        		.byte	97
2601    20D6  6C        		.byte	108
2602    20D7  63        		.byte	99
2603    20D8  3A        		.byte	58
2604    20D9  20        		.byte	32
2605    20DA  30        		.byte	48
2606    20DB  78        		.byte	120
2607    20DC  25        		.byte	37
2608    20DD  30        		.byte	48
2609    20DE  34        		.byte	52
2610    20DF  68        		.byte	104
2611    20E0  69        		.byte	105
2612    20E1  0A        		.byte	10
2613    20E2  00        		.byte	0
2614                    	;  781  
2615                    	;  782  /* Read data block of 512 bytes to buffer
2616                    	;  783   * Returns YES if ok or NO if error
2617                    	;  784   */
2618                    	;  785  int sdread(unsigned char *rdbuf, unsigned long rdblkno)
2619                    	;  786      {
2620                    	_sdread:
2621    20E3  CD0000    		call	c.savs
2622    20E6  21E0FF    		ld	hl,65504
2623    20E9  39        		add	hl,sp
2624    20EA  F9        		ld	sp,hl
2625                    	;  787      unsigned char *statptr;
2626                    	;  788      unsigned char rbyte;
2627                    	;  789      unsigned char cmdbuf[5];   /* buffer to build command in */
2628                    	;  790      unsigned char rstatbuf[5]; /* buffer to recieve status in */
2629                    	;  791      int nbytes;
2630                    	;  792      int tries;
2631                    	;  793      unsigned long blktoread;
2632                    	;  794      unsigned int rxcrc16;
2633                    	;  795      unsigned int calcrc16;
2634                    	;  796  
2635                    	;  797      ledon();
2636    20EB  CD0000    		call	_ledon
2637                    	;  798      spiselect();
2638    20EE  CD0000    		call	_spiselect
2639                    	;  799  
2640                    	;  800      if (!sdinitok)
2641    20F1  2A0C00    		ld	hl,(_sdinitok)
2642    20F4  7C        		ld	a,h
2643    20F5  B5        		or	l
2644    20F6  2019      		jr	nz,L1672
2645                    	;  801          {
2646                    	;  802          if (sdtestflg)
2647    20F8  2A0000    		ld	hl,(_sdtestflg)
2648    20FB  7C        		ld	a,h
2649    20FC  B5        		or	l
2650    20FD  2806      		jr	z,L1772
2651                    	;  803              {
2652                    	;  804              printf("SD card not initialized\n");
2653    20FF  21EA1F    		ld	hl,L5731
2654    2102  CD0000    		call	_printf
2655                    	L1772:
2656                    	;  805              } /* sdtestflg */
2657                    	;  806          spideselect();
2658    2105  CD0000    		call	_spideselect
2659                    	;  807          ledoff();
2660    2108  CD0000    		call	_ledoff
2661                    	;  808          return (NO);
2662    210B  010000    		ld	bc,0
2663    210E  C30000    		jp	c.rets
2664                    	L1672:
2665                    	;  809          }
2666                    	;  810  
2667                    	;  811      /* CMD17: READ_SINGLE_BLOCK */
2668                    	;  812      /* Insert block # into command */
2669                    	;  813      memcpy(cmdbuf, cmd17, 5);
2670    2111  210500    		ld	hl,5
2671    2114  E5        		push	hl
2672    2115  213700    		ld	hl,_cmd17
2673    2118  E5        		push	hl
2674    2119  DDE5      		push	ix
2675    211B  C1        		pop	bc
2676    211C  21F2FF    		ld	hl,65522
2677    211F  09        		add	hl,bc
2678    2120  CD0000    		call	_memcpy
2679    2123  F1        		pop	af
2680    2124  F1        		pop	af
2681                    	;  814      blktoread = blkmult * rdblkno;
2682    2125  DDE5      		push	ix
2683    2127  C1        		pop	bc
2684    2128  21E4FF    		ld	hl,65508
2685    212B  09        		add	hl,bc
2686    212C  E5        		push	hl
2687    212D  210600    		ld	hl,_blkmult
2688    2130  CD0000    		call	c.0mvf
2689    2133  210000    		ld	hl,c.r0
2690    2136  E5        		push	hl
2691    2137  DDE5      		push	ix
2692    2139  C1        		pop	bc
2693    213A  210600    		ld	hl,6
2694    213D  09        		add	hl,bc
2695    213E  E5        		push	hl
2696    213F  CD0000    		call	c.lmul
2697    2142  CD0000    		call	c.mvl
2698    2145  F1        		pop	af
2699                    	;  815      cmdbuf[4] = blktoread & 0xff;
2700    2146  DD6EE6    		ld	l,(ix-26)
2701    2149  7D        		ld	a,l
2702    214A  E6FF      		and	255
2703    214C  DD77F6    		ld	(ix-10),a
2704                    	;  816      blktoread = blktoread >> 8;
2705    214F  DDE5      		push	ix
2706    2151  C1        		pop	bc
2707    2152  21E4FF    		ld	hl,65508
2708    2155  09        		add	hl,bc
2709    2156  E5        		push	hl
2710    2157  210800    		ld	hl,8
2711    215A  E5        		push	hl
2712    215B  CD0000    		call	c.ulrsh
2713    215E  F1        		pop	af
2714                    	;  817      cmdbuf[3] = blktoread & 0xff;
2715    215F  DD6EE6    		ld	l,(ix-26)
2716    2162  7D        		ld	a,l
2717    2163  E6FF      		and	255
2718    2165  DD77F5    		ld	(ix-11),a
2719                    	;  818      blktoread = blktoread >> 8;
2720    2168  DDE5      		push	ix
2721    216A  C1        		pop	bc
2722    216B  21E4FF    		ld	hl,65508
2723    216E  09        		add	hl,bc
2724    216F  E5        		push	hl
2725    2170  210800    		ld	hl,8
2726    2173  E5        		push	hl
2727    2174  CD0000    		call	c.ulrsh
2728    2177  F1        		pop	af
2729                    	;  819      cmdbuf[2] = blktoread & 0xff;
2730    2178  DD6EE6    		ld	l,(ix-26)
2731    217B  7D        		ld	a,l
2732    217C  E6FF      		and	255
2733    217E  DD77F4    		ld	(ix-12),a
2734                    	;  820      blktoread = blktoread >> 8;
2735    2181  DDE5      		push	ix
2736    2183  C1        		pop	bc
2737    2184  21E4FF    		ld	hl,65508
2738    2187  09        		add	hl,bc
2739    2188  E5        		push	hl
2740    2189  210800    		ld	hl,8
2741    218C  E5        		push	hl
2742    218D  CD0000    		call	c.ulrsh
2743    2190  F1        		pop	af
2744                    	;  821      cmdbuf[1] = blktoread & 0xff;
2745    2191  DD6EE6    		ld	l,(ix-26)
2746    2194  7D        		ld	a,l
2747    2195  E6FF      		and	255
2748    2197  DD77F3    		ld	(ix-13),a
2749                    	;  822  
2750                    	;  823      if (sdtestflg)
2751    219A  2A0000    		ld	hl,(_sdtestflg)
2752    219D  7C        		ld	a,h
2753    219E  B5        		or	l
2754    219F  2829      		jr	z,L1003
2755                    	;  824          {
2756                    	;  825          printf("\nCMD17: READ_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
2757                    	;  826                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
2758    21A1  DD4EF6    		ld	c,(ix-10)
2759    21A4  97        		sub	a
2760    21A5  47        		ld	b,a
2761    21A6  C5        		push	bc
2762    21A7  DD4EF5    		ld	c,(ix-11)
2763    21AA  97        		sub	a
2764    21AB  47        		ld	b,a
2765    21AC  C5        		push	bc
2766    21AD  DD4EF4    		ld	c,(ix-12)
2767    21B0  97        		sub	a
2768    21B1  47        		ld	b,a
2769    21B2  C5        		push	bc
2770    21B3  DD4EF3    		ld	c,(ix-13)
2771    21B6  97        		sub	a
2772    21B7  47        		ld	b,a
2773    21B8  C5        		push	bc
2774    21B9  DD4EF2    		ld	c,(ix-14)
2775    21BC  97        		sub	a
2776    21BD  47        		ld	b,a
2777    21BE  C5        		push	bc
2778    21BF  210320    		ld	hl,L5041
2779    21C2  CD0000    		call	_printf
2780    21C5  210A00    		ld	hl,10
2781    21C8  39        		add	hl,sp
2782    21C9  F9        		ld	sp,hl
2783                    	L1003:
2784                    	;  827          } /* sdtestflg */
2785                    	;  828      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2786    21CA  210100    		ld	hl,1
2787    21CD  E5        		push	hl
2788    21CE  DDE5      		push	ix
2789    21D0  C1        		pop	bc
2790    21D1  21EDFF    		ld	hl,65517
2791    21D4  09        		add	hl,bc
2792    21D5  E5        		push	hl
2793    21D6  DDE5      		push	ix
2794    21D8  C1        		pop	bc
2795    21D9  21F2FF    		ld	hl,65522
2796    21DC  09        		add	hl,bc
2797    21DD  CD7701    		call	_sdcommand
2798    21E0  F1        		pop	af
2799    21E1  F1        		pop	af
2800    21E2  DD71F8    		ld	(ix-8),c
2801    21E5  DD70F9    		ld	(ix-7),b
2802                    	;  829      if (sdtestflg)
2803    21E8  2A0000    		ld	hl,(_sdtestflg)
2804    21EB  7C        		ld	a,h
2805    21EC  B5        		or	l
2806    21ED  2811      		jr	z,L1103
2807                    	;  830          {
2808                    	;  831          printf("CMD17 R1 response [%02x]\n", statptr[0]);
2809    21EF  DD6EF8    		ld	l,(ix-8)
2810    21F2  DD66F9    		ld	h,(ix-7)
2811    21F5  4E        		ld	c,(hl)
2812    21F6  97        		sub	a
2813    21F7  47        		ld	b,a
2814    21F8  C5        		push	bc
2815    21F9  214220    		ld	hl,L5141
2816    21FC  CD0000    		call	_printf
2817    21FF  F1        		pop	af
2818                    	L1103:
2819                    	;  832          } /* sdtestflg */
2820                    	;  833      if (statptr[0])
2821    2200  DD6EF8    		ld	l,(ix-8)
2822    2203  DD66F9    		ld	h,(ix-7)
2823    2206  7E        		ld	a,(hl)
2824    2207  B7        		or	a
2825    2208  2819      		jr	z,L1203
2826                    	;  834          {
2827                    	;  835          if (sdtestflg)
2828    220A  2A0000    		ld	hl,(_sdtestflg)
2829    220D  7C        		ld	a,h
2830    220E  B5        		or	l
2831    220F  2806      		jr	z,L1303
2832                    	;  836              {
2833                    	;  837              printf("  could not read block\n");
2834    2211  215C20    		ld	hl,L5241
2835    2214  CD0000    		call	_printf
2836                    	L1303:
2837                    	;  838              } /* sdtestflg */
2838                    	;  839          spideselect();
2839    2217  CD0000    		call	_spideselect
2840                    	;  840          ledoff();
2841    221A  CD0000    		call	_ledoff
2842                    	;  841          return (NO);
2843    221D  010000    		ld	bc,0
2844    2220  C30000    		jp	c.rets
2845                    	L1203:
2846                    	;  842          }
2847                    	;  843      /* looking for 0xfe that is the byte before data */
2848                    	;  844      for (tries = 80; (0 < tries) && ((rbyte = spiio(0xff)) != 0xfe); tries--)
2849    2223  DD36E850  		ld	(ix-24),80
2850    2227  DD36E900  		ld	(ix-23),0
2851                    	L1403:
2852    222B  97        		sub	a
2853    222C  DD96E8    		sub	(ix-24)
2854    222F  3E00      		ld	a,0
2855    2231  DD9EE9    		sbc	a,(ix-23)
2856    2234  F28022    		jp	p,L1503
2857    2237  21FF00    		ld	hl,255
2858    223A  CD0000    		call	_spiio
2859    223D  DD71F7    		ld	(ix-9),c
2860    2240  DD7EF7    		ld	a,(ix-9)
2861    2243  FEFE      		cp	254
2862    2245  2839      		jr	z,L1503
2863                    	;  845          {
2864                    	;  846          if ((rbyte & 0xe0) == 0x00)
2865    2247  DD6EF7    		ld	l,(ix-9)
2866    224A  7D        		ld	a,l
2867    224B  E6E0      		and	224
2868    224D  2016      		jr	nz,L1603
2869                    	;  847              {
2870                    	;  848              /* If a read operation fails and the card cannot provide
2871                    	;  849                 the required data, it will send a data error token instead
2872                    	;  850               */
2873                    	;  851              if (sdtestflg)
2874    224F  2A0000    		ld	hl,(_sdtestflg)
2875    2252  7C        		ld	a,h
2876    2253  B5        		or	l
2877    2254  281E      		jr	z,L1113
2878                    	;  852                  {
2879                    	;  853                  printf("  read error: [%02x]\n", rbyte);
2880    2256  DD4EF7    		ld	c,(ix-9)
2881    2259  97        		sub	a
2882    225A  47        		ld	b,a
2883    225B  C5        		push	bc
2884    225C  217420    		ld	hl,L5341
2885    225F  CD0000    		call	_printf
2886    2262  F1        		pop	af
2887    2263  180F      		jr	L1113
2888                    	L1603:
2889    2265  DD6EE8    		ld	l,(ix-24)
2890    2268  DD66E9    		ld	h,(ix-23)
2891    226B  2B        		dec	hl
2892    226C  DD75E8    		ld	(ix-24),l
2893    226F  DD74E9    		ld	(ix-23),h
2894    2272  18B7      		jr	L1403
2895                    	L1113:
2896                    	;  854                  } /* sdtestflg */
2897                    	;  855              spideselect();
2898    2274  CD0000    		call	_spideselect
2899                    	;  856              ledoff();
2900    2277  CD0000    		call	_ledoff
2901                    	;  857              return (NO);
2902    227A  010000    		ld	bc,0
2903    227D  C30000    		jp	c.rets
2904                    	L1503:
2905                    	;  858              }
2906                    	;  859          }
2907                    	;  860      if (tries == 0) /* tried too many times */
2908    2280  DD7EE8    		ld	a,(ix-24)
2909    2283  DDB6E9    		or	(ix-23)
2910    2286  2019      		jr	nz,L1213
2911                    	;  861          {
2912                    	;  862          if (sdtestflg)
2913    2288  2A0000    		ld	hl,(_sdtestflg)
2914    228B  7C        		ld	a,h
2915    228C  B5        		or	l
2916    228D  2806      		jr	z,L1313
2917                    	;  863              {
2918                    	;  864              printf("  no data found\n");
2919    228F  218A20    		ld	hl,L5441
2920    2292  CD0000    		call	_printf
2921                    	L1313:
2922                    	;  865              } /* sdtestflg */
2923                    	;  866          spideselect();
2924    2295  CD0000    		call	_spideselect
2925                    	;  867          ledoff();
2926    2298  CD0000    		call	_ledoff
2927                    	;  868          return (NO);
2928    229B  010000    		ld	bc,0
2929    229E  C30000    		jp	c.rets
2930                    	L1213:
2931                    	;  869          }
2932                    	;  870      else
2933                    	;  871          {
2934                    	;  872          calcrc16 = 0;
2935    22A1  DD36E000  		ld	(ix-32),0
2936    22A5  DD36E100  		ld	(ix-31),0
2937                    	;  873          for (nbytes = 0; nbytes < 512; nbytes++)
2938    22A9  DD36EA00  		ld	(ix-22),0
2939    22AD  DD36EB00  		ld	(ix-21),0
2940                    	L1513:
2941    22B1  DD7EEA    		ld	a,(ix-22)
2942    22B4  D600      		sub	0
2943    22B6  DD7EEB    		ld	a,(ix-21)
2944    22B9  DE02      		sbc	a,2
2945    22BB  F2F822    		jp	p,L1613
2946                    	;  874              {
2947                    	;  875              rbyte = spiio(0xff);
2948    22BE  21FF00    		ld	hl,255
2949    22C1  CD0000    		call	_spiio
2950    22C4  DD71F7    		ld	(ix-9),c
2951                    	;  876              calcrc16 = CRC16_one(calcrc16, rbyte);
2952    22C7  DD6EF7    		ld	l,(ix-9)
2953    22CA  97        		sub	a
2954    22CB  67        		ld	h,a
2955    22CC  E5        		push	hl
2956    22CD  DD6EE0    		ld	l,(ix-32)
2957    22D0  DD66E1    		ld	h,(ix-31)
2958    22D3  CDC900    		call	_CRC16_one
2959    22D6  F1        		pop	af
2960    22D7  DD71E0    		ld	(ix-32),c
2961    22DA  DD70E1    		ld	(ix-31),b
2962                    	;  877              rdbuf[nbytes] = rbyte;
2963    22DD  DD6E04    		ld	l,(ix+4)
2964    22E0  DD6605    		ld	h,(ix+5)
2965    22E3  DD4EEA    		ld	c,(ix-22)
2966    22E6  DD46EB    		ld	b,(ix-21)
2967    22E9  09        		add	hl,bc
2968    22EA  DD7EF7    		ld	a,(ix-9)
2969    22ED  77        		ld	(hl),a
2970                    	;  878              }
2971    22EE  DD34EA    		inc	(ix-22)
2972    22F1  2003      		jr	nz,L401
2973    22F3  DD34EB    		inc	(ix-21)
2974                    	L401:
2975    22F6  18B9      		jr	L1513
2976                    	L1613:
2977                    	;  879          rxcrc16 = spiio(0xff) << 8;
2978    22F8  21FF00    		ld	hl,255
2979    22FB  CD0000    		call	_spiio
2980    22FE  69        		ld	l,c
2981    22FF  60        		ld	h,b
2982    2300  29        		add	hl,hl
2983    2301  29        		add	hl,hl
2984    2302  29        		add	hl,hl
2985    2303  29        		add	hl,hl
2986    2304  29        		add	hl,hl
2987    2305  29        		add	hl,hl
2988    2306  29        		add	hl,hl
2989    2307  29        		add	hl,hl
2990    2308  DD75E2    		ld	(ix-30),l
2991    230B  DD74E3    		ld	(ix-29),h
2992                    	;  880          rxcrc16 += spiio(0xff);
2993    230E  21FF00    		ld	hl,255
2994    2311  CD0000    		call	_spiio
2995    2314  DD6EE2    		ld	l,(ix-30)
2996    2317  DD66E3    		ld	h,(ix-29)
2997    231A  09        		add	hl,bc
2998    231B  DD75E2    		ld	(ix-30),l
2999    231E  DD74E3    		ld	(ix-29),h
3000                    	;  881  
3001                    	;  882          if (sdtestflg)
3002    2321  2A0000    		ld	hl,(_sdtestflg)
3003    2324  7C        		ld	a,h
3004    2325  B5        		or	l
3005    2326  2816      		jr	z,L1123
3006                    	;  883              {
3007                    	;  884              printf("  read data block %ld:\n", rdblkno);
3008    2328  DD6609    		ld	h,(ix+9)
3009    232B  DD6E08    		ld	l,(ix+8)
3010    232E  E5        		push	hl
3011    232F  DD6607    		ld	h,(ix+7)
3012    2332  DD6E06    		ld	l,(ix+6)
3013    2335  E5        		push	hl
3014    2336  219B20    		ld	hl,L5541
3015    2339  CD0000    		call	_printf
3016    233C  F1        		pop	af
3017    233D  F1        		pop	af
3018                    	L1123:
3019                    	;  885              } /* sdtestflg */
3020                    	;  886          if (rxcrc16 != calcrc16)
3021    233E  DD7EE2    		ld	a,(ix-30)
3022    2341  DDBEE0    		cp	(ix-32)
3023    2344  2006      		jr	nz,L601
3024    2346  DD7EE3    		ld	a,(ix-29)
3025    2349  DDBEE1    		cp	(ix-31)
3026                    	L601:
3027    234C  2829      		jr	z,L1413
3028                    	;  887              {
3029                    	;  888              if (sdtestflg)
3030    234E  2A0000    		ld	hl,(_sdtestflg)
3031    2351  7C        		ld	a,h
3032    2352  B5        		or	l
3033    2353  2816      		jr	z,L1323
3034                    	;  889                  {
3035                    	;  890                  printf("  CRC16 error, recieved: 0x%04x, calc: 0x%04hi\n",
3036                    	;  891                         rxcrc16, calcrc16);
3037    2355  DD6EE0    		ld	l,(ix-32)
3038    2358  DD66E1    		ld	h,(ix-31)
3039    235B  E5        		push	hl
3040    235C  DD6EE2    		ld	l,(ix-30)
3041    235F  DD66E3    		ld	h,(ix-29)
3042    2362  E5        		push	hl
3043    2363  21B320    		ld	hl,L5641
3044    2366  CD0000    		call	_printf
3045    2369  F1        		pop	af
3046    236A  F1        		pop	af
3047                    	L1323:
3048                    	;  892                  } /* sdtestflg */
3049                    	;  893              spideselect();
3050    236B  CD0000    		call	_spideselect
3051                    	;  894              ledoff();
3052    236E  CD0000    		call	_ledoff
3053                    	;  895              return (NO);
3054    2371  010000    		ld	bc,0
3055    2374  C30000    		jp	c.rets
3056                    	L1413:
3057                    	;  896              }
3058                    	;  897          }
3059                    	;  898      spideselect();
3060    2377  CD0000    		call	_spideselect
3061                    	;  899      ledoff();
3062    237A  CD0000    		call	_ledoff
3063                    	;  900      return (YES);
3064    237D  010100    		ld	bc,1
3065    2380  C30000    		jp	c.rets
3066                    	L5741:
3067    2383  53        		.byte	83
3068    2384  44        		.byte	68
3069    2385  20        		.byte	32
3070    2386  63        		.byte	99
3071    2387  61        		.byte	97
3072    2388  72        		.byte	114
3073    2389  64        		.byte	100
3074    238A  20        		.byte	32
3075    238B  6E        		.byte	110
3076    238C  6F        		.byte	111
3077    238D  74        		.byte	116
3078    238E  20        		.byte	32
3079    238F  69        		.byte	105
3080    2390  6E        		.byte	110
3081    2391  69        		.byte	105
3082    2392  74        		.byte	116
3083    2393  69        		.byte	105
3084    2394  61        		.byte	97
3085    2395  6C        		.byte	108
3086    2396  69        		.byte	105
3087    2397  7A        		.byte	122
3088    2398  65        		.byte	101
3089    2399  64        		.byte	100
3090    239A  0A        		.byte	10
3091    239B  00        		.byte	0
3092                    	L5051:
3093    239C  20        		.byte	32
3094    239D  20        		.byte	32
3095    239E  77        		.byte	119
3096    239F  72        		.byte	114
3097    23A0  69        		.byte	105
3098    23A1  74        		.byte	116
3099    23A2  65        		.byte	101
3100    23A3  20        		.byte	32
3101    23A4  64        		.byte	100
3102    23A5  61        		.byte	97
3103    23A6  74        		.byte	116
3104    23A7  61        		.byte	97
3105    23A8  20        		.byte	32
3106    23A9  62        		.byte	98
3107    23AA  6C        		.byte	108
3108    23AB  6F        		.byte	111
3109    23AC  63        		.byte	99
3110    23AD  6B        		.byte	107
3111    23AE  20        		.byte	32
3112    23AF  25        		.byte	37
3113    23B0  6C        		.byte	108
3114    23B1  64        		.byte	100
3115    23B2  3A        		.byte	58
3116    23B3  0A        		.byte	10
3117    23B4  00        		.byte	0
3118                    	L5151:
3119    23B5  0A        		.byte	10
3120    23B6  43        		.byte	67
3121    23B7  4D        		.byte	77
3122    23B8  44        		.byte	68
3123    23B9  32        		.byte	50
3124    23BA  34        		.byte	52
3125    23BB  3A        		.byte	58
3126    23BC  20        		.byte	32
3127    23BD  57        		.byte	87
3128    23BE  52        		.byte	82
3129    23BF  49        		.byte	73
3130    23C0  54        		.byte	84
3131    23C1  45        		.byte	69
3132    23C2  5F        		.byte	95
3133    23C3  53        		.byte	83
3134    23C4  49        		.byte	73
3135    23C5  4E        		.byte	78
3136    23C6  47        		.byte	71
3137    23C7  4C        		.byte	76
3138    23C8  45        		.byte	69
3139    23C9  5F        		.byte	95
3140    23CA  42        		.byte	66
3141    23CB  4C        		.byte	76
3142    23CC  4F        		.byte	79
3143    23CD  43        		.byte	67
3144    23CE  4B        		.byte	75
3145    23CF  2C        		.byte	44
3146    23D0  20        		.byte	32
3147    23D1  63        		.byte	99
3148    23D2  6F        		.byte	111
3149    23D3  6D        		.byte	109
3150    23D4  6D        		.byte	109
3151    23D5  61        		.byte	97
3152    23D6  6E        		.byte	110
3153    23D7  64        		.byte	100
3154    23D8  20        		.byte	32
3155    23D9  5B        		.byte	91
3156    23DA  25        		.byte	37
3157    23DB  30        		.byte	48
3158    23DC  32        		.byte	50
3159    23DD  78        		.byte	120
3160    23DE  20        		.byte	32
3161    23DF  25        		.byte	37
3162    23E0  30        		.byte	48
3163    23E1  32        		.byte	50
3164    23E2  78        		.byte	120
3165    23E3  20        		.byte	32
3166    23E4  25        		.byte	37
3167    23E5  30        		.byte	48
3168    23E6  32        		.byte	50
3169    23E7  78        		.byte	120
3170    23E8  20        		.byte	32
3171    23E9  25        		.byte	37
3172    23EA  30        		.byte	48
3173    23EB  32        		.byte	50
3174    23EC  78        		.byte	120
3175    23ED  20        		.byte	32
3176    23EE  25        		.byte	37
3177    23EF  30        		.byte	48
3178    23F0  32        		.byte	50
3179    23F1  78        		.byte	120
3180    23F2  5D        		.byte	93
3181    23F3  0A        		.byte	10
3182    23F4  00        		.byte	0
3183                    	L5251:
3184    23F5  43        		.byte	67
3185    23F6  4D        		.byte	77
3186    23F7  44        		.byte	68
3187    23F8  32        		.byte	50
3188    23F9  34        		.byte	52
3189    23FA  20        		.byte	32
3190    23FB  52        		.byte	82
3191    23FC  31        		.byte	49
3192    23FD  20        		.byte	32
3193    23FE  72        		.byte	114
3194    23FF  65        		.byte	101
3195    2400  73        		.byte	115
3196    2401  70        		.byte	112
3197    2402  6F        		.byte	111
3198    2403  6E        		.byte	110
3199    2404  73        		.byte	115
3200    2405  65        		.byte	101
3201    2406  20        		.byte	32
3202    2407  5B        		.byte	91
3203    2408  25        		.byte	37
3204    2409  30        		.byte	48
3205    240A  32        		.byte	50
3206    240B  78        		.byte	120
3207    240C  5D        		.byte	93
3208    240D  0A        		.byte	10
3209    240E  00        		.byte	0
3210                    	L5351:
3211    240F  20        		.byte	32
3212    2410  20        		.byte	32
3213    2411  63        		.byte	99
3214    2412  6F        		.byte	111
3215    2413  75        		.byte	117
3216    2414  6C        		.byte	108
3217    2415  64        		.byte	100
3218    2416  20        		.byte	32
3219    2417  6E        		.byte	110
3220    2418  6F        		.byte	111
3221    2419  74        		.byte	116
3222    241A  20        		.byte	32
3223    241B  77        		.byte	119
3224    241C  72        		.byte	114
3225    241D  69        		.byte	105
3226    241E  74        		.byte	116
3227    241F  65        		.byte	101
3228    2420  20        		.byte	32
3229    2421  62        		.byte	98
3230    2422  6C        		.byte	108
3231    2423  6F        		.byte	111
3232    2424  63        		.byte	99
3233    2425  6B        		.byte	107
3234    2426  0A        		.byte	10
3235    2427  00        		.byte	0
3236                    	L5451:
3237    2428  4E        		.byte	78
3238    2429  6F        		.byte	111
3239    242A  20        		.byte	32
3240    242B  64        		.byte	100
3241    242C  61        		.byte	97
3242    242D  74        		.byte	116
3243    242E  61        		.byte	97
3244    242F  20        		.byte	32
3245    2430  72        		.byte	114
3246    2431  65        		.byte	101
3247    2432  73        		.byte	115
3248    2433  70        		.byte	112
3249    2434  6F        		.byte	111
3250    2435  6E        		.byte	110
3251    2436  73        		.byte	115
3252    2437  65        		.byte	101
3253    2438  0A        		.byte	10
3254    2439  00        		.byte	0
3255                    	L5551:
3256    243A  44        		.byte	68
3257    243B  61        		.byte	97
3258    243C  74        		.byte	116
3259    243D  61        		.byte	97
3260    243E  20        		.byte	32
3261    243F  72        		.byte	114
3262    2440  65        		.byte	101
3263    2441  73        		.byte	115
3264    2442  70        		.byte	112
3265    2443  6F        		.byte	111
3266    2444  6E        		.byte	110
3267    2445  73        		.byte	115
3268    2446  65        		.byte	101
3269    2447  20        		.byte	32
3270    2448  5B        		.byte	91
3271    2449  25        		.byte	37
3272    244A  30        		.byte	48
3273    244B  32        		.byte	50
3274    244C  78        		.byte	120
3275    244D  5D        		.byte	93
3276    244E  00        		.byte	0
3277                    	L5651:
3278    244F  2C        		.byte	44
3279    2450  20        		.byte	32
3280    2451  64        		.byte	100
3281    2452  61        		.byte	97
3282    2453  74        		.byte	116
3283    2454  61        		.byte	97
3284    2455  20        		.byte	32
3285    2456  61        		.byte	97
3286    2457  63        		.byte	99
3287    2458  63        		.byte	99
3288    2459  65        		.byte	101
3289    245A  70        		.byte	112
3290    245B  74        		.byte	116
3291    245C  65        		.byte	101
3292    245D  64        		.byte	100
3293    245E  0A        		.byte	10
3294    245F  00        		.byte	0
3295                    	L5751:
3296    2460  53        		.byte	83
3297    2461  65        		.byte	101
3298    2462  6E        		.byte	110
3299    2463  74        		.byte	116
3300    2464  20        		.byte	32
3301    2465  39        		.byte	57
3302    2466  2A        		.byte	42
3303    2467  38        		.byte	56
3304    2468  20        		.byte	32
3305    2469  28        		.byte	40
3306    246A  37        		.byte	55
3307    246B  32        		.byte	50
3308    246C  29        		.byte	41
3309    246D  20        		.byte	32
3310    246E  63        		.byte	99
3311    246F  6C        		.byte	108
3312    2470  6F        		.byte	111
3313    2471  63        		.byte	99
3314    2472  6B        		.byte	107
3315    2473  20        		.byte	32
3316    2474  70        		.byte	112
3317    2475  75        		.byte	117
3318    2476  6C        		.byte	108
3319    2477  73        		.byte	115
3320    2478  65        		.byte	101
3321    2479  73        		.byte	115
3322    247A  2C        		.byte	44
3323    247B  20        		.byte	32
3324    247C  73        		.byte	115
3325    247D  65        		.byte	101
3326    247E  6C        		.byte	108
3327    247F  65        		.byte	101
3328    2480  63        		.byte	99
3329    2481  74        		.byte	116
3330    2482  20        		.byte	32
3331    2483  61        		.byte	97
3332    2484  63        		.byte	99
3333    2485  74        		.byte	116
3334    2486  69        		.byte	105
3335    2487  76        		.byte	118
3336    2488  65        		.byte	101
3337    2489  0A        		.byte	10
3338    248A  00        		.byte	0
3339                    	L5061:
3340    248B  2C        		.byte	44
3341    248C  20        		.byte	32
3342    248D  64        		.byte	100
3343    248E  61        		.byte	97
3344    248F  74        		.byte	116
3345    2490  61        		.byte	97
3346    2491  20        		.byte	32
3347    2492  6E        		.byte	110
3348    2493  6F        		.byte	111
3349    2494  74        		.byte	116
3350    2495  20        		.byte	32
3351    2496  61        		.byte	97
3352    2497  63        		.byte	99
3353    2498  63        		.byte	99
3354    2499  65        		.byte	101
3355    249A  70        		.byte	112
3356    249B  74        		.byte	116
3357    249C  65        		.byte	101
3358    249D  64        		.byte	100
3359    249E  0A        		.byte	10
3360    249F  00        		.byte	0
3361                    	;  901      }
3362                    	;  902  
3363                    	;  903  /* Write data block of 512 bytes from buffer
3364                    	;  904   * Returns YES if ok or NO if error
3365                    	;  905   */
3366                    	;  906  int sdwrite(unsigned char *wrbuf, unsigned long wrblkno)
3367                    	;  907      {
3368                    	_sdwrite:
3369    24A0  CD0000    		call	c.savs
3370    24A3  21E2FF    		ld	hl,65506
3371    24A6  39        		add	hl,sp
3372    24A7  F9        		ld	sp,hl
3373                    	;  908      unsigned char *statptr;
3374                    	;  909      unsigned char rbyte;
3375                    	;  910      unsigned char tbyte;
3376                    	;  911      unsigned char cmdbuf[5];   /* buffer to build command in */
3377                    	;  912      unsigned char rstatbuf[5]; /* buffer to recieve status in */
3378                    	;  913      int nbytes;
3379                    	;  914      int tries;
3380                    	;  915      unsigned long blktowrite;
3381                    	;  916      unsigned int calcrc16;
3382                    	;  917  
3383                    	;  918      ledon();
3384    24A8  CD0000    		call	_ledon
3385                    	;  919      spiselect();
3386    24AB  CD0000    		call	_spiselect
3387                    	;  920  
3388                    	;  921      if (!sdinitok)
3389    24AE  2A0C00    		ld	hl,(_sdinitok)
3390    24B1  7C        		ld	a,h
3391    24B2  B5        		or	l
3392    24B3  2019      		jr	nz,L1423
3393                    	;  922          {
3394                    	;  923          if (sdtestflg)
3395    24B5  2A0000    		ld	hl,(_sdtestflg)
3396    24B8  7C        		ld	a,h
3397    24B9  B5        		or	l
3398    24BA  2806      		jr	z,L1523
3399                    	;  924              {
3400                    	;  925              printf("SD card not initialized\n");
3401    24BC  218323    		ld	hl,L5741
3402    24BF  CD0000    		call	_printf
3403                    	L1523:
3404                    	;  926              } /* sdtestflg */
3405                    	;  927          spideselect();
3406    24C2  CD0000    		call	_spideselect
3407                    	;  928          ledoff();
3408    24C5  CD0000    		call	_ledoff
3409                    	;  929          return (NO);
3410    24C8  010000    		ld	bc,0
3411    24CB  C30000    		jp	c.rets
3412                    	L1423:
3413                    	;  930          }
3414                    	;  931  
3415                    	;  932      if (sdtestflg)
3416    24CE  2A0000    		ld	hl,(_sdtestflg)
3417    24D1  7C        		ld	a,h
3418    24D2  B5        		or	l
3419    24D3  2816      		jr	z,L1623
3420                    	;  933          {
3421                    	;  934          printf("  write data block %ld:\n", wrblkno);
3422    24D5  DD6609    		ld	h,(ix+9)
3423    24D8  DD6E08    		ld	l,(ix+8)
3424    24DB  E5        		push	hl
3425    24DC  DD6607    		ld	h,(ix+7)
3426    24DF  DD6E06    		ld	l,(ix+6)
3427    24E2  E5        		push	hl
3428    24E3  219C23    		ld	hl,L5051
3429    24E6  CD0000    		call	_printf
3430    24E9  F1        		pop	af
3431    24EA  F1        		pop	af
3432                    	L1623:
3433                    	;  935          } /* sdtestflg */
3434                    	;  936      /* CMD24: WRITE_SINGLE_BLOCK */
3435                    	;  937      /* Insert block # into command */
3436                    	;  938      memcpy(cmdbuf, cmd24, 5);
3437    24EB  210500    		ld	hl,5
3438    24EE  E5        		push	hl
3439    24EF  213D00    		ld	hl,_cmd24
3440    24F2  E5        		push	hl
3441    24F3  DDE5      		push	ix
3442    24F5  C1        		pop	bc
3443    24F6  21F1FF    		ld	hl,65521
3444    24F9  09        		add	hl,bc
3445    24FA  CD0000    		call	_memcpy
3446    24FD  F1        		pop	af
3447    24FE  F1        		pop	af
3448                    	;  939      blktowrite = blkmult * wrblkno;
3449    24FF  DDE5      		push	ix
3450    2501  C1        		pop	bc
3451    2502  21E4FF    		ld	hl,65508
3452    2505  09        		add	hl,bc
3453    2506  E5        		push	hl
3454    2507  210600    		ld	hl,_blkmult
3455    250A  CD0000    		call	c.0mvf
3456    250D  210000    		ld	hl,c.r0
3457    2510  E5        		push	hl
3458    2511  DDE5      		push	ix
3459    2513  C1        		pop	bc
3460    2514  210600    		ld	hl,6
3461    2517  09        		add	hl,bc
3462    2518  E5        		push	hl
3463    2519  CD0000    		call	c.lmul
3464    251C  CD0000    		call	c.mvl
3465    251F  F1        		pop	af
3466                    	;  940      cmdbuf[4] = blktowrite & 0xff;
3467    2520  DD6EE6    		ld	l,(ix-26)
3468    2523  7D        		ld	a,l
3469    2524  E6FF      		and	255
3470    2526  DD77F5    		ld	(ix-11),a
3471                    	;  941      blktowrite = blktowrite >> 8;
3472    2529  DDE5      		push	ix
3473    252B  C1        		pop	bc
3474    252C  21E4FF    		ld	hl,65508
3475    252F  09        		add	hl,bc
3476    2530  E5        		push	hl
3477    2531  210800    		ld	hl,8
3478    2534  E5        		push	hl
3479    2535  CD0000    		call	c.ulrsh
3480    2538  F1        		pop	af
3481                    	;  942      cmdbuf[3] = blktowrite & 0xff;
3482    2539  DD6EE6    		ld	l,(ix-26)
3483    253C  7D        		ld	a,l
3484    253D  E6FF      		and	255
3485    253F  DD77F4    		ld	(ix-12),a
3486                    	;  943      blktowrite = blktowrite >> 8;
3487    2542  DDE5      		push	ix
3488    2544  C1        		pop	bc
3489    2545  21E4FF    		ld	hl,65508
3490    2548  09        		add	hl,bc
3491    2549  E5        		push	hl
3492    254A  210800    		ld	hl,8
3493    254D  E5        		push	hl
3494    254E  CD0000    		call	c.ulrsh
3495    2551  F1        		pop	af
3496                    	;  944      cmdbuf[2] = blktowrite & 0xff;
3497    2552  DD6EE6    		ld	l,(ix-26)
3498    2555  7D        		ld	a,l
3499    2556  E6FF      		and	255
3500    2558  DD77F3    		ld	(ix-13),a
3501                    	;  945      blktowrite = blktowrite >> 8;
3502    255B  DDE5      		push	ix
3503    255D  C1        		pop	bc
3504    255E  21E4FF    		ld	hl,65508
3505    2561  09        		add	hl,bc
3506    2562  E5        		push	hl
3507    2563  210800    		ld	hl,8
3508    2566  E5        		push	hl
3509    2567  CD0000    		call	c.ulrsh
3510    256A  F1        		pop	af
3511                    	;  946      cmdbuf[1] = blktowrite & 0xff;
3512    256B  DD6EE6    		ld	l,(ix-26)
3513    256E  7D        		ld	a,l
3514    256F  E6FF      		and	255
3515    2571  DD77F2    		ld	(ix-14),a
3516                    	;  947  
3517                    	;  948      if (sdtestflg)
3518    2574  2A0000    		ld	hl,(_sdtestflg)
3519    2577  7C        		ld	a,h
3520    2578  B5        		or	l
3521    2579  2829      		jr	z,L1723
3522                    	;  949          {
3523                    	;  950          printf("\nCMD24: WRITE_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
3524                    	;  951                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
3525    257B  DD4EF5    		ld	c,(ix-11)
3526    257E  97        		sub	a
3527    257F  47        		ld	b,a
3528    2580  C5        		push	bc
3529    2581  DD4EF4    		ld	c,(ix-12)
3530    2584  97        		sub	a
3531    2585  47        		ld	b,a
3532    2586  C5        		push	bc
3533    2587  DD4EF3    		ld	c,(ix-13)
3534    258A  97        		sub	a
3535    258B  47        		ld	b,a
3536    258C  C5        		push	bc
3537    258D  DD4EF2    		ld	c,(ix-14)
3538    2590  97        		sub	a
3539    2591  47        		ld	b,a
3540    2592  C5        		push	bc
3541    2593  DD4EF1    		ld	c,(ix-15)
3542    2596  97        		sub	a
3543    2597  47        		ld	b,a
3544    2598  C5        		push	bc
3545    2599  21B523    		ld	hl,L5151
3546    259C  CD0000    		call	_printf
3547    259F  210A00    		ld	hl,10
3548    25A2  39        		add	hl,sp
3549    25A3  F9        		ld	sp,hl
3550                    	L1723:
3551                    	;  952          } /* sdtestflg */
3552                    	;  953      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3553    25A4  210100    		ld	hl,1
3554    25A7  E5        		push	hl
3555    25A8  DDE5      		push	ix
3556    25AA  C1        		pop	bc
3557    25AB  21ECFF    		ld	hl,65516
3558    25AE  09        		add	hl,bc
3559    25AF  E5        		push	hl
3560    25B0  DDE5      		push	ix
3561    25B2  C1        		pop	bc
3562    25B3  21F1FF    		ld	hl,65521
3563    25B6  09        		add	hl,bc
3564    25B7  CD7701    		call	_sdcommand
3565    25BA  F1        		pop	af
3566    25BB  F1        		pop	af
3567    25BC  DD71F8    		ld	(ix-8),c
3568    25BF  DD70F9    		ld	(ix-7),b
3569                    	;  954      if (sdtestflg)
3570    25C2  2A0000    		ld	hl,(_sdtestflg)
3571    25C5  7C        		ld	a,h
3572    25C6  B5        		or	l
3573    25C7  2811      		jr	z,L1033
3574                    	;  955          {
3575                    	;  956          printf("CMD24 R1 response [%02x]\n", statptr[0]);
3576    25C9  DD6EF8    		ld	l,(ix-8)
3577    25CC  DD66F9    		ld	h,(ix-7)
3578    25CF  4E        		ld	c,(hl)
3579    25D0  97        		sub	a
3580    25D1  47        		ld	b,a
3581    25D2  C5        		push	bc
3582    25D3  21F523    		ld	hl,L5251
3583    25D6  CD0000    		call	_printf
3584    25D9  F1        		pop	af
3585                    	L1033:
3586                    	;  957          } /* sdtestflg */
3587                    	;  958      if (statptr[0])
3588    25DA  DD6EF8    		ld	l,(ix-8)
3589    25DD  DD66F9    		ld	h,(ix-7)
3590    25E0  7E        		ld	a,(hl)
3591    25E1  B7        		or	a
3592    25E2  2819      		jr	z,L1133
3593                    	;  959          {
3594                    	;  960          if (sdtestflg)
3595    25E4  2A0000    		ld	hl,(_sdtestflg)
3596    25E7  7C        		ld	a,h
3597    25E8  B5        		or	l
3598    25E9  2806      		jr	z,L1233
3599                    	;  961              {
3600                    	;  962              printf("  could not write block\n");
3601    25EB  210F24    		ld	hl,L5351
3602    25EE  CD0000    		call	_printf
3603                    	L1233:
3604                    	;  963              } /* sdtestflg */
3605                    	;  964          spideselect();
3606    25F1  CD0000    		call	_spideselect
3607                    	;  965          ledoff();
3608    25F4  CD0000    		call	_ledoff
3609                    	;  966          return (NO);
3610    25F7  010000    		ld	bc,0
3611    25FA  C30000    		jp	c.rets
3612                    	L1133:
3613                    	;  967          }
3614                    	;  968      /* send 0xfe, the byte before data */
3615                    	;  969      spiio(0xfe);
3616    25FD  21FE00    		ld	hl,254
3617    2600  CD0000    		call	_spiio
3618                    	;  970      /* initialize crc and send block */
3619                    	;  971      calcrc16 = 0;
3620    2603  DD36E200  		ld	(ix-30),0
3621    2607  DD36E300  		ld	(ix-29),0
3622                    	;  972      for (nbytes = 0; nbytes < 512; nbytes++)
3623    260B  DD36EA00  		ld	(ix-22),0
3624    260F  DD36EB00  		ld	(ix-21),0
3625                    	L1333:
3626    2613  DD7EEA    		ld	a,(ix-22)
3627    2616  D600      		sub	0
3628    2618  DD7EEB    		ld	a,(ix-21)
3629    261B  DE02      		sbc	a,2
3630    261D  F25926    		jp	p,L1433
3631                    	;  973          {
3632                    	;  974          tbyte = wrbuf[nbytes];
3633    2620  DD6E04    		ld	l,(ix+4)
3634    2623  DD6605    		ld	h,(ix+5)
3635    2626  DD4EEA    		ld	c,(ix-22)
3636    2629  DD46EB    		ld	b,(ix-21)
3637    262C  09        		add	hl,bc
3638    262D  7E        		ld	a,(hl)
3639    262E  DD77F6    		ld	(ix-10),a
3640                    	;  975          spiio(tbyte);
3641    2631  DD6EF6    		ld	l,(ix-10)
3642    2634  97        		sub	a
3643    2635  67        		ld	h,a
3644    2636  CD0000    		call	_spiio
3645                    	;  976          calcrc16 = CRC16_one(calcrc16, tbyte);
3646    2639  DD6EF6    		ld	l,(ix-10)
3647    263C  97        		sub	a
3648    263D  67        		ld	h,a
3649    263E  E5        		push	hl
3650    263F  DD6EE2    		ld	l,(ix-30)
3651    2642  DD66E3    		ld	h,(ix-29)
3652    2645  CDC900    		call	_CRC16_one
3653    2648  F1        		pop	af
3654    2649  DD71E2    		ld	(ix-30),c
3655    264C  DD70E3    		ld	(ix-29),b
3656                    	;  977          }
3657    264F  DD34EA    		inc	(ix-22)
3658    2652  2003      		jr	nz,L211
3659    2654  DD34EB    		inc	(ix-21)
3660                    	L211:
3661    2657  18BA      		jr	L1333
3662                    	L1433:
3663                    	;  978      spiio((calcrc16 >> 8) & 0xff);
3664    2659  DD6EE2    		ld	l,(ix-30)
3665    265C  DD66E3    		ld	h,(ix-29)
3666    265F  E5        		push	hl
3667    2660  210800    		ld	hl,8
3668    2663  E5        		push	hl
3669    2664  CD0000    		call	c.ursh
3670    2667  E1        		pop	hl
3671    2668  7D        		ld	a,l
3672    2669  E6FF      		and	255
3673    266B  6F        		ld	l,a
3674    266C  97        		sub	a
3675    266D  67        		ld	h,a
3676    266E  CD0000    		call	_spiio
3677                    	;  979      spiio(calcrc16 & 0xff);
3678    2671  DD6EE2    		ld	l,(ix-30)
3679    2674  DD66E3    		ld	h,(ix-29)
3680    2677  7D        		ld	a,l
3681    2678  E6FF      		and	255
3682    267A  6F        		ld	l,a
3683    267B  97        		sub	a
3684    267C  67        		ld	h,a
3685    267D  CD0000    		call	_spiio
3686                    	;  980  
3687                    	;  981      /* check data resposnse */
3688                    	;  982      for (tries = 20;
3689    2680  DD36E814  		ld	(ix-24),20
3690    2684  DD36E900  		ld	(ix-23),0
3691                    	L1733:
3692                    	;  983              0 < tries && (((rbyte = spiio(0xff)) & 0x11) != 0x01);
3693    2688  97        		sub	a
3694    2689  DD96E8    		sub	(ix-24)
3695    268C  3E00      		ld	a,0
3696    268E  DD9EE9    		sbc	a,(ix-23)
3697    2691  F2C126    		jp	p,L1043
3698    2694  21FF00    		ld	hl,255
3699    2697  CD0000    		call	_spiio
3700    269A  DD71F7    		ld	(ix-9),c
3701    269D  DD6EF7    		ld	l,(ix-9)
3702    26A0  97        		sub	a
3703    26A1  67        		ld	h,a
3704    26A2  7D        		ld	a,l
3705    26A3  E611      		and	17
3706    26A5  6F        		ld	l,a
3707    26A6  97        		sub	a
3708    26A7  67        		ld	h,a
3709    26A8  7D        		ld	a,l
3710    26A9  FE01      		cp	1
3711    26AB  2003      		jr	nz,L411
3712    26AD  7C        		ld	a,h
3713    26AE  FE00      		cp	0
3714                    	L411:
3715    26B0  280F      		jr	z,L1043
3716                    	;  984              tries--)
3717                    	L1143:
3718    26B2  DD6EE8    		ld	l,(ix-24)
3719    26B5  DD66E9    		ld	h,(ix-23)
3720    26B8  2B        		dec	hl
3721    26B9  DD75E8    		ld	(ix-24),l
3722    26BC  DD74E9    		ld	(ix-23),h
3723    26BF  18C7      		jr	L1733
3724                    	L1043:
3725                    	;  985          ;
3726                    	;  986      if (tries == 0)
3727    26C1  DD7EE8    		ld	a,(ix-24)
3728    26C4  DDB6E9    		or	(ix-23)
3729    26C7  2019      		jr	nz,L1343
3730                    	;  987          {
3731                    	;  988          if (sdtestflg)
3732    26C9  2A0000    		ld	hl,(_sdtestflg)
3733    26CC  7C        		ld	a,h
3734    26CD  B5        		or	l
3735    26CE  2806      		jr	z,L1443
3736                    	;  989              {
3737                    	;  990              printf("No data response\n");
3738    26D0  212824    		ld	hl,L5451
3739    26D3  CD0000    		call	_printf
3740                    	L1443:
3741                    	;  991              } /* sdtestflg */
3742                    	;  992          spideselect();
3743    26D6  CD0000    		call	_spideselect
3744                    	;  993          ledoff();
3745    26D9  CD0000    		call	_ledoff
3746                    	;  994          return (NO);
3747    26DC  010000    		ld	bc,0
3748    26DF  C30000    		jp	c.rets
3749                    	L1343:
3750                    	;  995          }
3751                    	;  996      else
3752                    	;  997          {
3753                    	;  998          if (sdtestflg)
3754    26E2  2A0000    		ld	hl,(_sdtestflg)
3755    26E5  7C        		ld	a,h
3756    26E6  B5        		or	l
3757    26E7  2813      		jr	z,L1643
3758                    	;  999              {
3759                    	; 1000              printf("Data response [%02x]", 0x1f & rbyte);
3760    26E9  DD6EF7    		ld	l,(ix-9)
3761    26EC  97        		sub	a
3762    26ED  67        		ld	h,a
3763    26EE  7D        		ld	a,l
3764    26EF  E61F      		and	31
3765    26F1  6F        		ld	l,a
3766    26F2  97        		sub	a
3767    26F3  67        		ld	h,a
3768    26F4  E5        		push	hl
3769    26F5  213A24    		ld	hl,L5551
3770    26F8  CD0000    		call	_printf
3771    26FB  F1        		pop	af
3772                    	L1643:
3773                    	; 1001              } /* sdtestflg */
3774                    	; 1002          if ((0x1f & rbyte) == 0x05)
3775    26FC  DD6EF7    		ld	l,(ix-9)
3776    26FF  97        		sub	a
3777    2700  67        		ld	h,a
3778    2701  7D        		ld	a,l
3779    2702  E61F      		and	31
3780    2704  6F        		ld	l,a
3781    2705  97        		sub	a
3782    2706  67        		ld	h,a
3783    2707  7D        		ld	a,l
3784    2708  FE05      		cp	5
3785    270A  2003      		jr	nz,L611
3786    270C  7C        		ld	a,h
3787    270D  FE00      		cp	0
3788                    	L611:
3789    270F  C26127    		jp	nz,L1743
3790                    	; 1003              {
3791                    	; 1004              if (sdtestflg)
3792    2712  2A0000    		ld	hl,(_sdtestflg)
3793    2715  7C        		ld	a,h
3794    2716  B5        		or	l
3795    2717  2806      		jr	z,L1053
3796                    	; 1005                  {
3797                    	; 1006                  printf(", data accepted\n");
3798    2719  214F24    		ld	hl,L5651
3799    271C  CD0000    		call	_printf
3800                    	L1053:
3801                    	; 1007                  } /* sdtestflg */
3802                    	; 1008              for (nbytes = 9; 0 < nbytes; nbytes--)
3803    271F  DD36EA09  		ld	(ix-22),9
3804    2723  DD36EB00  		ld	(ix-21),0
3805                    	L1153:
3806    2727  97        		sub	a
3807    2728  DD96EA    		sub	(ix-22)
3808    272B  3E00      		ld	a,0
3809    272D  DD9EEB    		sbc	a,(ix-21)
3810    2730  F24827    		jp	p,L1253
3811                    	; 1009                  spiio(0xff);
3812    2733  21FF00    		ld	hl,255
3813    2736  CD0000    		call	_spiio
3814    2739  DD6EEA    		ld	l,(ix-22)
3815    273C  DD66EB    		ld	h,(ix-21)
3816    273F  2B        		dec	hl
3817    2740  DD75EA    		ld	(ix-22),l
3818    2743  DD74EB    		ld	(ix-21),h
3819    2746  18DF      		jr	L1153
3820                    	L1253:
3821                    	; 1010              if (sdtestflg)
3822    2748  2A0000    		ld	hl,(_sdtestflg)
3823    274B  7C        		ld	a,h
3824    274C  B5        		or	l
3825    274D  2806      		jr	z,L1553
3826                    	; 1011                  {
3827                    	; 1012                  printf("Sent 9*8 (72) clock pulses, select active\n");
3828    274F  216024    		ld	hl,L5751
3829    2752  CD0000    		call	_printf
3830                    	L1553:
3831                    	; 1013                  } /* sdtestflg */
3832                    	; 1014              spideselect();
3833    2755  CD0000    		call	_spideselect
3834                    	; 1015              ledoff();
3835    2758  CD0000    		call	_ledoff
3836                    	; 1016              return (YES);
3837    275B  010100    		ld	bc,1
3838    275E  C30000    		jp	c.rets
3839                    	L1743:
3840                    	; 1017              }
3841                    	; 1018          else
3842                    	; 1019              {
3843                    	; 1020              if (sdtestflg)
3844    2761  2A0000    		ld	hl,(_sdtestflg)
3845    2764  7C        		ld	a,h
3846    2765  B5        		or	l
3847    2766  2806      		jr	z,L1753
3848                    	; 1021                  {
3849                    	; 1022                  printf(", data not accepted\n");
3850    2768  218B24    		ld	hl,L5061
3851    276B  CD0000    		call	_printf
3852                    	L1753:
3853                    	; 1023                  } /* sdtestflg */
3854                    	; 1024              spideselect();
3855    276E  CD0000    		call	_spideselect
3856                    	; 1025              ledoff();
3857    2771  CD0000    		call	_ledoff
3858                    	; 1026              return (NO);
3859    2774  010000    		ld	bc,0
3860    2777  C30000    		jp	c.rets
3861                    	L5161:
3862    277A  2A        		.byte	42
3863    277B  0A        		.byte	10
3864    277C  00        		.byte	0
3865                    	L5261:
3866    277D  25        		.byte	37
3867    277E  30        		.byte	48
3868    277F  34        		.byte	52
3869    2780  78        		.byte	120
3870    2781  20        		.byte	32
3871    2782  00        		.byte	0
3872                    	L5361:
3873    2783  25        		.byte	37
3874    2784  30        		.byte	48
3875    2785  32        		.byte	50
3876    2786  78        		.byte	120
3877    2787  20        		.byte	32
3878    2788  00        		.byte	0
3879                    	L5461:
3880    2789  20        		.byte	32
3881    278A  7C        		.byte	124
3882    278B  00        		.byte	0
3883                    	L5561:
3884    278C  7C        		.byte	124
3885    278D  0A        		.byte	10
3886    278E  00        		.byte	0
3887                    	; 1027              }
3888                    	; 1028          }
3889                    	; 1029      }
3890                    	; 1030  
3891                    	; 1031  /* Print data in 512 byte buffer */
3892                    	; 1032  void sddatprt(unsigned char *prtbuf)
3893                    	; 1033      {
3894                    	_sddatprt:
3895    278F  CD0000    		call	c.savs
3896    2792  21EEFF    		ld	hl,65518
3897    2795  39        		add	hl,sp
3898    2796  F9        		ld	sp,hl
3899                    	; 1034      /* Variables used for "pretty-print" */
3900                    	; 1035      int allzero, dmpline, dotprted, lastallz, nbytes;
3901                    	; 1036      unsigned char *prtptr;
3902                    	; 1037  
3903                    	; 1038      prtptr = prtbuf;
3904    2797  DD7E04    		ld	a,(ix+4)
3905    279A  DD77EE    		ld	(ix-18),a
3906    279D  DD7E05    		ld	a,(ix+5)
3907    27A0  DD77EF    		ld	(ix-17),a
3908                    	; 1039      dotprted = NO;
3909    27A3  DD36F400  		ld	(ix-12),0
3910    27A7  DD36F500  		ld	(ix-11),0
3911                    	; 1040      lastallz = NO;
3912    27AB  DD36F200  		ld	(ix-14),0
3913    27AF  DD36F300  		ld	(ix-13),0
3914                    	; 1041      for (dmpline = 0; dmpline < 32; dmpline++)
3915    27B3  DD36F600  		ld	(ix-10),0
3916    27B7  DD36F700  		ld	(ix-9),0
3917                    	L1063:
3918    27BB  DD7EF6    		ld	a,(ix-10)
3919    27BE  D620      		sub	32
3920    27C0  DD7EF7    		ld	a,(ix-9)
3921    27C3  DE00      		sbc	a,0
3922    27C5  F21C29    		jp	p,L1163
3923                    	; 1042          {
3924                    	; 1043          /* test if all 16 bytes are 0x00 */
3925                    	; 1044          allzero = YES;
3926    27C8  DD36F801  		ld	(ix-8),1
3927    27CC  DD36F900  		ld	(ix-7),0
3928                    	; 1045          for (nbytes = 0; nbytes < 16; nbytes++)
3929    27D0  DD36F000  		ld	(ix-16),0
3930    27D4  DD36F100  		ld	(ix-15),0
3931                    	L1463:
3932    27D8  DD7EF0    		ld	a,(ix-16)
3933    27DB  D610      		sub	16
3934    27DD  DD7EF1    		ld	a,(ix-15)
3935    27E0  DE00      		sbc	a,0
3936    27E2  F20828    		jp	p,L1563
3937                    	; 1046              {
3938                    	; 1047              if (prtptr[nbytes] != 0)
3939    27E5  DD6EEE    		ld	l,(ix-18)
3940    27E8  DD66EF    		ld	h,(ix-17)
3941    27EB  DD4EF0    		ld	c,(ix-16)
3942    27EE  DD46F1    		ld	b,(ix-15)
3943    27F1  09        		add	hl,bc
3944    27F2  7E        		ld	a,(hl)
3945    27F3  B7        		or	a
3946    27F4  2808      		jr	z,L1663
3947                    	; 1048                  allzero = NO;
3948    27F6  DD36F800  		ld	(ix-8),0
3949    27FA  DD36F900  		ld	(ix-7),0
3950                    	L1663:
3951    27FE  DD34F0    		inc	(ix-16)
3952    2801  2003      		jr	nz,L421
3953    2803  DD34F1    		inc	(ix-15)
3954                    	L421:
3955    2806  18D0      		jr	L1463
3956                    	L1563:
3957                    	; 1049              }
3958                    	; 1050          if (lastallz && allzero)
3959    2808  DD7EF2    		ld	a,(ix-14)
3960    280B  DDB6F3    		or	(ix-13)
3961    280E  2822      		jr	z,L1173
3962    2810  DD7EF8    		ld	a,(ix-8)
3963    2813  DDB6F9    		or	(ix-7)
3964    2816  281A      		jr	z,L1173
3965                    	; 1051              {
3966                    	; 1052              if (!dotprted)
3967    2818  DD7EF4    		ld	a,(ix-12)
3968    281B  DDB6F5    		or	(ix-11)
3969    281E  C2F128    		jp	nz,L1373
3970                    	; 1053                  {
3971                    	; 1054                  printf("*\n");
3972    2821  217A27    		ld	hl,L5161
3973    2824  CD0000    		call	_printf
3974                    	; 1055                  dotprted = YES;
3975    2827  DD36F401  		ld	(ix-12),1
3976    282B  DD36F500  		ld	(ix-11),0
3977    282F  C3F128    		jp	L1373
3978                    	L1173:
3979                    	; 1056                  }
3980                    	; 1057              }
3981                    	; 1058          else
3982                    	; 1059              {
3983                    	; 1060              dotprted = NO;
3984    2832  DD36F400  		ld	(ix-12),0
3985    2836  DD36F500  		ld	(ix-11),0
3986                    	; 1061              /* print offset */
3987                    	; 1062              printf("%04x ", dmpline * 16);
3988    283A  DD6EF6    		ld	l,(ix-10)
3989    283D  DD66F7    		ld	h,(ix-9)
3990    2840  E5        		push	hl
3991    2841  211000    		ld	hl,16
3992    2844  E5        		push	hl
3993    2845  CD0000    		call	c.imul
3994    2848  217D27    		ld	hl,L5261
3995    284B  CD0000    		call	_printf
3996    284E  F1        		pop	af
3997                    	; 1063              /* print 16 bytes in hex */
3998                    	; 1064              for (nbytes = 0; nbytes < 16; nbytes++)
3999    284F  DD36F000  		ld	(ix-16),0
4000    2853  DD36F100  		ld	(ix-15),0
4001                    	L1473:
4002    2857  DD7EF0    		ld	a,(ix-16)
4003    285A  D610      		sub	16
4004    285C  DD7EF1    		ld	a,(ix-15)
4005    285F  DE00      		sbc	a,0
4006    2861  F28628    		jp	p,L1573
4007                    	; 1065                  printf("%02x ", prtptr[nbytes]);
4008    2864  DD6EEE    		ld	l,(ix-18)
4009    2867  DD66EF    		ld	h,(ix-17)
4010    286A  DD4EF0    		ld	c,(ix-16)
4011    286D  DD46F1    		ld	b,(ix-15)
4012    2870  09        		add	hl,bc
4013    2871  4E        		ld	c,(hl)
4014    2872  97        		sub	a
4015    2873  47        		ld	b,a
4016    2874  C5        		push	bc
4017    2875  218327    		ld	hl,L5361
4018    2878  CD0000    		call	_printf
4019    287B  F1        		pop	af
4020    287C  DD34F0    		inc	(ix-16)
4021    287F  2003      		jr	nz,L621
4022    2881  DD34F1    		inc	(ix-15)
4023                    	L621:
4024    2884  18D1      		jr	L1473
4025                    	L1573:
4026                    	; 1066              /* print these bytes in ASCII if printable */
4027                    	; 1067              printf(" |");
4028    2886  218927    		ld	hl,L5461
4029    2889  CD0000    		call	_printf
4030                    	; 1068              for (nbytes = 0; nbytes < 16; nbytes++)
4031    288C  DD36F000  		ld	(ix-16),0
4032    2890  DD36F100  		ld	(ix-15),0
4033                    	L1004:
4034    2894  DD7EF0    		ld	a,(ix-16)
4035    2897  D610      		sub	16
4036    2899  DD7EF1    		ld	a,(ix-15)
4037    289C  DE00      		sbc	a,0
4038    289E  F2EB28    		jp	p,L1104
4039                    	; 1069                  {
4040                    	; 1070                  if ((' ' <= prtptr[nbytes]) && (prtptr[nbytes] < 127))
4041    28A1  DD6EEE    		ld	l,(ix-18)
4042    28A4  DD66EF    		ld	h,(ix-17)
4043    28A7  DD4EF0    		ld	c,(ix-16)
4044    28AA  DD46F1    		ld	b,(ix-15)
4045    28AD  09        		add	hl,bc
4046    28AE  7E        		ld	a,(hl)
4047    28AF  FE20      		cp	32
4048    28B1  3827      		jr	c,L1404
4049    28B3  DD6EEE    		ld	l,(ix-18)
4050    28B6  DD66EF    		ld	h,(ix-17)
4051    28B9  DD4EF0    		ld	c,(ix-16)
4052    28BC  DD46F1    		ld	b,(ix-15)
4053    28BF  09        		add	hl,bc
4054    28C0  7E        		ld	a,(hl)
4055    28C1  FE7F      		cp	127
4056    28C3  3015      		jr	nc,L1404
4057                    	; 1071                      putchar(prtptr[nbytes]);
4058    28C5  DD6EEE    		ld	l,(ix-18)
4059    28C8  DD66EF    		ld	h,(ix-17)
4060    28CB  DD4EF0    		ld	c,(ix-16)
4061    28CE  DD46F1    		ld	b,(ix-15)
4062    28D1  09        		add	hl,bc
4063    28D2  6E        		ld	l,(hl)
4064    28D3  97        		sub	a
4065    28D4  67        		ld	h,a
4066    28D5  CD0000    		call	_putchar
4067                    	; 1072                  else
4068    28D8  1806      		jr	L1204
4069                    	L1404:
4070                    	; 1073                      putchar('.');
4071    28DA  212E00    		ld	hl,46
4072    28DD  CD0000    		call	_putchar
4073                    	L1204:
4074    28E0  DD34F0    		inc	(ix-16)
4075    28E3  2003      		jr	nz,L031
4076    28E5  DD34F1    		inc	(ix-15)
4077                    	L031:
4078    28E8  C39428    		jp	L1004
4079                    	L1104:
4080                    	; 1074                  }
4081                    	; 1075              printf("|\n");
4082    28EB  218C27    		ld	hl,L5561
4083    28EE  CD0000    		call	_printf
4084                    	L1373:
4085                    	; 1076              }
4086                    	; 1077          prtptr += 16;
4087    28F1  DD6EEE    		ld	l,(ix-18)
4088    28F4  DD66EF    		ld	h,(ix-17)
4089    28F7  7D        		ld	a,l
4090    28F8  C610      		add	a,16
4091    28FA  6F        		ld	l,a
4092    28FB  7C        		ld	a,h
4093    28FC  CE00      		adc	a,0
4094    28FE  67        		ld	h,a
4095    28FF  DD75EE    		ld	(ix-18),l
   0    2902  DD74EF    		ld	(ix-17),h
   1                    	; 1078          lastallz = allzero;
   2    2905  DD7EF8    		ld	a,(ix-8)
   3    2908  DD77F2    		ld	(ix-14),a
   4    290B  DD7EF9    		ld	a,(ix-7)
   5    290E  DD77F3    		ld	(ix-13),a
   6                    	; 1079          }
   7    2911  DD34F6    		inc	(ix-10)
   8    2914  2003      		jr	nz,L221
   9    2916  DD34F7    		inc	(ix-9)
  10                    	L221:
  11    2919  C3BB27    		jp	L1063
  12                    	L1163:
  13                    	; 1080      }
  14    291C  C30000    		jp	c.rets
  15                    	L5661:
  16    291F  25        		.byte	37
  17    2920  30        		.byte	48
  18    2921  32        		.byte	50
  19    2922  78        		.byte	120
  20    2923  25        		.byte	37
  21    2924  30        		.byte	48
  22    2925  32        		.byte	50
  23    2926  78        		.byte	120
  24    2927  25        		.byte	37
  25    2928  30        		.byte	48
  26    2929  32        		.byte	50
  27    292A  78        		.byte	120
  28    292B  25        		.byte	37
  29    292C  30        		.byte	48
  30    292D  32        		.byte	50
  31    292E  78        		.byte	120
  32    292F  2D        		.byte	45
  33    2930  00        		.byte	0
  34                    	L5761:
  35    2931  25        		.byte	37
  36    2932  30        		.byte	48
  37    2933  32        		.byte	50
  38    2934  78        		.byte	120
  39    2935  25        		.byte	37
  40    2936  30        		.byte	48
  41    2937  32        		.byte	50
  42    2938  78        		.byte	120
  43    2939  2D        		.byte	45
  44    293A  00        		.byte	0
  45                    	L5071:
  46    293B  25        		.byte	37
  47    293C  30        		.byte	48
  48    293D  32        		.byte	50
  49    293E  78        		.byte	120
  50    293F  25        		.byte	37
  51    2940  30        		.byte	48
  52    2941  32        		.byte	50
  53    2942  78        		.byte	120
  54    2943  2D        		.byte	45
  55    2944  00        		.byte	0
  56                    	L5171:
  57    2945  25        		.byte	37
  58    2946  30        		.byte	48
  59    2947  32        		.byte	50
  60    2948  78        		.byte	120
  61    2949  25        		.byte	37
  62    294A  30        		.byte	48
  63    294B  32        		.byte	50
  64    294C  78        		.byte	120
  65    294D  2D        		.byte	45
  66    294E  00        		.byte	0
  67                    	L5271:
  68    294F  25        		.byte	37
  69    2950  30        		.byte	48
  70    2951  32        		.byte	50
  71    2952  78        		.byte	120
  72    2953  25        		.byte	37
  73    2954  30        		.byte	48
  74    2955  32        		.byte	50
  75    2956  78        		.byte	120
  76    2957  25        		.byte	37
  77    2958  30        		.byte	48
  78    2959  32        		.byte	50
  79    295A  78        		.byte	120
  80    295B  25        		.byte	37
  81    295C  30        		.byte	48
  82    295D  32        		.byte	50
  83    295E  78        		.byte	120
  84    295F  25        		.byte	37
  85    2960  30        		.byte	48
  86    2961  32        		.byte	50
  87    2962  78        		.byte	120
  88    2963  25        		.byte	37
  89    2964  30        		.byte	48
  90    2965  32        		.byte	50
  91    2966  78        		.byte	120
  92    2967  00        		.byte	0
  93                    	; 1081  
  94                    	; 1082  /* Print GUID (mixed endian format)
  95                    	; 1083   */
  96                    	; 1084  void prtguid(unsigned char *guidptr)
  97                    	; 1085      {
  98                    	_prtguid:
  99    2968  CD0000    		call	c.savs
 100    296B  F5        		push	af
 101    296C  F5        		push	af
 102    296D  F5        		push	af
 103    296E  F5        		push	af
 104                    	; 1086      int index;
 105                    	; 1087  
 106                    	; 1088      printf("%02x%02x%02x%02x-", guidptr[3], guidptr[2], guidptr[1], guidptr[0]);
 107    296F  DD6E04    		ld	l,(ix+4)
 108    2972  DD6605    		ld	h,(ix+5)
 109    2975  4E        		ld	c,(hl)
 110    2976  97        		sub	a
 111    2977  47        		ld	b,a
 112    2978  C5        		push	bc
 113    2979  DD6E04    		ld	l,(ix+4)
 114    297C  DD6605    		ld	h,(ix+5)
 115    297F  23        		inc	hl
 116    2980  4E        		ld	c,(hl)
 117    2981  97        		sub	a
 118    2982  47        		ld	b,a
 119    2983  C5        		push	bc
 120    2984  DD6E04    		ld	l,(ix+4)
 121    2987  DD6605    		ld	h,(ix+5)
 122    298A  23        		inc	hl
 123    298B  23        		inc	hl
 124    298C  4E        		ld	c,(hl)
 125    298D  97        		sub	a
 126    298E  47        		ld	b,a
 127    298F  C5        		push	bc
 128    2990  DD6E04    		ld	l,(ix+4)
 129    2993  DD6605    		ld	h,(ix+5)
 130    2996  23        		inc	hl
 131    2997  23        		inc	hl
 132    2998  23        		inc	hl
 133    2999  4E        		ld	c,(hl)
 134    299A  97        		sub	a
 135    299B  47        		ld	b,a
 136    299C  C5        		push	bc
 137    299D  211F29    		ld	hl,L5661
 138    29A0  CD0000    		call	_printf
 139    29A3  F1        		pop	af
 140    29A4  F1        		pop	af
 141    29A5  F1        		pop	af
 142    29A6  F1        		pop	af
 143                    	; 1089      printf("%02x%02x-", guidptr[5], guidptr[4]);
 144    29A7  DD6E04    		ld	l,(ix+4)
 145    29AA  DD6605    		ld	h,(ix+5)
 146    29AD  23        		inc	hl
 147    29AE  23        		inc	hl
 148    29AF  23        		inc	hl
 149    29B0  23        		inc	hl
 150    29B1  4E        		ld	c,(hl)
 151    29B2  97        		sub	a
 152    29B3  47        		ld	b,a
 153    29B4  C5        		push	bc
 154    29B5  DD6E04    		ld	l,(ix+4)
 155    29B8  DD6605    		ld	h,(ix+5)
 156    29BB  010500    		ld	bc,5
 157    29BE  09        		add	hl,bc
 158    29BF  4E        		ld	c,(hl)
 159    29C0  97        		sub	a
 160    29C1  47        		ld	b,a
 161    29C2  C5        		push	bc
 162    29C3  213129    		ld	hl,L5761
 163    29C6  CD0000    		call	_printf
 164    29C9  F1        		pop	af
 165    29CA  F1        		pop	af
 166                    	; 1090      printf("%02x%02x-", guidptr[7], guidptr[6]);
 167    29CB  DD6E04    		ld	l,(ix+4)
 168    29CE  DD6605    		ld	h,(ix+5)
 169    29D1  010600    		ld	bc,6
 170    29D4  09        		add	hl,bc
 171    29D5  4E        		ld	c,(hl)
 172    29D6  97        		sub	a
 173    29D7  47        		ld	b,a
 174    29D8  C5        		push	bc
 175    29D9  DD6E04    		ld	l,(ix+4)
 176    29DC  DD6605    		ld	h,(ix+5)
 177    29DF  010700    		ld	bc,7
 178    29E2  09        		add	hl,bc
 179    29E3  4E        		ld	c,(hl)
 180    29E4  97        		sub	a
 181    29E5  47        		ld	b,a
 182    29E6  C5        		push	bc
 183    29E7  213B29    		ld	hl,L5071
 184    29EA  CD0000    		call	_printf
 185    29ED  F1        		pop	af
 186    29EE  F1        		pop	af
 187                    	; 1091      printf("%02x%02x-", guidptr[8], guidptr[9]);
 188    29EF  DD6E04    		ld	l,(ix+4)
 189    29F2  DD6605    		ld	h,(ix+5)
 190    29F5  010900    		ld	bc,9
 191    29F8  09        		add	hl,bc
 192    29F9  4E        		ld	c,(hl)
 193    29FA  97        		sub	a
 194    29FB  47        		ld	b,a
 195    29FC  C5        		push	bc
 196    29FD  DD6E04    		ld	l,(ix+4)
 197    2A00  DD6605    		ld	h,(ix+5)
 198    2A03  010800    		ld	bc,8
 199    2A06  09        		add	hl,bc
 200    2A07  4E        		ld	c,(hl)
 201    2A08  97        		sub	a
 202    2A09  47        		ld	b,a
 203    2A0A  C5        		push	bc
 204    2A0B  214529    		ld	hl,L5171
 205    2A0E  CD0000    		call	_printf
 206    2A11  F1        		pop	af
 207    2A12  F1        		pop	af
 208                    	; 1092      printf("%02x%02x%02x%02x%02x%02x",
 209                    	; 1093             guidptr[10], guidptr[11], guidptr[12], guidptr[13], guidptr[14], guidptr[15]);
 210    2A13  DD6E04    		ld	l,(ix+4)
 211    2A16  DD6605    		ld	h,(ix+5)
 212    2A19  010F00    		ld	bc,15
 213    2A1C  09        		add	hl,bc
 214    2A1D  4E        		ld	c,(hl)
 215    2A1E  97        		sub	a
 216    2A1F  47        		ld	b,a
 217    2A20  C5        		push	bc
 218    2A21  DD6E04    		ld	l,(ix+4)
 219    2A24  DD6605    		ld	h,(ix+5)
 220    2A27  010E00    		ld	bc,14
 221    2A2A  09        		add	hl,bc
 222    2A2B  4E        		ld	c,(hl)
 223    2A2C  97        		sub	a
 224    2A2D  47        		ld	b,a
 225    2A2E  C5        		push	bc
 226    2A2F  DD6E04    		ld	l,(ix+4)
 227    2A32  DD6605    		ld	h,(ix+5)
 228    2A35  010D00    		ld	bc,13
 229    2A38  09        		add	hl,bc
 230    2A39  4E        		ld	c,(hl)
 231    2A3A  97        		sub	a
 232    2A3B  47        		ld	b,a
 233    2A3C  C5        		push	bc
 234    2A3D  DD6E04    		ld	l,(ix+4)
 235    2A40  DD6605    		ld	h,(ix+5)
 236    2A43  010C00    		ld	bc,12
 237    2A46  09        		add	hl,bc
 238    2A47  4E        		ld	c,(hl)
 239    2A48  97        		sub	a
 240    2A49  47        		ld	b,a
 241    2A4A  C5        		push	bc
 242    2A4B  DD6E04    		ld	l,(ix+4)
 243    2A4E  DD6605    		ld	h,(ix+5)
 244    2A51  010B00    		ld	bc,11
 245    2A54  09        		add	hl,bc
 246    2A55  4E        		ld	c,(hl)
 247    2A56  97        		sub	a
 248    2A57  47        		ld	b,a
 249    2A58  C5        		push	bc
 250    2A59  DD6E04    		ld	l,(ix+4)
 251    2A5C  DD6605    		ld	h,(ix+5)
 252    2A5F  010A00    		ld	bc,10
 253    2A62  09        		add	hl,bc
 254    2A63  4E        		ld	c,(hl)
 255    2A64  97        		sub	a
 256    2A65  47        		ld	b,a
 257    2A66  C5        		push	bc
 258    2A67  214F29    		ld	hl,L5271
 259    2A6A  CD0000    		call	_printf
 260    2A6D  210C00    		ld	hl,12
 261    2A70  39        		add	hl,sp
 262    2A71  F9        		ld	sp,hl
 263                    	; 1094      }
 264    2A72  C30000    		jp	c.rets
 265                    	L5371:
 266    2A75  43        		.byte	67
 267    2A76  61        		.byte	97
 268    2A77  6E        		.byte	110
 269    2A78  27        		.byte	39
 270    2A79  74        		.byte	116
 271    2A7A  20        		.byte	32
 272    2A7B  72        		.byte	114
 273    2A7C  65        		.byte	101
 274    2A7D  61        		.byte	97
 275    2A7E  64        		.byte	100
 276    2A7F  20        		.byte	32
 277    2A80  47        		.byte	71
 278    2A81  50        		.byte	80
 279    2A82  54        		.byte	84
 280    2A83  20        		.byte	32
 281    2A84  65        		.byte	101
 282    2A85  6E        		.byte	110
 283    2A86  74        		.byte	116
 284    2A87  72        		.byte	114
 285    2A88  79        		.byte	121
 286    2A89  20        		.byte	32
 287    2A8A  62        		.byte	98
 288    2A8B  6C        		.byte	108
 289    2A8C  6F        		.byte	111
 290    2A8D  63        		.byte	99
 291    2A8E  6B        		.byte	107
 292    2A8F  0A        		.byte	10
 293    2A90  00        		.byte	0
 294                    	L5471:
 295    2A91  47        		.byte	71
 296    2A92  50        		.byte	80
 297    2A93  54        		.byte	84
 298    2A94  20        		.byte	32
 299    2A95  70        		.byte	112
 300    2A96  61        		.byte	97
 301    2A97  72        		.byte	114
 302    2A98  74        		.byte	116
 303    2A99  69        		.byte	105
 304    2A9A  74        		.byte	116
 305    2A9B  69        		.byte	105
 306    2A9C  6F        		.byte	111
 307    2A9D  6E        		.byte	110
 308    2A9E  20        		.byte	32
 309    2A9F  65        		.byte	101
 310    2AA0  6E        		.byte	110
 311    2AA1  74        		.byte	116
 312    2AA2  72        		.byte	114
 313    2AA3  79        		.byte	121
 314    2AA4  20        		.byte	32
 315    2AA5  25        		.byte	37
 316    2AA6  64        		.byte	100
 317    2AA7  3A        		.byte	58
 318    2AA8  00        		.byte	0
 319                    	L5571:
 320    2AA9  20        		.byte	32
 321    2AAA  4E        		.byte	78
 322    2AAB  6F        		.byte	111
 323    2AAC  74        		.byte	116
 324    2AAD  20        		.byte	32
 325    2AAE  75        		.byte	117
 326    2AAF  73        		.byte	115
 327    2AB0  65        		.byte	101
 328    2AB1  64        		.byte	100
 329    2AB2  20        		.byte	32
 330    2AB3  65        		.byte	101
 331    2AB4  6E        		.byte	110
 332    2AB5  74        		.byte	116
 333    2AB6  72        		.byte	114
 334    2AB7  79        		.byte	121
 335    2AB8  0A        		.byte	10
 336    2AB9  00        		.byte	0
 337                    	L5671:
 338    2ABA  0A        		.byte	10
 339    2ABB  20        		.byte	32
 340    2ABC  20        		.byte	32
 341    2ABD  50        		.byte	80
 342    2ABE  61        		.byte	97
 343    2ABF  72        		.byte	114
 344    2AC0  74        		.byte	116
 345    2AC1  69        		.byte	105
 346    2AC2  74        		.byte	116
 347    2AC3  69        		.byte	105
 348    2AC4  6F        		.byte	111
 349    2AC5  6E        		.byte	110
 350    2AC6  20        		.byte	32
 351    2AC7  74        		.byte	116
 352    2AC8  79        		.byte	121
 353    2AC9  70        		.byte	112
 354    2ACA  65        		.byte	101
 355    2ACB  20        		.byte	32
 356    2ACC  47        		.byte	71
 357    2ACD  55        		.byte	85
 358    2ACE  49        		.byte	73
 359    2ACF  44        		.byte	68
 360    2AD0  3A        		.byte	58
 361    2AD1  20        		.byte	32
 362    2AD2  00        		.byte	0
 363                    	L5771:
 364    2AD3  0A        		.byte	10
 365    2AD4  20        		.byte	32
 366    2AD5  20        		.byte	32
 367    2AD6  5B        		.byte	91
 368    2AD7  00        		.byte	0
 369                    	L5002:
 370    2AD8  25        		.byte	37
 371    2AD9  30        		.byte	48
 372    2ADA  32        		.byte	50
 373    2ADB  78        		.byte	120
 374    2ADC  20        		.byte	32
 375    2ADD  00        		.byte	0
 376                    	L5102:
 377    2ADE  08        		.byte	8
 378    2ADF  5D        		.byte	93
 379    2AE0  00        		.byte	0
 380                    	L5202:
 381    2AE1  0A        		.byte	10
 382    2AE2  20        		.byte	32
 383    2AE3  20        		.byte	32
 384    2AE4  55        		.byte	85
 385    2AE5  6E        		.byte	110
 386    2AE6  69        		.byte	105
 387    2AE7  71        		.byte	113
 388    2AE8  75        		.byte	117
 389    2AE9  65        		.byte	101
 390    2AEA  20        		.byte	32
 391    2AEB  70        		.byte	112
 392    2AEC  61        		.byte	97
 393    2AED  72        		.byte	114
 394    2AEE  74        		.byte	116
 395    2AEF  69        		.byte	105
 396    2AF0  74        		.byte	116
 397    2AF1  69        		.byte	105
 398    2AF2  6F        		.byte	111
 399    2AF3  6E        		.byte	110
 400    2AF4  20        		.byte	32
 401    2AF5  47        		.byte	71
 402    2AF6  55        		.byte	85
 403    2AF7  49        		.byte	73
 404    2AF8  44        		.byte	68
 405    2AF9  3A        		.byte	58
 406    2AFA  20        		.byte	32
 407    2AFB  00        		.byte	0
 408                    	L5302:
 409    2AFC  0A        		.byte	10
 410    2AFD  20        		.byte	32
 411    2AFE  20        		.byte	32
 412    2AFF  5B        		.byte	91
 413    2B00  00        		.byte	0
 414                    	L5402:
 415    2B01  25        		.byte	37
 416    2B02  30        		.byte	48
 417    2B03  32        		.byte	50
 418    2B04  78        		.byte	120
 419    2B05  20        		.byte	32
 420    2B06  00        		.byte	0
 421                    	L5502:
 422    2B07  08        		.byte	8
 423    2B08  5D        		.byte	93
 424    2B09  00        		.byte	0
 425                    	L5602:
 426    2B0A  0A        		.byte	10
 427    2B0B  20        		.byte	32
 428    2B0C  20        		.byte	32
 429    2B0D  46        		.byte	70
 430    2B0E  69        		.byte	105
 431    2B0F  72        		.byte	114
 432    2B10  73        		.byte	115
 433    2B11  74        		.byte	116
 434    2B12  20        		.byte	32
 435    2B13  4C        		.byte	76
 436    2B14  42        		.byte	66
 437    2B15  41        		.byte	65
 438    2B16  3A        		.byte	58
 439    2B17  20        		.byte	32
 440    2B18  00        		.byte	0
 441                    	L5702:
 442    2B19  25        		.byte	37
 443    2B1A  6C        		.byte	108
 444    2B1B  75        		.byte	117
 445    2B1C  00        		.byte	0
 446                    	L5012:
 447    2B1D  20        		.byte	32
 448    2B1E  5B        		.byte	91
 449    2B1F  00        		.byte	0
 450                    	L5112:
 451    2B20  25        		.byte	37
 452    2B21  30        		.byte	48
 453    2B22  32        		.byte	50
 454    2B23  78        		.byte	120
 455    2B24  20        		.byte	32
 456    2B25  00        		.byte	0
 457                    	L5212:
 458    2B26  08        		.byte	8
 459    2B27  5D        		.byte	93
 460    2B28  00        		.byte	0
 461                    	L5312:
 462    2B29  0A        		.byte	10
 463    2B2A  20        		.byte	32
 464    2B2B  20        		.byte	32
 465    2B2C  4C        		.byte	76
 466    2B2D  61        		.byte	97
 467    2B2E  73        		.byte	115
 468    2B2F  74        		.byte	116
 469    2B30  20        		.byte	32
 470    2B31  4C        		.byte	76
 471    2B32  42        		.byte	66
 472    2B33  41        		.byte	65
 473    2B34  3A        		.byte	58
 474    2B35  20        		.byte	32
 475    2B36  00        		.byte	0
 476                    	L5412:
 477    2B37  25        		.byte	37
 478    2B38  6C        		.byte	108
 479    2B39  75        		.byte	117
 480    2B3A  2C        		.byte	44
 481    2B3B  20        		.byte	32
 482    2B3C  73        		.byte	115
 483    2B3D  69        		.byte	105
 484    2B3E  7A        		.byte	122
 485    2B3F  65        		.byte	101
 486    2B40  20        		.byte	32
 487    2B41  25        		.byte	37
 488    2B42  6C        		.byte	108
 489    2B43  75        		.byte	117
 490    2B44  20        		.byte	32
 491    2B45  4D        		.byte	77
 492    2B46  42        		.byte	66
 493    2B47  79        		.byte	121
 494    2B48  74        		.byte	116
 495    2B49  65        		.byte	101
 496    2B4A  00        		.byte	0
 497                    	L5512:
 498    2B4B  20        		.byte	32
 499    2B4C  5B        		.byte	91
 500    2B4D  00        		.byte	0
 501                    	L5612:
 502    2B4E  25        		.byte	37
 503    2B4F  30        		.byte	48
 504    2B50  32        		.byte	50
 505    2B51  78        		.byte	120
 506    2B52  20        		.byte	32
 507    2B53  00        		.byte	0
 508                    	L5712:
 509    2B54  08        		.byte	8
 510    2B55  5D        		.byte	93
 511    2B56  00        		.byte	0
 512                    	L5022:
 513    2B57  0A        		.byte	10
 514    2B58  20        		.byte	32
 515    2B59  20        		.byte	32
 516    2B5A  41        		.byte	65
 517    2B5B  74        		.byte	116
 518    2B5C  74        		.byte	116
 519    2B5D  72        		.byte	114
 520    2B5E  69        		.byte	105
 521    2B5F  62        		.byte	98
 522    2B60  75        		.byte	117
 523    2B61  74        		.byte	116
 524    2B62  65        		.byte	101
 525    2B63  20        		.byte	32
 526    2B64  66        		.byte	102
 527    2B65  6C        		.byte	108
 528    2B66  61        		.byte	97
 529    2B67  67        		.byte	103
 530    2B68  73        		.byte	115
 531    2B69  3A        		.byte	58
 532    2B6A  20        		.byte	32
 533    2B6B  5B        		.byte	91
 534    2B6C  00        		.byte	0
 535                    	L5122:
 536    2B6D  25        		.byte	37
 537    2B6E  30        		.byte	48
 538    2B6F  32        		.byte	50
 539    2B70  78        		.byte	120
 540    2B71  20        		.byte	32
 541    2B72  00        		.byte	0
 542                    	L5222:
 543    2B73  08        		.byte	8
 544    2B74  5D        		.byte	93
 545    2B75  0A        		.byte	10
 546    2B76  20        		.byte	32
 547    2B77  20        		.byte	32
 548    2B78  50        		.byte	80
 549    2B79  61        		.byte	97
 550    2B7A  72        		.byte	114
 551    2B7B  74        		.byte	116
 552    2B7C  69        		.byte	105
 553    2B7D  74        		.byte	116
 554    2B7E  69        		.byte	105
 555    2B7F  6F        		.byte	111
 556    2B80  6E        		.byte	110
 557    2B81  20        		.byte	32
 558    2B82  6E        		.byte	110
 559    2B83  61        		.byte	97
 560    2B84  6D        		.byte	109
 561    2B85  65        		.byte	101
 562    2B86  3A        		.byte	58
 563    2B87  20        		.byte	32
 564    2B88  20        		.byte	32
 565    2B89  00        		.byte	0
 566                    	L5322:
 567    2B8A  6E        		.byte	110
 568    2B8B  61        		.byte	97
 569    2B8C  6D        		.byte	109
 570    2B8D  65        		.byte	101
 571    2B8E  20        		.byte	32
 572    2B8F  66        		.byte	102
 573    2B90  69        		.byte	105
 574    2B91  65        		.byte	101
 575    2B92  6C        		.byte	108
 576    2B93  64        		.byte	100
 577    2B94  20        		.byte	32
 578    2B95  65        		.byte	101
 579    2B96  6D        		.byte	109
 580    2B97  70        		.byte	112
 581    2B98  74        		.byte	116
 582    2B99  79        		.byte	121
 583    2B9A  00        		.byte	0
 584                    	L5422:
 585    2B9B  0A        		.byte	10
 586    2B9C  00        		.byte	0
 587                    	L5522:
 588    2B9D  20        		.byte	32
 589    2B9E  20        		.byte	32
 590    2B9F  20        		.byte	32
 591    2BA0  5B        		.byte	91
 592    2BA1  00        		.byte	0
 593                    	L5622:
 594    2BA2  0A        		.byte	10
 595    2BA3  20        		.byte	32
 596    2BA4  20        		.byte	32
 597    2BA5  20        		.byte	32
 598    2BA6  20        		.byte	32
 599    2BA7  00        		.byte	0
 600                    	L5722:
 601    2BA8  25        		.byte	37
 602    2BA9  30        		.byte	48
 603    2BAA  32        		.byte	50
 604    2BAB  78        		.byte	120
 605    2BAC  20        		.byte	32
 606    2BAD  00        		.byte	0
 607                    	L5032:
 608    2BAE  08        		.byte	8
 609    2BAF  5D        		.byte	93
 610    2BB0  0A        		.byte	10
 611    2BB1  00        		.byte	0
 612                    	; 1095  
 613                    	; 1096  /* Analyze and print GPT entry
 614                    	; 1097   */
 615                    	; 1098  int prtgptent(unsigned int entryno)
 616                    	; 1099      {
 617                    	_prtgptent:
 618    2BB2  CD0000    		call	c.savs
 619    2BB5  21E4FF    		ld	hl,65508
 620    2BB8  39        		add	hl,sp
 621    2BB9  F9        		ld	sp,hl
 622                    	; 1100      int index;
 623                    	; 1101      int entryidx;
 624                    	; 1102      int hasname;
 625                    	; 1103      unsigned int block;
 626                    	; 1104      unsigned char *rxdata;
 627                    	; 1105      unsigned char *entryptr;
 628                    	; 1106      unsigned char tstzero = 0;
 629    2BBA  DD36ED00  		ld	(ix-19),0
 630                    	; 1107      unsigned long flba;
 631                    	; 1108      unsigned long llba;
 632                    	; 1109  
 633                    	; 1110      block = 2 + (entryno / 4);
 634    2BBE  DD6E04    		ld	l,(ix+4)
 635    2BC1  DD6605    		ld	h,(ix+5)
 636    2BC4  E5        		push	hl
 637    2BC5  210400    		ld	hl,4
 638    2BC8  E5        		push	hl
 639    2BC9  CD0000    		call	c.udiv
 640    2BCC  E1        		pop	hl
 641    2BCD  23        		inc	hl
 642    2BCE  23        		inc	hl
 643    2BCF  DD75F2    		ld	(ix-14),l
 644    2BD2  DD74F3    		ld	(ix-13),h
 645                    	; 1111      if ((curblkno != block) || !curblkok)
 646    2BD5  210200    		ld	hl,_curblkno
 647    2BD8  E5        		push	hl
 648    2BD9  DDE5      		push	ix
 649    2BDB  C1        		pop	bc
 650    2BDC  21F2FF    		ld	hl,65522
 651    2BDF  09        		add	hl,bc
 652    2BE0  4D        		ld	c,l
 653    2BE1  44        		ld	b,h
 654    2BE2  97        		sub	a
 655    2BE3  320000    		ld	(c.r0),a
 656    2BE6  320100    		ld	(c.r0+1),a
 657    2BE9  0A        		ld	a,(bc)
 658    2BEA  320200    		ld	(c.r0+2),a
 659    2BED  03        		inc	bc
 660    2BEE  0A        		ld	a,(bc)
 661    2BEF  320300    		ld	(c.r0+3),a
 662    2BF2  210000    		ld	hl,c.r0
 663    2BF5  E5        		push	hl
 664    2BF6  CD0000    		call	c.lcmp
 665    2BF9  2008      		jr	nz,L1704
 666    2BFB  2A1000    		ld	hl,(_curblkok)
 667    2BFE  7C        		ld	a,h
 668    2BFF  B5        		or	l
 669    2C00  C2602C    		jp	nz,L1604
 670                    	L1704:
 671                    	; 1112          {
 672                    	; 1113          if (!sdread(sdrdbuf, block))
 673    2C03  DDE5      		push	ix
 674    2C05  C1        		pop	bc
 675    2C06  21F2FF    		ld	hl,65522
 676    2C09  09        		add	hl,bc
 677    2C0A  4D        		ld	c,l
 678    2C0B  44        		ld	b,h
 679    2C0C  97        		sub	a
 680    2C0D  320000    		ld	(c.r0),a
 681    2C10  320100    		ld	(c.r0+1),a
 682    2C13  0A        		ld	a,(bc)
 683    2C14  320200    		ld	(c.r0+2),a
 684    2C17  03        		inc	bc
 685    2C18  0A        		ld	a,(bc)
 686    2C19  320300    		ld	(c.r0+3),a
 687    2C1C  210300    		ld	hl,c.r0+3
 688    2C1F  46        		ld	b,(hl)
 689    2C20  2B        		dec	hl
 690    2C21  4E        		ld	c,(hl)
 691    2C22  C5        		push	bc
 692    2C23  2B        		dec	hl
 693    2C24  46        		ld	b,(hl)
 694    2C25  2B        		dec	hl
 695    2C26  4E        		ld	c,(hl)
 696    2C27  C5        		push	bc
 697    2C28  214C00    		ld	hl,_sdrdbuf
 698    2C2B  CDE320    		call	_sdread
 699    2C2E  F1        		pop	af
 700    2C2F  F1        		pop	af
 701    2C30  79        		ld	a,c
 702    2C31  B0        		or	b
 703    2C32  2013      		jr	nz,L1014
 704                    	; 1114              {
 705                    	; 1115              if (sdtestflg)
 706    2C34  2A0000    		ld	hl,(_sdtestflg)
 707    2C37  7C        		ld	a,h
 708    2C38  B5        		or	l
 709    2C39  280C      		jr	z,L1014
 710                    	; 1116                  {
 711                    	; 1117                  printf("Can't read GPT entry block\n");
 712    2C3B  21752A    		ld	hl,L5371
 713    2C3E  CD0000    		call	_printf
 714                    	; 1118                  return (NO);
 715    2C41  010000    		ld	bc,0
 716    2C44  C30000    		jp	c.rets
 717                    	L1014:
 718                    	; 1119                  } /* sdtestflg */
 719                    	; 1120              }
 720                    	; 1121          curblkno = block;
 721    2C47  97        		sub	a
 722    2C48  320200    		ld	(_curblkno),a
 723    2C4B  320300    		ld	(_curblkno+1),a
 724    2C4E  DD7EF2    		ld	a,(ix-14)
 725    2C51  320400    		ld	(_curblkno+2),a
 726                    	; 1122          curblkok = YES;
 727    2C54  210100    		ld	hl,1
 728    2C57  DD7EF3    		ld	a,(ix-13)
 729    2C5A  320500    		ld	(_curblkno+3),a
 730    2C5D  221000    		ld	(_curblkok),hl
 731                    	L1604:
 732                    	; 1123          }
 733                    	; 1124      rxdata = sdrdbuf;
 734    2C60  214C00    		ld	hl,_sdrdbuf
 735    2C63  DD75F0    		ld	(ix-16),l
 736    2C66  DD74F1    		ld	(ix-15),h
 737                    	; 1125      entryptr = rxdata + (128 * (entryno % 4));
 738    2C69  DD6E04    		ld	l,(ix+4)
 739    2C6C  DD6605    		ld	h,(ix+5)
 740    2C6F  E5        		push	hl
 741    2C70  210400    		ld	hl,4
 742    2C73  E5        		push	hl
 743    2C74  CD0000    		call	c.umod
 744    2C77  218000    		ld	hl,128
 745    2C7A  E5        		push	hl
 746    2C7B  CD0000    		call	c.imul
 747    2C7E  E1        		pop	hl
 748    2C7F  DD4EF0    		ld	c,(ix-16)
 749    2C82  DD46F1    		ld	b,(ix-15)
 750    2C85  09        		add	hl,bc
 751    2C86  DD75EE    		ld	(ix-18),l
 752    2C89  DD74EF    		ld	(ix-17),h
 753                    	; 1126      for (index = 0; index < 16; index++)
 754    2C8C  DD36F800  		ld	(ix-8),0
 755    2C90  DD36F900  		ld	(ix-7),0
 756                    	L1214:
 757    2C94  DD7EF8    		ld	a,(ix-8)
 758    2C97  D610      		sub	16
 759    2C99  DD7EF9    		ld	a,(ix-7)
 760    2C9C  DE00      		sbc	a,0
 761    2C9E  F2BF2C    		jp	p,L1314
 762                    	; 1127          tstzero |= entryptr[index];
 763    2CA1  DD6EEE    		ld	l,(ix-18)
 764    2CA4  DD66EF    		ld	h,(ix-17)
 765    2CA7  DD4EF8    		ld	c,(ix-8)
 766    2CAA  DD46F9    		ld	b,(ix-7)
 767    2CAD  09        		add	hl,bc
 768    2CAE  DD7EED    		ld	a,(ix-19)
 769    2CB1  B6        		or	(hl)
 770    2CB2  DD77ED    		ld	(ix-19),a
 771    2CB5  DD34F8    		inc	(ix-8)
 772    2CB8  2003      		jr	nz,L631
 773    2CBA  DD34F9    		inc	(ix-7)
 774                    	L631:
 775    2CBD  18D5      		jr	L1214
 776                    	L1314:
 777                    	; 1128      if (sdtestflg)
 778    2CBF  2A0000    		ld	hl,(_sdtestflg)
 779    2CC2  7C        		ld	a,h
 780    2CC3  B5        		or	l
 781    2CC4  280F      		jr	z,L1614
 782                    	; 1129          {
 783                    	; 1130          printf("GPT partition entry %d:", entryno + 1);
 784    2CC6  DD6E04    		ld	l,(ix+4)
 785    2CC9  DD6605    		ld	h,(ix+5)
 786    2CCC  23        		inc	hl
 787    2CCD  E5        		push	hl
 788    2CCE  21912A    		ld	hl,L5471
 789    2CD1  CD0000    		call	_printf
 790    2CD4  F1        		pop	af
 791                    	L1614:
 792                    	; 1131          } /* sdtestflg */
 793                    	; 1132      if (!tstzero)
 794    2CD5  DD7EED    		ld	a,(ix-19)
 795    2CD8  B7        		or	a
 796    2CD9  2013      		jr	nz,L1714
 797                    	; 1133          {
 798                    	; 1134          if (sdtestflg)
 799    2CDB  2A0000    		ld	hl,(_sdtestflg)
 800    2CDE  7C        		ld	a,h
 801    2CDF  B5        		or	l
 802    2CE0  2806      		jr	z,L1024
 803                    	; 1135              {
 804                    	; 1136              printf(" Not used entry\n");
 805    2CE2  21A92A    		ld	hl,L5571
 806    2CE5  CD0000    		call	_printf
 807                    	L1024:
 808                    	; 1137              } /* sdtestflg */
 809                    	; 1138          return (NO);
 810    2CE8  010000    		ld	bc,0
 811    2CEB  C30000    		jp	c.rets
 812                    	L1714:
 813                    	; 1139          }
 814                    	; 1140      if (sdtestflg)
 815    2CEE  2A0000    		ld	hl,(_sdtestflg)
 816    2CF1  7C        		ld	a,h
 817    2CF2  B5        		or	l
 818    2CF3  CAA82D    		jp	z,L1124
 819                    	; 1141          {
 820                    	; 1142          printf("\n  Partition type GUID: ");
 821    2CF6  21BA2A    		ld	hl,L5671
 822    2CF9  CD0000    		call	_printf
 823                    	; 1143          prtguid(entryptr);
 824    2CFC  DD6EEE    		ld	l,(ix-18)
 825    2CFF  DD66EF    		ld	h,(ix-17)
 826    2D02  CD6829    		call	_prtguid
 827                    	; 1144          printf("\n  [");
 828    2D05  21D32A    		ld	hl,L5771
 829    2D08  CD0000    		call	_printf
 830                    	; 1145          for (index = 0; index < 16; index++)
 831    2D0B  DD36F800  		ld	(ix-8),0
 832    2D0F  DD36F900  		ld	(ix-7),0
 833                    	L1224:
 834    2D13  DD7EF8    		ld	a,(ix-8)
 835    2D16  D610      		sub	16
 836    2D18  DD7EF9    		ld	a,(ix-7)
 837    2D1B  DE00      		sbc	a,0
 838    2D1D  F2422D    		jp	p,L1324
 839                    	; 1146              printf("%02x ", entryptr[index]);
 840    2D20  DD6EEE    		ld	l,(ix-18)
 841    2D23  DD66EF    		ld	h,(ix-17)
 842    2D26  DD4EF8    		ld	c,(ix-8)
 843    2D29  DD46F9    		ld	b,(ix-7)
 844    2D2C  09        		add	hl,bc
 845    2D2D  4E        		ld	c,(hl)
 846    2D2E  97        		sub	a
 847    2D2F  47        		ld	b,a
 848    2D30  C5        		push	bc
 849    2D31  21D82A    		ld	hl,L5002
 850    2D34  CD0000    		call	_printf
 851    2D37  F1        		pop	af
 852    2D38  DD34F8    		inc	(ix-8)
 853    2D3B  2003      		jr	nz,L041
 854    2D3D  DD34F9    		inc	(ix-7)
 855                    	L041:
 856    2D40  18D1      		jr	L1224
 857                    	L1324:
 858                    	; 1147          printf("\b]");
 859    2D42  21DE2A    		ld	hl,L5102
 860    2D45  CD0000    		call	_printf
 861                    	; 1148          printf("\n  Unique partition GUID: ");
 862    2D48  21E12A    		ld	hl,L5202
 863    2D4B  CD0000    		call	_printf
 864                    	; 1149          prtguid(entryptr + 16);
 865    2D4E  DD6EEE    		ld	l,(ix-18)
 866    2D51  DD66EF    		ld	h,(ix-17)
 867    2D54  011000    		ld	bc,16
 868    2D57  09        		add	hl,bc
 869    2D58  CD6829    		call	_prtguid
 870                    	; 1150          printf("\n  [");
 871    2D5B  21FC2A    		ld	hl,L5302
 872    2D5E  CD0000    		call	_printf
 873                    	; 1151          for (index = 0; index < 16; index++)
 874    2D61  DD36F800  		ld	(ix-8),0
 875    2D65  DD36F900  		ld	(ix-7),0
 876                    	L1624:
 877    2D69  DD7EF8    		ld	a,(ix-8)
 878    2D6C  D610      		sub	16
 879    2D6E  DD7EF9    		ld	a,(ix-7)
 880    2D71  DE00      		sbc	a,0
 881    2D73  F29C2D    		jp	p,L1724
 882                    	; 1152              printf("%02x ", (entryptr + 16)[index]);
 883    2D76  DD6EEE    		ld	l,(ix-18)
 884    2D79  DD66EF    		ld	h,(ix-17)
 885    2D7C  011000    		ld	bc,16
 886    2D7F  09        		add	hl,bc
 887    2D80  DD4EF8    		ld	c,(ix-8)
 888    2D83  DD46F9    		ld	b,(ix-7)
 889    2D86  09        		add	hl,bc
 890    2D87  4E        		ld	c,(hl)
 891    2D88  97        		sub	a
 892    2D89  47        		ld	b,a
 893    2D8A  C5        		push	bc
 894    2D8B  21012B    		ld	hl,L5402
 895    2D8E  CD0000    		call	_printf
 896    2D91  F1        		pop	af
 897    2D92  DD34F8    		inc	(ix-8)
 898    2D95  2003      		jr	nz,L241
 899    2D97  DD34F9    		inc	(ix-7)
 900                    	L241:
 901    2D9A  18CD      		jr	L1624
 902                    	L1724:
 903                    	; 1153          printf("\b]");
 904    2D9C  21072B    		ld	hl,L5502
 905    2D9F  CD0000    		call	_printf
 906                    	; 1154          printf("\n  First LBA: ");
 907    2DA2  210A2B    		ld	hl,L5602
 908    2DA5  CD0000    		call	_printf
 909                    	L1124:
 910                    	; 1155          /* lower 32 bits of LBA should be sufficient (I hope) */
 911                    	; 1156          } /* sdtestflg */
 912                    	; 1157      flba = (unsigned long)entryptr[32] + ((unsigned long)entryptr[33] << 8) +
 913                    	; 1158             ((unsigned long)entryptr[34] << 16) + ((unsigned long)entryptr[35] << 24);
 914    2DA8  DDE5      		push	ix
 915    2DAA  C1        		pop	bc
 916    2DAB  21E8FF    		ld	hl,65512
 917    2DAE  09        		add	hl,bc
 918    2DAF  E5        		push	hl
 919    2DB0  DD6EEE    		ld	l,(ix-18)
 920    2DB3  DD66EF    		ld	h,(ix-17)
 921    2DB6  012000    		ld	bc,32
 922    2DB9  09        		add	hl,bc
 923    2DBA  4D        		ld	c,l
 924    2DBB  44        		ld	b,h
 925    2DBC  97        		sub	a
 926    2DBD  320000    		ld	(c.r0),a
 927    2DC0  320100    		ld	(c.r0+1),a
 928    2DC3  0A        		ld	a,(bc)
 929    2DC4  320200    		ld	(c.r0+2),a
 930    2DC7  97        		sub	a
 931    2DC8  320300    		ld	(c.r0+3),a
 932    2DCB  210000    		ld	hl,c.r0
 933    2DCE  E5        		push	hl
 934    2DCF  DD6EEE    		ld	l,(ix-18)
 935    2DD2  DD66EF    		ld	h,(ix-17)
 936    2DD5  012100    		ld	bc,33
 937    2DD8  09        		add	hl,bc
 938    2DD9  4D        		ld	c,l
 939    2DDA  44        		ld	b,h
 940    2DDB  97        		sub	a
 941    2DDC  320000    		ld	(c.r1),a
 942    2DDF  320100    		ld	(c.r1+1),a
 943    2DE2  0A        		ld	a,(bc)
 944    2DE3  320200    		ld	(c.r1+2),a
 945    2DE6  97        		sub	a
 946    2DE7  320300    		ld	(c.r1+3),a
 947    2DEA  210000    		ld	hl,c.r1
 948    2DED  E5        		push	hl
 949    2DEE  210800    		ld	hl,8
 950    2DF1  E5        		push	hl
 951    2DF2  CD0000    		call	c.llsh
 952    2DF5  CD0000    		call	c.ladd
 953    2DF8  DD6EEE    		ld	l,(ix-18)
 954    2DFB  DD66EF    		ld	h,(ix-17)
 955    2DFE  012200    		ld	bc,34
 956    2E01  09        		add	hl,bc
 957    2E02  4D        		ld	c,l
 958    2E03  44        		ld	b,h
 959    2E04  97        		sub	a
 960    2E05  320000    		ld	(c.r1),a
 961    2E08  320100    		ld	(c.r1+1),a
 962    2E0B  0A        		ld	a,(bc)
 963    2E0C  320200    		ld	(c.r1+2),a
 964    2E0F  97        		sub	a
 965    2E10  320300    		ld	(c.r1+3),a
 966    2E13  210000    		ld	hl,c.r1
 967    2E16  E5        		push	hl
 968    2E17  211000    		ld	hl,16
 969    2E1A  E5        		push	hl
 970    2E1B  CD0000    		call	c.llsh
 971    2E1E  CD0000    		call	c.ladd
 972    2E21  DD6EEE    		ld	l,(ix-18)
 973    2E24  DD66EF    		ld	h,(ix-17)
 974    2E27  012300    		ld	bc,35
 975    2E2A  09        		add	hl,bc
 976    2E2B  4D        		ld	c,l
 977    2E2C  44        		ld	b,h
 978    2E2D  97        		sub	a
 979    2E2E  320000    		ld	(c.r1),a
 980    2E31  320100    		ld	(c.r1+1),a
 981    2E34  0A        		ld	a,(bc)
 982    2E35  320200    		ld	(c.r1+2),a
 983    2E38  97        		sub	a
 984    2E39  320300    		ld	(c.r1+3),a
 985    2E3C  210000    		ld	hl,c.r1
 986    2E3F  E5        		push	hl
 987    2E40  211800    		ld	hl,24
 988    2E43  E5        		push	hl
 989    2E44  CD0000    		call	c.llsh
 990    2E47  CD0000    		call	c.ladd
 991    2E4A  CD0000    		call	c.mvl
 992    2E4D  F1        		pop	af
 993                    	; 1159      if (sdtestflg)
 994    2E4E  2A0000    		ld	hl,(_sdtestflg)
 995    2E51  7C        		ld	a,h
 996    2E52  B5        		or	l
 997    2E53  CAB52E    		jp	z,L1234
 998                    	; 1160          {
 999                    	; 1161          printf("%lu", flba);
1000    2E56  DD66EB    		ld	h,(ix-21)
1001    2E59  DD6EEA    		ld	l,(ix-22)
1002    2E5C  E5        		push	hl
1003    2E5D  DD66E9    		ld	h,(ix-23)
1004    2E60  DD6EE8    		ld	l,(ix-24)
1005    2E63  E5        		push	hl
1006    2E64  21192B    		ld	hl,L5702
1007    2E67  CD0000    		call	_printf
1008    2E6A  F1        		pop	af
1009    2E6B  F1        		pop	af
1010                    	; 1162          printf(" [");
1011    2E6C  211D2B    		ld	hl,L5012
1012    2E6F  CD0000    		call	_printf
1013                    	; 1163          for (index = 32; index < (32 + 8); index++)
1014    2E72  DD36F820  		ld	(ix-8),32
1015    2E76  DD36F900  		ld	(ix-7),0
1016                    	L1334:
1017    2E7A  DD7EF8    		ld	a,(ix-8)
1018    2E7D  D628      		sub	40
1019    2E7F  DD7EF9    		ld	a,(ix-7)
1020    2E82  DE00      		sbc	a,0
1021    2E84  F2A92E    		jp	p,L1434
1022                    	; 1164              printf("%02x ", entryptr[index]);
1023    2E87  DD6EEE    		ld	l,(ix-18)
1024    2E8A  DD66EF    		ld	h,(ix-17)
1025    2E8D  DD4EF8    		ld	c,(ix-8)
1026    2E90  DD46F9    		ld	b,(ix-7)
1027    2E93  09        		add	hl,bc
1028    2E94  4E        		ld	c,(hl)
1029    2E95  97        		sub	a
1030    2E96  47        		ld	b,a
1031    2E97  C5        		push	bc
1032    2E98  21202B    		ld	hl,L5112
1033    2E9B  CD0000    		call	_printf
1034    2E9E  F1        		pop	af
1035    2E9F  DD34F8    		inc	(ix-8)
1036    2EA2  2003      		jr	nz,L441
1037    2EA4  DD34F9    		inc	(ix-7)
1038                    	L441:
1039    2EA7  18D1      		jr	L1334
1040                    	L1434:
1041                    	; 1165          printf("\b]");
1042    2EA9  21262B    		ld	hl,L5212
1043    2EAC  CD0000    		call	_printf
1044                    	; 1166          printf("\n  Last LBA: ");
1045    2EAF  21292B    		ld	hl,L5312
1046    2EB2  CD0000    		call	_printf
1047                    	L1234:
1048                    	; 1167          } /* sdtestflg */
1049                    	; 1168      /* lower 32 bits of LBA should be sufficient (I hope) */
1050                    	; 1169      llba = (unsigned long)entryptr[40] + ((unsigned long)entryptr[41] << 8) +
1051                    	; 1170             ((unsigned long)entryptr[42] << 16) + ((unsigned long)entryptr[43] << 24);
1052    2EB5  DDE5      		push	ix
1053    2EB7  C1        		pop	bc
1054    2EB8  21E4FF    		ld	hl,65508
1055    2EBB  09        		add	hl,bc
1056    2EBC  E5        		push	hl
1057    2EBD  DD6EEE    		ld	l,(ix-18)
1058    2EC0  DD66EF    		ld	h,(ix-17)
1059    2EC3  012800    		ld	bc,40
1060    2EC6  09        		add	hl,bc
1061    2EC7  4D        		ld	c,l
1062    2EC8  44        		ld	b,h
1063    2EC9  97        		sub	a
1064    2ECA  320000    		ld	(c.r0),a
1065    2ECD  320100    		ld	(c.r0+1),a
1066    2ED0  0A        		ld	a,(bc)
1067    2ED1  320200    		ld	(c.r0+2),a
1068    2ED4  97        		sub	a
1069    2ED5  320300    		ld	(c.r0+3),a
1070    2ED8  210000    		ld	hl,c.r0
1071    2EDB  E5        		push	hl
1072    2EDC  DD6EEE    		ld	l,(ix-18)
1073    2EDF  DD66EF    		ld	h,(ix-17)
1074    2EE2  012900    		ld	bc,41
1075    2EE5  09        		add	hl,bc
1076    2EE6  4D        		ld	c,l
1077    2EE7  44        		ld	b,h
1078    2EE8  97        		sub	a
1079    2EE9  320000    		ld	(c.r1),a
1080    2EEC  320100    		ld	(c.r1+1),a
1081    2EEF  0A        		ld	a,(bc)
1082    2EF0  320200    		ld	(c.r1+2),a
1083    2EF3  97        		sub	a
1084    2EF4  320300    		ld	(c.r1+3),a
1085    2EF7  210000    		ld	hl,c.r1
1086    2EFA  E5        		push	hl
1087    2EFB  210800    		ld	hl,8
1088    2EFE  E5        		push	hl
1089    2EFF  CD0000    		call	c.llsh
1090    2F02  CD0000    		call	c.ladd
1091    2F05  DD6EEE    		ld	l,(ix-18)
1092    2F08  DD66EF    		ld	h,(ix-17)
1093    2F0B  012A00    		ld	bc,42
1094    2F0E  09        		add	hl,bc
1095    2F0F  4D        		ld	c,l
1096    2F10  44        		ld	b,h
1097    2F11  97        		sub	a
1098    2F12  320000    		ld	(c.r1),a
1099    2F15  320100    		ld	(c.r1+1),a
1100    2F18  0A        		ld	a,(bc)
1101    2F19  320200    		ld	(c.r1+2),a
1102    2F1C  97        		sub	a
1103    2F1D  320300    		ld	(c.r1+3),a
1104    2F20  210000    		ld	hl,c.r1
1105    2F23  E5        		push	hl
1106    2F24  211000    		ld	hl,16
1107    2F27  E5        		push	hl
1108    2F28  CD0000    		call	c.llsh
1109    2F2B  CD0000    		call	c.ladd
1110    2F2E  DD6EEE    		ld	l,(ix-18)
1111    2F31  DD66EF    		ld	h,(ix-17)
1112    2F34  012B00    		ld	bc,43
1113    2F37  09        		add	hl,bc
1114    2F38  4D        		ld	c,l
1115    2F39  44        		ld	b,h
1116    2F3A  97        		sub	a
1117    2F3B  320000    		ld	(c.r1),a
1118    2F3E  320100    		ld	(c.r1+1),a
1119    2F41  0A        		ld	a,(bc)
1120    2F42  320200    		ld	(c.r1+2),a
1121    2F45  97        		sub	a
1122    2F46  320300    		ld	(c.r1+3),a
1123    2F49  210000    		ld	hl,c.r1
1124    2F4C  E5        		push	hl
1125    2F4D  211800    		ld	hl,24
1126    2F50  E5        		push	hl
1127    2F51  CD0000    		call	c.llsh
1128    2F54  CD0000    		call	c.ladd
1129    2F57  CD0000    		call	c.mvl
1130    2F5A  F1        		pop	af
1131                    	; 1171  
1132                    	; 1172      if (entryptr[48] & 0x04)
1133    2F5B  DD6EEE    		ld	l,(ix-18)
1134    2F5E  DD66EF    		ld	h,(ix-17)
1135    2F61  013000    		ld	bc,48
1136    2F64  09        		add	hl,bc
1137    2F65  7E        		ld	a,(hl)
1138    2F66  CB57      		bit	2,a
1139    2F68  6F        		ld	l,a
1140    2F69  2815      		jr	z,L1734
1141                    	; 1173          dskmap[partdsk].bootable = YES;
1142    2F6B  2A0E00    		ld	hl,(_partdsk)
1143    2F6E  E5        		push	hl
1144    2F6F  212000    		ld	hl,32
1145    2F72  E5        		push	hl
1146    2F73  CD0000    		call	c.imul
1147    2F76  E1        		pop	hl
1148    2F77  015402    		ld	bc,_dskmap+2
1149    2F7A  09        		add	hl,bc
1150    2F7B  3601      		ld	(hl),1
1151    2F7D  23        		inc	hl
1152    2F7E  3600      		ld	(hl),0
1153                    	L1734:
1154                    	; 1174      dskmap[partdsk].partype = PARTGPT;
1155    2F80  2A0E00    		ld	hl,(_partdsk)
1156    2F83  E5        		push	hl
1157    2F84  212000    		ld	hl,32
1158    2F87  E5        		push	hl
1159    2F88  CD0000    		call	c.imul
1160    2F8B  E1        		pop	hl
1161    2F8C  015202    		ld	bc,_dskmap
1162    2F8F  09        		add	hl,bc
1163    2F90  3603      		ld	(hl),3
1164                    	; 1175      dskmap[partdsk].dskletter = 'A' + partdsk;
1165    2F92  2A0E00    		ld	hl,(_partdsk)
1166    2F95  E5        		push	hl
1167    2F96  212000    		ld	hl,32
1168    2F99  E5        		push	hl
1169    2F9A  CD0000    		call	c.imul
1170    2F9D  E1        		pop	hl
1171    2F9E  015302    		ld	bc,_dskmap+1
1172    2FA1  09        		add	hl,bc
1173    2FA2  3A0E00    		ld	a,(_partdsk)
1174    2FA5  C641      		add	a,65
1175    2FA7  4F        		ld	c,a
1176    2FA8  71        		ld	(hl),c
1177                    	; 1176      dskmap[partdsk].dskstart = flba;
1178    2FA9  2A0E00    		ld	hl,(_partdsk)
1179    2FAC  E5        		push	hl
1180    2FAD  212000    		ld	hl,32
1181    2FB0  E5        		push	hl
1182    2FB1  CD0000    		call	c.imul
1183    2FB4  E1        		pop	hl
1184    2FB5  015602    		ld	bc,_dskmap+4
1185    2FB8  09        		add	hl,bc
1186    2FB9  E5        		push	hl
1187    2FBA  DDE5      		push	ix
1188    2FBC  C1        		pop	bc
1189    2FBD  21E8FF    		ld	hl,65512
1190    2FC0  09        		add	hl,bc
1191    2FC1  E5        		push	hl
1192    2FC2  CD0000    		call	c.mvl
1193    2FC5  F1        		pop	af
1194                    	; 1177      dskmap[partdsk].dskend = llba;
1195    2FC6  2A0E00    		ld	hl,(_partdsk)
1196    2FC9  E5        		push	hl
1197    2FCA  212000    		ld	hl,32
1198    2FCD  E5        		push	hl
1199    2FCE  CD0000    		call	c.imul
1200    2FD1  E1        		pop	hl
1201    2FD2  015A02    		ld	bc,_dskmap+8
1202    2FD5  09        		add	hl,bc
1203    2FD6  E5        		push	hl
1204    2FD7  DDE5      		push	ix
1205    2FD9  C1        		pop	bc
1206    2FDA  21E4FF    		ld	hl,65508
1207    2FDD  09        		add	hl,bc
1208    2FDE  E5        		push	hl
1209    2FDF  CD0000    		call	c.mvl
1210    2FE2  F1        		pop	af
1211                    	; 1178      dskmap[partdsk].dsksize = llba - flba + 1;
1212    2FE3  2A0E00    		ld	hl,(_partdsk)
1213    2FE6  E5        		push	hl
1214    2FE7  212000    		ld	hl,32
1215    2FEA  E5        		push	hl
1216    2FEB  CD0000    		call	c.imul
1217    2FEE  E1        		pop	hl
1218    2FEF  015E02    		ld	bc,_dskmap+12
1219    2FF2  09        		add	hl,bc
1220    2FF3  E5        		push	hl
1221    2FF4  DDE5      		push	ix
1222    2FF6  C1        		pop	bc
1223    2FF7  21E4FF    		ld	hl,65508
1224    2FFA  09        		add	hl,bc
1225    2FFB  CD0000    		call	c.0mvf
1226    2FFE  210000    		ld	hl,c.r0
1227    3001  E5        		push	hl
1228    3002  DDE5      		push	ix
1229    3004  C1        		pop	bc
1230    3005  21E8FF    		ld	hl,65512
1231    3008  09        		add	hl,bc
1232    3009  E5        		push	hl
1233    300A  CD0000    		call	c.lsub
1234    300D  3E01      		ld	a,1
1235    300F  320200    		ld	(c.r1+2),a
1236    3012  87        		add	a,a
1237    3013  9F        		sbc	a,a
1238    3014  320300    		ld	(c.r1+3),a
1239    3017  320100    		ld	(c.r1+1),a
1240    301A  320000    		ld	(c.r1),a
1241    301D  210000    		ld	hl,c.r1
1242    3020  E5        		push	hl
1243    3021  CD0000    		call	c.ladd
1244    3024  CD0000    		call	c.mvl
1245    3027  F1        		pop	af
1246                    	; 1179      memcpy(dskmap[partdsk].dsktype, entryptr, 16);
1247    3028  211000    		ld	hl,16
1248    302B  E5        		push	hl
1249    302C  DD6EEE    		ld	l,(ix-18)
1250    302F  DD66EF    		ld	h,(ix-17)
1251    3032  E5        		push	hl
1252    3033  2A0E00    		ld	hl,(_partdsk)
1253    3036  E5        		push	hl
1254    3037  212000    		ld	hl,32
1255    303A  E5        		push	hl
1256    303B  CD0000    		call	c.imul
1257    303E  E1        		pop	hl
1258    303F  016202    		ld	bc,_dskmap+16
1259    3042  09        		add	hl,bc
1260    3043  CD0000    		call	_memcpy
1261    3046  F1        		pop	af
1262    3047  F1        		pop	af
1263                    	; 1180      partdsk++;
1264    3048  2A0E00    		ld	hl,(_partdsk)
1265    304B  23        		inc	hl
1266    304C  220E00    		ld	(_partdsk),hl
1267                    	; 1181  
1268                    	; 1182      if (sdtestflg)
1269    304F  2A0000    		ld	hl,(_sdtestflg)
1270    3052  7C        		ld	a,h
1271    3053  B5        		or	l
1272    3054  CA3331    		jp	z,L1044
1273                    	; 1183          {
1274                    	; 1184          printf("%lu, size %lu MByte", llba, (llba - flba) >> 11);
1275    3057  DDE5      		push	ix
1276    3059  C1        		pop	bc
1277    305A  21E4FF    		ld	hl,65508
1278    305D  09        		add	hl,bc
1279    305E  CD0000    		call	c.0mvf
1280    3061  210000    		ld	hl,c.r0
1281    3064  E5        		push	hl
1282    3065  DDE5      		push	ix
1283    3067  C1        		pop	bc
1284    3068  21E8FF    		ld	hl,65512
1285    306B  09        		add	hl,bc
1286    306C  E5        		push	hl
1287    306D  CD0000    		call	c.lsub
1288    3070  210B00    		ld	hl,11
1289    3073  E5        		push	hl
1290    3074  CD0000    		call	c.ulrsh
1291    3077  E1        		pop	hl
1292    3078  23        		inc	hl
1293    3079  23        		inc	hl
1294    307A  4E        		ld	c,(hl)
1295    307B  23        		inc	hl
1296    307C  46        		ld	b,(hl)
1297    307D  C5        		push	bc
1298    307E  2B        		dec	hl
1299    307F  2B        		dec	hl
1300    3080  2B        		dec	hl
1301    3081  4E        		ld	c,(hl)
1302    3082  23        		inc	hl
1303    3083  46        		ld	b,(hl)
1304    3084  C5        		push	bc
1305    3085  DD66E7    		ld	h,(ix-25)
1306    3088  DD6EE6    		ld	l,(ix-26)
1307    308B  E5        		push	hl
1308    308C  DD66E5    		ld	h,(ix-27)
1309    308F  DD6EE4    		ld	l,(ix-28)
1310    3092  E5        		push	hl
1311    3093  21372B    		ld	hl,L5412
1312    3096  CD0000    		call	_printf
1313    3099  F1        		pop	af
1314    309A  F1        		pop	af
1315    309B  F1        		pop	af
1316    309C  F1        		pop	af
1317                    	; 1185          printf(" [");
1318    309D  214B2B    		ld	hl,L5512
1319    30A0  CD0000    		call	_printf
1320                    	; 1186          for (index = 40; index < (40 + 8); index++)
1321    30A3  DD36F828  		ld	(ix-8),40
1322    30A7  DD36F900  		ld	(ix-7),0
1323                    	L1144:
1324    30AB  DD7EF8    		ld	a,(ix-8)
1325    30AE  D630      		sub	48
1326    30B0  DD7EF9    		ld	a,(ix-7)
1327    30B3  DE00      		sbc	a,0
1328    30B5  F2DA30    		jp	p,L1244
1329                    	; 1187              printf("%02x ", entryptr[index]);
1330    30B8  DD6EEE    		ld	l,(ix-18)
1331    30BB  DD66EF    		ld	h,(ix-17)
1332    30BE  DD4EF8    		ld	c,(ix-8)
1333    30C1  DD46F9    		ld	b,(ix-7)
1334    30C4  09        		add	hl,bc
1335    30C5  4E        		ld	c,(hl)
1336    30C6  97        		sub	a
1337    30C7  47        		ld	b,a
1338    30C8  C5        		push	bc
1339    30C9  214E2B    		ld	hl,L5612
1340    30CC  CD0000    		call	_printf
1341    30CF  F1        		pop	af
1342    30D0  DD34F8    		inc	(ix-8)
1343    30D3  2003      		jr	nz,L641
1344    30D5  DD34F9    		inc	(ix-7)
1345                    	L641:
1346    30D8  18D1      		jr	L1144
1347                    	L1244:
1348                    	; 1188          printf("\b]");
1349    30DA  21542B    		ld	hl,L5712
1350    30DD  CD0000    		call	_printf
1351                    	; 1189          printf("\n  Attribute flags: [");
1352    30E0  21572B    		ld	hl,L5022
1353    30E3  CD0000    		call	_printf
1354                    	; 1190          /* bits 0 - 2 and 60 - 63 should be decoded */
1355                    	; 1191          for (index = 0; index < 8; index++)
1356    30E6  DD36F800  		ld	(ix-8),0
1357    30EA  DD36F900  		ld	(ix-7),0
1358                    	L1544:
1359    30EE  DD7EF8    		ld	a,(ix-8)
1360    30F1  D608      		sub	8
1361    30F3  DD7EF9    		ld	a,(ix-7)
1362    30F6  DE00      		sbc	a,0
1363    30F8  F22D31    		jp	p,L1644
1364                    	; 1192              {
1365                    	; 1193              entryidx = index + 48;
1366    30FB  DD6EF8    		ld	l,(ix-8)
1367    30FE  DD66F9    		ld	h,(ix-7)
1368    3101  013000    		ld	bc,48
1369    3104  09        		add	hl,bc
1370    3105  DD75F6    		ld	(ix-10),l
1371    3108  DD74F7    		ld	(ix-9),h
1372                    	; 1194              printf("%02x ", entryptr[entryidx]);
1373    310B  DD6EEE    		ld	l,(ix-18)
1374    310E  DD66EF    		ld	h,(ix-17)
1375    3111  DD4EF6    		ld	c,(ix-10)
1376    3114  DD46F7    		ld	b,(ix-9)
1377    3117  09        		add	hl,bc
1378    3118  4E        		ld	c,(hl)
1379    3119  97        		sub	a
1380    311A  47        		ld	b,a
1381    311B  C5        		push	bc
1382    311C  216D2B    		ld	hl,L5122
1383    311F  CD0000    		call	_printf
1384    3122  F1        		pop	af
1385                    	; 1195              }
1386    3123  DD34F8    		inc	(ix-8)
1387    3126  2003      		jr	nz,L051
1388    3128  DD34F9    		inc	(ix-7)
1389                    	L051:
1390    312B  18C1      		jr	L1544
1391                    	L1644:
1392                    	; 1196          printf("\b]\n  Partition name:  ");
1393    312D  21732B    		ld	hl,L5222
1394    3130  CD0000    		call	_printf
1395                    	L1044:
1396                    	; 1197          } /* sdtestflg */
1397                    	; 1198      /* partition name is in UTF-16LE code units */
1398                    	; 1199      hasname = NO;
1399    3133  DD36F400  		ld	(ix-12),0
1400    3137  DD36F500  		ld	(ix-11),0
1401                    	; 1200      for (index = 0; index < 72; index += 2)
1402    313B  DD36F800  		ld	(ix-8),0
1403    313F  DD36F900  		ld	(ix-7),0
1404                    	L1154:
1405    3143  DD7EF8    		ld	a,(ix-8)
1406    3146  D648      		sub	72
1407    3148  DD7EF9    		ld	a,(ix-7)
1408    314B  DE00      		sbc	a,0
1409    314D  F2E331    		jp	p,L1254
1410                    	; 1201          {
1411                    	; 1202          entryidx = index + 56;
1412    3150  DD6EF8    		ld	l,(ix-8)
1413    3153  DD66F9    		ld	h,(ix-7)
1414    3156  013800    		ld	bc,56
1415    3159  09        		add	hl,bc
1416    315A  DD75F6    		ld	(ix-10),l
1417    315D  DD74F7    		ld	(ix-9),h
1418                    	; 1203          if ((entryptr[entryidx] | entryptr[entryidx + 1]) == 0)
1419    3160  DD6EEE    		ld	l,(ix-18)
1420    3163  DD66EF    		ld	h,(ix-17)
1421    3166  DD4EF6    		ld	c,(ix-10)
1422    3169  DD46F7    		ld	b,(ix-9)
1423    316C  09        		add	hl,bc
1424    316D  6E        		ld	l,(hl)
1425    316E  E5        		push	hl
1426    316F  DD6EF6    		ld	l,(ix-10)
1427    3172  DD66F7    		ld	h,(ix-9)
1428    3175  23        		inc	hl
1429    3176  DD4EEE    		ld	c,(ix-18)
1430    3179  DD46EF    		ld	b,(ix-17)
1431    317C  09        		add	hl,bc
1432    317D  C1        		pop	bc
1433    317E  79        		ld	a,c
1434    317F  B6        		or	(hl)
1435    3180  4F        		ld	c,a
1436    3181  CAE331    		jp	z,L1254
1437                    	; 1204              break;
1438                    	; 1205          if (sdtestflg)
1439    3184  2A0000    		ld	hl,(_sdtestflg)
1440    3187  7C        		ld	a,h
1441    3188  B5        		or	l
1442    3189  283F      		jr	z,L1654
1443                    	; 1206              {
1444                    	; 1207              if ((' ' <= entryptr[entryidx]) && (entryptr[entryidx] < 127))
1445    318B  DD6EEE    		ld	l,(ix-18)
1446    318E  DD66EF    		ld	h,(ix-17)
1447    3191  DD4EF6    		ld	c,(ix-10)
1448    3194  DD46F7    		ld	b,(ix-9)
1449    3197  09        		add	hl,bc
1450    3198  7E        		ld	a,(hl)
1451    3199  FE20      		cp	32
1452    319B  3827      		jr	c,L1754
1453    319D  DD6EEE    		ld	l,(ix-18)
1454    31A0  DD66EF    		ld	h,(ix-17)
1455    31A3  DD4EF6    		ld	c,(ix-10)
1456    31A6  DD46F7    		ld	b,(ix-9)
1457    31A9  09        		add	hl,bc
1458    31AA  7E        		ld	a,(hl)
1459    31AB  FE7F      		cp	127
1460    31AD  3015      		jr	nc,L1754
1461                    	; 1208                  putchar(entryptr[entryidx]);
1462    31AF  DD6EEE    		ld	l,(ix-18)
1463    31B2  DD66EF    		ld	h,(ix-17)
1464    31B5  DD4EF6    		ld	c,(ix-10)
1465    31B8  DD46F7    		ld	b,(ix-9)
1466    31BB  09        		add	hl,bc
1467    31BC  6E        		ld	l,(hl)
1468    31BD  97        		sub	a
1469    31BE  67        		ld	h,a
1470    31BF  CD0000    		call	_putchar
1471                    	; 1209              else
1472    31C2  1806      		jr	L1654
1473                    	L1754:
1474                    	; 1210                  putchar('.');
1475    31C4  212E00    		ld	hl,46
1476    31C7  CD0000    		call	_putchar
1477                    	L1654:
1478                    	; 1211              } /* sdtestflg */
1479                    	; 1212          hasname = YES;
1480    31CA  DD36F401  		ld	(ix-12),1
1481    31CE  DD36F500  		ld	(ix-11),0
1482                    	; 1213          }
1483    31D2  DD6EF8    		ld	l,(ix-8)
1484    31D5  DD66F9    		ld	h,(ix-7)
1485    31D8  23        		inc	hl
1486    31D9  23        		inc	hl
1487    31DA  DD75F8    		ld	(ix-8),l
1488    31DD  DD74F9    		ld	(ix-7),h
1489    31E0  C34331    		jp	L1154
1490                    	L1254:
1491                    	; 1214      if (sdtestflg)
1492    31E3  2A0000    		ld	hl,(_sdtestflg)
1493    31E6  7C        		ld	a,h
1494    31E7  B5        		or	l
1495    31E8  CA6C32    		jp	z,L1164
1496                    	; 1215          {
1497                    	; 1216          if (!hasname)
1498    31EB  DD7EF4    		ld	a,(ix-12)
1499    31EE  DDB6F5    		or	(ix-11)
1500    31F1  2006      		jr	nz,L1264
1501                    	; 1217              printf("name field empty");
1502    31F3  218A2B    		ld	hl,L5322
1503    31F6  CD0000    		call	_printf
1504                    	L1264:
1505                    	; 1218          printf("\n");
1506    31F9  219B2B    		ld	hl,L5422
1507    31FC  CD0000    		call	_printf
1508                    	; 1219          printf("   [");
1509    31FF  219D2B    		ld	hl,L5522
1510    3202  CD0000    		call	_printf
1511                    	; 1220          for (index = 0; index < 72; index++)
1512    3205  DD36F800  		ld	(ix-8),0
1513    3209  DD36F900  		ld	(ix-7),0
1514                    	L1364:
1515    320D  DD7EF8    		ld	a,(ix-8)
1516    3210  D648      		sub	72
1517    3212  DD7EF9    		ld	a,(ix-7)
1518    3215  DE00      		sbc	a,0
1519    3217  F26632    		jp	p,L1464
1520                    	; 1221              {
1521                    	; 1222              if (((index & 0xf) == 0) && (index != 0))
1522    321A  DD6EF8    		ld	l,(ix-8)
1523    321D  DD66F9    		ld	h,(ix-7)
1524    3220  7D        		ld	a,l
1525    3221  E60F      		and	15
1526    3223  200E      		jr	nz,L1764
1527    3225  DD7EF8    		ld	a,(ix-8)
1528    3228  DDB6F9    		or	(ix-7)
1529    322B  2806      		jr	z,L1764
1530                    	; 1223                  printf("\n    ");
1531    322D  21A22B    		ld	hl,L5622
1532    3230  CD0000    		call	_printf
1533                    	L1764:
1534                    	; 1224              entryidx = index + 56;
1535    3233  DD6EF8    		ld	l,(ix-8)
1536    3236  DD66F9    		ld	h,(ix-7)
1537    3239  013800    		ld	bc,56
1538    323C  09        		add	hl,bc
1539    323D  DD75F6    		ld	(ix-10),l
1540    3240  DD74F7    		ld	(ix-9),h
1541                    	; 1225              printf("%02x ", entryptr[entryidx]);
1542    3243  DD6EEE    		ld	l,(ix-18)
1543    3246  DD66EF    		ld	h,(ix-17)
1544    3249  DD4EF6    		ld	c,(ix-10)
1545    324C  DD46F7    		ld	b,(ix-9)
1546    324F  09        		add	hl,bc
1547    3250  4E        		ld	c,(hl)
1548    3251  97        		sub	a
1549    3252  47        		ld	b,a
1550    3253  C5        		push	bc
1551    3254  21A82B    		ld	hl,L5722
1552    3257  CD0000    		call	_printf
1553    325A  F1        		pop	af
1554                    	; 1226              }
1555    325B  DD34F8    		inc	(ix-8)
1556    325E  2003      		jr	nz,L251
1557    3260  DD34F9    		inc	(ix-7)
1558                    	L251:
1559    3263  C30D32    		jp	L1364
1560                    	L1464:
1561                    	; 1227          printf("\b]\n");
1562    3266  21AE2B    		ld	hl,L5032
1563    3269  CD0000    		call	_printf
1564                    	L1164:
1565                    	; 1228          } /* sdtestflg */
1566                    	; 1229      return (YES);
1567    326C  010100    		ld	bc,1
1568    326F  C30000    		jp	c.rets
1569                    	L5132:
1570    3272  47        		.byte	71
1571    3273  50        		.byte	80
1572    3274  54        		.byte	84
1573    3275  20        		.byte	32
1574    3276  68        		.byte	104
1575    3277  65        		.byte	101
1576    3278  61        		.byte	97
1577    3279  64        		.byte	100
1578    327A  65        		.byte	101
1579    327B  72        		.byte	114
1580    327C  0A        		.byte	10
1581    327D  00        		.byte	0
1582                    	L5232:
1583    327E  43        		.byte	67
1584    327F  61        		.byte	97
1585    3280  6E        		.byte	110
1586    3281  27        		.byte	39
1587    3282  74        		.byte	116
1588    3283  20        		.byte	32
1589    3284  72        		.byte	114
1590    3285  65        		.byte	101
1591    3286  61        		.byte	97
1592    3287  64        		.byte	100
1593    3288  20        		.byte	32
1594    3289  47        		.byte	71
1595    328A  50        		.byte	80
1596    328B  54        		.byte	84
1597    328C  20        		.byte	32
1598    328D  70        		.byte	112
1599    328E  61        		.byte	97
1600    328F  72        		.byte	114
1601    3290  74        		.byte	116
1602    3291  69        		.byte	105
1603    3292  74        		.byte	116
1604    3293  69        		.byte	105
1605    3294  6F        		.byte	111
1606    3295  6E        		.byte	110
1607    3296  20        		.byte	32
1608    3297  74        		.byte	116
1609    3298  61        		.byte	97
1610    3299  62        		.byte	98
1611    329A  6C        		.byte	108
1612    329B  65        		.byte	101
1613    329C  20        		.byte	32
1614    329D  68        		.byte	104
1615    329E  65        		.byte	101
1616    329F  61        		.byte	97
1617    32A0  64        		.byte	100
1618    32A1  65        		.byte	101
1619    32A2  72        		.byte	114
1620    32A3  0A        		.byte	10
1621    32A4  00        		.byte	0
1622                    	L5332:
1623    32A5  20        		.byte	32
1624    32A6  20        		.byte	32
1625    32A7  53        		.byte	83
1626    32A8  69        		.byte	105
1627    32A9  67        		.byte	103
1628    32AA  6E        		.byte	110
1629    32AB  61        		.byte	97
1630    32AC  74        		.byte	116
1631    32AD  75        		.byte	117
1632    32AE  72        		.byte	114
1633    32AF  65        		.byte	101
1634    32B0  3A        		.byte	58
1635    32B1  20        		.byte	32
1636    32B2  25        		.byte	37
1637    32B3  2E        		.byte	46
1638    32B4  38        		.byte	56
1639    32B5  73        		.byte	115
1640    32B6  0A        		.byte	10
1641    32B7  00        		.byte	0
1642                    	L5432:
1643    32B8  20        		.byte	32
1644    32B9  20        		.byte	32
1645    32BA  52        		.byte	82
1646    32BB  65        		.byte	101
1647    32BC  76        		.byte	118
1648    32BD  69        		.byte	105
1649    32BE  73        		.byte	115
1650    32BF  69        		.byte	105
1651    32C0  6F        		.byte	111
1652    32C1  6E        		.byte	110
1653    32C2  3A        		.byte	58
1654    32C3  20        		.byte	32
1655    32C4  25        		.byte	37
1656    32C5  64        		.byte	100
1657    32C6  2E        		.byte	46
1658    32C7  25        		.byte	37
1659    32C8  64        		.byte	100
1660    32C9  20        		.byte	32
1661    32CA  5B        		.byte	91
1662    32CB  25        		.byte	37
1663    32CC  30        		.byte	48
1664    32CD  32        		.byte	50
1665    32CE  78        		.byte	120
1666    32CF  20        		.byte	32
1667    32D0  25        		.byte	37
1668    32D1  30        		.byte	48
1669    32D2  32        		.byte	50
1670    32D3  78        		.byte	120
1671    32D4  20        		.byte	32
1672    32D5  25        		.byte	37
1673    32D6  30        		.byte	48
1674    32D7  32        		.byte	50
1675    32D8  78        		.byte	120
1676    32D9  20        		.byte	32
1677    32DA  25        		.byte	37
1678    32DB  30        		.byte	48
1679    32DC  32        		.byte	50
1680    32DD  78        		.byte	120
1681    32DE  5D        		.byte	93
1682    32DF  0A        		.byte	10
1683    32E0  00        		.byte	0
1684                    	L5532:
1685    32E1  20        		.byte	32
1686    32E2  20        		.byte	32
1687    32E3  4E        		.byte	78
1688    32E4  75        		.byte	117
1689    32E5  6D        		.byte	109
1690    32E6  62        		.byte	98
1691    32E7  65        		.byte	101
1692    32E8  72        		.byte	114
1693    32E9  20        		.byte	32
1694    32EA  6F        		.byte	111
1695    32EB  66        		.byte	102
1696    32EC  20        		.byte	32
1697    32ED  70        		.byte	112
1698    32EE  61        		.byte	97
1699    32EF  72        		.byte	114
1700    32F0  74        		.byte	116
1701    32F1  69        		.byte	105
1702    32F2  74        		.byte	116
1703    32F3  69        		.byte	105
1704    32F4  6F        		.byte	111
1705    32F5  6E        		.byte	110
1706    32F6  20        		.byte	32
1707    32F7  65        		.byte	101
1708    32F8  6E        		.byte	110
1709    32F9  74        		.byte	116
1710    32FA  72        		.byte	114
1711    32FB  69        		.byte	105
1712    32FC  65        		.byte	101
1713    32FD  73        		.byte	115
1714    32FE  3A        		.byte	58
1715    32FF  20        		.byte	32
1716    3300  25        		.byte	37
1717    3301  6C        		.byte	108
1718    3302  75        		.byte	117
1719    3303  20        		.byte	32
1720    3304  28        		.byte	40
1721    3305  6D        		.byte	109
1722    3306  61        		.byte	97
1723    3307  79        		.byte	121
1724    3308  20        		.byte	32
1725    3309  62        		.byte	98
1726    330A  65        		.byte	101
1727    330B  20        		.byte	32
1728    330C  61        		.byte	97
1729    330D  63        		.byte	99
1730    330E  74        		.byte	116
1731    330F  75        		.byte	117
1732    3310  61        		.byte	97
1733    3311  6C        		.byte	108
1734    3312  20        		.byte	32
1735    3313  6F        		.byte	111
1736    3314  72        		.byte	114
1737    3315  20        		.byte	32
1738    3316  6D        		.byte	109
1739    3317  61        		.byte	97
1740    3318  78        		.byte	120
1741    3319  69        		.byte	105
1742    331A  6D        		.byte	109
1743    331B  75        		.byte	117
1744    331C  6D        		.byte	109
1745    331D  29        		.byte	41
1746    331E  0A        		.byte	10
1747    331F  00        		.byte	0
1748                    	L5632:
1749    3320  46        		.byte	70
1750    3321  69        		.byte	105
1751    3322  72        		.byte	114
1752    3323  73        		.byte	115
1753    3324  74        		.byte	116
1754    3325  20        		.byte	32
1755    3326  31        		.byte	49
1756    3327  36        		.byte	54
1757    3328  20        		.byte	32
1758    3329  47        		.byte	71
1759    332A  50        		.byte	80
1760    332B  54        		.byte	84
1761    332C  20        		.byte	32
1762    332D  65        		.byte	101
1763    332E  6E        		.byte	110
1764    332F  74        		.byte	116
1765    3330  72        		.byte	114
1766    3331  69        		.byte	105
1767    3332  65        		.byte	101
1768    3333  73        		.byte	115
1769    3334  20        		.byte	32
1770    3335  73        		.byte	115
1771    3336  63        		.byte	99
1772    3337  61        		.byte	97
1773    3338  6E        		.byte	110
1774    3339  6E        		.byte	110
1775    333A  65        		.byte	101
1776    333B  64        		.byte	100
1777    333C  0A        		.byte	10
1778    333D  00        		.byte	0
1779                    	; 1230      }
1780                    	; 1231  
1781                    	; 1232  /* Analyze and print GPT header
1782                    	; 1233   */
1783                    	; 1234  void sdgpthdr(unsigned long block)
1784                    	; 1235      {
1785                    	_sdgpthdr:
1786    333E  CD0000    		call	c.savs
1787    3341  21F0FF    		ld	hl,65520
1788    3344  39        		add	hl,sp
1789    3345  F9        		ld	sp,hl
1790                    	; 1236      int index;
1791                    	; 1237      unsigned int partno;
1792                    	; 1238      unsigned char *rxdata;
1793                    	; 1239      unsigned long entries;
1794                    	; 1240  
1795                    	; 1241      if (sdtestflg)
1796    3346  2A0000    		ld	hl,(_sdtestflg)
1797    3349  7C        		ld	a,h
1798    334A  B5        		or	l
1799    334B  2806      		jr	z,L1074
1800                    	; 1242          {
1801                    	; 1243          printf("GPT header\n");
1802    334D  217232    		ld	hl,L5132
1803    3350  CD0000    		call	_printf
1804                    	L1074:
1805                    	; 1244          } /* sdtestflg */
1806                    	; 1245      if (!sdread(sdrdbuf, block))
1807    3353  DD6607    		ld	h,(ix+7)
1808    3356  DD6E06    		ld	l,(ix+6)
1809    3359  E5        		push	hl
1810    335A  DD6605    		ld	h,(ix+5)
1811    335D  DD6E04    		ld	l,(ix+4)
1812    3360  E5        		push	hl
1813    3361  214C00    		ld	hl,_sdrdbuf
1814    3364  CDE320    		call	_sdread
1815    3367  F1        		pop	af
1816    3368  F1        		pop	af
1817    3369  79        		ld	a,c
1818    336A  B0        		or	b
1819    336B  2010      		jr	nz,L1174
1820                    	; 1246          {
1821                    	; 1247          if (sdtestflg)
1822    336D  2A0000    		ld	hl,(_sdtestflg)
1823    3370  7C        		ld	a,h
1824    3371  B5        		or	l
1825    3372  2806      		jr	z,L1274
1826                    	; 1248              {
1827                    	; 1249              printf("Can't read GPT partition table header\n");
1828    3374  217E32    		ld	hl,L5232
1829    3377  CD0000    		call	_printf
1830                    	L1274:
1831                    	; 1250              } /* sdtestflg */
1832                    	; 1251          return;
1833    337A  C30000    		jp	c.rets
1834                    	L1174:
1835                    	; 1252          }
1836                    	; 1253      curblkno = block;
1837    337D  210200    		ld	hl,_curblkno
1838    3380  E5        		push	hl
1839    3381  DDE5      		push	ix
1840    3383  C1        		pop	bc
1841    3384  210400    		ld	hl,4
1842    3387  09        		add	hl,bc
1843    3388  E5        		push	hl
1844    3389  CD0000    		call	c.mvl
1845    338C  F1        		pop	af
1846                    	; 1254      curblkok = YES;
1847    338D  210100    		ld	hl,1
1848    3390  221000    		ld	(_curblkok),hl
1849                    	; 1255  
1850                    	; 1256      rxdata = sdrdbuf;
1851    3393  214C00    		ld	hl,_sdrdbuf
1852    3396  DD75F4    		ld	(ix-12),l
1853    3399  DD74F5    		ld	(ix-11),h
1854                    	; 1257      if (sdtestflg)
1855    339C  2A0000    		ld	hl,(_sdtestflg)
1856    339F  7C        		ld	a,h
1857    33A0  B5        		or	l
1858    33A1  CAFF34    		jp	z,L1374
1859                    	; 1258          {
1860                    	; 1259          printf("  Signature: %.8s\n", &rxdata[0]);
1861    33A4  DD6EF4    		ld	l,(ix-12)
1862    33A7  DD66F5    		ld	h,(ix-11)
1863    33AA  E5        		push	hl
1864    33AB  21A532    		ld	hl,L5332
1865    33AE  CD0000    		call	_printf
1866    33B1  F1        		pop	af
1867                    	; 1260          printf("  Revision: %d.%d [%02x %02x %02x %02x]\n",
1868                    	; 1261                 (int)rxdata[8] * ((int)rxdata[9] << 8),
1869                    	; 1262                 (int)rxdata[10] + ((int)rxdata[11] << 8),
1870                    	; 1263                 rxdata[8], rxdata[9], rxdata[10], rxdata[11]);
1871    33B2  DD6EF4    		ld	l,(ix-12)
1872    33B5  DD66F5    		ld	h,(ix-11)
1873    33B8  010B00    		ld	bc,11
1874    33BB  09        		add	hl,bc
1875    33BC  4E        		ld	c,(hl)
1876    33BD  97        		sub	a
1877    33BE  47        		ld	b,a
1878    33BF  C5        		push	bc
1879    33C0  DD6EF4    		ld	l,(ix-12)
1880    33C3  DD66F5    		ld	h,(ix-11)
1881    33C6  010A00    		ld	bc,10
1882    33C9  09        		add	hl,bc
1883    33CA  4E        		ld	c,(hl)
1884    33CB  97        		sub	a
1885    33CC  47        		ld	b,a
1886    33CD  C5        		push	bc
1887    33CE  DD6EF4    		ld	l,(ix-12)
1888    33D1  DD66F5    		ld	h,(ix-11)
1889    33D4  010900    		ld	bc,9
1890    33D7  09        		add	hl,bc
1891    33D8  4E        		ld	c,(hl)
1892    33D9  97        		sub	a
1893    33DA  47        		ld	b,a
1894    33DB  C5        		push	bc
1895    33DC  DD6EF4    		ld	l,(ix-12)
1896    33DF  DD66F5    		ld	h,(ix-11)
1897    33E2  010800    		ld	bc,8
1898    33E5  09        		add	hl,bc
1899    33E6  4E        		ld	c,(hl)
1900    33E7  97        		sub	a
1901    33E8  47        		ld	b,a
1902    33E9  C5        		push	bc
1903    33EA  DD6EF4    		ld	l,(ix-12)
1904    33ED  DD66F5    		ld	h,(ix-11)
1905    33F0  010A00    		ld	bc,10
1906    33F3  09        		add	hl,bc
1907    33F4  6E        		ld	l,(hl)
1908    33F5  97        		sub	a
1909    33F6  67        		ld	h,a
1910    33F7  E5        		push	hl
1911    33F8  DD6EF4    		ld	l,(ix-12)
1912    33FB  DD66F5    		ld	h,(ix-11)
1913    33FE  010B00    		ld	bc,11
1914    3401  09        		add	hl,bc
1915    3402  6E        		ld	l,(hl)
1916    3403  97        		sub	a
1917    3404  67        		ld	h,a
1918    3405  29        		add	hl,hl
1919    3406  29        		add	hl,hl
1920    3407  29        		add	hl,hl
1921    3408  29        		add	hl,hl
1922    3409  29        		add	hl,hl
1923    340A  29        		add	hl,hl
1924    340B  29        		add	hl,hl
1925    340C  29        		add	hl,hl
1926    340D  E3        		ex	(sp),hl
1927    340E  C1        		pop	bc
1928    340F  09        		add	hl,bc
1929    3410  E5        		push	hl
1930    3411  DD6EF4    		ld	l,(ix-12)
1931    3414  DD66F5    		ld	h,(ix-11)
1932    3417  010800    		ld	bc,8
1933    341A  09        		add	hl,bc
1934    341B  6E        		ld	l,(hl)
1935    341C  97        		sub	a
1936    341D  67        		ld	h,a
1937    341E  E5        		push	hl
1938    341F  DD6EF4    		ld	l,(ix-12)
1939    3422  DD66F5    		ld	h,(ix-11)
1940    3425  010900    		ld	bc,9
1941    3428  09        		add	hl,bc
1942    3429  6E        		ld	l,(hl)
1943    342A  97        		sub	a
1944    342B  67        		ld	h,a
1945    342C  29        		add	hl,hl
1946    342D  29        		add	hl,hl
1947    342E  29        		add	hl,hl
1948    342F  29        		add	hl,hl
1949    3430  29        		add	hl,hl
1950    3431  29        		add	hl,hl
1951    3432  29        		add	hl,hl
1952    3433  29        		add	hl,hl
1953    3434  E5        		push	hl
1954    3435  CD0000    		call	c.imul
1955    3438  21B832    		ld	hl,L5432
1956    343B  CD0000    		call	_printf
1957    343E  210C00    		ld	hl,12
1958    3441  39        		add	hl,sp
1959    3442  F9        		ld	sp,hl
1960                    	; 1264          entries = (unsigned long)rxdata[80] + ((unsigned long)rxdata[81] << 8) +
1961                    	; 1265                    ((unsigned long)rxdata[82] << 16) + ((unsigned long)rxdata[83] << 24);
1962    3443  DDE5      		push	ix
1963    3445  C1        		pop	bc
1964    3446  21F0FF    		ld	hl,65520
1965    3449  09        		add	hl,bc
1966    344A  E5        		push	hl
1967    344B  DD6EF4    		ld	l,(ix-12)
1968    344E  DD66F5    		ld	h,(ix-11)
1969    3451  015000    		ld	bc,80
1970    3454  09        		add	hl,bc
1971    3455  4D        		ld	c,l
1972    3456  44        		ld	b,h
1973    3457  97        		sub	a
1974    3458  320000    		ld	(c.r0),a
1975    345B  320100    		ld	(c.r0+1),a
1976    345E  0A        		ld	a,(bc)
1977    345F  320200    		ld	(c.r0+2),a
1978    3462  97        		sub	a
1979    3463  320300    		ld	(c.r0+3),a
1980    3466  210000    		ld	hl,c.r0
1981    3469  E5        		push	hl
1982    346A  DD6EF4    		ld	l,(ix-12)
1983    346D  DD66F5    		ld	h,(ix-11)
1984    3470  015100    		ld	bc,81
1985    3473  09        		add	hl,bc
1986    3474  4D        		ld	c,l
1987    3475  44        		ld	b,h
1988    3476  97        		sub	a
1989    3477  320000    		ld	(c.r1),a
1990    347A  320100    		ld	(c.r1+1),a
1991    347D  0A        		ld	a,(bc)
1992    347E  320200    		ld	(c.r1+2),a
1993    3481  97        		sub	a
1994    3482  320300    		ld	(c.r1+3),a
1995    3485  210000    		ld	hl,c.r1
1996    3488  E5        		push	hl
1997    3489  210800    		ld	hl,8
1998    348C  E5        		push	hl
1999    348D  CD0000    		call	c.llsh
2000    3490  CD0000    		call	c.ladd
2001    3493  DD6EF4    		ld	l,(ix-12)
2002    3496  DD66F5    		ld	h,(ix-11)
2003    3499  015200    		ld	bc,82
2004    349C  09        		add	hl,bc
2005    349D  4D        		ld	c,l
2006    349E  44        		ld	b,h
2007    349F  97        		sub	a
2008    34A0  320000    		ld	(c.r1),a
2009    34A3  320100    		ld	(c.r1+1),a
2010    34A6  0A        		ld	a,(bc)
2011    34A7  320200    		ld	(c.r1+2),a
2012    34AA  97        		sub	a
2013    34AB  320300    		ld	(c.r1+3),a
2014    34AE  210000    		ld	hl,c.r1
2015    34B1  E5        		push	hl
2016    34B2  211000    		ld	hl,16
2017    34B5  E5        		push	hl
2018    34B6  CD0000    		call	c.llsh
2019    34B9  CD0000    		call	c.ladd
2020    34BC  DD6EF4    		ld	l,(ix-12)
2021    34BF  DD66F5    		ld	h,(ix-11)
2022    34C2  015300    		ld	bc,83
2023    34C5  09        		add	hl,bc
2024    34C6  4D        		ld	c,l
2025    34C7  44        		ld	b,h
2026    34C8  97        		sub	a
2027    34C9  320000    		ld	(c.r1),a
2028    34CC  320100    		ld	(c.r1+1),a
2029    34CF  0A        		ld	a,(bc)
2030    34D0  320200    		ld	(c.r1+2),a
2031    34D3  97        		sub	a
2032    34D4  320300    		ld	(c.r1+3),a
2033    34D7  210000    		ld	hl,c.r1
2034    34DA  E5        		push	hl
2035    34DB  211800    		ld	hl,24
2036    34DE  E5        		push	hl
2037    34DF  CD0000    		call	c.llsh
2038    34E2  CD0000    		call	c.ladd
2039    34E5  CD0000    		call	c.mvl
2040    34E8  F1        		pop	af
2041                    	; 1266          printf("  Number of partition entries: %lu (may be actual or maximum)\n", entries);
2042    34E9  DD66F3    		ld	h,(ix-13)
2043    34EC  DD6EF2    		ld	l,(ix-14)
2044    34EF  E5        		push	hl
2045    34F0  DD66F1    		ld	h,(ix-15)
2046    34F3  DD6EF0    		ld	l,(ix-16)
2047    34F6  E5        		push	hl
2048    34F7  21E132    		ld	hl,L5532
2049    34FA  CD0000    		call	_printf
2050    34FD  F1        		pop	af
2051    34FE  F1        		pop	af
2052                    	L1374:
2053                    	; 1267          } /* sdtestflg */
2054                    	; 1268      for (partno = 0; (partno < 16) && (partdsk < 16); partno++)
2055    34FF  DD36F600  		ld	(ix-10),0
2056    3503  DD36F700  		ld	(ix-9),0
2057                    	L1474:
2058    3507  DD7EF6    		ld	a,(ix-10)
2059    350A  D610      		sub	16
2060    350C  DD7EF7    		ld	a,(ix-9)
2061    350F  DE00      		sbc	a,0
2062    3511  302E      		jr	nc,L1574
2063    3513  3A0E00    		ld	a,(_partdsk)
2064    3516  D610      		sub	16
2065    3518  3A0F00    		ld	a,(_partdsk+1)
2066    351B  DE00      		sbc	a,0
2067    351D  F24135    		jp	p,L1574
2068                    	; 1269          {
2069                    	; 1270          if (!prtgptent(partno))
2070    3520  DD6EF6    		ld	l,(ix-10)
2071    3523  DD66F7    		ld	h,(ix-9)
2072    3526  CDB22B    		call	_prtgptent
2073    3529  79        		ld	a,c
2074    352A  B0        		or	b
2075    352B  200A      		jr	nz,L1674
2076                    	; 1271              {
2077                    	; 1272              if (!sdtestflg)
2078    352D  2A0000    		ld	hl,(_sdtestflg)
2079    3530  7C        		ld	a,h
2080    3531  B5        		or	l
2081    3532  2003      		jr	nz,L1674
2082                    	; 1273                  {
2083                    	; 1274                  /* go through all entries if compiled as test program */
2084                    	; 1275                  return;
2085    3534  C30000    		jp	c.rets
2086                    	L1674:
2087    3537  DD34F6    		inc	(ix-10)
2088    353A  2003      		jr	nz,L651
2089    353C  DD34F7    		inc	(ix-9)
2090                    	L651:
2091    353F  18C6      		jr	L1474
2092                    	L1574:
2093                    	; 1276                  } /* sdtestflg */
2094                    	; 1277              }
2095                    	; 1278          }
2096                    	; 1279      if (sdtestflg)
2097    3541  2A0000    		ld	hl,(_sdtestflg)
2098    3544  7C        		ld	a,h
2099    3545  B5        		or	l
2100    3546  2806      		jr	z,L1205
2101                    	; 1280          {
2102                    	; 1281          printf("First 16 GPT entries scanned\n");
2103    3548  212033    		ld	hl,L5632
2104    354B  CD0000    		call	_printf
2105                    	L1205:
2106                    	; 1282          } /* sdtestflg */
2107                    	; 1283      }
2108    354E  C30000    		jp	c.rets
2109                    	L5732:
2110    3551  4E        		.byte	78
2111    3552  6F        		.byte	111
2112    3553  74        		.byte	116
2113    3554  20        		.byte	32
2114    3555  75        		.byte	117
2115    3556  73        		.byte	115
2116    3557  65        		.byte	101
2117    3558  64        		.byte	100
2118    3559  20        		.byte	32
2119    355A  65        		.byte	101
2120    355B  6E        		.byte	110
2121    355C  74        		.byte	116
2122    355D  72        		.byte	114
2123    355E  79        		.byte	121
2124    355F  0A        		.byte	10
2125    3560  00        		.byte	0
2126                    	L5042:
2127    3561  42        		.byte	66
2128    3562  6F        		.byte	111
2129    3563  6F        		.byte	111
2130    3564  74        		.byte	116
2131    3565  20        		.byte	32
2132    3566  69        		.byte	105
2133    3567  6E        		.byte	110
2134    3568  64        		.byte	100
2135    3569  69        		.byte	105
2136    356A  63        		.byte	99
2137    356B  61        		.byte	97
2138    356C  74        		.byte	116
2139    356D  6F        		.byte	111
2140    356E  72        		.byte	114
2141    356F  3A        		.byte	58
2142    3570  20        		.byte	32
2143    3571  30        		.byte	48
2144    3572  78        		.byte	120
2145    3573  25        		.byte	37
2146    3574  30        		.byte	48
2147    3575  32        		.byte	50
2148    3576  78        		.byte	120
2149    3577  2C        		.byte	44
2150    3578  20        		.byte	32
2151    3579  53        		.byte	83
2152    357A  79        		.byte	121
2153    357B  73        		.byte	115
2154    357C  74        		.byte	116
2155    357D  65        		.byte	101
2156    357E  6D        		.byte	109
2157    357F  20        		.byte	32
2158    3580  49        		.byte	73
2159    3581  44        		.byte	68
2160    3582  3A        		.byte	58
2161    3583  20        		.byte	32
2162    3584  30        		.byte	48
2163    3585  78        		.byte	120
2164    3586  25        		.byte	37
2165    3587  30        		.byte	48
2166    3588  32        		.byte	50
2167    3589  78        		.byte	120
2168    358A  0A        		.byte	10
2169    358B  00        		.byte	0
2170                    	L5142:
2171    358C  20        		.byte	32
2172    358D  20        		.byte	32
2173    358E  45        		.byte	69
2174    358F  78        		.byte	120
2175    3590  74        		.byte	116
2176    3591  65        		.byte	101
2177    3592  6E        		.byte	110
2178    3593  64        		.byte	100
2179    3594  65        		.byte	101
2180    3595  64        		.byte	100
2181    3596  20        		.byte	32
2182    3597  70        		.byte	112
2183    3598  61        		.byte	97
2184    3599  72        		.byte	114
2185    359A  74        		.byte	116
2186    359B  69        		.byte	105
2187    359C  74        		.byte	116
2188    359D  69        		.byte	105
2189    359E  6F        		.byte	111
2190    359F  6E        		.byte	110
2191    35A0  20        		.byte	32
2192    35A1  65        		.byte	101
2193    35A2  6E        		.byte	110
2194    35A3  74        		.byte	116
2195    35A4  72        		.byte	114
2196    35A5  79        		.byte	121
2197    35A6  0A        		.byte	10
2198    35A7  00        		.byte	0
2199                    	L5242:
2200    35A8  20        		.byte	32
2201    35A9  20        		.byte	32
2202    35AA  55        		.byte	85
2203    35AB  6E        		.byte	110
2204    35AC  6F        		.byte	111
2205    35AD  66        		.byte	102
2206    35AE  66        		.byte	102
2207    35AF  69        		.byte	105
2208    35B0  63        		.byte	99
2209    35B1  69        		.byte	105
2210    35B2  61        		.byte	97
2211    35B3  6C        		.byte	108
2212    35B4  20        		.byte	32
2213    35B5  34        		.byte	52
2214    35B6  38        		.byte	56
2215    35B7  20        		.byte	32
2216    35B8  62        		.byte	98
2217    35B9  69        		.byte	105
2218    35BA  74        		.byte	116
2219    35BB  20        		.byte	32
2220    35BC  4C        		.byte	76
2221    35BD  42        		.byte	66
2222    35BE  41        		.byte	65
2223    35BF  20        		.byte	32
2224    35C0  50        		.byte	80
2225    35C1  72        		.byte	114
2226    35C2  6F        		.byte	111
2227    35C3  70        		.byte	112
2228    35C4  6F        		.byte	111
2229    35C5  73        		.byte	115
2230    35C6  65        		.byte	101
2231    35C7  64        		.byte	100
2232    35C8  20        		.byte	32
2233    35C9  4D        		.byte	77
2234    35CA  42        		.byte	66
2235    35CB  52        		.byte	82
2236    35CC  20        		.byte	32
2237    35CD  46        		.byte	70
2238    35CE  6F        		.byte	111
2239    35CF  72        		.byte	114
2240    35D0  6D        		.byte	109
2241    35D1  61        		.byte	97
2242    35D2  74        		.byte	116
2243    35D3  2C        		.byte	44
2244    35D4  20        		.byte	32
2245    35D5  6E        		.byte	110
2246    35D6  6F        		.byte	111
2247    35D7  20        		.byte	32
2248    35D8  43        		.byte	67
2249    35D9  48        		.byte	72
2250    35DA  53        		.byte	83
2251    35DB  0A        		.byte	10
2252    35DC  00        		.byte	0
2253                    	L5342:
2254    35DD  20        		.byte	32
2255    35DE  20        		.byte	32
2256    35DF  62        		.byte	98
2257    35E0  65        		.byte	101
2258    35E1  67        		.byte	103
2259    35E2  69        		.byte	105
2260    35E3  6E        		.byte	110
2261    35E4  20        		.byte	32
2262    35E5  43        		.byte	67
2263    35E6  48        		.byte	72
2264    35E7  53        		.byte	83
2265    35E8  3A        		.byte	58
2266    35E9  20        		.byte	32
2267    35EA  30        		.byte	48
2268    35EB  78        		.byte	120
2269    35EC  25        		.byte	37
2270    35ED  30        		.byte	48
2271    35EE  32        		.byte	50
2272    35EF  78        		.byte	120
2273    35F0  2D        		.byte	45
2274    35F1  30        		.byte	48
2275    35F2  78        		.byte	120
2276    35F3  25        		.byte	37
2277    35F4  30        		.byte	48
2278    35F5  32        		.byte	50
2279    35F6  78        		.byte	120
2280    35F7  2D        		.byte	45
2281    35F8  30        		.byte	48
2282    35F9  78        		.byte	120
2283    35FA  25        		.byte	37
2284    35FB  30        		.byte	48
2285    35FC  32        		.byte	50
2286    35FD  78        		.byte	120
2287    35FE  20        		.byte	32
2288    35FF  28        		.byte	40
2289    3600  63        		.byte	99
2290    3601  79        		.byte	121
2291    3602  6C        		.byte	108
2292    3603  3A        		.byte	58
2293    3604  20        		.byte	32
2294    3605  25        		.byte	37
2295    3606  64        		.byte	100
2296    3607  2C        		.byte	44
2297    3608  20        		.byte	32
2298    3609  68        		.byte	104
2299    360A  65        		.byte	101
2300    360B  61        		.byte	97
2301    360C  64        		.byte	100
2302    360D  3A        		.byte	58
2303    360E  20        		.byte	32
2304    360F  25        		.byte	37
2305    3610  64        		.byte	100
2306    3611  20        		.byte	32
2307    3612  73        		.byte	115
2308    3613  65        		.byte	101
2309    3614  63        		.byte	99
2310    3615  74        		.byte	116
2311    3616  6F        		.byte	111
2312    3617  72        		.byte	114
2313    3618  3A        		.byte	58
2314    3619  20        		.byte	32
2315    361A  25        		.byte	37
2316    361B  64        		.byte	100
2317    361C  29        		.byte	41
2318    361D  0A        		.byte	10
2319    361E  00        		.byte	0
2320                    	L5442:
2321    361F  20        		.byte	32
2322    3620  20        		.byte	32
2323    3621  65        		.byte	101
2324    3622  6E        		.byte	110
2325    3623  64        		.byte	100
2326    3624  20        		.byte	32
2327    3625  43        		.byte	67
2328    3626  48        		.byte	72
2329    3627  53        		.byte	83
2330    3628  20        		.byte	32
2331    3629  30        		.byte	48
2332    362A  78        		.byte	120
2333    362B  25        		.byte	37
2334    362C  30        		.byte	48
2335    362D  32        		.byte	50
2336    362E  78        		.byte	120
2337    362F  2D        		.byte	45
2338    3630  30        		.byte	48
2339    3631  78        		.byte	120
2340    3632  25        		.byte	37
2341    3633  30        		.byte	48
2342    3634  32        		.byte	50
2343    3635  78        		.byte	120
2344    3636  2D        		.byte	45
2345    3637  30        		.byte	48
2346    3638  78        		.byte	120
2347    3639  25        		.byte	37
2348    363A  30        		.byte	48
2349    363B  32        		.byte	50
2350    363C  78        		.byte	120
2351    363D  20        		.byte	32
2352    363E  28        		.byte	40
2353    363F  63        		.byte	99
2354    3640  79        		.byte	121
2355    3641  6C        		.byte	108
2356    3642  3A        		.byte	58
2357    3643  20        		.byte	32
2358    3644  25        		.byte	37
2359    3645  64        		.byte	100
2360    3646  2C        		.byte	44
2361    3647  20        		.byte	32
2362    3648  68        		.byte	104
2363    3649  65        		.byte	101
2364    364A  61        		.byte	97
2365    364B  64        		.byte	100
2366    364C  3A        		.byte	58
2367    364D  20        		.byte	32
2368    364E  25        		.byte	37
2369    364F  64        		.byte	100
2370    3650  20        		.byte	32
2371    3651  73        		.byte	115
2372    3652  65        		.byte	101
2373    3653  63        		.byte	99
2374    3654  74        		.byte	116
2375    3655  6F        		.byte	111
2376    3656  72        		.byte	114
2377    3657  3A        		.byte	58
2378    3658  20        		.byte	32
2379    3659  25        		.byte	37
2380    365A  64        		.byte	100
2381    365B  29        		.byte	41
2382    365C  0A        		.byte	10
2383    365D  00        		.byte	0
2384                    	L5542:
2385    365E  20        		.byte	32
2386    365F  20        		.byte	32
2387    3660  70        		.byte	112
2388    3661  61        		.byte	97
2389    3662  72        		.byte	114
2390    3663  74        		.byte	116
2391    3664  69        		.byte	105
2392    3665  74        		.byte	116
2393    3666  69        		.byte	105
2394    3667  6F        		.byte	111
2395    3668  6E        		.byte	110
2396    3669  20        		.byte	32
2397    366A  73        		.byte	115
2398    366B  74        		.byte	116
2399    366C  61        		.byte	97
2400    366D  72        		.byte	114
2401    366E  74        		.byte	116
2402    366F  20        		.byte	32
2403    3670  4C        		.byte	76
2404    3671  42        		.byte	66
2405    3672  41        		.byte	65
2406    3673  3A        		.byte	58
2407    3674  20        		.byte	32
2408    3675  25        		.byte	37
2409    3676  6C        		.byte	108
2410    3677  75        		.byte	117
2411    3678  20        		.byte	32
2412    3679  5B        		.byte	91
2413    367A  25        		.byte	37
2414    367B  30        		.byte	48
2415    367C  38        		.byte	56
2416    367D  6C        		.byte	108
2417    367E  78        		.byte	120
2418    367F  5D        		.byte	93
2419    3680  0A        		.byte	10
2420    3681  00        		.byte	0
2421                    	L5642:
2422    3682  20        		.byte	32
2423    3683  20        		.byte	32
2424    3684  70        		.byte	112
2425    3685  61        		.byte	97
2426    3686  72        		.byte	114
2427    3687  74        		.byte	116
2428    3688  69        		.byte	105
2429    3689  74        		.byte	116
2430    368A  69        		.byte	105
2431    368B  6F        		.byte	111
2432    368C  6E        		.byte	110
2433    368D  20        		.byte	32
2434    368E  73        		.byte	115
2435    368F  69        		.byte	105
2436    3690  7A        		.byte	122
2437    3691  65        		.byte	101
2438    3692  20        		.byte	32
2439    3693  4C        		.byte	76
2440    3694  42        		.byte	66
2441    3695  41        		.byte	65
2442    3696  3A        		.byte	58
2443    3697  20        		.byte	32
2444    3698  25        		.byte	37
2445    3699  6C        		.byte	108
2446    369A  75        		.byte	117
2447    369B  20        		.byte	32
2448    369C  5B        		.byte	91
2449    369D  25        		.byte	37
2450    369E  30        		.byte	48
2451    369F  38        		.byte	56
2452    36A0  6C        		.byte	108
2453    36A1  78        		.byte	120
2454    36A2  5D        		.byte	93
2455    36A3  2C        		.byte	44
2456    36A4  20        		.byte	32
2457    36A5  25        		.byte	37
2458    36A6  6C        		.byte	108
2459    36A7  75        		.byte	117
2460    36A8  20        		.byte	32
2461    36A9  4D        		.byte	77
2462    36AA  42        		.byte	66
2463    36AB  79        		.byte	121
2464    36AC  74        		.byte	116
2465    36AD  65        		.byte	101
2466    36AE  0A        		.byte	10
2467    36AF  00        		.byte	0
2468                    	L5742:
2469    36B0  47        		.byte	71
2470    36B1  54        		.byte	84
2471    36B2  50        		.byte	80
2472    36B3  20        		.byte	32
2473    36B4  70        		.byte	112
2474    36B5  61        		.byte	97
2475    36B6  72        		.byte	114
2476    36B7  74        		.byte	116
2477    36B8  69        		.byte	105
2478    36B9  74        		.byte	116
2479    36BA  69        		.byte	105
2480    36BB  6F        		.byte	111
2481    36BC  6E        		.byte	110
2482    36BD  73        		.byte	115
2483    36BE  0A        		.byte	10
2484    36BF  00        		.byte	0
2485                    	L261:
2486    36C0  00        		.byte	0
2487    36C1  00        		.byte	0
2488    36C2  00        		.byte	0
2489    36C3  00        		.byte	0
2490                    	L5052:
2491    36C4  20        		.byte	32
2492    36C5  20        		.byte	32
2493    36C6  63        		.byte	99
2494    36C7  61        		.byte	97
2495    36C8  6E        		.byte	110
2496    36C9  27        		.byte	39
2497    36CA  74        		.byte	116
2498    36CB  20        		.byte	32
2499    36CC  72        		.byte	114
2500    36CD  65        		.byte	101
2501    36CE  61        		.byte	97
2502    36CF  64        		.byte	100
2503    36D0  20        		.byte	32
2504    36D1  4D        		.byte	77
2505    36D2  42        		.byte	66
2506    36D3  52        		.byte	82
2507    36D4  20        		.byte	32
2508    36D5  6F        		.byte	111
2509    36D6  6E        		.byte	110
2510    36D7  20        		.byte	32
2511    36D8  73        		.byte	115
2512    36D9  65        		.byte	101
2513    36DA  63        		.byte	99
2514    36DB  74        		.byte	116
2515    36DC  6F        		.byte	111
2516    36DD  72        		.byte	114
2517    36DE  20        		.byte	32
2518    36DF  30        		.byte	48
2519    36E0  0A        		.byte	10
2520    36E1  00        		.byte	0
2521                    	; 1284  
2522                    	; 1285  /* Analyze and print MBR partition entry
2523                    	; 1286   * Returns:
2524                    	; 1287   *    -1 if errror - should not happen
2525                    	; 1288   *     0 if not used entry
2526                    	; 1289   *     1 if MBR entry
2527                    	; 1290   *     2 if EBR entry
2528                    	; 1291   *     3 if GTP entry
2529                    	; 1292   */
2530                    	; 1293  int sdmbrentry(unsigned char *partptr)
2531                    	; 1294      {
2532                    	_sdmbrentry:
2533    36E2  CD0000    		call	c.savs
2534    36E5  21EEFF    		ld	hl,65518
2535    36E8  39        		add	hl,sp
2536    36E9  F9        		ld	sp,hl
2537                    	; 1295      int index;
2538                    	; 1296      int parttype;
2539                    	; 1297      unsigned long lbastart;
2540                    	; 1298      unsigned long lbasize;
2541                    	; 1299  
2542                    	; 1300      parttype = PARTMBR;
2543    36EA  DD36F601  		ld	(ix-10),1
2544    36EE  DD36F700  		ld	(ix-9),0
2545                    	; 1301      if (!partptr[4])
2546    36F2  DD6E04    		ld	l,(ix+4)
2547    36F5  DD6605    		ld	h,(ix+5)
2548    36F8  23        		inc	hl
2549    36F9  23        		inc	hl
2550    36FA  23        		inc	hl
2551    36FB  23        		inc	hl
2552    36FC  7E        		ld	a,(hl)
2553    36FD  B7        		or	a
2554    36FE  2013      		jr	nz,L1305
2555                    	; 1302          {
2556                    	; 1303          if (sdtestflg)
2557    3700  2A0000    		ld	hl,(_sdtestflg)
2558    3703  7C        		ld	a,h
2559    3704  B5        		or	l
2560    3705  2806      		jr	z,L1405
2561                    	; 1304              {
2562                    	; 1305              printf("Not used entry\n");
2563    3707  215135    		ld	hl,L5732
2564    370A  CD0000    		call	_printf
2565                    	L1405:
2566                    	; 1306              } /* sdtestflg */
2567                    	; 1307          return (PARTZRO);
2568    370D  010000    		ld	bc,0
2569    3710  C30000    		jp	c.rets
2570                    	L1305:
2571                    	; 1308          }
2572                    	; 1309      if (sdtestflg)
2573    3713  2A0000    		ld	hl,(_sdtestflg)
2574    3716  7C        		ld	a,h
2575    3717  B5        		or	l
2576    3718  CA7038    		jp	z,L1505
2577                    	; 1310          {
2578                    	; 1311          printf("Boot indicator: 0x%02x, System ID: 0x%02x\n",
2579                    	; 1312                 partptr[0], partptr[4]);
2580    371B  DD6E04    		ld	l,(ix+4)
2581    371E  DD6605    		ld	h,(ix+5)
2582    3721  23        		inc	hl
2583    3722  23        		inc	hl
2584    3723  23        		inc	hl
2585    3724  23        		inc	hl
2586    3725  4E        		ld	c,(hl)
2587    3726  97        		sub	a
2588    3727  47        		ld	b,a
2589    3728  C5        		push	bc
2590    3729  DD6E04    		ld	l,(ix+4)
2591    372C  DD6605    		ld	h,(ix+5)
2592    372F  4E        		ld	c,(hl)
2593    3730  97        		sub	a
2594    3731  47        		ld	b,a
2595    3732  C5        		push	bc
2596    3733  216135    		ld	hl,L5042
2597    3736  CD0000    		call	_printf
2598    3739  F1        		pop	af
2599    373A  F1        		pop	af
2600                    	; 1313  
2601                    	; 1314          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f))
2602    373B  DD6E04    		ld	l,(ix+4)
2603    373E  DD6605    		ld	h,(ix+5)
2604    3741  23        		inc	hl
2605    3742  23        		inc	hl
2606    3743  23        		inc	hl
2607    3744  23        		inc	hl
2608    3745  7E        		ld	a,(hl)
2609    3746  FE05      		cp	5
2610    3748  280F      		jr	z,L1705
2611    374A  DD6E04    		ld	l,(ix+4)
2612    374D  DD6605    		ld	h,(ix+5)
2613    3750  23        		inc	hl
2614    3751  23        		inc	hl
2615    3752  23        		inc	hl
2616    3753  23        		inc	hl
2617    3754  7E        		ld	a,(hl)
2618    3755  FE0F      		cp	15
2619    3757  2006      		jr	nz,L1605
2620                    	L1705:
2621                    	; 1315              {
2622                    	; 1316              printf("  Extended partition entry\n");
2623    3759  218C35    		ld	hl,L5142
2624    375C  CD0000    		call	_printf
2625                    	L1605:
2626                    	; 1317              }
2627                    	; 1318          if (partptr[0] & 0x01)
2628    375F  DD6E04    		ld	l,(ix+4)
2629    3762  DD6605    		ld	h,(ix+5)
2630    3765  7E        		ld	a,(hl)
2631    3766  CB47      		bit	0,a
2632    3768  6F        		ld	l,a
2633    3769  2809      		jr	z,L1015
2634                    	; 1319              {
2635                    	; 1320              printf("  Unofficial 48 bit LBA Proposed MBR Format, no CHS\n");
2636    376B  21A835    		ld	hl,L5242
2637    376E  CD0000    		call	_printf
2638                    	; 1321              /* this is however discussed
2639                    	; 1322                 https://wiki.osdev.org/Partition_Table#.22Unofficial.22_48_bit_LBA_Proposed_MBR_Format
2640                    	; 1323              */
2641                    	; 1324              }
2642                    	; 1325          else
2643    3771  C37038    		jp	L1505
2644                    	L1015:
2645                    	; 1326              {
2646                    	; 1327              printf("  begin CHS: 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
2647                    	; 1328                     partptr[1], partptr[2], partptr[3],
2648                    	; 1329                     ((partptr[2] & 0xc0) >> 2) + partptr[3],
2649                    	; 1330                     partptr[1],
2650                    	; 1331                     partptr[2] & 0x3f);
2651    3774  DD6E04    		ld	l,(ix+4)
2652    3777  DD6605    		ld	h,(ix+5)
2653    377A  23        		inc	hl
2654    377B  23        		inc	hl
2655    377C  6E        		ld	l,(hl)
2656    377D  97        		sub	a
2657    377E  67        		ld	h,a
2658    377F  7D        		ld	a,l
2659    3780  E63F      		and	63
2660    3782  6F        		ld	l,a
2661    3783  97        		sub	a
2662    3784  67        		ld	h,a
2663    3785  E5        		push	hl
2664    3786  DD6E04    		ld	l,(ix+4)
2665    3789  DD6605    		ld	h,(ix+5)
2666    378C  23        		inc	hl
2667    378D  4E        		ld	c,(hl)
2668    378E  97        		sub	a
2669    378F  47        		ld	b,a
2670    3790  C5        		push	bc
2671    3791  DD6E04    		ld	l,(ix+4)
2672    3794  DD6605    		ld	h,(ix+5)
2673    3797  23        		inc	hl
2674    3798  23        		inc	hl
2675    3799  6E        		ld	l,(hl)
2676    379A  97        		sub	a
2677    379B  67        		ld	h,a
2678    379C  7D        		ld	a,l
2679    379D  E6C0      		and	192
2680    379F  6F        		ld	l,a
2681    37A0  97        		sub	a
2682    37A1  67        		ld	h,a
2683    37A2  E5        		push	hl
2684    37A3  210200    		ld	hl,2
2685    37A6  E5        		push	hl
2686    37A7  CD0000    		call	c.irsh
2687    37AA  E1        		pop	hl
2688    37AB  E5        		push	hl
2689    37AC  DD6E04    		ld	l,(ix+4)
2690    37AF  DD6605    		ld	h,(ix+5)
2691    37B2  23        		inc	hl
2692    37B3  23        		inc	hl
2693    37B4  23        		inc	hl
2694    37B5  6E        		ld	l,(hl)
2695    37B6  97        		sub	a
2696    37B7  67        		ld	h,a
2697    37B8  E3        		ex	(sp),hl
2698    37B9  C1        		pop	bc
2699    37BA  09        		add	hl,bc
2700    37BB  E5        		push	hl
2701    37BC  DD6E04    		ld	l,(ix+4)
2702    37BF  DD6605    		ld	h,(ix+5)
2703    37C2  23        		inc	hl
2704    37C3  23        		inc	hl
2705    37C4  23        		inc	hl
2706    37C5  4E        		ld	c,(hl)
2707    37C6  97        		sub	a
2708    37C7  47        		ld	b,a
2709    37C8  C5        		push	bc
2710    37C9  DD6E04    		ld	l,(ix+4)
2711    37CC  DD6605    		ld	h,(ix+5)
2712    37CF  23        		inc	hl
2713    37D0  23        		inc	hl
2714    37D1  4E        		ld	c,(hl)
2715    37D2  97        		sub	a
2716    37D3  47        		ld	b,a
2717    37D4  C5        		push	bc
2718    37D5  DD6E04    		ld	l,(ix+4)
2719    37D8  DD6605    		ld	h,(ix+5)
2720    37DB  23        		inc	hl
2721    37DC  4E        		ld	c,(hl)
2722    37DD  97        		sub	a
2723    37DE  47        		ld	b,a
2724    37DF  C5        		push	bc
2725    37E0  21DD35    		ld	hl,L5342
2726    37E3  CD0000    		call	_printf
2727    37E6  210C00    		ld	hl,12
2728    37E9  39        		add	hl,sp
2729    37EA  F9        		ld	sp,hl
2730                    	; 1332              printf("  end CHS 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
2731                    	; 1333                     partptr[5], partptr[6], partptr[7],
2732                    	; 1334                     ((partptr[6] & 0xc0) >> 2) + partptr[7],
2733                    	; 1335                     partptr[5],
2734                    	; 1336                     partptr[6] & 0x3f);
2735    37EB  DD6E04    		ld	l,(ix+4)
2736    37EE  DD6605    		ld	h,(ix+5)
2737    37F1  010600    		ld	bc,6
2738    37F4  09        		add	hl,bc
2739    37F5  6E        		ld	l,(hl)
2740    37F6  97        		sub	a
2741    37F7  67        		ld	h,a
2742    37F8  7D        		ld	a,l
2743    37F9  E63F      		and	63
2744    37FB  6F        		ld	l,a
2745    37FC  97        		sub	a
2746    37FD  67        		ld	h,a
2747    37FE  E5        		push	hl
2748    37FF  DD6E04    		ld	l,(ix+4)
2749    3802  DD6605    		ld	h,(ix+5)
2750    3805  010500    		ld	bc,5
2751    3808  09        		add	hl,bc
2752    3809  4E        		ld	c,(hl)
2753    380A  97        		sub	a
2754    380B  47        		ld	b,a
2755    380C  C5        		push	bc
2756    380D  DD6E04    		ld	l,(ix+4)
2757    3810  DD6605    		ld	h,(ix+5)
2758    3813  010600    		ld	bc,6
2759    3816  09        		add	hl,bc
2760    3817  6E        		ld	l,(hl)
2761    3818  97        		sub	a
2762    3819  67        		ld	h,a
2763    381A  7D        		ld	a,l
2764    381B  E6C0      		and	192
2765    381D  6F        		ld	l,a
2766    381E  97        		sub	a
2767    381F  67        		ld	h,a
2768    3820  E5        		push	hl
2769    3821  210200    		ld	hl,2
2770    3824  E5        		push	hl
2771    3825  CD0000    		call	c.irsh
2772    3828  E1        		pop	hl
2773    3829  E5        		push	hl
2774    382A  DD6E04    		ld	l,(ix+4)
2775    382D  DD6605    		ld	h,(ix+5)
2776    3830  010700    		ld	bc,7
2777    3833  09        		add	hl,bc
2778    3834  6E        		ld	l,(hl)
2779    3835  97        		sub	a
2780    3836  67        		ld	h,a
2781    3837  E3        		ex	(sp),hl
2782    3838  C1        		pop	bc
2783    3839  09        		add	hl,bc
2784    383A  E5        		push	hl
2785    383B  DD6E04    		ld	l,(ix+4)
2786    383E  DD6605    		ld	h,(ix+5)
2787    3841  010700    		ld	bc,7
2788    3844  09        		add	hl,bc
2789    3845  4E        		ld	c,(hl)
2790    3846  97        		sub	a
2791    3847  47        		ld	b,a
2792    3848  C5        		push	bc
2793    3849  DD6E04    		ld	l,(ix+4)
2794    384C  DD6605    		ld	h,(ix+5)
2795    384F  010600    		ld	bc,6
2796    3852  09        		add	hl,bc
2797    3853  4E        		ld	c,(hl)
2798    3854  97        		sub	a
2799    3855  47        		ld	b,a
2800    3856  C5        		push	bc
2801    3857  DD6E04    		ld	l,(ix+4)
2802    385A  DD6605    		ld	h,(ix+5)
2803    385D  010500    		ld	bc,5
2804    3860  09        		add	hl,bc
2805    3861  4E        		ld	c,(hl)
2806    3862  97        		sub	a
2807    3863  47        		ld	b,a
2808    3864  C5        		push	bc
2809    3865  211F36    		ld	hl,L5442
2810    3868  CD0000    		call	_printf
2811    386B  210C00    		ld	hl,12
2812    386E  39        		add	hl,sp
2813    386F  F9        		ld	sp,hl
2814                    	L1505:
2815                    	; 1337              }
2816                    	; 1338          } /* sdtestflg */
2817                    	; 1339      /* not showing high 16 bits if 48 bit LBA */
2818                    	; 1340      lbastart = (unsigned long)partptr[8] +
2819                    	; 1341                 ((unsigned long)partptr[9] << 8) +
2820                    	; 1342                 ((unsigned long)partptr[10] << 16) +
2821                    	; 1343                 ((unsigned long)partptr[11] << 24);
2822    3870  DDE5      		push	ix
2823    3872  C1        		pop	bc
2824    3873  21F2FF    		ld	hl,65522
2825    3876  09        		add	hl,bc
2826    3877  E5        		push	hl
2827    3878  DD6E04    		ld	l,(ix+4)
2828    387B  DD6605    		ld	h,(ix+5)
2829    387E  010800    		ld	bc,8
2830    3881  09        		add	hl,bc
2831    3882  4D        		ld	c,l
2832    3883  44        		ld	b,h
2833    3884  97        		sub	a
2834    3885  320000    		ld	(c.r0),a
2835    3888  320100    		ld	(c.r0+1),a
2836    388B  0A        		ld	a,(bc)
2837    388C  320200    		ld	(c.r0+2),a
2838    388F  97        		sub	a
2839    3890  320300    		ld	(c.r0+3),a
2840    3893  210000    		ld	hl,c.r0
2841    3896  E5        		push	hl
2842    3897  DD6E04    		ld	l,(ix+4)
2843    389A  DD6605    		ld	h,(ix+5)
2844    389D  010900    		ld	bc,9
2845    38A0  09        		add	hl,bc
2846    38A1  4D        		ld	c,l
2847    38A2  44        		ld	b,h
2848    38A3  97        		sub	a
2849    38A4  320000    		ld	(c.r1),a
2850    38A7  320100    		ld	(c.r1+1),a
2851    38AA  0A        		ld	a,(bc)
2852    38AB  320200    		ld	(c.r1+2),a
2853    38AE  97        		sub	a
2854    38AF  320300    		ld	(c.r1+3),a
2855    38B2  210000    		ld	hl,c.r1
2856    38B5  E5        		push	hl
2857    38B6  210800    		ld	hl,8
2858    38B9  E5        		push	hl
2859    38BA  CD0000    		call	c.llsh
2860    38BD  CD0000    		call	c.ladd
2861    38C0  DD6E04    		ld	l,(ix+4)
2862    38C3  DD6605    		ld	h,(ix+5)
2863    38C6  010A00    		ld	bc,10
2864    38C9  09        		add	hl,bc
2865    38CA  4D        		ld	c,l
2866    38CB  44        		ld	b,h
2867    38CC  97        		sub	a
2868    38CD  320000    		ld	(c.r1),a
2869    38D0  320100    		ld	(c.r1+1),a
2870    38D3  0A        		ld	a,(bc)
2871    38D4  320200    		ld	(c.r1+2),a
2872    38D7  97        		sub	a
2873    38D8  320300    		ld	(c.r1+3),a
2874    38DB  210000    		ld	hl,c.r1
2875    38DE  E5        		push	hl
2876    38DF  211000    		ld	hl,16
2877    38E2  E5        		push	hl
2878    38E3  CD0000    		call	c.llsh
2879    38E6  CD0000    		call	c.ladd
2880    38E9  DD6E04    		ld	l,(ix+4)
2881    38EC  DD6605    		ld	h,(ix+5)
2882    38EF  010B00    		ld	bc,11
2883    38F2  09        		add	hl,bc
2884    38F3  4D        		ld	c,l
2885    38F4  44        		ld	b,h
2886    38F5  97        		sub	a
2887    38F6  320000    		ld	(c.r1),a
2888    38F9  320100    		ld	(c.r1+1),a
2889    38FC  0A        		ld	a,(bc)
2890    38FD  320200    		ld	(c.r1+2),a
2891    3900  97        		sub	a
2892    3901  320300    		ld	(c.r1+3),a
2893    3904  210000    		ld	hl,c.r1
2894    3907  E5        		push	hl
2895    3908  211800    		ld	hl,24
2896    390B  E5        		push	hl
2897    390C  CD0000    		call	c.llsh
2898    390F  CD0000    		call	c.ladd
2899    3912  CD0000    		call	c.mvl
2900    3915  F1        		pop	af
2901                    	; 1344      lbasize = (unsigned long)partptr[12] +
2902                    	; 1345                ((unsigned long)partptr[13] << 8) +
2903                    	; 1346                ((unsigned long)partptr[14] << 16) +
2904                    	; 1347                ((unsigned long)partptr[15] << 24);
2905    3916  DDE5      		push	ix
2906    3918  C1        		pop	bc
2907    3919  21EEFF    		ld	hl,65518
2908    391C  09        		add	hl,bc
2909    391D  E5        		push	hl
2910    391E  DD6E04    		ld	l,(ix+4)
2911    3921  DD6605    		ld	h,(ix+5)
2912    3924  010C00    		ld	bc,12
2913    3927  09        		add	hl,bc
2914    3928  4D        		ld	c,l
2915    3929  44        		ld	b,h
2916    392A  97        		sub	a
2917    392B  320000    		ld	(c.r0),a
2918    392E  320100    		ld	(c.r0+1),a
2919    3931  0A        		ld	a,(bc)
2920    3932  320200    		ld	(c.r0+2),a
2921    3935  97        		sub	a
2922    3936  320300    		ld	(c.r0+3),a
2923    3939  210000    		ld	hl,c.r0
2924    393C  E5        		push	hl
2925    393D  DD6E04    		ld	l,(ix+4)
2926    3940  DD6605    		ld	h,(ix+5)
2927    3943  010D00    		ld	bc,13
2928    3946  09        		add	hl,bc
2929    3947  4D        		ld	c,l
2930    3948  44        		ld	b,h
2931    3949  97        		sub	a
2932    394A  320000    		ld	(c.r1),a
2933    394D  320100    		ld	(c.r1+1),a
2934    3950  0A        		ld	a,(bc)
2935    3951  320200    		ld	(c.r1+2),a
2936    3954  97        		sub	a
2937    3955  320300    		ld	(c.r1+3),a
2938    3958  210000    		ld	hl,c.r1
2939    395B  E5        		push	hl
2940    395C  210800    		ld	hl,8
2941    395F  E5        		push	hl
2942    3960  CD0000    		call	c.llsh
2943    3963  CD0000    		call	c.ladd
2944    3966  DD6E04    		ld	l,(ix+4)
2945    3969  DD6605    		ld	h,(ix+5)
2946    396C  010E00    		ld	bc,14
2947    396F  09        		add	hl,bc
2948    3970  4D        		ld	c,l
2949    3971  44        		ld	b,h
2950    3972  97        		sub	a
2951    3973  320000    		ld	(c.r1),a
2952    3976  320100    		ld	(c.r1+1),a
2953    3979  0A        		ld	a,(bc)
2954    397A  320200    		ld	(c.r1+2),a
2955    397D  97        		sub	a
2956    397E  320300    		ld	(c.r1+3),a
2957    3981  210000    		ld	hl,c.r1
2958    3984  E5        		push	hl
2959    3985  211000    		ld	hl,16
2960    3988  E5        		push	hl
2961    3989  CD0000    		call	c.llsh
2962    398C  CD0000    		call	c.ladd
2963    398F  DD6E04    		ld	l,(ix+4)
2964    3992  DD6605    		ld	h,(ix+5)
2965    3995  010F00    		ld	bc,15
2966    3998  09        		add	hl,bc
2967    3999  4D        		ld	c,l
2968    399A  44        		ld	b,h
2969    399B  97        		sub	a
2970    399C  320000    		ld	(c.r1),a
2971    399F  320100    		ld	(c.r1+1),a
2972    39A2  0A        		ld	a,(bc)
2973    39A3  320200    		ld	(c.r1+2),a
2974    39A6  97        		sub	a
2975    39A7  320300    		ld	(c.r1+3),a
2976    39AA  210000    		ld	hl,c.r1
2977    39AD  E5        		push	hl
2978    39AE  211800    		ld	hl,24
2979    39B1  E5        		push	hl
2980    39B2  CD0000    		call	c.llsh
2981    39B5  CD0000    		call	c.ladd
2982    39B8  CD0000    		call	c.mvl
2983    39BB  F1        		pop	af
2984                    	; 1348  
2985                    	; 1349      if (!(partptr[4] == 0xee)) /* not pointing to a GPT partition */
2986    39BC  DD6E04    		ld	l,(ix+4)
2987    39BF  DD6605    		ld	h,(ix+5)
2988    39C2  23        		inc	hl
2989    39C3  23        		inc	hl
2990    39C4  23        		inc	hl
2991    39C5  23        		inc	hl
2992    39C6  7E        		ld	a,(hl)
2993    39C7  FEEE      		cp	238
2994    39C9  CA463C    		jp	z,L1215
2995                    	; 1350          {
2996                    	; 1351          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f)) /* EBR partition */
2997    39CC  DD6E04    		ld	l,(ix+4)
2998    39CF  DD6605    		ld	h,(ix+5)
2999    39D2  23        		inc	hl
3000    39D3  23        		inc	hl
3001    39D4  23        		inc	hl
3002    39D5  23        		inc	hl
3003    39D6  7E        		ld	a,(hl)
3004    39D7  FE05      		cp	5
3005    39D9  2810      		jr	z,L1415
3006    39DB  DD6E04    		ld	l,(ix+4)
3007    39DE  DD6605    		ld	h,(ix+5)
3008    39E1  23        		inc	hl
3009    39E2  23        		inc	hl
3010    39E3  23        		inc	hl
3011    39E4  23        		inc	hl
3012    39E5  7E        		ld	a,(hl)
3013    39E6  FE0F      		cp	15
3014    39E8  C2173B    		jp	nz,L1315
3015                    	L1415:
3016                    	; 1352              {
3017                    	; 1353              parttype = PARTEBR;
3018    39EB  DD36F602  		ld	(ix-10),2
3019    39EF  DD36F700  		ld	(ix-9),0
3020                    	; 1354              if (curblkno == 0) /* points to EBR in the MBR */
3021    39F3  210200    		ld	hl,_curblkno
3022    39F6  7E        		ld	a,(hl)
3023    39F7  23        		inc	hl
3024    39F8  B6        		or	(hl)
3025    39F9  23        		inc	hl
3026    39FA  B6        		or	(hl)
3027    39FB  23        		inc	hl
3028    39FC  B6        		or	(hl)
3029    39FD  C2F73A    		jp	nz,L1515
3030                    	; 1355                  {
3031                    	; 1356                  ebrnext = 0;
3032    3A00  97        		sub	a
3033    3A01  321200    		ld	(_ebrnext),a
3034    3A04  321300    		ld	(_ebrnext+1),a
3035    3A07  321400    		ld	(_ebrnext+2),a
3036    3A0A  321500    		ld	(_ebrnext+3),a
3037                    	; 1357                  dskmap[partdsk].partype = EBRCONT;
3038    3A0D  2A0E00    		ld	hl,(_partdsk)
3039    3A10  E5        		push	hl
3040    3A11  212000    		ld	hl,32
3041    3A14  E5        		push	hl
3042    3A15  CD0000    		call	c.imul
3043    3A18  E1        		pop	hl
3044    3A19  015202    		ld	bc,_dskmap
3045    3A1C  09        		add	hl,bc
3046    3A1D  3614      		ld	(hl),20
3047                    	; 1358                  dskmap[partdsk].dskletter = 'A' + partdsk;
3048    3A1F  2A0E00    		ld	hl,(_partdsk)
3049    3A22  E5        		push	hl
3050    3A23  212000    		ld	hl,32
3051    3A26  E5        		push	hl
3052    3A27  CD0000    		call	c.imul
3053    3A2A  E1        		pop	hl
3054    3A2B  015302    		ld	bc,_dskmap+1
3055    3A2E  09        		add	hl,bc
3056    3A2F  3A0E00    		ld	a,(_partdsk)
3057    3A32  C641      		add	a,65
3058    3A34  4F        		ld	c,a
3059    3A35  71        		ld	(hl),c
3060                    	; 1359                  dskmap[partdsk].dskstart = lbastart;
3061    3A36  2A0E00    		ld	hl,(_partdsk)
3062    3A39  E5        		push	hl
3063    3A3A  212000    		ld	hl,32
3064    3A3D  E5        		push	hl
3065    3A3E  CD0000    		call	c.imul
3066    3A41  E1        		pop	hl
3067    3A42  015602    		ld	bc,_dskmap+4
3068    3A45  09        		add	hl,bc
3069    3A46  E5        		push	hl
3070    3A47  DDE5      		push	ix
3071    3A49  C1        		pop	bc
3072    3A4A  21F2FF    		ld	hl,65522
3073    3A4D  09        		add	hl,bc
3074    3A4E  E5        		push	hl
3075    3A4F  CD0000    		call	c.mvl
3076    3A52  F1        		pop	af
3077                    	; 1360                  dskmap[partdsk].dskend = lbastart + lbasize - 1;
3078    3A53  2A0E00    		ld	hl,(_partdsk)
3079    3A56  E5        		push	hl
3080    3A57  212000    		ld	hl,32
3081    3A5A  E5        		push	hl
3082    3A5B  CD0000    		call	c.imul
3083    3A5E  E1        		pop	hl
3084    3A5F  015A02    		ld	bc,_dskmap+8
3085    3A62  09        		add	hl,bc
3086    3A63  E5        		push	hl
3087    3A64  DDE5      		push	ix
3088    3A66  C1        		pop	bc
3089    3A67  21F2FF    		ld	hl,65522
3090    3A6A  09        		add	hl,bc
3091    3A6B  CD0000    		call	c.0mvf
3092    3A6E  210000    		ld	hl,c.r0
3093    3A71  E5        		push	hl
3094    3A72  DDE5      		push	ix
3095    3A74  C1        		pop	bc
3096    3A75  21EEFF    		ld	hl,65518
3097    3A78  09        		add	hl,bc
3098    3A79  E5        		push	hl
3099    3A7A  CD0000    		call	c.ladd
3100    3A7D  3EFF      		ld	a,255
3101    3A7F  320200    		ld	(c.r1+2),a
3102    3A82  87        		add	a,a
3103    3A83  9F        		sbc	a,a
3104    3A84  320300    		ld	(c.r1+3),a
3105    3A87  320100    		ld	(c.r1+1),a
3106    3A8A  320000    		ld	(c.r1),a
3107    3A8D  210000    		ld	hl,c.r1
3108    3A90  E5        		push	hl
3109    3A91  CD0000    		call	c.ladd
3110    3A94  CD0000    		call	c.mvl
3111    3A97  F1        		pop	af
3112                    	; 1361                  dskmap[partdsk].dsksize = lbasize;
3113    3A98  2A0E00    		ld	hl,(_partdsk)
3114    3A9B  E5        		push	hl
3115    3A9C  212000    		ld	hl,32
3116    3A9F  E5        		push	hl
3117    3AA0  CD0000    		call	c.imul
3118    3AA3  E1        		pop	hl
3119    3AA4  015E02    		ld	bc,_dskmap+12
3120    3AA7  09        		add	hl,bc
3121    3AA8  E5        		push	hl
3122    3AA9  DDE5      		push	ix
3123    3AAB  C1        		pop	bc
3124    3AAC  21EEFF    		ld	hl,65518
3125    3AAF  09        		add	hl,bc
3126    3AB0  E5        		push	hl
3127    3AB1  CD0000    		call	c.mvl
3128    3AB4  F1        		pop	af
3129                    	; 1362                  dskmap[partdsk].dsktype[0] = partptr[4];
3130    3AB5  2A0E00    		ld	hl,(_partdsk)
3131    3AB8  E5        		push	hl
3132    3AB9  212000    		ld	hl,32
3133    3ABC  E5        		push	hl
3134    3ABD  CD0000    		call	c.imul
3135    3AC0  E1        		pop	hl
3136    3AC1  016202    		ld	bc,_dskmap+16
3137    3AC4  09        		add	hl,bc
3138    3AC5  DD4E04    		ld	c,(ix+4)
3139    3AC8  DD4605    		ld	b,(ix+5)
3140    3ACB  03        		inc	bc
3141    3ACC  03        		inc	bc
3142    3ACD  03        		inc	bc
3143    3ACE  03        		inc	bc
3144    3ACF  0A        		ld	a,(bc)
3145    3AD0  77        		ld	(hl),a
3146                    	; 1363                  partdsk++;
3147    3AD1  2A0E00    		ld	hl,(_partdsk)
3148    3AD4  23        		inc	hl
3149    3AD5  220E00    		ld	(_partdsk),hl
3150                    	; 1364                  ebrrecs[ebrrecidx++] = lbastart; /* save to handle later */
3151    3AD8  2A1600    		ld	hl,(_ebrrecidx)
3152    3ADB  E5        		push	hl
3153    3ADC  23        		inc	hl
3154    3ADD  221600    		ld	(_ebrrecidx),hl
3155    3AE0  E1        		pop	hl
3156    3AE1  29        		add	hl,hl
3157    3AE2  29        		add	hl,hl
3158    3AE3  011800    		ld	bc,_ebrrecs
3159    3AE6  09        		add	hl,bc
3160    3AE7  E5        		push	hl
3161    3AE8  DDE5      		push	ix
3162    3AEA  C1        		pop	bc
3163    3AEB  21F2FF    		ld	hl,65522
3164    3AEE  09        		add	hl,bc
3165    3AEF  E5        		push	hl
3166    3AF0  CD0000    		call	c.mvl
3167    3AF3  F1        		pop	af
3168                    	; 1365                  }
3169                    	; 1366              else
3170    3AF4  C3463C    		jp	L1215
3171                    	L1515:
3172                    	; 1367                  {
3173                    	; 1368                  ebrnext = curblkno + lbastart;
3174    3AF7  211200    		ld	hl,_ebrnext
3175    3AFA  E5        		push	hl
3176    3AFB  210200    		ld	hl,_curblkno
3177    3AFE  CD0000    		call	c.0mvf
3178    3B01  210000    		ld	hl,c.r0
3179    3B04  E5        		push	hl
3180    3B05  DDE5      		push	ix
3181    3B07  C1        		pop	bc
3182    3B08  21F2FF    		ld	hl,65522
3183    3B0B  09        		add	hl,bc
3184    3B0C  E5        		push	hl
3185    3B0D  CD0000    		call	c.ladd
3186    3B10  CD0000    		call	c.mvl
3187    3B13  F1        		pop	af
3188    3B14  C3463C    		jp	L1215
3189                    	L1315:
3190                    	; 1369                  }
3191                    	; 1370              }
3192                    	; 1371          else
3193                    	; 1372              {
3194                    	; 1373              if (0 < lbasize) /* one more ugly hack to avoid empty partitions */
3195    3B17  DD7EEE    		ld	a,(ix-18)
3196    3B1A  DDB6EF    		or	(ix-17)
3197    3B1D  DDB6F0    		or	(ix-16)
3198    3B20  DDB6F1    		or	(ix-15)
3199    3B23  CA463C    		jp	z,L1215
3200                    	; 1374                  {
3201                    	; 1375                  if (partptr[0] & 0x80)
3202    3B26  DD6E04    		ld	l,(ix+4)
3203    3B29  DD6605    		ld	h,(ix+5)
3204    3B2C  7E        		ld	a,(hl)
3205    3B2D  CB7F      		bit	7,a
3206    3B2F  6F        		ld	l,a
3207    3B30  2815      		jr	z,L1125
3208                    	; 1376                      dskmap[partdsk].bootable = YES;
3209    3B32  2A0E00    		ld	hl,(_partdsk)
3210    3B35  E5        		push	hl
3211    3B36  212000    		ld	hl,32
3212    3B39  E5        		push	hl
3213    3B3A  CD0000    		call	c.imul
3214    3B3D  E1        		pop	hl
3215    3B3E  015402    		ld	bc,_dskmap+2
3216    3B41  09        		add	hl,bc
3217    3B42  3601      		ld	(hl),1
3218    3B44  23        		inc	hl
3219    3B45  3600      		ld	(hl),0
3220                    	L1125:
3221                    	; 1377                  if (curblkno == 0)
3222    3B47  210200    		ld	hl,_curblkno
3223    3B4A  7E        		ld	a,(hl)
3224    3B4B  23        		inc	hl
3225    3B4C  B6        		or	(hl)
3226    3B4D  23        		inc	hl
3227    3B4E  B6        		or	(hl)
3228    3B4F  23        		inc	hl
3229    3B50  B6        		or	(hl)
3230    3B51  2014      		jr	nz,L1225
3231                    	; 1378                      dskmap[partdsk].partype = PARTMBR;
3232    3B53  2A0E00    		ld	hl,(_partdsk)
3233    3B56  E5        		push	hl
3234    3B57  212000    		ld	hl,32
3235    3B5A  E5        		push	hl
3236    3B5B  CD0000    		call	c.imul
3237    3B5E  E1        		pop	hl
3238    3B5F  015202    		ld	bc,_dskmap
3239    3B62  09        		add	hl,bc
3240    3B63  3601      		ld	(hl),1
3241                    	; 1379                  else
3242    3B65  1812      		jr	L1325
3243                    	L1225:
3244                    	; 1380                      dskmap[partdsk].partype = PARTEBR;
3245    3B67  2A0E00    		ld	hl,(_partdsk)
3246    3B6A  E5        		push	hl
3247    3B6B  212000    		ld	hl,32
3248    3B6E  E5        		push	hl
3249    3B6F  CD0000    		call	c.imul
3250    3B72  E1        		pop	hl
3251    3B73  015202    		ld	bc,_dskmap
3252    3B76  09        		add	hl,bc
3253    3B77  3602      		ld	(hl),2
3254                    	L1325:
3255                    	; 1381                  dskmap[partdsk].dskletter = 'A' + partdsk;
3256    3B79  2A0E00    		ld	hl,(_partdsk)
3257    3B7C  E5        		push	hl
3258    3B7D  212000    		ld	hl,32
3259    3B80  E5        		push	hl
3260    3B81  CD0000    		call	c.imul
3261    3B84  E1        		pop	hl
3262    3B85  015302    		ld	bc,_dskmap+1
3263    3B88  09        		add	hl,bc
3264    3B89  3A0E00    		ld	a,(_partdsk)
3265    3B8C  C641      		add	a,65
3266    3B8E  4F        		ld	c,a
3267    3B8F  71        		ld	(hl),c
3268                    	; 1382                  dskmap[partdsk].dskstart = curblkno + lbastart;
3269    3B90  2A0E00    		ld	hl,(_partdsk)
3270    3B93  E5        		push	hl
3271    3B94  212000    		ld	hl,32
3272    3B97  E5        		push	hl
3273    3B98  CD0000    		call	c.imul
3274    3B9B  E1        		pop	hl
3275    3B9C  015602    		ld	bc,_dskmap+4
3276    3B9F  09        		add	hl,bc
3277    3BA0  E5        		push	hl
3278    3BA1  210200    		ld	hl,_curblkno
3279    3BA4  CD0000    		call	c.0mvf
3280    3BA7  210000    		ld	hl,c.r0
3281    3BAA  E5        		push	hl
3282    3BAB  DDE5      		push	ix
3283    3BAD  C1        		pop	bc
3284    3BAE  21F2FF    		ld	hl,65522
3285    3BB1  09        		add	hl,bc
3286    3BB2  E5        		push	hl
3287    3BB3  CD0000    		call	c.ladd
3288    3BB6  CD0000    		call	c.mvl
3289    3BB9  F1        		pop	af
3290                    	; 1383                  dskmap[partdsk].dskend = curblkno + lbastart + lbasize - 1;
3291    3BBA  2A0E00    		ld	hl,(_partdsk)
3292    3BBD  E5        		push	hl
3293    3BBE  212000    		ld	hl,32
3294    3BC1  E5        		push	hl
3295    3BC2  CD0000    		call	c.imul
3296    3BC5  E1        		pop	hl
3297    3BC6  015A02    		ld	bc,_dskmap+8
3298    3BC9  09        		add	hl,bc
3299    3BCA  E5        		push	hl
3300    3BCB  210200    		ld	hl,_curblkno
3301    3BCE  CD0000    		call	c.0mvf
3302    3BD1  210000    		ld	hl,c.r0
3303    3BD4  E5        		push	hl
3304    3BD5  DDE5      		push	ix
3305    3BD7  C1        		pop	bc
3306    3BD8  21F2FF    		ld	hl,65522
3307    3BDB  09        		add	hl,bc
3308    3BDC  E5        		push	hl
3309    3BDD  CD0000    		call	c.ladd
3310    3BE0  DDE5      		push	ix
3311    3BE2  C1        		pop	bc
3312    3BE3  21EEFF    		ld	hl,65518
3313    3BE6  09        		add	hl,bc
3314    3BE7  E5        		push	hl
3315    3BE8  CD0000    		call	c.ladd
3316    3BEB  3EFF      		ld	a,255
3317    3BED  320200    		ld	(c.r1+2),a
3318    3BF0  87        		add	a,a
3319    3BF1  9F        		sbc	a,a
3320    3BF2  320300    		ld	(c.r1+3),a
3321    3BF5  320100    		ld	(c.r1+1),a
3322    3BF8  320000    		ld	(c.r1),a
3323    3BFB  210000    		ld	hl,c.r1
3324    3BFE  E5        		push	hl
3325    3BFF  CD0000    		call	c.ladd
3326    3C02  CD0000    		call	c.mvl
3327    3C05  F1        		pop	af
3328                    	; 1384                  dskmap[partdsk].dsksize = lbasize;
3329    3C06  2A0E00    		ld	hl,(_partdsk)
3330    3C09  E5        		push	hl
3331    3C0A  212000    		ld	hl,32
3332    3C0D  E5        		push	hl
3333    3C0E  CD0000    		call	c.imul
3334    3C11  E1        		pop	hl
3335    3C12  015E02    		ld	bc,_dskmap+12
3336    3C15  09        		add	hl,bc
3337    3C16  E5        		push	hl
3338    3C17  DDE5      		push	ix
3339    3C19  C1        		pop	bc
3340    3C1A  21EEFF    		ld	hl,65518
3341    3C1D  09        		add	hl,bc
3342    3C1E  E5        		push	hl
3343    3C1F  CD0000    		call	c.mvl
3344    3C22  F1        		pop	af
3345                    	; 1385                  dskmap[partdsk].dsktype[0] = partptr[4];
3346    3C23  2A0E00    		ld	hl,(_partdsk)
3347    3C26  E5        		push	hl
3348    3C27  212000    		ld	hl,32
3349    3C2A  E5        		push	hl
3350    3C2B  CD0000    		call	c.imul
3351    3C2E  E1        		pop	hl
3352    3C2F  016202    		ld	bc,_dskmap+16
3353    3C32  09        		add	hl,bc
3354    3C33  DD4E04    		ld	c,(ix+4)
3355    3C36  DD4605    		ld	b,(ix+5)
3356    3C39  03        		inc	bc
3357    3C3A  03        		inc	bc
3358    3C3B  03        		inc	bc
3359    3C3C  03        		inc	bc
3360    3C3D  0A        		ld	a,(bc)
3361    3C3E  77        		ld	(hl),a
3362                    	; 1386                  partdsk++;
3363    3C3F  2A0E00    		ld	hl,(_partdsk)
3364    3C42  23        		inc	hl
3365    3C43  220E00    		ld	(_partdsk),hl
3366                    	L1215:
3367                    	; 1387                  }
3368                    	; 1388              }
3369                    	; 1389          }
3370                    	; 1390  
3371                    	; 1391      if (sdtestflg)
3372    3C46  2A0000    		ld	hl,(_sdtestflg)
3373    3C49  7C        		ld	a,h
3374    3C4A  B5        		or	l
3375    3C4B  CAE83C    		jp	z,L1425
3376                    	; 1392          {
3377                    	; 1393          printf("  partition start LBA: %lu [%08lx]\n",
3378                    	; 1394                 curblkno + lbastart, curblkno + lbastart);
3379    3C4E  210200    		ld	hl,_curblkno
3380    3C51  CD0000    		call	c.0mvf
3381    3C54  210000    		ld	hl,c.r0
3382    3C57  E5        		push	hl
3383    3C58  DDE5      		push	ix
3384    3C5A  C1        		pop	bc
3385    3C5B  21F2FF    		ld	hl,65522
3386    3C5E  09        		add	hl,bc
3387    3C5F  E5        		push	hl
3388    3C60  CD0000    		call	c.ladd
3389    3C63  E1        		pop	hl
3390    3C64  23        		inc	hl
3391    3C65  23        		inc	hl
3392    3C66  4E        		ld	c,(hl)
3393    3C67  23        		inc	hl
3394    3C68  46        		ld	b,(hl)
3395    3C69  C5        		push	bc
3396    3C6A  2B        		dec	hl
3397    3C6B  2B        		dec	hl
3398    3C6C  2B        		dec	hl
3399    3C6D  4E        		ld	c,(hl)
3400    3C6E  23        		inc	hl
3401    3C6F  46        		ld	b,(hl)
3402    3C70  C5        		push	bc
3403    3C71  210200    		ld	hl,_curblkno
3404    3C74  CD0000    		call	c.0mvf
3405    3C77  210000    		ld	hl,c.r0
3406    3C7A  E5        		push	hl
3407    3C7B  DDE5      		push	ix
3408    3C7D  C1        		pop	bc
3409    3C7E  21F2FF    		ld	hl,65522
3410    3C81  09        		add	hl,bc
3411    3C82  E5        		push	hl
3412    3C83  CD0000    		call	c.ladd
3413    3C86  E1        		pop	hl
3414    3C87  23        		inc	hl
3415    3C88  23        		inc	hl
3416    3C89  4E        		ld	c,(hl)
3417    3C8A  23        		inc	hl
3418    3C8B  46        		ld	b,(hl)
3419    3C8C  C5        		push	bc
3420    3C8D  2B        		dec	hl
3421    3C8E  2B        		dec	hl
3422    3C8F  2B        		dec	hl
3423    3C90  4E        		ld	c,(hl)
3424    3C91  23        		inc	hl
3425    3C92  46        		ld	b,(hl)
3426    3C93  C5        		push	bc
3427    3C94  215E36    		ld	hl,L5542
3428    3C97  CD0000    		call	_printf
3429    3C9A  F1        		pop	af
3430    3C9B  F1        		pop	af
3431    3C9C  F1        		pop	af
3432    3C9D  F1        		pop	af
3433                    	; 1395          printf("  partition size LBA: %lu [%08lx], %lu MByte\n",
3434                    	; 1396                 lbasize, lbasize, lbasize >> 11);
3435    3C9E  DDE5      		push	ix
3436    3CA0  C1        		pop	bc
3437    3CA1  21EEFF    		ld	hl,65518
3438    3CA4  09        		add	hl,bc
3439    3CA5  CD0000    		call	c.0mvf
3440    3CA8  210000    		ld	hl,c.r0
3441    3CAB  E5        		push	hl
3442    3CAC  210B00    		ld	hl,11
3443    3CAF  E5        		push	hl
3444    3CB0  CD0000    		call	c.ulrsh
3445    3CB3  E1        		pop	hl
3446    3CB4  23        		inc	hl
3447    3CB5  23        		inc	hl
3448    3CB6  4E        		ld	c,(hl)
3449    3CB7  23        		inc	hl
3450    3CB8  46        		ld	b,(hl)
3451    3CB9  C5        		push	bc
3452    3CBA  2B        		dec	hl
3453    3CBB  2B        		dec	hl
3454    3CBC  2B        		dec	hl
3455    3CBD  4E        		ld	c,(hl)
3456    3CBE  23        		inc	hl
3457    3CBF  46        		ld	b,(hl)
3458    3CC0  C5        		push	bc
3459    3CC1  DD66F1    		ld	h,(ix-15)
3460    3CC4  DD6EF0    		ld	l,(ix-16)
3461    3CC7  E5        		push	hl
3462    3CC8  DD66EF    		ld	h,(ix-17)
3463    3CCB  DD6EEE    		ld	l,(ix-18)
3464    3CCE  E5        		push	hl
3465    3CCF  DD66F1    		ld	h,(ix-15)
3466    3CD2  DD6EF0    		ld	l,(ix-16)
3467    3CD5  E5        		push	hl
3468    3CD6  DD66EF    		ld	h,(ix-17)
3469    3CD9  DD6EEE    		ld	l,(ix-18)
3470    3CDC  E5        		push	hl
3471    3CDD  218236    		ld	hl,L5642
3472    3CE0  CD0000    		call	_printf
3473    3CE3  210C00    		ld	hl,12
3474    3CE6  39        		add	hl,sp
3475    3CE7  F9        		ld	sp,hl
3476                    	L1425:
3477                    	; 1397          } /* sdtestflg */
3478                    	; 1398      if (partptr[4] == 0xee) /* GPT partitions */
3479    3CE8  DD6E04    		ld	l,(ix+4)
3480    3CEB  DD6605    		ld	h,(ix+5)
3481    3CEE  23        		inc	hl
3482    3CEF  23        		inc	hl
3483    3CF0  23        		inc	hl
3484    3CF1  23        		inc	hl
3485    3CF2  7E        		ld	a,(hl)
3486    3CF3  FEEE      		cp	238
3487    3CF5  C25E3D    		jp	nz,L1525
3488                    	; 1399          {
3489                    	; 1400          parttype = PARTGPT;
3490    3CF8  DD36F603  		ld	(ix-10),3
3491    3CFC  DD36F700  		ld	(ix-9),0
3492                    	; 1401          if (sdtestflg)
3493    3D00  2A0000    		ld	hl,(_sdtestflg)
3494    3D03  7C        		ld	a,h
3495    3D04  B5        		or	l
3496    3D05  2806      		jr	z,L1625
3497                    	; 1402              {
3498                    	; 1403              printf("GTP partitions\n");
3499    3D07  21B036    		ld	hl,L5742
3500    3D0A  CD0000    		call	_printf
3501                    	L1625:
3502                    	; 1404              } /* sdtestflg */
3503                    	; 1405          sdgpthdr(lbastart); /* handle GTP partitions */
3504    3D0D  DD66F5    		ld	h,(ix-11)
3505    3D10  DD6EF4    		ld	l,(ix-12)
3506    3D13  E5        		push	hl
3507    3D14  DD66F3    		ld	h,(ix-13)
3508    3D17  DD6EF2    		ld	l,(ix-14)
3509    3D1A  CD3E33    		call	_sdgpthdr
3510    3D1D  F1        		pop	af
3511                    	; 1406          /* re-read MBR on sector 0
3512                    	; 1407             This is probably not needed as there
3513                    	; 1408             is only one entry (the first one)
3514                    	; 1409             in the MBR when using GPT */
3515                    	; 1410          if (sdread(sdrdbuf, 0))
3516    3D1E  21C336    		ld	hl,L261+3
3517    3D21  46        		ld	b,(hl)
3518    3D22  2B        		dec	hl
3519    3D23  4E        		ld	c,(hl)
3520    3D24  C5        		push	bc
3521    3D25  2B        		dec	hl
3522    3D26  46        		ld	b,(hl)
3523    3D27  2B        		dec	hl
3524    3D28  4E        		ld	c,(hl)
3525    3D29  C5        		push	bc
3526    3D2A  214C00    		ld	hl,_sdrdbuf
3527    3D2D  CDE320    		call	_sdread
3528    3D30  F1        		pop	af
3529    3D31  F1        		pop	af
3530    3D32  79        		ld	a,c
3531    3D33  B0        		or	b
3532    3D34  2815      		jr	z,L1725
3533                    	; 1411              {
3534                    	; 1412              curblkno = 0;
3535                    	; 1413              curblkok = YES;
3536    3D36  210100    		ld	hl,1
3537                    	;    1  /*  z80sdbt.c Boot and SD card test program.
3538                    	;    2   *
3539                    	;    3   *  Boot code for my DIY Z80 Computer. This
3540                    	;    4   *  program is compiled with Whitesmiths/COSMIC
3541                    	;    5   *  C compiler for Z80.
3542                    	;    6   *
3543                    	;    7   *  Initializes the hardware and detects the
3544                    	;    8   *  presence and partitioning of an attached SD card.
3545                    	;    9   *
3546                    	;   10   *  You are free to use, modify, and redistribute
3547                    	;   11   *  this source code. No warranties are given.
3548                    	;   12   *  Hastily Cobbled Together 2021 and 2022
3549                    	;   13   *  by Hans-Ake Lund
3550                    	;   14   *
3551                    	;   15   */
3552                    	;   16  
3553                    	;   17  #include <std.h>
3554                    	;   18  #include "z80computer.h"
3555                    	;   19  #include "builddate.h"
3556                    	;   20  
3557                    	;   21  /* Program name and version */
3558                    	;   22  #define PRGNAME "z80sdbt "
3559                    	;   23  #define VERSION "version 0.9, "
3560                    	;   24  /* Address in high RAM where to copy uploader */
3561                    	;   25  #define UPLADDR 0xf000
3562                    	;   26  
3563                    	;   27  /* This code should be cleaned up when
3564                    	;   28     remaining functions are implemented
3565                    	;   29   */
3566                    	;   30  #define PARTZRO 0  /* Empty partition entry */
3567                    	;   31  #define PARTMBR 1  /* MBR partition */
3568                    	;   32  #define PARTEBR 2  /* EBR logical partition */
3569                    	;   33  #define PARTGPT 3  /* GPT partition */
3570                    	;   34  #define EBRCONT 20 /* EBR container partition in MBR */
3571                    	;   35  
3572                    	;   36  struct partentry
3573                    	;   37      {
3574                    	;   38      char partype;
3575                    	;   39      char dskletter;
3576                    	;   40      int bootable;
3577                    	;   41      unsigned long dskstart;
3578                    	;   42      unsigned long dskend;
3579                    	;   43      unsigned long dsksize;
3580                    	;   44      unsigned char dsktype[16];
3581                    	;   45      } dskmap[16];
3582                    	;   46  
3583                    	;   47  unsigned char dsksign[4]; /* MBR/EBR disk signature */
3584                    	;   48  
3585                    	;   49  /* Function prototypes */
3586                    	;   50  void sdmbrpart(unsigned long);
3587                    	;   51  
3588                    	;   52  /* External data */
3589                    	;   53  extern const char upload[];
3590                    	;   54  extern const int upload_size;
3591                    	;   55  extern const int binsize;
3592                    	;   56  extern const int binstart;
3593                    	;   57  
3594                    	;   58  /* RAM/EPROM probe */
3595                    	;   59  const int ramprobe = 0;
3596                    	;   60  int *rampptr;
3597                    	;   61  
3598                    	;   62  /* Response length in bytes
3599                    	;   63   */
3600                    	;   64  #define R1_LEN 1
3601                    	;   65  #define R3_LEN 5
3602                    	;   66  #define R7_LEN 5
3603                    	;   67  
3604                    	;   68  /* The SD card commands (5 bytes) and a CRC7 byte as the last byte.
3605                    	;   69   * (The CRC7 byte in the tables below are only for information,
3606                    	;   70   * it is calculated by the sdcommand routine.)
3607                    	;   71   */
3608                    	;   72  const unsigned char cmd0[] = {0x40, 0x00, 0x00, 0x00, 0x00, 0x95};
3609                    	;   73  const unsigned char cmd8[] = {0x48, 0x00, 0x00, 0x01, 0xaa, 0x87};
3610                    	;   74  const unsigned char cmd9[] = {0x49, 0x00, 0x00, 0x00, 0x00, 0xaf};
3611                    	;   75  const unsigned char cmd10[] = {0x4a, 0x00, 0x00, 0x00, 0x00, 0x1b};
3612                    	;   76  const unsigned char cmd16[] = {0x50, 0x00, 0x00, 0x02, 0x00, 0x15};
3613                    	;   77  const unsigned char cmd17[] = {0x51, 0x00, 0x00, 0x00, 0x00, 0x55};
3614                    	;   78  const unsigned char cmd24[] = {0x58, 0x00, 0x00, 0x00, 0x00, 0x6f};
3615                    	;   79  const unsigned char cmd55[] = {0x77, 0x00, 0x00, 0x00, 0x00, 0x65};
3616                    	;   80  const unsigned char cmd58[] = {0x7a, 0x00, 0x00, 0x00, 0x00, 0xfd};
3617                    	;   81  const unsigned char acmd41[] = {0x69, 0x40, 0x00, 0x01, 0xaa, 0x33};
3618                    	;   82  
3619                    	;   83  /* Partition identifiers
3620                    	;   84   */
3621                    	;   85  /* For GPT I have decided that a CP/M partition
3622                    	;   86   * has GUID: AC7176FD-8D55-4FFF-86A5-A36D6368D0CB
3623                    	;   87   */
3624                    	;   88  const unsigned char gptcpm[] =
3625                    	;   89      {
3626                    	;   90      0xfd, 0x76, 0x71, 0xac, 0x55, 0x8d, 0xff, 0x4f,
3627                    	;   91      0x86, 0xa5, 0xa3, 0x6d, 0x63, 0x68, 0xd0, 0xcb
3628                    	;   92      };
3629                    	;   93  /* For MBR/EBR the partition type for CP/M is 0x52
3630                    	;   94   * according to: https://en.wikipedia.org/wiki/Partition_type
3631                    	;   95   */
3632                    	;   96  const unsigned char mbrcpm = 0x52;    /* CP/M partition */
3633                    	;   97  const unsigned char mbrexcode = 0x5f; /* Z80 executable code partition */
3634                    	;   98  /* has a special format that */
3635                    	;   99  /* includes number of sectors to */
3636                    	;  100  /* load and a signature, TBD */
3637                    	;  101  
3638                    	;  102  /* Buffers
3639                    	;  103   */
3640                    	;  104  unsigned char sdrdbuf[512];  /* recieved data from the SD card */
3641                    	;  105  
3642                    	;  106  unsigned char ocrreg[4];     /* SD card OCR register */
3643                    	;  107  unsigned char cidreg[16];    /* SD card CID register */
3644                    	;  108  unsigned char csdreg[16];    /* SD card CSD register */
3645                    	;  109  unsigned long ebrrecs[4];    /* detected EBR records to process */
3646                    	;  110  int ebrrecidx; /* how many EBR records that are populated */
3647                    	;  111  unsigned long ebrnext; /* next chained ebr record */
3648                    	;  112  
3649                    	;  113  /* Variables
3650                    	;  114   */
3651                    	;  115  int curblkok;  /* if YES curblockno is read into buffer */
3652                    	;  116  int partdsk;   /* partition/disk number, 0 = disk A */
3653                    	;  117  int sdinitok;  /* SD card initialized and ready */
3654                    	;  118  int sdver2;    /* SD card version 2 if YES, version 1 if NO */
3655                    	;  119  unsigned long blkmult;   /* block address multiplier */
3656                    	;  120  unsigned long curblkno;  /* block in buffer if curblkok == YES */
3657                    	;  121  
3658                    	;  122  /* debug bool */
3659                    	;  123  int sdtestflg;
3660                    	;  124  
3661                    	;  125  /* CRC routines from:
3662                    	;  126   * https://github.com/LonelyWolf/stm32/blob/master/stm32l-dosfs/sdcard.c
3663                    	;  127   */
3664                    	;  128  
3665                    	;  129  /*
3666                    	;  130  // Calculate CRC7
3667                    	;  131  // It's a 7 bit CRC with polynomial x^7 + x^3 + 1
3668                    	;  132  // input:
3669                    	;  133  //   crcIn - the CRC before (0 for first step)
3670                    	;  134  //   data - byte for CRC calculation
3671                    	;  135  // return: the new CRC7
3672                    	;  136  */
3673                    	;  137  unsigned char CRC7_one(unsigned char crcIn, unsigned char data)
3674                    	;  138      {
3675                    	;  139      const unsigned char g = 0x89;
3676                    	;  140      unsigned char i;
3677                    	;  141  
3678                    	;  142      crcIn ^= data;
3679                    	;  143      for (i = 0; i < 8; i++)
3680                    	;  144          {
3681                    	;  145          if (crcIn & 0x80) crcIn ^= g;
3682                    	;  146          crcIn <<= 1;
3683                    	;  147          }
3684                    	;  148  
3685                    	;  149      return crcIn;
3686                    	;  150      }
3687                    	;  151  
3688                    	;  152  /*
3689                    	;  153  // Calculate CRC16 CCITT
3690                    	;  154  // It's a 16 bit CRC with polynomial x^16 + x^12 + x^5 + 1
3691                    	;  155  // input:
3692                    	;  156  //   crcIn - the CRC before (0 for rist step)
3693                    	;  157  //   data - byte for CRC calculation
3694                    	;  158  // return: the CRC16 value
3695                    	;  159  */
3696                    	;  160  unsigned int CRC16_one(unsigned int crcIn, unsigned char data)
3697                    	;  161      {
3698                    	;  162      crcIn  = (unsigned char)(crcIn >> 8)|(crcIn << 8);
3699                    	;  163      crcIn ^=  data;
3700                    	;  164      crcIn ^= (unsigned char)(crcIn & 0xff) >> 4;
3701                    	;  165      crcIn ^= (crcIn << 8) << 4;
3702                    	;  166      crcIn ^= ((crcIn & 0xff) << 4) << 1;
3703                    	;  167  
3704                    	;  168      return crcIn;
3705                    	;  169      }
3706                    	;  170  
3707                    	;  171  /* Send command to SD card and recieve answer.
3708                    	;  172   * A command is 5 bytes long and is followed by
3709                    	;  173   * a CRC7 checksum byte.
3710                    	;  174   * Returns a pointer to the response
3711                    	;  175   * or 0 if no response start bit found.
3712                    	;  176   */
3713                    	;  177  unsigned char *sdcommand(unsigned char *sdcmdp,
3714                    	;  178                           unsigned char *recbuf, int recbytes)
3715                    	;  179      {
3716                    	;  180      int searchn;  /* byte counter to search for response */
3717                    	;  181      int sdcbytes; /* byte counter for bytes to send */
3718                    	;  182      unsigned char *retptr; /* pointer used to store response */
3719                    	;  183      unsigned char rbyte;   /* recieved byte */
3720                    	;  184      unsigned char crc = 0; /* calculated CRC7 */
3721                    	;  185  
3722                    	;  186      /* send 8*2 clockpules */
3723                    	;  187      spiio(0xff);
3724                    	;  188      spiio(0xff);
3725                    	;  189      for (sdcbytes = 5; 0 < sdcbytes; sdcbytes--) /* send bytes */
3726                    	;  190          {
3727                    	;  191          crc = CRC7_one(crc, *sdcmdp);
3728                    	;  192          spiio(*sdcmdp++);
3729                    	;  193          }
3730                    	;  194      spiio(crc | 0x01);
3731                    	;  195      /* search for recieved byte with start bit
3732                    	;  196         for a maximum of 10 recieved bytes  */
3733                    	;  197      for (searchn = 10; 0 < searchn; searchn--)
3734                    	;  198          {
3735                    	;  199          rbyte = spiio(0xff);
3736                    	;  200          if ((rbyte & 0x80) == 0)
3737                    	;  201              break;
3738                    	;  202          }
3739                    	;  203      if (searchn == 0) /* no start bit found */
3740                    	;  204          return (NO);
3741                    	;  205      retptr = recbuf;
3742                    	;  206      *retptr++ = rbyte;
3743                    	;  207      for (; 1 < recbytes; recbytes--) /* recieve bytes */
3744                    	;  208          *retptr++ = spiio(0xff);
3745                    	;  209      return (recbuf);
3746                    	;  210      }
3747                    	;  211  
3748                    	;  212  /* Initialise SD card interface
3749                    	;  213   *
3750                    	;  214   * returns YES if ok and NO if not ok
3751                    	;  215   *
3752                    	;  216   * References:
3753                    	;  217   *   https://www.sdcard.org/downloads/pls/
3754                    	;  218   *      Physical Layer Simplified Specification version 8.0
3755                    	;  219   *
3756                    	;  220   * A nice flowchart how to initialize:
3757                    	;  221   *   https://www.totalphase.com/blog/2018/08/set-sdc-mmc-cards-spi-mode-verify-files-successfully-programmed/
3758                    	;  222   *
3759                    	;  223   */
3760                    	;  224  int sdinit()
3761                    	;  225      {
3762                    	;  226      int nbytes;  /* byte counter */
3763                    	;  227      int tries;   /* tries to get to active state or searching for data  */
3764                    	;  228      int wtloop;  /* timer loop when trying to enter active state */
3765                    	;  229      unsigned char cmdbuf[5];   /* buffer to build command in */
3766                    	;  230      unsigned char rstatbuf[5]; /* buffer to recieve status in */
3767                    	;  231      unsigned char *statptr;    /* pointer to returned status from SD command */
3768                    	;  232      unsigned char crc;         /* crc register for CID and CSD */
3769                    	;  233      unsigned char rbyte;       /* recieved byte */
3770                    	;  234      unsigned char *prtptr;     /* for debug printing */
3771                    	;  235  
3772                    	;  236      ledon();
3773                    	;  237      spideselect();
3774                    	;  238      sdinitok = NO;
3775                    	;  239  
3776                    	;  240      /* start to generate 9*8 clock pulses with not selected SD card */
3777                    	;  241      for (nbytes = 9; 0 < nbytes; nbytes--)
3778                    	;  242          spiio(0xff);
3779                    	;  243      if (sdtestflg)
3780                    	;  244          {
3781                    	;  245          printf("\nSent 8*8 (72) clock pulses, select not active\n");
3782                    	;  246          } /* sdtestflg */
3783                    	;  247      spiselect();
3784                    	;  248  
3785                    	;  249      /* CMD0: GO_IDLE_STATE */
3786                    	;  250      for (tries = 0; tries < 10; tries++)
3787                    	;  251          {
3788                    	;  252          memcpy(cmdbuf, cmd0, 5);
3789                    	;  253          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3790                    	;  254          if (sdtestflg)
3791                    	;  255              {
3792                    	;  256              if (!statptr)
3793                    	;  257                  printf("CMD0: no response\n");
3794                    	;  258              else
3795                    	;  259                  printf("CMD0: GO_IDLE_STATE, R1 response [%02x]\n", statptr[0]);
3796                    	;  260              } /* sdtestflg */
3797                    	;  261          if (!statptr)
3798                    	;  262              {
3799                    	;  263              spideselect();
3800                    	;  264              ledoff();
3801                    	;  265              return (NO);
3802                    	;  266              }
3803                    	;  267          if (statptr[0] == 0x01)
3804                    	;  268              break;
3805                    	;  269          for (wtloop = 0; wtloop < tries * 10; wtloop++)
3806                    	;  270              {
3807                    	;  271              /* wait loop, time increasing for each try */
3808                    	;  272              spiio(0xff);
3809                    	;  273              }
3810                    	;  274          }
3811                    	;  275  
3812                    	;  276      /* CMD8: SEND_IF_COND */
3813                    	;  277      memcpy(cmdbuf, cmd8, 5);
3814                    	;  278      statptr = sdcommand(cmdbuf, rstatbuf, R7_LEN);
3815                    	;  279      if (sdtestflg)
3816                    	;  280          {
3817                    	;  281          if (!statptr)
3818                    	;  282              printf("CMD8: no response\n");
3819                    	;  283          else
3820                    	;  284              {
3821                    	;  285              printf("CMD8: SEND_IF_COND, R7 response [%02x %02x %02x %02x %02x], ",
3822                    	;  286                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
3823                    	;  287              if (!(statptr[0] & 0xfe)) /* no error */
3824                    	;  288                  {
3825                    	;  289                  if (statptr[4] == 0xaa)
3826                    	;  290                      printf("echo back ok, ");
3827                    	;  291                  else
3828                    	;  292                      printf("invalid echo back\n");
3829                    	;  293                  }
3830                    	;  294              }
3831                    	;  295          } /* sdtestflg */
3832                    	;  296      if (!statptr || (statptr[0] & 0xfe)) /* if no answer or error */
3833                    	;  297          {
3834                    	;  298          sdver2 = NO;
3835                    	;  299          if (sdtestflg)
3836                    	;  300              {
3837                    	;  301              printf("probably SD ver. 1\n");
3838                    	;  302              } /* sdtestflg */
3839                    	;  303          }
3840                    	;  304      else
3841                    	;  305          {
3842                    	;  306          sdver2 = YES;
3843                    	;  307          if (statptr[4] != 0xaa) /* but invalid echo back */
3844                    	;  308              {
3845                    	;  309              spideselect();
3846                    	;  310              ledoff();
3847                    	;  311              return (NO);
3848                    	;  312              }
3849                    	;  313          if (sdtestflg)
3850                    	;  314              {
3851                    	;  315              printf("SD ver 2\n");
3852                    	;  316              } /* sdtestflg */
3853                    	;  317          }
3854                    	;  318  
3855                    	;  319      /* CMD55: APP_CMD followed by ACMD41: SEND_OP_COND until status is 0x00 */
3856                    	;  320      for (tries = 0; tries < 20; tries++)
3857                    	;  321          {
3858                    	;  322          memcpy(cmdbuf, cmd55, 5);
3859                    	;  323          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3860                    	;  324          if (sdtestflg)
3861                    	;  325              {
3862                    	;  326              if (!statptr)
3863                    	;  327                  printf("CMD55: no response\n");
3864                    	;  328              else
3865                    	;  329                  printf("CMD55: APP_CMD, R1 response [%02x]\n", statptr[0]);
3866                    	;  330              } /* sdtestflg */
3867                    	;  331          if (!statptr)
3868                    	;  332              {
3869                    	;  333              spideselect();
3870                    	;  334              ledoff();
3871                    	;  335              return (NO);
3872                    	;  336              }
3873                    	;  337          memcpy(cmdbuf, acmd41, 5);
3874                    	;  338          if (sdver2)
3875                    	;  339              cmdbuf[1] = 0x40;
3876                    	;  340          else
3877                    	;  341              cmdbuf[1] = 0x00;
3878                    	;  342          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3879                    	;  343          if (sdtestflg)
3880                    	;  344              {
3881                    	;  345              if (!statptr)
3882                    	;  346                  printf("ACMD41: no response\n");
3883                    	;  347              else
3884                    	;  348                  printf("ACMD41: SEND_OP_COND, R1 response [%02x]%s\n",
3885                    	;  349                         statptr[0], (statptr[0] == 0x00) ? " - ready" : "");
3886                    	;  350              } /* sdtestflg */
3887                    	;  351          if (!statptr)
3888                    	;  352              {
3889                    	;  353              spideselect();
3890                    	;  354              ledoff();
3891                    	;  355              return (NO);
3892                    	;  356              }
3893                    	;  357          if (statptr[0] == 0x00) /* now the SD card is ready */
3894                    	;  358              {
3895                    	;  359              break;
3896                    	;  360              }
3897                    	;  361          for (wtloop = 0; wtloop < tries * 10; wtloop++)
3898                    	;  362              {
3899                    	;  363              /* wait loop, time increasing for each try */
3900                    	;  364              spiio(0xff);
3901                    	;  365              }
3902                    	;  366          }
3903                    	;  367  
3904                    	;  368      /* CMD58: READ_OCR */
3905                    	;  369      /* According to the flow chart this should not work
3906                    	;  370         for SD ver. 1 but the response is ok anyway
3907                    	;  371         all tested SD cards  */
3908                    	;  372      memcpy(cmdbuf, cmd58, 5);
3909                    	;  373      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
3910                    	;  374      if (sdtestflg)
3911                    	;  375          {
3912                    	;  376          if (!statptr)
3913                    	;  377              printf("CMD58: no response\n");
3914                    	;  378          else
3915                    	;  379              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
3916                    	;  380                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
3917                    	;  381          } /* sdtestflg */
3918                    	;  382      if (!statptr)
3919                    	;  383          {
3920                    	;  384          spideselect();
3921                    	;  385          ledoff();
3922                    	;  386          return (NO);
3923                    	;  387          }
3924                    	;  388      memcpy(&ocrreg[0], &statptr[1], sizeof (ocrreg));
3925                    	;  389      blkmult = 1; /* assume block address */
3926                    	;  390      if (ocrreg[0] & 0x80)
3927                    	;  391          {
3928                    	;  392          /* SD Ver.2+ */
3929                    	;  393          if (!(ocrreg[0] & 0x40))
3930                    	;  394              {
3931                    	;  395              /* SD Ver.2+, Byte address */
3932                    	;  396              blkmult = 512;
3933                    	;  397              }
3934                    	;  398          }
3935                    	;  399  
3936                    	;  400      /* CMD 16: SET_BLOCKLEN, only if Byte addressing */
3937                    	;  401      if (blkmult == 512)
3938                    	;  402          {
3939                    	;  403          memcpy(cmdbuf, cmd16, 5);
3940                    	;  404          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3941                    	;  405          if (sdtestflg)
3942                    	;  406              {
3943                    	;  407              if (!statptr)
3944                    	;  408                  printf("CMD16: no response\n");
3945                    	;  409              else
3946                    	;  410                  printf("CMD16: SET_BLOCKLEN (to 512 bytes), R1 response [%02x]\n",
3947                    	;  411                         statptr[0]);
3948                    	;  412              } /* sdtestflg */
3949                    	;  413          if (!statptr)
3950                    	;  414              {
3951                    	;  415              spideselect();
3952                    	;  416              ledoff();
3953                    	;  417              return (NO);
3954                    	;  418              }
3955                    	;  419          }
3956                    	;  420      /* Register information:
3957                    	;  421       *   https://www.cameramemoryspeed.com/sd-memory-card-faq/reading-sd-card-cid-serial-psn-internal-numbers/
3958                    	;  422       */
3959                    	;  423  
3960                    	;  424      /* CMD10: SEND_CID */
3961                    	;  425      memcpy(cmdbuf, cmd10, 5);
3962                    	;  426      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3963                    	;  427      if (sdtestflg)
3964                    	;  428          {
3965                    	;  429          if (!statptr)
3966                    	;  430              printf("CMD10: no response\n");
3967                    	;  431          else
3968                    	;  432              printf("CMD10: SEND_CID, R1 response [%02x]\n", statptr[0]);
3969                    	;  433          } /* sdtestflg */
3970                    	;  434      if (!statptr)
3971                    	;  435          {
3972                    	;  436          spideselect();
3973                    	;  437          ledoff();
3974                    	;  438          return (NO);
3975                    	;  439          }
3976                    	;  440      /* looking for 0xfe that is the byte before data */
3977                    	;  441      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
3978                    	;  442          ;
3979                    	;  443      if (tries == 0) /* tried too many times */
3980                    	;  444          {
3981                    	;  445          if (sdtestflg)
3982                    	;  446              {
3983                    	;  447              printf("  No data found\n");
3984                    	;  448              } /* sdtestflg */
3985                    	;  449          spideselect();
3986                    	;  450          ledoff();
3987                    	;  451          return (NO);
3988                    	;  452          }
3989                    	;  453      else
3990                    	;  454          {
3991                    	;  455          crc = 0;
3992                    	;  456          for (nbytes = 0; nbytes < 15; nbytes++)
3993                    	;  457              {
3994                    	;  458              rbyte = spiio(0xff);
3995                    	;  459              cidreg[nbytes] = rbyte;
3996                    	;  460              crc = CRC7_one(crc, rbyte);
3997                    	;  461              }
3998                    	;  462          cidreg[15] = spiio(0xff);
3999                    	;  463          crc |= 0x01;
4000                    	;  464          /* some SD cards need additional clock pulses */
4001                    	;  465          for (nbytes = 9; 0 < nbytes; nbytes--)
4002                    	;  466              spiio(0xff);
4003                    	;  467          if (sdtestflg)
4004                    	;  468              {
4005                    	;  469              prtptr = &cidreg[0];
4006                    	;  470              printf("  CID: [");
4007                    	;  471              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
4008                    	;  472                  printf("%02x ", *prtptr);
4009                    	;  473              prtptr = &cidreg[0];
4010                    	;  474              printf("\b] |");
4011                    	;  475              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
4012                    	;  476                  {
4013                    	;  477                  if ((' ' <= *prtptr) && (*prtptr < 127))
4014                    	;  478                      putchar(*prtptr);
4015                    	;  479                  else
4016                    	;  480                      putchar('.');
4017                    	;  481                  }
4018                    	;  482              printf("|\n");
4019                    	;  483              if (crc == cidreg[15])
4020                    	;  484                  {
4021                    	;  485                  printf("CRC7 ok: [%02x]\n", crc);
4022                    	;  486                  }
4023                    	;  487              else
4024                    	;  488                  {
4025                    	;  489                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
4026                    	;  490                         crc, cidreg[15]);
4027                    	;  491                  /* could maybe return failure here */
4028                    	;  492                  }
4029                    	;  493              } /* sdtestflg */
4030                    	;  494          }
4031                    	;  495  
4032                    	;  496      /* CMD9: SEND_CSD */
4033                    	;  497      memcpy(cmdbuf, cmd9, 5);
4034                    	;  498      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
4035                    	;  499      if (sdtestflg)
4036                    	;  500          {
4037                    	;  501          if (!statptr)
4038                    	;  502              printf("CMD9: no response\n");
4039                    	;  503          else
4040                    	;  504              printf("CMD9: SEND_CSD, R1 response [%02x]\n", statptr[0]);
4041                    	;  505          } /* sdtestflg */
4042                    	;  506      if (!statptr)
4043                    	;  507          {
4044                    	;  508          spideselect();
4045                    	;  509          ledoff();
4046                    	;  510          return (NO);
4047                    	;  511          }
4048                    	;  512      /* looking for 0xfe that is the byte before data */
4049                    	;  513      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
4050                    	;  514          ;
4051                    	;  515      if (tries == 0) /* tried too many times */
4052                    	;  516          {
4053                    	;  517          if (sdtestflg)
4054                    	;  518              {
4055                    	;  519              printf("  No data found\n");
4056                    	;  520              } /* sdtestflg */
4057                    	;  521          return (NO);
4058                    	;  522          }
4059                    	;  523      else
4060                    	;  524          {
4061                    	;  525          crc = 0;
4062                    	;  526          for (nbytes = 0; nbytes < 15; nbytes++)
4063                    	;  527              {
4064                    	;  528              rbyte = spiio(0xff);
4065                    	;  529              csdreg[nbytes] = rbyte;
4066                    	;  530              crc = CRC7_one(crc, rbyte);
4067                    	;  531              }
4068                    	;  532          csdreg[15] = spiio(0xff);
4069                    	;  533          crc |= 0x01;
4070                    	;  534          /* some SD cards need additional clock pulses */
4071                    	;  535          for (nbytes = 9; 0 < nbytes; nbytes--)
4072                    	;  536              spiio(0xff);
4073                    	;  537          if (sdtestflg)
4074                    	;  538              {
4075                    	;  539              prtptr = &csdreg[0];
4076                    	;  540              printf("  CSD: [");
4077                    	;  541              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
4078                    	;  542                  printf("%02x ", *prtptr);
4079                    	;  543              prtptr = &csdreg[0];
4080                    	;  544              printf("\b] |");
4081                    	;  545              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
4082                    	;  546                  {
4083                    	;  547                  if ((' ' <= *prtptr) && (*prtptr < 127))
4084                    	;  548                      putchar(*prtptr);
4085                    	;  549                  else
4086                    	;  550                      putchar('.');
4087                    	;  551                  }
4088                    	;  552              printf("|\n");
4089                    	;  553              if (crc == csdreg[15])
4090                    	;  554                  {
4091                    	;  555                  printf("CRC7 ok: [%02x]\n", crc);
4092                    	;  556                  }
4093                    	;  557              else
4094                    	;  558                  {
4095                    	;  559                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
   0                    	;  560                         crc, csdreg[15]);
   1                    	;  561                  /* could maybe return failure here */
   2                    	;  562                  }
   3                    	;  563              } /* sdtestflg */
   4                    	;  564          }
   5                    	;  565  
   6                    	;  566      for (nbytes = 9; 0 < nbytes; nbytes--)
   7                    	;  567          spiio(0xff);
   8                    	;  568      if (sdtestflg)
   9                    	;  569          {
  10                    	;  570          printf("Sent 9*8 (72) clock pulses, select active\n");
  11                    	;  571          } /* sdtestflg */
  12                    	;  572  
  13                    	;  573      sdinitok = YES;
  14                    	;  574  
  15                    	;  575      spideselect();
  16                    	;  576      ledoff();
  17                    	;  577  
  18                    	;  578      return (YES);
  19                    	;  579      }
  20                    	;  580  
  21                    	;  581  int sdprobe()
  22                    	;  582      {
  23                    	;  583      unsigned char cmdbuf[5];   /* buffer to build command in */
  24                    	;  584      unsigned char rstatbuf[5]; /* buffer to recieve status in */
  25                    	;  585      unsigned char *statptr;    /* pointer to returned status from SD command */
  26                    	;  586      int nbytes;  /* byte counter */
  27                    	;  587      int allzero = YES;
  28                    	;  588  
  29                    	;  589      ledon();
  30                    	;  590      spiselect();
  31                    	;  591  
  32                    	;  592      /* CMD58: READ_OCR */
  33                    	;  593      memcpy(cmdbuf, cmd58, 5);
  34                    	;  594      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
  35                    	;  595      for (nbytes = 0; nbytes < 5; nbytes++)
  36                    	;  596          {
  37                    	;  597          if (statptr[nbytes] != 0)
  38                    	;  598              allzero = NO;
  39                    	;  599          }
  40                    	;  600      if (sdtestflg)
  41                    	;  601          {
  42                    	;  602          if (!statptr)
  43                    	;  603              printf("CMD58: no response\n");
  44                    	;  604          else
  45                    	;  605              {
  46                    	;  606              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
  47                    	;  607                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
  48                    	;  608              if (allzero)
  49                    	;  609                  printf("SD card not inserted or not initialized\n");
  50                    	;  610              }
  51                    	;  611          } /* sdtestflg */
  52                    	;  612      if (!statptr || allzero)
  53                    	;  613          {
  54                    	;  614          sdinitok = NO;
  55                    	;  615          spideselect();
  56                    	;  616          ledoff();
  57                    	;  617          return (NO);
  58                    	;  618          }
  59                    	;  619  
  60                    	;  620      spideselect();
  61                    	;  621      ledoff();
  62                    	;  622  
  63                    	;  623      return (YES);
  64                    	;  624      }
  65                    	;  625  
  66                    	;  626  /* print OCR, CID and CSD registers*/
  67                    	;  627  void sdprtreg()
  68                    	;  628      {
  69                    	;  629      unsigned int n;
  70                    	;  630      unsigned int csize;
  71                    	;  631      unsigned long devsize;
  72                    	;  632      unsigned long capacity;
  73                    	;  633  
  74                    	;  634      if (!sdinitok)
  75                    	;  635          {
  76                    	;  636          printf("SD card not initialized\n");
  77                    	;  637          return;
  78                    	;  638          }
  79                    	;  639      printf("SD card information:");
  80                    	;  640      if (ocrreg[0] & 0x80)
  81                    	;  641          {
  82                    	;  642          if (ocrreg[0] & 0x40)
  83                    	;  643              printf("  SD card ver. 2+, Block address\n");
  84                    	;  644          else
  85                    	;  645              {
  86                    	;  646              if (sdver2)
  87                    	;  647                  printf("  SD card ver. 2+, Byte address\n");
  88                    	;  648              else
  89                    	;  649                  printf("  SD card ver. 1, Byte address\n");
  90                    	;  650              }
  91                    	;  651          }
  92                    	;  652      printf("  Manufacturer ID: 0x%02x, ", cidreg[0]);
  93                    	;  653      printf("OEM ID: %.2s, ", &cidreg[1]);
  94                    	;  654      printf("Product name: %.5s\n", &cidreg[3]);
  95                    	;  655      printf("  Product revision: %d.%d, ",
  96                    	;  656             (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
  97                    	;  657      printf("Serial number: %lu\n",
  98                    	;  658             (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
  99                    	;  659      printf("  Manufacturing date: %d-%d, ",
 100                    	;  660             2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
 101                    	;  661      if ((csdreg[0] & 0xc0) == 0x00) /* CSD version 1 */
 102                    	;  662          {
 103                    	;  663          n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
 104                    	;  664          csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
 105                    	;  665                  ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
 106                    	;  666          capacity = (unsigned long) csize << (n-10);
 107                    	;  667          printf("Device capacity: %lu MByte\n", capacity >> 10);
 108                    	;  668          }
 109                    	;  669      if ((csdreg[0] & 0xc0) == 0x40) /* CSD version 2 */
 110                    	;  670          {
 111                    	;  671          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
 112                    	;  672                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
 113                    	;  673          capacity = devsize << 9;
 114                    	;  674          printf("Device capacity: %lu MByte\n", capacity >> 10);
 115                    	;  675          }
 116                    	;  676      if ((csdreg[0] & 0xc0) == 0x80) /* CSD version 3 */
 117                    	;  677          {
 118                    	;  678          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
 119                    	;  679                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
 120                    	;  680          capacity = devsize << 9;
 121                    	;  681          printf("Device ultra capacity: %lu MByte\n", capacity >> 10);
 122                    	;  682          }
 123                    	;  683  
 124                    	;  684      if (sdtestflg)
 125                    	;  685          {
 126                    	;  686  
 127                    	;  687          printf("--------------------------------------\n");
 128                    	;  688          printf("OCR register:\n");
 129                    	;  689          if (ocrreg[2] & 0x80)
 130                    	;  690              printf("2.7-2.8V (bit 15) ");
 131                    	;  691          if (ocrreg[1] & 0x01)
 132                    	;  692              printf("2.8-2.9V (bit 16) ");
 133                    	;  693          if (ocrreg[1] & 0x02)
 134                    	;  694              printf("2.9-3.0V (bit 17) ");
 135                    	;  695          if (ocrreg[1] & 0x04)
 136                    	;  696              printf("3.0-3.1V (bit 18) \n");
 137                    	;  697          if (ocrreg[1] & 0x08)
 138                    	;  698              printf("3.1-3.2V (bit 19) ");
 139                    	;  699          if (ocrreg[1] & 0x10)
 140                    	;  700              printf("3.2-3.3V (bit 20) ");
 141                    	;  701          if (ocrreg[1] & 0x20)
 142                    	;  702              printf("3.3-3.4V (bit 21) ");
 143                    	;  703          if (ocrreg[1] & 0x40)
 144                    	;  704              printf("3.4-3.5V (bit 22) \n");
 145                    	;  705          if (ocrreg[1] & 0x80)
 146                    	;  706              printf("3.5-3.6V (bit 23) \n");
 147                    	;  707          if (ocrreg[0] & 0x01)
 148                    	;  708              printf("Switching to 1.8V Accepted (S18A) (bit 24) set ");
 149                    	;  709          if (ocrreg[0] & 0x08)
 150                    	;  710              printf("Over 2TB support Status (CO2T) (bit 27) set\n");
 151                    	;  711          if (ocrreg[0] & 0x20)
 152                    	;  712              printf("UHS-II Card Status (bit 29) set ");
 153                    	;  713          if (ocrreg[0] & 0x80)
 154                    	;  714              {
 155                    	;  715              if (ocrreg[0] & 0x40)
 156                    	;  716                  {
 157                    	;  717                  printf("Card Capacity Status (CCS) (bit 30) set\n");
 158                    	;  718                  printf("  SD Ver.2+, Block address");
 159                    	;  719                  }
 160                    	;  720              else
 161                    	;  721                  {
 162                    	;  722                  printf("Card Capacity Status (CCS) (bit 30) not set\n");
 163                    	;  723                  if (sdver2)
 164                    	;  724                      printf("  SD Ver.2+, Byte address");
 165                    	;  725                  else
 166                    	;  726                      printf("  SD Ver.1, Byte address");
 167                    	;  727                  }
 168                    	;  728              printf("\nCard power up status bit (busy) (bit 31) set\n");
 169                    	;  729              }
 170                    	;  730          else
 171                    	;  731              {
 172                    	;  732              printf("\nCard power up status bit (busy) (bit 31) not set.\n");
 173                    	;  733              printf("  This bit is not set if the card has not finished the power up routine.\n");
 174                    	;  734              }
 175                    	;  735          printf("--------------------------------------\n");
 176                    	;  736          printf("CID register:\n");
 177                    	;  737          printf("MID: 0x%02x, ", cidreg[0]);
 178                    	;  738          printf("OID: %.2s, ", &cidreg[1]);
 179                    	;  739          printf("PNM: %.5s, ", &cidreg[3]);
 180                    	;  740          printf("PRV: %d.%d, ",
 181                    	;  741                 (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
 182                    	;  742          printf("PSN: %lu, ",
 183                    	;  743                 (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
 184                    	;  744          printf("MDT: %d-%d\n",
 185                    	;  745                 2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
 186                    	;  746          printf("--------------------------------------\n");
 187                    	;  747          printf("CSD register:\n");
 188                    	;  748          if ((csdreg[0] & 0xc0) == 0x00)
 189                    	;  749              {
 190                    	;  750              printf("CSD Version 1.0, Standard Capacity\n");
 191                    	;  751              n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
 192                    	;  752              csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
 193                    	;  753                      ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
 194                    	;  754              capacity = (unsigned long) csize << (n-10);
 195                    	;  755              printf(" Device capacity: %lu KByte, %lu MByte\n",
 196                    	;  756                     capacity, capacity >> 10);
 197                    	;  757              }
 198                    	;  758          if ((csdreg[0] & 0xc0) == 0x40)
 199                    	;  759              {
 200                    	;  760              printf("CSD Version 2.0, High Capacity and Extended Capacity\n");
 201                    	;  761              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
 202                    	;  762                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
 203                    	;  763              capacity = devsize << 9;
 204                    	;  764              printf(" Device capacity: %lu KByte, %lu MByte\n",
 205                    	;  765                     capacity, capacity >> 10);
 206                    	;  766              }
 207                    	;  767          if ((csdreg[0] & 0xc0) == 0x80)
 208                    	;  768              {
 209                    	;  769              printf("CSD Version 3.0, Ultra Capacity (SDUC)\n");
 210                    	;  770              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
 211                    	;  771                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
 212                    	;  772              capacity = devsize << 9;
 213                    	;  773              printf(" Device capacity: %lu KByte, %lu MByte\n",
 214                    	;  774                     capacity, capacity >> 10);
 215                    	;  775              }
 216                    	;  776          printf("--------------------------------------\n");
 217                    	;  777  
 218                    	;  778          } /* sdtestflg */ /* SDTEST */
 219                    	;  779  
 220                    	;  780      }
 221                    	;  781  
 222                    	;  782  /* Read data block of 512 bytes to buffer
 223                    	;  783   * Returns YES if ok or NO if error
 224                    	;  784   */
 225                    	;  785  int sdread(unsigned char *rdbuf, unsigned long rdblkno)
 226                    	;  786      {
 227                    	;  787      unsigned char *statptr;
 228                    	;  788      unsigned char rbyte;
 229                    	;  789      unsigned char cmdbuf[5];   /* buffer to build command in */
 230                    	;  790      unsigned char rstatbuf[5]; /* buffer to recieve status in */
 231                    	;  791      int nbytes;
 232                    	;  792      int tries;
 233                    	;  793      unsigned long blktoread;
 234                    	;  794      unsigned int rxcrc16;
 235                    	;  795      unsigned int calcrc16;
 236                    	;  796  
 237                    	;  797      ledon();
 238                    	;  798      spiselect();
 239                    	;  799  
 240                    	;  800      if (!sdinitok)
 241                    	;  801          {
 242                    	;  802          if (sdtestflg)
 243                    	;  803              {
 244                    	;  804              printf("SD card not initialized\n");
 245                    	;  805              } /* sdtestflg */
 246                    	;  806          spideselect();
 247                    	;  807          ledoff();
 248                    	;  808          return (NO);
 249                    	;  809          }
 250                    	;  810  
 251                    	;  811      /* CMD17: READ_SINGLE_BLOCK */
 252                    	;  812      /* Insert block # into command */
 253                    	;  813      memcpy(cmdbuf, cmd17, 5);
 254                    	;  814      blktoread = blkmult * rdblkno;
 255                    	;  815      cmdbuf[4] = blktoread & 0xff;
 256                    	;  816      blktoread = blktoread >> 8;
 257                    	;  817      cmdbuf[3] = blktoread & 0xff;
 258                    	;  818      blktoread = blktoread >> 8;
 259                    	;  819      cmdbuf[2] = blktoread & 0xff;
 260                    	;  820      blktoread = blktoread >> 8;
 261                    	;  821      cmdbuf[1] = blktoread & 0xff;
 262                    	;  822  
 263                    	;  823      if (sdtestflg)
 264                    	;  824          {
 265                    	;  825          printf("\nCMD17: READ_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
 266                    	;  826                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
 267                    	;  827          } /* sdtestflg */
 268                    	;  828      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
 269                    	;  829      if (sdtestflg)
 270                    	;  830          {
 271                    	;  831          printf("CMD17 R1 response [%02x]\n", statptr[0]);
 272                    	;  832          } /* sdtestflg */
 273                    	;  833      if (statptr[0])
 274                    	;  834          {
 275                    	;  835          if (sdtestflg)
 276                    	;  836              {
 277                    	;  837              printf("  could not read block\n");
 278                    	;  838              } /* sdtestflg */
 279                    	;  839          spideselect();
 280                    	;  840          ledoff();
 281                    	;  841          return (NO);
 282                    	;  842          }
 283                    	;  843      /* looking for 0xfe that is the byte before data */
 284                    	;  844      for (tries = 80; (0 < tries) && ((rbyte = spiio(0xff)) != 0xfe); tries--)
 285                    	;  845          {
 286                    	;  846          if ((rbyte & 0xe0) == 0x00)
 287                    	;  847              {
 288                    	;  848              /* If a read operation fails and the card cannot provide
 289                    	;  849                 the required data, it will send a data error token instead
 290                    	;  850               */
 291                    	;  851              if (sdtestflg)
 292                    	;  852                  {
 293                    	;  853                  printf("  read error: [%02x]\n", rbyte);
 294                    	;  854                  } /* sdtestflg */
 295                    	;  855              spideselect();
 296                    	;  856              ledoff();
 297                    	;  857              return (NO);
 298                    	;  858              }
 299                    	;  859          }
 300                    	;  860      if (tries == 0) /* tried too many times */
 301                    	;  861          {
 302                    	;  862          if (sdtestflg)
 303                    	;  863              {
 304                    	;  864              printf("  no data found\n");
 305                    	;  865              } /* sdtestflg */
 306                    	;  866          spideselect();
 307                    	;  867          ledoff();
 308                    	;  868          return (NO);
 309                    	;  869          }
 310                    	;  870      else
 311                    	;  871          {
 312                    	;  872          calcrc16 = 0;
 313                    	;  873          for (nbytes = 0; nbytes < 512; nbytes++)
 314                    	;  874              {
 315                    	;  875              rbyte = spiio(0xff);
 316                    	;  876              calcrc16 = CRC16_one(calcrc16, rbyte);
 317                    	;  877              rdbuf[nbytes] = rbyte;
 318                    	;  878              }
 319                    	;  879          rxcrc16 = spiio(0xff) << 8;
 320                    	;  880          rxcrc16 += spiio(0xff);
 321                    	;  881  
 322                    	;  882          if (sdtestflg)
 323                    	;  883              {
 324                    	;  884              printf("  read data block %ld:\n", rdblkno);
 325                    	;  885              } /* sdtestflg */
 326                    	;  886          if (rxcrc16 != calcrc16)
 327                    	;  887              {
 328                    	;  888              if (sdtestflg)
 329                    	;  889                  {
 330                    	;  890                  printf("  CRC16 error, recieved: 0x%04x, calc: 0x%04hi\n",
 331                    	;  891                         rxcrc16, calcrc16);
 332                    	;  892                  } /* sdtestflg */
 333                    	;  893              spideselect();
 334                    	;  894              ledoff();
 335                    	;  895              return (NO);
 336                    	;  896              }
 337                    	;  897          }
 338                    	;  898      spideselect();
 339                    	;  899      ledoff();
 340                    	;  900      return (YES);
 341                    	;  901      }
 342                    	;  902  
 343                    	;  903  /* Write data block of 512 bytes from buffer
 344                    	;  904   * Returns YES if ok or NO if error
 345                    	;  905   */
 346                    	;  906  int sdwrite(unsigned char *wrbuf, unsigned long wrblkno)
 347                    	;  907      {
 348                    	;  908      unsigned char *statptr;
 349                    	;  909      unsigned char rbyte;
 350                    	;  910      unsigned char tbyte;
 351                    	;  911      unsigned char cmdbuf[5];   /* buffer to build command in */
 352                    	;  912      unsigned char rstatbuf[5]; /* buffer to recieve status in */
 353                    	;  913      int nbytes;
 354                    	;  914      int tries;
 355                    	;  915      unsigned long blktowrite;
 356                    	;  916      unsigned int calcrc16;
 357                    	;  917  
 358                    	;  918      ledon();
 359                    	;  919      spiselect();
 360                    	;  920  
 361                    	;  921      if (!sdinitok)
 362                    	;  922          {
 363                    	;  923          if (sdtestflg)
 364                    	;  924              {
 365                    	;  925              printf("SD card not initialized\n");
 366                    	;  926              } /* sdtestflg */
 367                    	;  927          spideselect();
 368                    	;  928          ledoff();
 369                    	;  929          return (NO);
 370                    	;  930          }
 371                    	;  931  
 372                    	;  932      if (sdtestflg)
 373                    	;  933          {
 374                    	;  934          printf("  write data block %ld:\n", wrblkno);
 375                    	;  935          } /* sdtestflg */
 376                    	;  936      /* CMD24: WRITE_SINGLE_BLOCK */
 377                    	;  937      /* Insert block # into command */
 378                    	;  938      memcpy(cmdbuf, cmd24, 5);
 379                    	;  939      blktowrite = blkmult * wrblkno;
 380                    	;  940      cmdbuf[4] = blktowrite & 0xff;
 381                    	;  941      blktowrite = blktowrite >> 8;
 382                    	;  942      cmdbuf[3] = blktowrite & 0xff;
 383                    	;  943      blktowrite = blktowrite >> 8;
 384                    	;  944      cmdbuf[2] = blktowrite & 0xff;
 385                    	;  945      blktowrite = blktowrite >> 8;
 386                    	;  946      cmdbuf[1] = blktowrite & 0xff;
 387                    	;  947  
 388                    	;  948      if (sdtestflg)
 389                    	;  949          {
 390                    	;  950          printf("\nCMD24: WRITE_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
 391                    	;  951                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
 392                    	;  952          } /* sdtestflg */
 393                    	;  953      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
 394                    	;  954      if (sdtestflg)
 395                    	;  955          {
 396                    	;  956          printf("CMD24 R1 response [%02x]\n", statptr[0]);
 397                    	;  957          } /* sdtestflg */
 398                    	;  958      if (statptr[0])
 399                    	;  959          {
 400                    	;  960          if (sdtestflg)
 401                    	;  961              {
 402                    	;  962              printf("  could not write block\n");
 403                    	;  963              } /* sdtestflg */
 404                    	;  964          spideselect();
 405                    	;  965          ledoff();
 406                    	;  966          return (NO);
 407                    	;  967          }
 408                    	;  968      /* send 0xfe, the byte before data */
 409                    	;  969      spiio(0xfe);
 410                    	;  970      /* initialize crc and send block */
 411                    	;  971      calcrc16 = 0;
 412                    	;  972      for (nbytes = 0; nbytes < 512; nbytes++)
 413                    	;  973          {
 414                    	;  974          tbyte = wrbuf[nbytes];
 415                    	;  975          spiio(tbyte);
 416                    	;  976          calcrc16 = CRC16_one(calcrc16, tbyte);
 417                    	;  977          }
 418                    	;  978      spiio((calcrc16 >> 8) & 0xff);
 419                    	;  979      spiio(calcrc16 & 0xff);
 420                    	;  980  
 421                    	;  981      /* check data resposnse */
 422                    	;  982      for (tries = 20;
 423                    	;  983              0 < tries && (((rbyte = spiio(0xff)) & 0x11) != 0x01);
 424                    	;  984              tries--)
 425                    	;  985          ;
 426                    	;  986      if (tries == 0)
 427                    	;  987          {
 428                    	;  988          if (sdtestflg)
 429                    	;  989              {
 430                    	;  990              printf("No data response\n");
 431                    	;  991              } /* sdtestflg */
 432                    	;  992          spideselect();
 433                    	;  993          ledoff();
 434                    	;  994          return (NO);
 435                    	;  995          }
 436                    	;  996      else
 437                    	;  997          {
 438                    	;  998          if (sdtestflg)
 439                    	;  999              {
 440                    	; 1000              printf("Data response [%02x]", 0x1f & rbyte);
 441                    	; 1001              } /* sdtestflg */
 442                    	; 1002          if ((0x1f & rbyte) == 0x05)
 443                    	; 1003              {
 444                    	; 1004              if (sdtestflg)
 445                    	; 1005                  {
 446                    	; 1006                  printf(", data accepted\n");
 447                    	; 1007                  } /* sdtestflg */
 448                    	; 1008              for (nbytes = 9; 0 < nbytes; nbytes--)
 449                    	; 1009                  spiio(0xff);
 450                    	; 1010              if (sdtestflg)
 451                    	; 1011                  {
 452                    	; 1012                  printf("Sent 9*8 (72) clock pulses, select active\n");
 453                    	; 1013                  } /* sdtestflg */
 454                    	; 1014              spideselect();
 455                    	; 1015              ledoff();
 456                    	; 1016              return (YES);
 457                    	; 1017              }
 458                    	; 1018          else
 459                    	; 1019              {
 460                    	; 1020              if (sdtestflg)
 461                    	; 1021                  {
 462                    	; 1022                  printf(", data not accepted\n");
 463                    	; 1023                  } /* sdtestflg */
 464                    	; 1024              spideselect();
 465                    	; 1025              ledoff();
 466                    	; 1026              return (NO);
 467                    	; 1027              }
 468                    	; 1028          }
 469                    	; 1029      }
 470                    	; 1030  
 471                    	; 1031  /* Print data in 512 byte buffer */
 472                    	; 1032  void sddatprt(unsigned char *prtbuf)
 473                    	; 1033      {
 474                    	; 1034      /* Variables used for "pretty-print" */
 475                    	; 1035      int allzero, dmpline, dotprted, lastallz, nbytes;
 476                    	; 1036      unsigned char *prtptr;
 477                    	; 1037  
 478                    	; 1038      prtptr = prtbuf;
 479                    	; 1039      dotprted = NO;
 480                    	; 1040      lastallz = NO;
 481                    	; 1041      for (dmpline = 0; dmpline < 32; dmpline++)
 482                    	; 1042          {
 483                    	; 1043          /* test if all 16 bytes are 0x00 */
 484                    	; 1044          allzero = YES;
 485                    	; 1045          for (nbytes = 0; nbytes < 16; nbytes++)
 486                    	; 1046              {
 487                    	; 1047              if (prtptr[nbytes] != 0)
 488                    	; 1048                  allzero = NO;
 489                    	; 1049              }
 490                    	; 1050          if (lastallz && allzero)
 491                    	; 1051              {
 492                    	; 1052              if (!dotprted)
 493                    	; 1053                  {
 494                    	; 1054                  printf("*\n");
 495                    	; 1055                  dotprted = YES;
 496                    	; 1056                  }
 497                    	; 1057              }
 498                    	; 1058          else
 499                    	; 1059              {
 500                    	; 1060              dotprted = NO;
 501                    	; 1061              /* print offset */
 502                    	; 1062              printf("%04x ", dmpline * 16);
 503                    	; 1063              /* print 16 bytes in hex */
 504                    	; 1064              for (nbytes = 0; nbytes < 16; nbytes++)
 505                    	; 1065                  printf("%02x ", prtptr[nbytes]);
 506                    	; 1066              /* print these bytes in ASCII if printable */
 507                    	; 1067              printf(" |");
 508                    	; 1068              for (nbytes = 0; nbytes < 16; nbytes++)
 509                    	; 1069                  {
 510                    	; 1070                  if ((' ' <= prtptr[nbytes]) && (prtptr[nbytes] < 127))
 511                    	; 1071                      putchar(prtptr[nbytes]);
 512                    	; 1072                  else
 513                    	; 1073                      putchar('.');
 514                    	; 1074                  }
 515                    	; 1075              printf("|\n");
 516                    	; 1076              }
 517                    	; 1077          prtptr += 16;
 518                    	; 1078          lastallz = allzero;
 519                    	; 1079          }
 520                    	; 1080      }
 521                    	; 1081  
 522                    	; 1082  /* Print GUID (mixed endian format)
 523                    	; 1083   */
 524                    	; 1084  void prtguid(unsigned char *guidptr)
 525                    	; 1085      {
 526                    	; 1086      int index;
 527                    	; 1087  
 528                    	; 1088      printf("%02x%02x%02x%02x-", guidptr[3], guidptr[2], guidptr[1], guidptr[0]);
 529                    	; 1089      printf("%02x%02x-", guidptr[5], guidptr[4]);
 530                    	; 1090      printf("%02x%02x-", guidptr[7], guidptr[6]);
 531                    	; 1091      printf("%02x%02x-", guidptr[8], guidptr[9]);
 532                    	; 1092      printf("%02x%02x%02x%02x%02x%02x",
 533                    	; 1093             guidptr[10], guidptr[11], guidptr[12], guidptr[13], guidptr[14], guidptr[15]);
 534                    	; 1094      }
 535                    	; 1095  
 536                    	; 1096  /* Analyze and print GPT entry
 537                    	; 1097   */
 538                    	; 1098  int prtgptent(unsigned int entryno)
 539                    	; 1099      {
 540                    	; 1100      int index;
 541                    	; 1101      int entryidx;
 542                    	; 1102      int hasname;
 543                    	; 1103      unsigned int block;
 544                    	; 1104      unsigned char *rxdata;
 545                    	; 1105      unsigned char *entryptr;
 546                    	; 1106      unsigned char tstzero = 0;
 547                    	; 1107      unsigned long flba;
 548                    	; 1108      unsigned long llba;
 549                    	; 1109  
 550                    	; 1110      block = 2 + (entryno / 4);
 551                    	; 1111      if ((curblkno != block) || !curblkok)
 552                    	; 1112          {
 553                    	; 1113          if (!sdread(sdrdbuf, block))
 554                    	; 1114              {
 555                    	; 1115              if (sdtestflg)
 556                    	; 1116                  {
 557                    	; 1117                  printf("Can't read GPT entry block\n");
 558                    	; 1118                  return (NO);
 559                    	; 1119                  } /* sdtestflg */
 560                    	; 1120              }
 561                    	; 1121          curblkno = block;
 562                    	; 1122          curblkok = YES;
 563                    	; 1123          }
 564                    	; 1124      rxdata = sdrdbuf;
 565                    	; 1125      entryptr = rxdata + (128 * (entryno % 4));
 566                    	; 1126      for (index = 0; index < 16; index++)
 567                    	; 1127          tstzero |= entryptr[index];
 568                    	; 1128      if (sdtestflg)
 569                    	; 1129          {
 570                    	; 1130          printf("GPT partition entry %d:", entryno + 1);
 571                    	; 1131          } /* sdtestflg */
 572                    	; 1132      if (!tstzero)
 573                    	; 1133          {
 574                    	; 1134          if (sdtestflg)
 575                    	; 1135              {
 576                    	; 1136              printf(" Not used entry\n");
 577                    	; 1137              } /* sdtestflg */
 578                    	; 1138          return (NO);
 579                    	; 1139          }
 580                    	; 1140      if (sdtestflg)
 581                    	; 1141          {
 582                    	; 1142          printf("\n  Partition type GUID: ");
 583                    	; 1143          prtguid(entryptr);
 584                    	; 1144          printf("\n  [");
 585                    	; 1145          for (index = 0; index < 16; index++)
 586                    	; 1146              printf("%02x ", entryptr[index]);
 587                    	; 1147          printf("\b]");
 588                    	; 1148          printf("\n  Unique partition GUID: ");
 589                    	; 1149          prtguid(entryptr + 16);
 590                    	; 1150          printf("\n  [");
 591                    	; 1151          for (index = 0; index < 16; index++)
 592                    	; 1152              printf("%02x ", (entryptr + 16)[index]);
 593                    	; 1153          printf("\b]");
 594                    	; 1154          printf("\n  First LBA: ");
 595                    	; 1155          /* lower 32 bits of LBA should be sufficient (I hope) */
 596                    	; 1156          } /* sdtestflg */
 597                    	; 1157      flba = (unsigned long)entryptr[32] + ((unsigned long)entryptr[33] << 8) +
 598                    	; 1158             ((unsigned long)entryptr[34] << 16) + ((unsigned long)entryptr[35] << 24);
 599                    	; 1159      if (sdtestflg)
 600                    	; 1160          {
 601                    	; 1161          printf("%lu", flba);
 602                    	; 1162          printf(" [");
 603                    	; 1163          for (index = 32; index < (32 + 8); index++)
 604                    	; 1164              printf("%02x ", entryptr[index]);
 605                    	; 1165          printf("\b]");
 606                    	; 1166          printf("\n  Last LBA: ");
 607                    	; 1167          } /* sdtestflg */
 608                    	; 1168      /* lower 32 bits of LBA should be sufficient (I hope) */
 609                    	; 1169      llba = (unsigned long)entryptr[40] + ((unsigned long)entryptr[41] << 8) +
 610                    	; 1170             ((unsigned long)entryptr[42] << 16) + ((unsigned long)entryptr[43] << 24);
 611                    	; 1171  
 612                    	; 1172      if (entryptr[48] & 0x04)
 613                    	; 1173          dskmap[partdsk].bootable = YES;
 614                    	; 1174      dskmap[partdsk].partype = PARTGPT;
 615                    	; 1175      dskmap[partdsk].dskletter = 'A' + partdsk;
 616                    	; 1176      dskmap[partdsk].dskstart = flba;
 617                    	; 1177      dskmap[partdsk].dskend = llba;
 618                    	; 1178      dskmap[partdsk].dsksize = llba - flba + 1;
 619                    	; 1179      memcpy(dskmap[partdsk].dsktype, entryptr, 16);
 620                    	; 1180      partdsk++;
 621                    	; 1181  
 622                    	; 1182      if (sdtestflg)
 623                    	; 1183          {
 624                    	; 1184          printf("%lu, size %lu MByte", llba, (llba - flba) >> 11);
 625                    	; 1185          printf(" [");
 626                    	; 1186          for (index = 40; index < (40 + 8); index++)
 627                    	; 1187              printf("%02x ", entryptr[index]);
 628                    	; 1188          printf("\b]");
 629                    	; 1189          printf("\n  Attribute flags: [");
 630                    	; 1190          /* bits 0 - 2 and 60 - 63 should be decoded */
 631                    	; 1191          for (index = 0; index < 8; index++)
 632                    	; 1192              {
 633                    	; 1193              entryidx = index + 48;
 634                    	; 1194              printf("%02x ", entryptr[entryidx]);
 635                    	; 1195              }
 636                    	; 1196          printf("\b]\n  Partition name:  ");
 637                    	; 1197          } /* sdtestflg */
 638                    	; 1198      /* partition name is in UTF-16LE code units */
 639                    	; 1199      hasname = NO;
 640                    	; 1200      for (index = 0; index < 72; index += 2)
 641                    	; 1201          {
 642                    	; 1202          entryidx = index + 56;
 643                    	; 1203          if ((entryptr[entryidx] | entryptr[entryidx + 1]) == 0)
 644                    	; 1204              break;
 645                    	; 1205          if (sdtestflg)
 646                    	; 1206              {
 647                    	; 1207              if ((' ' <= entryptr[entryidx]) && (entryptr[entryidx] < 127))
 648                    	; 1208                  putchar(entryptr[entryidx]);
 649                    	; 1209              else
 650                    	; 1210                  putchar('.');
 651                    	; 1211              } /* sdtestflg */
 652                    	; 1212          hasname = YES;
 653                    	; 1213          }
 654                    	; 1214      if (sdtestflg)
 655                    	; 1215          {
 656                    	; 1216          if (!hasname)
 657                    	; 1217              printf("name field empty");
 658                    	; 1218          printf("\n");
 659                    	; 1219          printf("   [");
 660                    	; 1220          for (index = 0; index < 72; index++)
 661                    	; 1221              {
 662                    	; 1222              if (((index & 0xf) == 0) && (index != 0))
 663                    	; 1223                  printf("\n    ");
 664                    	; 1224              entryidx = index + 56;
 665                    	; 1225              printf("%02x ", entryptr[entryidx]);
 666                    	; 1226              }
 667                    	; 1227          printf("\b]\n");
 668                    	; 1228          } /* sdtestflg */
 669                    	; 1229      return (YES);
 670                    	; 1230      }
 671                    	; 1231  
 672                    	; 1232  /* Analyze and print GPT header
 673                    	; 1233   */
 674                    	; 1234  void sdgpthdr(unsigned long block)
 675                    	; 1235      {
 676                    	; 1236      int index;
 677                    	; 1237      unsigned int partno;
 678                    	; 1238      unsigned char *rxdata;
 679                    	; 1239      unsigned long entries;
 680                    	; 1240  
 681                    	; 1241      if (sdtestflg)
 682                    	; 1242          {
 683                    	; 1243          printf("GPT header\n");
 684                    	; 1244          } /* sdtestflg */
 685                    	; 1245      if (!sdread(sdrdbuf, block))
 686                    	; 1246          {
 687                    	; 1247          if (sdtestflg)
 688                    	; 1248              {
 689                    	; 1249              printf("Can't read GPT partition table header\n");
 690                    	; 1250              } /* sdtestflg */
 691                    	; 1251          return;
 692                    	; 1252          }
 693                    	; 1253      curblkno = block;
 694                    	; 1254      curblkok = YES;
 695                    	; 1255  
 696                    	; 1256      rxdata = sdrdbuf;
 697                    	; 1257      if (sdtestflg)
 698                    	; 1258          {
 699                    	; 1259          printf("  Signature: %.8s\n", &rxdata[0]);
 700                    	; 1260          printf("  Revision: %d.%d [%02x %02x %02x %02x]\n",
 701                    	; 1261                 (int)rxdata[8] * ((int)rxdata[9] << 8),
 702                    	; 1262                 (int)rxdata[10] + ((int)rxdata[11] << 8),
 703                    	; 1263                 rxdata[8], rxdata[9], rxdata[10], rxdata[11]);
 704                    	; 1264          entries = (unsigned long)rxdata[80] + ((unsigned long)rxdata[81] << 8) +
 705                    	; 1265                    ((unsigned long)rxdata[82] << 16) + ((unsigned long)rxdata[83] << 24);
 706                    	; 1266          printf("  Number of partition entries: %lu (may be actual or maximum)\n", entries);
 707                    	; 1267          } /* sdtestflg */
 708                    	; 1268      for (partno = 0; (partno < 16) && (partdsk < 16); partno++)
 709                    	; 1269          {
 710                    	; 1270          if (!prtgptent(partno))
 711                    	; 1271              {
 712                    	; 1272              if (!sdtestflg)
 713                    	; 1273                  {
 714                    	; 1274                  /* go through all entries if compiled as test program */
 715                    	; 1275                  return;
 716                    	; 1276                  } /* sdtestflg */
 717                    	; 1277              }
 718                    	; 1278          }
 719                    	; 1279      if (sdtestflg)
 720                    	; 1280          {
 721                    	; 1281          printf("First 16 GPT entries scanned\n");
 722                    	; 1282          } /* sdtestflg */
 723                    	; 1283      }
 724                    	; 1284  
 725                    	; 1285  /* Analyze and print MBR partition entry
 726                    	; 1286   * Returns:
 727                    	; 1287   *    -1 if errror - should not happen
 728                    	; 1288   *     0 if not used entry
 729                    	; 1289   *     1 if MBR entry
 730                    	; 1290   *     2 if EBR entry
 731                    	; 1291   *     3 if GTP entry
 732                    	; 1292   */
 733                    	; 1293  int sdmbrentry(unsigned char *partptr)
 734                    	; 1294      {
 735                    	; 1295      int index;
 736                    	; 1296      int parttype;
 737                    	; 1297      unsigned long lbastart;
 738                    	; 1298      unsigned long lbasize;
 739                    	; 1299  
 740                    	; 1300      parttype = PARTMBR;
 741                    	; 1301      if (!partptr[4])
 742                    	; 1302          {
 743                    	; 1303          if (sdtestflg)
 744                    	; 1304              {
 745                    	; 1305              printf("Not used entry\n");
 746                    	; 1306              } /* sdtestflg */
 747                    	; 1307          return (PARTZRO);
 748                    	; 1308          }
 749                    	; 1309      if (sdtestflg)
 750                    	; 1310          {
 751                    	; 1311          printf("Boot indicator: 0x%02x, System ID: 0x%02x\n",
 752                    	; 1312                 partptr[0], partptr[4]);
 753                    	; 1313  
 754                    	; 1314          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f))
 755                    	; 1315              {
 756                    	; 1316              printf("  Extended partition entry\n");
 757                    	; 1317              }
 758                    	; 1318          if (partptr[0] & 0x01)
 759                    	; 1319              {
 760                    	; 1320              printf("  Unofficial 48 bit LBA Proposed MBR Format, no CHS\n");
 761                    	; 1321              /* this is however discussed
 762                    	; 1322                 https://wiki.osdev.org/Partition_Table#.22Unofficial.22_48_bit_LBA_Proposed_MBR_Format
 763                    	; 1323              */
 764                    	; 1324              }
 765                    	; 1325          else
 766                    	; 1326              {
 767                    	; 1327              printf("  begin CHS: 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
 768                    	; 1328                     partptr[1], partptr[2], partptr[3],
 769                    	; 1329                     ((partptr[2] & 0xc0) >> 2) + partptr[3],
 770                    	; 1330                     partptr[1],
 771                    	; 1331                     partptr[2] & 0x3f);
 772                    	; 1332              printf("  end CHS 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
 773                    	; 1333                     partptr[5], partptr[6], partptr[7],
 774                    	; 1334                     ((partptr[6] & 0xc0) >> 2) + partptr[7],
 775                    	; 1335                     partptr[5],
 776                    	; 1336                     partptr[6] & 0x3f);
 777                    	; 1337              }
 778                    	; 1338          } /* sdtestflg */
 779                    	; 1339      /* not showing high 16 bits if 48 bit LBA */
 780                    	; 1340      lbastart = (unsigned long)partptr[8] +
 781                    	; 1341                 ((unsigned long)partptr[9] << 8) +
 782                    	; 1342                 ((unsigned long)partptr[10] << 16) +
 783                    	; 1343                 ((unsigned long)partptr[11] << 24);
 784                    	; 1344      lbasize = (unsigned long)partptr[12] +
 785                    	; 1345                ((unsigned long)partptr[13] << 8) +
 786                    	; 1346                ((unsigned long)partptr[14] << 16) +
 787                    	; 1347                ((unsigned long)partptr[15] << 24);
 788                    	; 1348  
 789                    	; 1349      if (!(partptr[4] == 0xee)) /* not pointing to a GPT partition */
 790                    	; 1350          {
 791                    	; 1351          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f)) /* EBR partition */
 792                    	; 1352              {
 793                    	; 1353              parttype = PARTEBR;
 794                    	; 1354              if (curblkno == 0) /* points to EBR in the MBR */
 795                    	; 1355                  {
 796                    	; 1356                  ebrnext = 0;
 797                    	; 1357                  dskmap[partdsk].partype = EBRCONT;
 798                    	; 1358                  dskmap[partdsk].dskletter = 'A' + partdsk;
 799                    	; 1359                  dskmap[partdsk].dskstart = lbastart;
 800                    	; 1360                  dskmap[partdsk].dskend = lbastart + lbasize - 1;
 801                    	; 1361                  dskmap[partdsk].dsksize = lbasize;
 802                    	; 1362                  dskmap[partdsk].dsktype[0] = partptr[4];
 803                    	; 1363                  partdsk++;
 804                    	; 1364                  ebrrecs[ebrrecidx++] = lbastart; /* save to handle later */
 805                    	; 1365                  }
 806                    	; 1366              else
 807                    	; 1367                  {
 808                    	; 1368                  ebrnext = curblkno + lbastart;
 809                    	; 1369                  }
 810                    	; 1370              }
 811                    	; 1371          else
 812                    	; 1372              {
 813                    	; 1373              if (0 < lbasize) /* one more ugly hack to avoid empty partitions */
 814                    	; 1374                  {
 815                    	; 1375                  if (partptr[0] & 0x80)
 816                    	; 1376                      dskmap[partdsk].bootable = YES;
 817                    	; 1377                  if (curblkno == 0)
 818                    	; 1378                      dskmap[partdsk].partype = PARTMBR;
 819                    	; 1379                  else
 820                    	; 1380                      dskmap[partdsk].partype = PARTEBR;
 821                    	; 1381                  dskmap[partdsk].dskletter = 'A' + partdsk;
 822                    	; 1382                  dskmap[partdsk].dskstart = curblkno + lbastart;
 823                    	; 1383                  dskmap[partdsk].dskend = curblkno + lbastart + lbasize - 1;
 824                    	; 1384                  dskmap[partdsk].dsksize = lbasize;
 825                    	; 1385                  dskmap[partdsk].dsktype[0] = partptr[4];
 826                    	; 1386                  partdsk++;
 827                    	; 1387                  }
 828                    	; 1388              }
 829                    	; 1389          }
 830                    	; 1390  
 831                    	; 1391      if (sdtestflg)
 832                    	; 1392          {
 833                    	; 1393          printf("  partition start LBA: %lu [%08lx]\n",
 834                    	; 1394                 curblkno + lbastart, curblkno + lbastart);
 835                    	; 1395          printf("  partition size LBA: %lu [%08lx], %lu MByte\n",
 836                    	; 1396                 lbasize, lbasize, lbasize >> 11);
 837                    	; 1397          } /* sdtestflg */
 838                    	; 1398      if (partptr[4] == 0xee) /* GPT partitions */
 839                    	; 1399          {
 840                    	; 1400          parttype = PARTGPT;
 841                    	; 1401          if (sdtestflg)
 842                    	; 1402              {
 843                    	; 1403              printf("GTP partitions\n");
 844                    	; 1404              } /* sdtestflg */
 845                    	; 1405          sdgpthdr(lbastart); /* handle GTP partitions */
 846                    	; 1406          /* re-read MBR on sector 0
 847                    	; 1407             This is probably not needed as there
 848                    	; 1408             is only one entry (the first one)
 849                    	; 1409             in the MBR when using GPT */
 850                    	; 1410          if (sdread(sdrdbuf, 0))
 851                    	; 1411              {
 852                    	; 1412              curblkno = 0;
 853    3D39  97        		sub	a
 854    3D3A  320200    		ld	(_curblkno),a
 855    3D3D  320300    		ld	(_curblkno+1),a
 856    3D40  320400    		ld	(_curblkno+2),a
 857    3D43  320500    		ld	(_curblkno+3),a
 858    3D46  221000    		ld	(_curblkok),hl
 859                    	; 1413              curblkok = YES;
 860                    	; 1414              }
 861                    	; 1415          else
 862    3D49  1813      		jr	L1525
 863                    	L1725:
 864                    	; 1416              {
 865                    	; 1417              if (sdtestflg)
 866    3D4B  2A0000    		ld	hl,(_sdtestflg)
 867    3D4E  7C        		ld	a,h
 868    3D4F  B5        		or	l
 869    3D50  2806      		jr	z,L1135
 870                    	; 1418                  {
 871                    	; 1419                  printf("  can't read MBR on sector 0\n");
 872    3D52  21C436    		ld	hl,L5052
 873    3D55  CD0000    		call	_printf
 874                    	L1135:
 875                    	; 1420                  } /* sdtestflg */
 876                    	; 1421              return(-1);
 877    3D58  01FFFF    		ld	bc,65535
 878    3D5B  C30000    		jp	c.rets
 879                    	L1525:
 880                    	; 1422              }
 881                    	; 1423          }
 882                    	; 1424      return (parttype);
 883    3D5E  DD4EF6    		ld	c,(ix-10)
 884    3D61  DD46F7    		ld	b,(ix-9)
 885    3D64  C30000    		jp	c.rets
 886                    	L5152:
 887    3D67  4D        		.byte	77
 888    3D68  42        		.byte	66
 889    3D69  52        		.byte	82
 890    3D6A  00        		.byte	0
 891                    	L5252:
 892    3D6B  45        		.byte	69
 893    3D6C  42        		.byte	66
 894    3D6D  52        		.byte	82
 895    3D6E  00        		.byte	0
 896                    	L5352:
 897    3D6F  52        		.byte	82
 898    3D70  65        		.byte	101
 899    3D71  61        		.byte	97
 900    3D72  64        		.byte	100
 901    3D73  20        		.byte	32
 902    3D74  25        		.byte	37
 903    3D75  73        		.byte	115
 904    3D76  20        		.byte	32
 905    3D77  66        		.byte	102
 906    3D78  72        		.byte	114
 907    3D79  6F        		.byte	111
 908    3D7A  6D        		.byte	109
 909    3D7B  20        		.byte	32
 910    3D7C  73        		.byte	115
 911    3D7D  65        		.byte	101
 912    3D7E  63        		.byte	99
 913    3D7F  74        		.byte	116
 914    3D80  6F        		.byte	111
 915    3D81  72        		.byte	114
 916    3D82  20        		.byte	32
 917    3D83  25        		.byte	37
 918    3D84  6C        		.byte	108
 919    3D85  75        		.byte	117
 920    3D86  0A        		.byte	10
 921    3D87  00        		.byte	0
 922                    	L5452:
 923    3D88  20        		.byte	32
 924    3D89  20        		.byte	32
 925    3D8A  63        		.byte	99
 926    3D8B  61        		.byte	97
 927    3D8C  6E        		.byte	110
 928    3D8D  27        		.byte	39
 929    3D8E  74        		.byte	116
 930    3D8F  20        		.byte	32
 931    3D90  72        		.byte	114
 932    3D91  65        		.byte	101
 933    3D92  61        		.byte	97
 934    3D93  64        		.byte	100
 935    3D94  20        		.byte	32
 936    3D95  25        		.byte	37
 937    3D96  73        		.byte	115
 938    3D97  20        		.byte	32
 939    3D98  73        		.byte	115
 940    3D99  65        		.byte	101
 941    3D9A  63        		.byte	99
 942    3D9B  74        		.byte	116
 943    3D9C  6F        		.byte	111
 944    3D9D  72        		.byte	114
 945    3D9E  20        		.byte	32
 946    3D9F  25        		.byte	37
 947    3DA0  6C        		.byte	108
 948    3DA1  75        		.byte	117
 949    3DA2  0A        		.byte	10
 950    3DA3  00        		.byte	0
 951                    	L5552:
 952    3DA4  20        		.byte	32
 953    3DA5  20        		.byte	32
 954    3DA6  6E        		.byte	110
 955    3DA7  6F        		.byte	111
 956    3DA8  20        		.byte	32
 957    3DA9  25        		.byte	37
 958    3DAA  73        		.byte	115
 959    3DAB  20        		.byte	32
 960    3DAC  62        		.byte	98
 961    3DAD  6F        		.byte	111
 962    3DAE  6F        		.byte	111
 963    3DAF  74        		.byte	116
 964    3DB0  20        		.byte	32
 965    3DB1  73        		.byte	115
 966    3DB2  69        		.byte	105
 967    3DB3  67        		.byte	103
 968    3DB4  6E        		.byte	110
 969    3DB5  61        		.byte	97
 970    3DB6  74        		.byte	116
 971    3DB7  75        		.byte	117
 972    3DB8  72        		.byte	114
 973    3DB9  65        		.byte	101
 974    3DBA  20        		.byte	32
 975    3DBB  66        		.byte	102
 976    3DBC  6F        		.byte	111
 977    3DBD  75        		.byte	117
 978    3DBE  6E        		.byte	110
 979    3DBF  64        		.byte	100
 980    3DC0  0A        		.byte	10
 981    3DC1  00        		.byte	0
 982                    	L5652:
 983    3DC2  20        		.byte	32
 984    3DC3  20        		.byte	32
 985    3DC4  64        		.byte	100
 986    3DC5  69        		.byte	105
 987    3DC6  73        		.byte	115
 988    3DC7  6B        		.byte	107
 989    3DC8  20        		.byte	32
 990    3DC9  69        		.byte	105
 991    3DCA  64        		.byte	100
 992    3DCB  65        		.byte	101
 993    3DCC  6E        		.byte	110
 994    3DCD  74        		.byte	116
 995    3DCE  69        		.byte	105
 996    3DCF  66        		.byte	102
 997    3DD0  69        		.byte	105
 998    3DD1  65        		.byte	101
 999    3DD2  72        		.byte	114
1000    3DD3  3A        		.byte	58
1001    3DD4  20        		.byte	32
1002    3DD5  30        		.byte	48
1003    3DD6  78        		.byte	120
1004    3DD7  25        		.byte	37
1005    3DD8  30        		.byte	48
1006    3DD9  32        		.byte	50
1007    3DDA  78        		.byte	120
1008    3DDB  25        		.byte	37
1009    3DDC  30        		.byte	48
1010    3DDD  32        		.byte	50
1011    3DDE  78        		.byte	120
1012    3DDF  25        		.byte	37
1013    3DE0  30        		.byte	48
1014    3DE1  32        		.byte	50
1015    3DE2  78        		.byte	120
1016    3DE3  25        		.byte	37
1017    3DE4  30        		.byte	48
1018    3DE5  32        		.byte	50
1019    3DE6  78        		.byte	120
1020    3DE7  0A        		.byte	10
1021    3DE8  00        		.byte	0
1022                    	L5752:
1023    3DE9  25        		.byte	37
1024    3DEA  73        		.byte	115
1025    3DEB  20        		.byte	32
1026    3DEC  70        		.byte	112
1027    3DED  61        		.byte	97
1028    3DEE  72        		.byte	114
1029    3DEF  74        		.byte	116
1030    3DF0  69        		.byte	105
1031    3DF1  74        		.byte	116
1032    3DF2  69        		.byte	105
1033    3DF3  6F        		.byte	111
1034    3DF4  6E        		.byte	110
1035    3DF5  20        		.byte	32
1036    3DF6  65        		.byte	101
1037    3DF7  6E        		.byte	110
1038    3DF8  74        		.byte	116
1039    3DF9  72        		.byte	114
1040    3DFA  79        		.byte	121
1041    3DFB  20        		.byte	32
1042    3DFC  25        		.byte	37
1043    3DFD  64        		.byte	100
1044    3DFE  3A        		.byte	58
1045    3DFF  20        		.byte	32
1046    3E00  00        		.byte	0
1047                    	L5062:
1048    3E01  20        		.byte	32
1049    3E02  20        		.byte	32
1050    3E03  63        		.byte	99
1051    3E04  61        		.byte	97
1052    3E05  6E        		.byte	110
1053    3E06  27        		.byte	39
1054    3E07  74        		.byte	116
1055    3E08  20        		.byte	32
1056    3E09  72        		.byte	114
1057    3E0A  65        		.byte	101
1058    3E0B  61        		.byte	97
1059    3E0C  64        		.byte	100
1060    3E0D  20        		.byte	32
1061    3E0E  25        		.byte	37
1062    3E0F  73        		.byte	115
1063    3E10  20        		.byte	32
1064    3E11  73        		.byte	115
1065    3E12  65        		.byte	101
1066    3E13  63        		.byte	99
1067    3E14  74        		.byte	116
1068    3E15  6F        		.byte	111
1069    3E16  72        		.byte	114
1070    3E17  20        		.byte	32
1071    3E18  25        		.byte	37
1072    3E19  6C        		.byte	108
1073    3E1A  75        		.byte	117
1074    3E1B  0A        		.byte	10
1075    3E1C  00        		.byte	0
1076                    	L5162:
1077    3E1D  45        		.byte	69
1078    3E1E  42        		.byte	66
1079    3E1F  52        		.byte	82
1080    3E20  20        		.byte	32
1081    3E21  70        		.byte	112
1082    3E22  61        		.byte	97
1083    3E23  72        		.byte	114
1084    3E24  74        		.byte	116
1085    3E25  69        		.byte	105
1086    3E26  74        		.byte	116
1087    3E27  69        		.byte	105
1088    3E28  6F        		.byte	111
1089    3E29  6E        		.byte	110
1090    3E2A  20        		.byte	32
1091    3E2B  65        		.byte	101
1092    3E2C  6E        		.byte	110
1093    3E2D  74        		.byte	116
1094    3E2E  72        		.byte	114
1095    3E2F  79        		.byte	121
1096    3E30  20        		.byte	32
1097    3E31  25        		.byte	37
1098    3E32  64        		.byte	100
1099    3E33  3A        		.byte	58
1100    3E34  20        		.byte	32
1101    3E35  00        		.byte	0
1102                    	L5262:
1103    3E36  45        		.byte	69
1104    3E37  6D        		.byte	109
1105    3E38  70        		.byte	112
1106    3E39  74        		.byte	116
1107    3E3A  79        		.byte	121
1108    3E3B  20        		.byte	32
1109    3E3C  70        		.byte	112
1110    3E3D  61        		.byte	97
1111    3E3E  72        		.byte	114
1112    3E3F  74        		.byte	116
1113    3E40  69        		.byte	105
1114    3E41  74        		.byte	116
1115    3E42  69        		.byte	105
1116    3E43  6F        		.byte	111
1117    3E44  6E        		.byte	110
1118    3E45  20        		.byte	32
1119    3E46  65        		.byte	101
1120    3E47  6E        		.byte	110
1121    3E48  74        		.byte	116
1122    3E49  72        		.byte	114
1123    3E4A  79        		.byte	121
1124    3E4B  0A        		.byte	10
1125    3E4C  00        		.byte	0
1126                    	L5362:
1127    3E4D  45        		.byte	69
1128    3E4E  42        		.byte	66
1129    3E4F  52        		.byte	82
1130    3E50  20        		.byte	32
1131    3E51  63        		.byte	99
1132    3E52  68        		.byte	104
1133    3E53  61        		.byte	97
1134    3E54  69        		.byte	105
1135    3E55  6E        		.byte	110
1136    3E56  0A        		.byte	10
1137    3E57  00        		.byte	0
1138                    	L5462:
1139    3E58  20        		.byte	32
1140    3E59  20        		.byte	32
1141    3E5A  63        		.byte	99
1142    3E5B  61        		.byte	97
1143    3E5C  6E        		.byte	110
1144    3E5D  27        		.byte	39
1145    3E5E  74        		.byte	116
1146    3E5F  20        		.byte	32
1147    3E60  72        		.byte	114
1148    3E61  65        		.byte	101
1149    3E62  61        		.byte	97
1150    3E63  64        		.byte	100
1151    3E64  20        		.byte	32
1152    3E65  25        		.byte	37
1153    3E66  73        		.byte	115
1154    3E67  20        		.byte	32
1155    3E68  73        		.byte	115
1156    3E69  65        		.byte	101
1157    3E6A  63        		.byte	99
1158    3E6B  74        		.byte	116
1159    3E6C  6F        		.byte	111
1160    3E6D  72        		.byte	114
1161    3E6E  20        		.byte	32
1162    3E6F  25        		.byte	37
1163    3E70  6C        		.byte	108
1164    3E71  75        		.byte	117
1165    3E72  0A        		.byte	10
1166    3E73  00        		.byte	0
1167                    	L5562:
1168    3E74  45        		.byte	69
1169    3E75  42        		.byte	66
1170    3E76  52        		.byte	82
1171    3E77  20        		.byte	32
1172    3E78  63        		.byte	99
1173    3E79  68        		.byte	104
1174    3E7A  61        		.byte	97
1175    3E7B  69        		.byte	105
1176    3E7C  6E        		.byte	110
1177    3E7D  65        		.byte	101
1178    3E7E  64        		.byte	100
1179    3E7F  20        		.byte	32
1180    3E80  20        		.byte	32
1181    3E81  70        		.byte	112
1182    3E82  61        		.byte	97
1183    3E83  72        		.byte	114
1184    3E84  74        		.byte	116
1185    3E85  69        		.byte	105
1186    3E86  74        		.byte	116
1187    3E87  69        		.byte	105
1188    3E88  6F        		.byte	111
1189    3E89  6E        		.byte	110
1190    3E8A  20        		.byte	32
1191    3E8B  65        		.byte	101
1192    3E8C  6E        		.byte	110
1193    3E8D  74        		.byte	116
1194    3E8E  72        		.byte	114
1195    3E8F  79        		.byte	121
1196    3E90  20        		.byte	32
1197    3E91  25        		.byte	37
1198    3E92  64        		.byte	100
1199    3E93  3A        		.byte	58
1200    3E94  20        		.byte	32
1201    3E95  00        		.byte	0
1202                    	; 1425      }
1203                    	; 1426  
1204                    	; 1427  /* Read and analyze MBR/EBR partition sector block
1205                    	; 1428   * and go through and print partition entries.
1206                    	; 1429   */
1207                    	; 1430  void sdmbrpart(unsigned long sector)
1208                    	; 1431      {
1209                    	_sdmbrpart:
1210    3E96  CD0000    		call	c.savs
1211    3E99  21EEFF    		ld	hl,65518
1212    3E9C  39        		add	hl,sp
1213    3E9D  F9        		ld	sp,hl
1214                    	; 1432      int partidx;  /* partition index 1 - 4 */
1215                    	; 1433      int cpartidx; /* chain partition index 1 - 4 */
1216                    	; 1434      int chainidx;
1217                    	; 1435      int enttype;
1218                    	; 1436      unsigned char *entp; /* pointer to partition entry */
1219                    	; 1437      char *mbrebr;
1220                    	; 1438  
1221                    	; 1439      if (sdtestflg)
1222    3E9E  2A0000    		ld	hl,(_sdtestflg)
1223    3EA1  7C        		ld	a,h
1224    3EA2  B5        		or	l
1225    3EA3  2840      		jr	z,L1235
1226                    	; 1440          {
1227                    	; 1441          if (sector == 0) /* if sector 0 it is MBR else it is EBR */
1228    3EA5  DD7E04    		ld	a,(ix+4)
1229    3EA8  DDB605    		or	(ix+5)
1230    3EAB  DDB606    		or	(ix+6)
1231    3EAE  DDB607    		or	(ix+7)
1232    3EB1  200B      		jr	nz,L1335
1233                    	; 1442              mbrebr = "MBR";
1234    3EB3  21673D    		ld	hl,L5152
1235    3EB6  DD75EE    		ld	(ix-18),l
1236    3EB9  DD74EF    		ld	(ix-17),h
1237                    	; 1443          else
1238    3EBC  1809      		jr	L1435
1239                    	L1335:
1240                    	; 1444              mbrebr = "EBR";
1241    3EBE  216B3D    		ld	hl,L5252
1242    3EC1  DD75EE    		ld	(ix-18),l
1243    3EC4  DD74EF    		ld	(ix-17),h
1244                    	L1435:
1245                    	; 1445          printf("Read %s from sector %lu\n", mbrebr, sector);
1246    3EC7  DD6607    		ld	h,(ix+7)
1247    3ECA  DD6E06    		ld	l,(ix+6)
1248    3ECD  E5        		push	hl
1249    3ECE  DD6605    		ld	h,(ix+5)
1250    3ED1  DD6E04    		ld	l,(ix+4)
1251    3ED4  E5        		push	hl
1252    3ED5  DD6EEE    		ld	l,(ix-18)
1253    3ED8  DD66EF    		ld	h,(ix-17)
1254    3EDB  E5        		push	hl
1255    3EDC  216F3D    		ld	hl,L5352
1256    3EDF  CD0000    		call	_printf
1257    3EE2  F1        		pop	af
1258    3EE3  F1        		pop	af
1259    3EE4  F1        		pop	af
1260                    	L1235:
1261                    	; 1446          } /* sdtestflg */
1262                    	; 1447      if (sdread(sdrdbuf, sector))
1263    3EE5  DD6607    		ld	h,(ix+7)
1264    3EE8  DD6E06    		ld	l,(ix+6)
1265    3EEB  E5        		push	hl
1266    3EEC  DD6605    		ld	h,(ix+5)
1267    3EEF  DD6E04    		ld	l,(ix+4)
1268    3EF2  E5        		push	hl
1269    3EF3  214C00    		ld	hl,_sdrdbuf
1270    3EF6  CDE320    		call	_sdread
1271    3EF9  F1        		pop	af
1272    3EFA  F1        		pop	af
1273    3EFB  79        		ld	a,c
1274    3EFC  B0        		or	b
1275    3EFD  2827      		jr	z,L1535
1276                    	; 1448          {
1277                    	; 1449          curblkno = sector;
1278    3EFF  210200    		ld	hl,_curblkno
1279    3F02  E5        		push	hl
1280    3F03  DDE5      		push	ix
1281    3F05  C1        		pop	bc
1282    3F06  210400    		ld	hl,4
1283    3F09  09        		add	hl,bc
1284    3F0A  E5        		push	hl
1285    3F0B  CD0000    		call	c.mvl
1286    3F0E  F1        		pop	af
1287                    	; 1450          curblkok = YES;
1288    3F0F  210100    		ld	hl,1
1289    3F12  221000    		ld	(_curblkok),hl
1290                    	; 1451          }
1291                    	; 1452      else
1292                    	; 1453          {
1293                    	; 1454          if (sdtestflg)
1294                    	; 1455              {
1295                    	; 1456              printf("  can't read %s sector %lu\n", mbrebr, sector);
1296                    	; 1457              } /* sdtestflg */
1297                    	; 1458          return;
1298                    	; 1459          }
1299                    	; 1460      if (!((sdrdbuf[0x1fe] == 0x55) && (sdrdbuf[0x1ff] == 0xaa)))
1300    3F15  3A4A02    		ld	a,(_sdrdbuf+510)
1301    3F18  FE55      		cp	85
1302    3F1A  2032      		jr	nz,L1145
1303    3F1C  3A4B02    		ld	a,(_sdrdbuf+511)
1304    3F1F  FEAA      		cp	170
1305    3F21  CA663F    		jp	z,L1045
1306    3F24  1828      		jr	L1145
1307                    	L1535:
1308    3F26  2A0000    		ld	hl,(_sdtestflg)
1309    3F29  7C        		ld	a,h
1310    3F2A  B5        		or	l
1311    3F2B  281E      		jr	z,L1735
1312    3F2D  DD6607    		ld	h,(ix+7)
1313    3F30  DD6E06    		ld	l,(ix+6)
1314    3F33  E5        		push	hl
1315    3F34  DD6605    		ld	h,(ix+5)
1316    3F37  DD6E04    		ld	l,(ix+4)
1317    3F3A  E5        		push	hl
1318    3F3B  DD6EEE    		ld	l,(ix-18)
1319    3F3E  DD66EF    		ld	h,(ix-17)
1320    3F41  E5        		push	hl
1321    3F42  21883D    		ld	hl,L5452
1322    3F45  CD0000    		call	_printf
1323    3F48  F1        		pop	af
1324    3F49  F1        		pop	af
1325    3F4A  F1        		pop	af
1326                    	L1735:
1327    3F4B  C30000    		jp	c.rets
1328                    	L1145:
1329                    	; 1461          {
1330                    	; 1462          if (sdtestflg)
1331    3F4E  2A0000    		ld	hl,(_sdtestflg)
1332    3F51  7C        		ld	a,h
1333    3F52  B5        		or	l
1334    3F53  280E      		jr	z,L1245
1335                    	; 1463              {
1336                    	; 1464              printf("  no %s boot signature found\n", mbrebr);
1337    3F55  DD6EEE    		ld	l,(ix-18)
1338    3F58  DD66EF    		ld	h,(ix-17)
1339    3F5B  E5        		push	hl
1340    3F5C  21A43D    		ld	hl,L5552
1341    3F5F  CD0000    		call	_printf
1342    3F62  F1        		pop	af
1343                    	L1245:
1344                    	; 1465              } /* sdtestflg */
1345                    	; 1466          return;
1346    3F63  C30000    		jp	c.rets
1347                    	L1045:
1348                    	; 1467          }
1349                    	; 1468      if (curblkno == 0)
1350    3F66  210200    		ld	hl,_curblkno
1351    3F69  7E        		ld	a,(hl)
1352    3F6A  23        		inc	hl
1353    3F6B  B6        		or	(hl)
1354    3F6C  23        		inc	hl
1355    3F6D  B6        		or	(hl)
1356    3F6E  23        		inc	hl
1357    3F6F  B6        		or	(hl)
1358    3F70  203D      		jr	nz,L1345
1359                    	; 1469          {
1360                    	; 1470          memcpy(dsksign, &sdrdbuf[0x1b8], sizeof dsksign);
1361    3F72  210400    		ld	hl,4
1362    3F75  E5        		push	hl
1363    3F76  210402    		ld	hl,_sdrdbuf+440
1364    3F79  E5        		push	hl
1365    3F7A  214E02    		ld	hl,_dsksign
1366    3F7D  CD0000    		call	_memcpy
1367    3F80  F1        		pop	af
1368    3F81  F1        		pop	af
1369                    	; 1471          if (sdtestflg)
1370    3F82  2A0000    		ld	hl,(_sdtestflg)
1371    3F85  7C        		ld	a,h
1372    3F86  B5        		or	l
1373    3F87  2826      		jr	z,L1345
1374                    	; 1472              {
1375                    	; 1473  
1376                    	; 1474              printf("  disk identifier: 0x%02x%02x%02x%02x\n",
1377                    	; 1475                     dsksign[3], dsksign[2], dsksign[1], dsksign[0]);
1378    3F89  3A4E02    		ld	a,(_dsksign)
1379    3F8C  4F        		ld	c,a
1380    3F8D  97        		sub	a
1381    3F8E  47        		ld	b,a
1382    3F8F  C5        		push	bc
1383    3F90  3A4F02    		ld	a,(_dsksign+1)
1384    3F93  4F        		ld	c,a
1385    3F94  97        		sub	a
1386    3F95  47        		ld	b,a
1387    3F96  C5        		push	bc
1388    3F97  3A5002    		ld	a,(_dsksign+2)
1389    3F9A  4F        		ld	c,a
1390    3F9B  97        		sub	a
1391    3F9C  47        		ld	b,a
1392    3F9D  C5        		push	bc
1393    3F9E  3A5102    		ld	a,(_dsksign+3)
1394    3FA1  4F        		ld	c,a
1395    3FA2  97        		sub	a
1396    3FA3  47        		ld	b,a
1397    3FA4  C5        		push	bc
1398    3FA5  21C23D    		ld	hl,L5652
1399    3FA8  CD0000    		call	_printf
1400    3FAB  F1        		pop	af
1401    3FAC  F1        		pop	af
1402    3FAD  F1        		pop	af
1403    3FAE  F1        		pop	af
1404                    	L1345:
1405                    	; 1476              } /* sdtestflg */
1406                    	; 1477          }
1407                    	; 1478      /* go through MBR partition entries until first empty */
1408                    	; 1479      /* !!as the MBR entry routine is called recusively a way is
1409                    	; 1480         needed to read sector 0 when going back to MBR if
1410                    	; 1481         there is a primary partition entry after an EBR entry!! */
1411                    	; 1482      entp = &sdrdbuf[0x01be] ;
1412    3FAF  210A02    		ld	hl,_sdrdbuf+446
1413    3FB2  DD75F0    		ld	(ix-16),l
1414    3FB5  DD74F1    		ld	(ix-15),h
1415                    	; 1483      for (partidx = 1; (partidx <= 4) && (partdsk < 16); partidx++, entp += 16)
1416    3FB8  DD36F801  		ld	(ix-8),1
1417    3FBC  DD36F900  		ld	(ix-7),0
1418                    	L1545:
1419    3FC0  3E04      		ld	a,4
1420    3FC2  DD96F8    		sub	(ix-8)
1421    3FC5  3E00      		ld	a,0
1422    3FC7  DD9EF9    		sbc	a,(ix-7)
1423    3FCA  FA4640    		jp	m,L1645
1424    3FCD  3A0E00    		ld	a,(_partdsk)
1425    3FD0  D610      		sub	16
1426    3FD2  3A0F00    		ld	a,(_partdsk+1)
1427    3FD5  DE00      		sbc	a,0
1428    3FD7  F24640    		jp	p,L1645
1429                    	; 1484          {
1430                    	; 1485          if (sdtestflg)
1431    3FDA  2A0000    		ld	hl,(_sdtestflg)
1432    3FDD  7C        		ld	a,h
1433    3FDE  B5        		or	l
1434    3FDF  2836      		jr	z,L1155
1435                    	; 1486              {
1436                    	; 1487              printf("%s partition entry %d: ", mbrebr, partidx);
1437    3FE1  DD6EF8    		ld	l,(ix-8)
1438    3FE4  DD66F9    		ld	h,(ix-7)
1439    3FE7  E5        		push	hl
1440    3FE8  DD6EEE    		ld	l,(ix-18)
1441    3FEB  DD66EF    		ld	h,(ix-17)
1442    3FEE  E5        		push	hl
1443    3FEF  21E93D    		ld	hl,L5752
1444    3FF2  CD0000    		call	_printf
1445    3FF5  F1        		pop	af
1446    3FF6  F1        		pop	af
1447    3FF7  181E      		jr	L1155
1448                    	L1745:
1449    3FF9  DD34F8    		inc	(ix-8)
1450    3FFC  2003      		jr	nz,L661
1451    3FFE  DD34F9    		inc	(ix-7)
1452                    	L661:
1453    4001  DD6EF0    		ld	l,(ix-16)
1454    4004  DD66F1    		ld	h,(ix-15)
1455    4007  7D        		ld	a,l
1456    4008  C610      		add	a,16
1457    400A  6F        		ld	l,a
1458    400B  7C        		ld	a,h
1459    400C  CE00      		adc	a,0
1460    400E  67        		ld	h,a
1461    400F  DD75F0    		ld	(ix-16),l
1462    4012  DD74F1    		ld	(ix-15),h
1463    4015  18A9      		jr	L1545
1464                    	L1155:
1465                    	; 1488              } /* sdtestflg */
1466                    	; 1489          enttype = sdmbrentry(entp);
1467    4017  DD6EF0    		ld	l,(ix-16)
1468    401A  DD66F1    		ld	h,(ix-15)
1469    401D  CDE236    		call	_sdmbrentry
1470    4020  DD71F2    		ld	(ix-14),c
1471    4023  DD70F3    		ld	(ix-13),b
1472                    	; 1490          if (enttype == -1) /* read error */
1473    4026  DD7EF2    		ld	a,(ix-14)
1474    4029  FEFF      		cp	255
1475    402B  2005      		jr	nz,L071
1476    402D  DD7EF3    		ld	a,(ix-13)
1477    4030  FEFF      		cp	255
1478                    	L071:
1479    4032  2003      		jr	nz,L1255
1480                    	; 1491                   return;
1481    4034  C30000    		jp	c.rets
1482                    	L1255:
1483                    	; 1492          else if (enttype == PARTZRO)
1484    4037  DD7EF2    		ld	a,(ix-14)
1485    403A  DDB6F3    		or	(ix-13)
1486    403D  20BA      		jr	nz,L1745
1487                    	; 1493              {
1488                    	; 1494              if (!sdtestflg)
1489    403F  2A0000    		ld	hl,(_sdtestflg)
1490    4042  7C        		ld	a,h
1491    4043  B5        		or	l
1492    4044  20B3      		jr	nz,L1745
1493                    	; 1495                  {
1494                    	; 1496                  /* if compiled as test program show also empty partitions */
1495                    	; 1497                  break;
1496                    	L1645:
1497                    	; 1498                  } /* sdtestflg */
1498                    	; 1499              }
1499                    	; 1500          }
1500                    	; 1501      /* now handle the previously saved EBR partition sectors */
1501                    	; 1502      for (partidx = 0; (partidx < ebrrecidx) && (partdsk < 16); partidx++)
1502    4046  DD36F800  		ld	(ix-8),0
1503    404A  DD36F900  		ld	(ix-7),0
1504                    	L1655:
1505    404E  211600    		ld	hl,_ebrrecidx
1506    4051  DD7EF8    		ld	a,(ix-8)
1507    4054  96        		sub	(hl)
1508    4055  DD7EF9    		ld	a,(ix-7)
1509    4058  23        		inc	hl
1510    4059  9E        		sbc	a,(hl)
1511    405A  F2AF42    		jp	p,L1755
1512    405D  3A0E00    		ld	a,(_partdsk)
1513    4060  D610      		sub	16
1514    4062  3A0F00    		ld	a,(_partdsk+1)
1515    4065  DE00      		sbc	a,0
1516    4067  F2AF42    		jp	p,L1755
1517                    	; 1503          {
1518                    	; 1504          if (sdread(sdrdbuf, ebrrecs[partidx]))
1519    406A  DD6EF8    		ld	l,(ix-8)
1520    406D  DD66F9    		ld	h,(ix-7)
1521    4070  29        		add	hl,hl
1522    4071  29        		add	hl,hl
1523    4072  011800    		ld	bc,_ebrrecs
1524    4075  09        		add	hl,bc
1525    4076  23        		inc	hl
1526    4077  23        		inc	hl
1527    4078  4E        		ld	c,(hl)
1528    4079  23        		inc	hl
1529    407A  46        		ld	b,(hl)
1530    407B  C5        		push	bc
1531    407C  2B        		dec	hl
1532    407D  2B        		dec	hl
1533    407E  2B        		dec	hl
1534    407F  4E        		ld	c,(hl)
1535    4080  23        		inc	hl
1536    4081  46        		ld	b,(hl)
1537    4082  C5        		push	bc
1538    4083  214C00    		ld	hl,_sdrdbuf
1539    4086  CDE320    		call	_sdread
1540    4089  F1        		pop	af
1541    408A  F1        		pop	af
1542    408B  79        		ld	a,c
1543    408C  B0        		or	b
1544    408D  CAFA40    		jp	z,L1265
1545                    	; 1505              {
1546                    	; 1506              curblkno = ebrrecs[partidx];
1547    4090  210200    		ld	hl,_curblkno
1548    4093  E5        		push	hl
1549    4094  DD6EF8    		ld	l,(ix-8)
1550    4097  DD66F9    		ld	h,(ix-7)
1551    409A  29        		add	hl,hl
1552    409B  29        		add	hl,hl
1553    409C  011800    		ld	bc,_ebrrecs
1554    409F  09        		add	hl,bc
1555    40A0  E5        		push	hl
1556    40A1  CD0000    		call	c.mvl
1557    40A4  F1        		pop	af
1558                    	; 1507              curblkok = YES;
1559    40A5  210100    		ld	hl,1
1560    40A8  221000    		ld	(_curblkok),hl
1561                    	; 1508              }
1562                    	; 1509          else
1563                    	; 1510              {
1564                    	; 1511              if (sdtestflg)
1565                    	; 1512                  {
1566                    	; 1513                  printf("  can't read %s sector %lu\n", mbrebr, sector);
1567                    	; 1514                  } /* sdtestflg */
1568                    	; 1515              return;
1569                    	; 1516              }
1570                    	; 1517          entp = &sdrdbuf[0x01be] ;
1571    40AB  210A02    		ld	hl,_sdrdbuf+446
1572    40AE  DD75F0    		ld	(ix-16),l
1573    40B1  DD74F1    		ld	(ix-15),h
1574                    	; 1518          for (partidx = 1; (partidx <= 4) && (partdsk < 16); partidx++, entp += 16)
1575    40B4  DD36F801  		ld	(ix-8),1
1576    40B8  DD36F900  		ld	(ix-7),0
1577                    	L1565:
1578    40BC  3E04      		ld	a,4
1579    40BE  DD96F8    		sub	(ix-8)
1580    40C1  3E00      		ld	a,0
1581    40C3  DD9EF9    		sbc	a,(ix-7)
1582    40C6  FAEF40    		jp	m,L1065
1583    40C9  3A0E00    		ld	a,(_partdsk)
1584    40CC  D610      		sub	16
1585    40CE  3A0F00    		ld	a,(_partdsk+1)
1586    40D1  DE00      		sbc	a,0
1587    40D3  F2EF40    		jp	p,L1065
1588                    	; 1519              {
1589                    	; 1520              if (sdtestflg)
1590    40D6  2A0000    		ld	hl,(_sdtestflg)
1591    40D9  7C        		ld	a,h
1592    40DA  B5        		or	l
1593    40DB  CA4141    		jp	z,L1175
1594                    	; 1521                  {
1595                    	; 1522                  printf("EBR partition entry %d: ", partidx);
1596    40DE  DD6EF8    		ld	l,(ix-8)
1597    40E1  DD66F9    		ld	h,(ix-7)
1598    40E4  E5        		push	hl
1599    40E5  211D3E    		ld	hl,L5162
1600    40E8  CD0000    		call	_printf
1601    40EB  F1        		pop	af
1602    40EC  C34141    		jp	L1175
1603                    	L1065:
1604    40EF  DD34F8    		inc	(ix-8)
1605    40F2  2003      		jr	nz,L271
1606    40F4  DD34F9    		inc	(ix-7)
1607                    	L271:
1608    40F7  C34E40    		jp	L1655
1609                    	L1265:
1610    40FA  2A0000    		ld	hl,(_sdtestflg)
1611    40FD  7C        		ld	a,h
1612    40FE  B5        		or	l
1613    40FF  281E      		jr	z,L1465
1614    4101  DD6607    		ld	h,(ix+7)
1615    4104  DD6E06    		ld	l,(ix+6)
1616    4107  E5        		push	hl
1617    4108  DD6605    		ld	h,(ix+5)
1618    410B  DD6E04    		ld	l,(ix+4)
1619    410E  E5        		push	hl
1620    410F  DD6EEE    		ld	l,(ix-18)
1621    4112  DD66EF    		ld	h,(ix-17)
1622    4115  E5        		push	hl
1623    4116  21013E    		ld	hl,L5062
1624    4119  CD0000    		call	_printf
1625    411C  F1        		pop	af
1626    411D  F1        		pop	af
1627    411E  F1        		pop	af
1628                    	L1465:
1629    411F  C30000    		jp	c.rets
1630                    	L1765:
1631    4122  DD34F8    		inc	(ix-8)
1632    4125  2003      		jr	nz,L471
1633    4127  DD34F9    		inc	(ix-7)
1634                    	L471:
1635    412A  DD6EF0    		ld	l,(ix-16)
1636    412D  DD66F1    		ld	h,(ix-15)
1637    4130  7D        		ld	a,l
1638    4131  C610      		add	a,16
1639    4133  6F        		ld	l,a
1640    4134  7C        		ld	a,h
1641    4135  CE00      		adc	a,0
1642    4137  67        		ld	h,a
1643    4138  DD75F0    		ld	(ix-16),l
1644    413B  DD74F1    		ld	(ix-15),h
1645    413E  C3BC40    		jp	L1565
1646                    	L1175:
1647                    	; 1523                  } /* sdtestflg */
1648                    	; 1524              enttype = sdmbrentry(entp);
1649    4141  DD6EF0    		ld	l,(ix-16)
1650    4144  DD66F1    		ld	h,(ix-15)
1651    4147  CDE236    		call	_sdmbrentry
1652    414A  DD71F2    		ld	(ix-14),c
1653    414D  DD70F3    		ld	(ix-13),b
1654                    	; 1525              if (enttype == -1) /* read error */
1655    4150  DD7EF2    		ld	a,(ix-14)
1656    4153  FEFF      		cp	255
1657    4155  2005      		jr	nz,L671
1658    4157  DD7EF3    		ld	a,(ix-13)
1659    415A  FEFF      		cp	255
1660                    	L671:
1661    415C  2003      		jr	nz,L1275
1662                    	; 1526                   return;
1663    415E  C30000    		jp	c.rets
1664                    	L1275:
1665                    	; 1527              else if (enttype == PARTZRO) /* empty partition entry */
1666    4161  DD7EF2    		ld	a,(ix-14)
1667    4164  DDB6F3    		or	(ix-13)
1668    4167  2010      		jr	nz,L1475
1669                    	; 1528                  {
1670                    	; 1529                  if (sdtestflg)
1671    4169  2A0000    		ld	hl,(_sdtestflg)
1672    416C  7C        		ld	a,h
1673    416D  B5        		or	l
1674    416E  CAEF40    		jp	z,L1065
1675                    	; 1530                      {
1676                    	; 1531                      /* if compiled as test program show also empty partitions */
1677                    	; 1532                      printf("Empty partition entry\n");
1678    4171  21363E    		ld	hl,L5262
1679    4174  CD0000    		call	_printf
1680                    	; 1533                      } /* sdtestflg */
1681                    	; 1534                  else
1682    4177  18A9      		jr	L1765
1683                    	L1475:
1684                    	; 1535                      break;
1685                    	; 1536                  }
1686                    	; 1537              else if (enttype == PARTEBR) /* next chained EBR */
1687    4179  DD7EF2    		ld	a,(ix-14)
1688    417C  FE02      		cp	2
1689    417E  2005      		jr	nz,L002
1690    4180  DD7EF3    		ld	a,(ix-13)
1691    4183  FE00      		cp	0
1692                    	L002:
1693    4185  C22241    		jp	nz,L1765
1694                    	; 1538                  {
1695                    	; 1539                  if (sdtestflg)
1696    4188  2A0000    		ld	hl,(_sdtestflg)
1697    418B  7C        		ld	a,h
1698    418C  B5        		or	l
1699    418D  2806      		jr	z,L1106
1700                    	; 1540                      {
1701                    	; 1541                      printf("EBR chain\n");
1702    418F  214D3E    		ld	hl,L5362
1703    4192  CD0000    		call	_printf
1704                    	L1106:
1705                    	; 1542                      } /* sdtestflg */
1706                    	; 1543                  /* follow the EBR chain */
1707                    	; 1544                  for (chainidx = 0;
1708    4195  DD36F400  		ld	(ix-12),0
1709    4199  DD36F500  		ld	(ix-11),0
1710                    	L1206:
1711                    	; 1545                      ebrnext && (chainidx < 16) && (partdsk < 16);
1712    419D  211200    		ld	hl,_ebrnext
1713    41A0  7E        		ld	a,(hl)
1714    41A1  23        		inc	hl
1715    41A2  B6        		or	(hl)
1716    41A3  23        		inc	hl
1717    41A4  B6        		or	(hl)
1718    41A5  23        		inc	hl
1719    41A6  B6        		or	(hl)
1720    41A7  CA2241    		jp	z,L1765
1721    41AA  DD7EF4    		ld	a,(ix-12)
1722    41AD  D610      		sub	16
1723    41AF  DD7EF5    		ld	a,(ix-11)
1724    41B2  DE00      		sbc	a,0
1725    41B4  F22241    		jp	p,L1765
1726    41B7  3A0E00    		ld	a,(_partdsk)
1727    41BA  D610      		sub	16
1728    41BC  3A0F00    		ld	a,(_partdsk+1)
1729    41BF  DE00      		sbc	a,0
1730    41C1  F22241    		jp	p,L1765
1731                    	; 1546                      chainidx++)
1732                    	; 1547                      {
1733                    	; 1548                      /* ugly hack to stop reading the same sector */
1734                    	; 1549                      if (ebrnext == curblkno)
1735    41C4  211200    		ld	hl,_ebrnext
1736    41C7  E5        		push	hl
1737    41C8  210200    		ld	hl,_curblkno
1738    41CB  E5        		push	hl
1739    41CC  CD0000    		call	c.lcmp
1740    41CF  200D      		jr	nz,L1606
1741                    	; 1550                           break;
1742    41D1  C32241    		jp	L1765
1743                    	L1406:
1744    41D4  DD34F4    		inc	(ix-12)
1745    41D7  2003      		jr	nz,L202
1746    41D9  DD34F5    		inc	(ix-11)
1747                    	L202:
1748    41DC  18BF      		jr	L1206
1749                    	L1606:
1750                    	; 1551                      if (sdread(sdrdbuf, ebrnext))
1751    41DE  211500    		ld	hl,_ebrnext+3
1752    41E1  46        		ld	b,(hl)
1753    41E2  2B        		dec	hl
1754    41E3  4E        		ld	c,(hl)
1755    41E4  C5        		push	bc
1756    41E5  2B        		dec	hl
1757    41E6  46        		ld	b,(hl)
1758    41E7  2B        		dec	hl
1759    41E8  4E        		ld	c,(hl)
1760    41E9  C5        		push	bc
1761    41EA  214C00    		ld	hl,_sdrdbuf
1762    41ED  CDE320    		call	_sdread
1763    41F0  F1        		pop	af
1764    41F1  F1        		pop	af
1765    41F2  79        		ld	a,c
1766    41F3  B0        		or	b
1767    41F4  2855      		jr	z,L1706
1768                    	; 1552                          {
1769                    	; 1553                          curblkno = ebrnext;
1770    41F6  210200    		ld	hl,_curblkno
1771    41F9  E5        		push	hl
1772    41FA  211200    		ld	hl,_ebrnext
1773    41FD  E5        		push	hl
1774    41FE  CD0000    		call	c.mvl
1775    4201  F1        		pop	af
1776                    	; 1554                          curblkok = YES;
1777    4202  210100    		ld	hl,1
1778    4205  221000    		ld	(_curblkok),hl
1779                    	; 1555                          }
1780                    	; 1556                      else
1781                    	; 1557                          {
1782                    	; 1558                          if (sdtestflg)
1783                    	; 1559                              {
1784                    	; 1560                              printf("  can't read %s sector %lu\n", mbrebr, sector);
1785                    	; 1561                              } /* sdtestflg */
1786                    	; 1562                          return;
1787                    	; 1563                          }
1788                    	; 1564                      entp = &sdrdbuf[0x01be] ;
1789    4208  210A02    		ld	hl,_sdrdbuf+446
1790    420B  DD75F0    		ld	(ix-16),l
1791    420E  DD74F1    		ld	(ix-15),h
1792                    	; 1565                      for (cpartidx = 1;
1793    4211  DD36F601  		ld	(ix-10),1
1794    4215  DD36F700  		ld	(ix-9),0
1795                    	L1216:
1796                    	; 1566                          (cpartidx <= 4) && (partdsk < 16);
1797    4219  3E04      		ld	a,4
1798    421B  DD96F6    		sub	(ix-10)
1799    421E  3E00      		ld	a,0
1800    4220  DD9EF7    		sbc	a,(ix-9)
1801    4223  FAD441    		jp	m,L1406
1802    4226  3A0E00    		ld	a,(_partdsk)
1803    4229  D610      		sub	16
1804    422B  3A0F00    		ld	a,(_partdsk+1)
1805    422E  DE00      		sbc	a,0
1806    4230  F2D441    		jp	p,L1406
1807                    	; 1567                          cpartidx++, entp += 16)
1808                    	; 1568                          {
1809                    	; 1569                          if (sdtestflg)
1810    4233  2A0000    		ld	hl,(_sdtestflg)
1811    4236  7C        		ld	a,h
1812    4237  B5        		or	l
1813    4238  CA9242    		jp	z,L1616
1814                    	; 1570                              {
1815                    	; 1571                              printf("EBR chained  partition entry %d: ",
1816                    	; 1572                                   cpartidx);
1817    423B  DD6EF6    		ld	l,(ix-10)
1818    423E  DD66F7    		ld	h,(ix-9)
1819    4241  E5        		push	hl
1820    4242  21743E    		ld	hl,L5562
1821    4245  CD0000    		call	_printf
1822    4248  F1        		pop	af
1823    4249  1847      		jr	L1616
1824                    	L1706:
1825    424B  2A0000    		ld	hl,(_sdtestflg)
1826    424E  7C        		ld	a,h
1827    424F  B5        		or	l
1828    4250  281E      		jr	z,L1116
1829    4252  DD6607    		ld	h,(ix+7)
1830    4255  DD6E06    		ld	l,(ix+6)
1831    4258  E5        		push	hl
1832    4259  DD6605    		ld	h,(ix+5)
1833    425C  DD6E04    		ld	l,(ix+4)
1834    425F  E5        		push	hl
1835    4260  DD6EEE    		ld	l,(ix-18)
1836    4263  DD66EF    		ld	h,(ix-17)
1837    4266  E5        		push	hl
1838    4267  21583E    		ld	hl,L5462
1839    426A  CD0000    		call	_printf
1840    426D  F1        		pop	af
1841    426E  F1        		pop	af
1842    426F  F1        		pop	af
1843                    	L1116:
1844    4270  C30000    		jp	c.rets
1845                    	L1416:
1846    4273  DD34F6    		inc	(ix-10)
1847    4276  2003      		jr	nz,L402
1848    4278  DD34F7    		inc	(ix-9)
1849                    	L402:
1850    427B  DD6EF0    		ld	l,(ix-16)
1851    427E  DD66F1    		ld	h,(ix-15)
1852    4281  7D        		ld	a,l
1853    4282  C610      		add	a,16
1854    4284  6F        		ld	l,a
1855    4285  7C        		ld	a,h
1856    4286  CE00      		adc	a,0
1857    4288  67        		ld	h,a
1858    4289  DD75F0    		ld	(ix-16),l
1859    428C  DD74F1    		ld	(ix-15),h
1860    428F  C31942    		jp	L1216
1861                    	L1616:
1862                    	; 1573                              } /* sdtestflg */
1863                    	; 1574                          enttype = sdmbrentry(entp);
1864    4292  DD6EF0    		ld	l,(ix-16)
1865    4295  DD66F1    		ld	h,(ix-15)
1866    4298  CDE236    		call	_sdmbrentry
1867    429B  DD71F2    		ld	(ix-14),c
1868    429E  DD70F3    		ld	(ix-13),b
1869                    	; 1575                          if (enttype == -1) /* read error */
1870    42A1  DD7EF2    		ld	a,(ix-14)
1871    42A4  FEFF      		cp	255
1872    42A6  2005      		jr	nz,L602
1873    42A8  DD7EF3    		ld	a,(ix-13)
1874    42AB  FEFF      		cp	255
1875                    	L602:
1876    42AD  20C4      		jr	nz,L1416
1877                    	; 1576                              return;
1878                    	; 1577                          }
1879                    	; 1578                      }
1880                    	; 1579                  }
1881                    	; 1580              }
1882                    	; 1581          }
1883                    	; 1582      }
1884                    	L1755:
1885                    	;    1  /*  z80sdbt.c Boot and SD card test program.
1886                    	;    2   *
1887                    	;    3   *  Boot code for my DIY Z80 Computer. This
1888                    	;    4   *  program is compiled with Whitesmiths/COSMIC
1889                    	;    5   *  C compiler for Z80.
1890                    	;    6   *
1891                    	;    7   *  Initializes the hardware and detects the
1892                    	;    8   *  presence and partitioning of an attached SD card.
1893                    	;    9   *
1894                    	;   10   *  You are free to use, modify, and redistribute
1895                    	;   11   *  this source code. No warranties are given.
1896                    	;   12   *  Hastily Cobbled Together 2021 and 2022
1897                    	;   13   *  by Hans-Ake Lund
1898                    	;   14   *
1899                    	;   15   */
1900                    	;   16  
1901                    	;   17  #include <std.h>
1902                    	;   18  #include "z80computer.h"
1903                    	;   19  #include "builddate.h"
1904                    	;   20  
1905                    	;   21  /* Program name and version */
1906                    	;   22  #define PRGNAME "z80sdbt "
1907                    	;   23  #define VERSION "version 0.9, "
1908                    	;   24  /* Address in high RAM where to copy uploader */
1909                    	;   25  #define UPLADDR 0xf000
1910                    	;   26  
1911                    	;   27  /* This code should be cleaned up when
1912                    	;   28     remaining functions are implemented
1913                    	;   29   */
1914                    	;   30  #define PARTZRO 0  /* Empty partition entry */
1915                    	;   31  #define PARTMBR 1  /* MBR partition */
1916                    	;   32  #define PARTEBR 2  /* EBR logical partition */
1917                    	;   33  #define PARTGPT 3  /* GPT partition */
1918                    	;   34  #define EBRCONT 20 /* EBR container partition in MBR */
1919                    	;   35  
1920                    	;   36  struct partentry
1921                    	;   37      {
1922                    	;   38      char partype;
1923                    	;   39      char dskletter;
1924                    	;   40      int bootable;
1925                    	;   41      unsigned long dskstart;
1926                    	;   42      unsigned long dskend;
1927                    	;   43      unsigned long dsksize;
1928                    	;   44      unsigned char dsktype[16];
1929                    	;   45      } dskmap[16];
1930                    	;   46  
1931                    	;   47  unsigned char dsksign[4]; /* MBR/EBR disk signature */
1932                    	;   48  
1933                    	;   49  /* Function prototypes */
1934                    	;   50  void sdmbrpart(unsigned long);
1935                    	;   51  
1936                    	;   52  /* External data */
1937                    	;   53  extern const char upload[];
1938                    	;   54  extern const int upload_size;
1939                    	;   55  extern const int binsize;
1940                    	;   56  extern const int binstart;
1941                    	;   57  
1942                    	;   58  /* RAM/EPROM probe */
1943                    	;   59  const int ramprobe = 0;
1944                    	;   60  int *rampptr;
1945                    	;   61  
1946                    	;   62  /* Response length in bytes
1947                    	;   63   */
1948                    	;   64  #define R1_LEN 1
1949                    	;   65  #define R3_LEN 5
1950                    	;   66  #define R7_LEN 5
1951                    	;   67  
1952                    	;   68  /* The SD card commands (5 bytes) and a CRC7 byte as the last byte.
1953                    	;   69   * (The CRC7 byte in the tables below are only for information,
1954                    	;   70   * it is calculated by the sdcommand routine.)
1955                    	;   71   */
1956                    	;   72  const unsigned char cmd0[] = {0x40, 0x00, 0x00, 0x00, 0x00, 0x95};
1957                    	;   73  const unsigned char cmd8[] = {0x48, 0x00, 0x00, 0x01, 0xaa, 0x87};
1958                    	;   74  const unsigned char cmd9[] = {0x49, 0x00, 0x00, 0x00, 0x00, 0xaf};
1959                    	;   75  const unsigned char cmd10[] = {0x4a, 0x00, 0x00, 0x00, 0x00, 0x1b};
1960                    	;   76  const unsigned char cmd16[] = {0x50, 0x00, 0x00, 0x02, 0x00, 0x15};
1961                    	;   77  const unsigned char cmd17[] = {0x51, 0x00, 0x00, 0x00, 0x00, 0x55};
1962                    	;   78  const unsigned char cmd24[] = {0x58, 0x00, 0x00, 0x00, 0x00, 0x6f};
1963                    	;   79  const unsigned char cmd55[] = {0x77, 0x00, 0x00, 0x00, 0x00, 0x65};
1964                    	;   80  const unsigned char cmd58[] = {0x7a, 0x00, 0x00, 0x00, 0x00, 0xfd};
1965                    	;   81  const unsigned char acmd41[] = {0x69, 0x40, 0x00, 0x01, 0xaa, 0x33};
1966                    	;   82  
1967                    	;   83  /* Partition identifiers
1968                    	;   84   */
1969                    	;   85  /* For GPT I have decided that a CP/M partition
1970                    	;   86   * has GUID: AC7176FD-8D55-4FFF-86A5-A36D6368D0CB
1971                    	;   87   */
1972                    	;   88  const unsigned char gptcpm[] =
1973                    	;   89      {
1974                    	;   90      0xfd, 0x76, 0x71, 0xac, 0x55, 0x8d, 0xff, 0x4f,
1975                    	;   91      0x86, 0xa5, 0xa3, 0x6d, 0x63, 0x68, 0xd0, 0xcb
1976                    	;   92      };
1977                    	;   93  /* For MBR/EBR the partition type for CP/M is 0x52
1978                    	;   94   * according to: https://en.wikipedia.org/wiki/Partition_type
1979                    	;   95   */
1980                    	;   96  const unsigned char mbrcpm = 0x52;    /* CP/M partition */
1981                    	;   97  const unsigned char mbrexcode = 0x5f; /* Z80 executable code partition */
1982                    	;   98  /* has a special format that */
1983                    	;   99  /* includes number of sectors to */
1984                    	;  100  /* load and a signature, TBD */
1985                    	;  101  
1986                    	;  102  /* Buffers
1987                    	;  103   */
1988                    	;  104  unsigned char sdrdbuf[512];  /* recieved data from the SD card */
1989                    	;  105  
1990                    	;  106  unsigned char ocrreg[4];     /* SD card OCR register */
1991                    	;  107  unsigned char cidreg[16];    /* SD card CID register */
1992                    	;  108  unsigned char csdreg[16];    /* SD card CSD register */
1993                    	;  109  unsigned long ebrrecs[4];    /* detected EBR records to process */
1994                    	;  110  int ebrrecidx; /* how many EBR records that are populated */
1995                    	;  111  unsigned long ebrnext; /* next chained ebr record */
1996                    	;  112  
1997                    	;  113  /* Variables
1998                    	;  114   */
1999                    	;  115  int curblkok;  /* if YES curblockno is read into buffer */
2000                    	;  116  int partdsk;   /* partition/disk number, 0 = disk A */
2001                    	;  117  int sdinitok;  /* SD card initialized and ready */
2002                    	;  118  int sdver2;    /* SD card version 2 if YES, version 1 if NO */
2003                    	;  119  unsigned long blkmult;   /* block address multiplier */
2004                    	;  120  unsigned long curblkno;  /* block in buffer if curblkok == YES */
2005                    	;  121  
2006                    	;  122  /* debug bool */
2007                    	;  123  int sdtestflg;
2008                    	;  124  
2009                    	;  125  /* CRC routines from:
2010                    	;  126   * https://github.com/LonelyWolf/stm32/blob/master/stm32l-dosfs/sdcard.c
2011                    	;  127   */
2012                    	;  128  
2013                    	;  129  /*
2014                    	;  130  // Calculate CRC7
2015                    	;  131  // It's a 7 bit CRC with polynomial x^7 + x^3 + 1
2016                    	;  132  // input:
2017                    	;  133  //   crcIn - the CRC before (0 for first step)
2018                    	;  134  //   data - byte for CRC calculation
2019                    	;  135  // return: the new CRC7
2020                    	;  136  */
2021                    	;  137  unsigned char CRC7_one(unsigned char crcIn, unsigned char data)
2022                    	;  138      {
2023                    	;  139      const unsigned char g = 0x89;
2024                    	;  140      unsigned char i;
2025                    	;  141  
2026                    	;  142      crcIn ^= data;
2027                    	;  143      for (i = 0; i < 8; i++)
2028                    	;  144          {
2029                    	;  145          if (crcIn & 0x80) crcIn ^= g;
2030                    	;  146          crcIn <<= 1;
2031                    	;  147          }
2032                    	;  148  
2033                    	;  149      return crcIn;
2034                    	;  150      }
2035                    	;  151  
2036                    	;  152  /*
2037                    	;  153  // Calculate CRC16 CCITT
2038                    	;  154  // It's a 16 bit CRC with polynomial x^16 + x^12 + x^5 + 1
2039                    	;  155  // input:
2040                    	;  156  //   crcIn - the CRC before (0 for rist step)
2041                    	;  157  //   data - byte for CRC calculation
2042                    	;  158  // return: the CRC16 value
2043                    	;  159  */
2044                    	;  160  unsigned int CRC16_one(unsigned int crcIn, unsigned char data)
2045                    	;  161      {
2046                    	;  162      crcIn  = (unsigned char)(crcIn >> 8)|(crcIn << 8);
2047                    	;  163      crcIn ^=  data;
2048                    	;  164      crcIn ^= (unsigned char)(crcIn & 0xff) >> 4;
2049                    	;  165      crcIn ^= (crcIn << 8) << 4;
2050                    	;  166      crcIn ^= ((crcIn & 0xff) << 4) << 1;
2051                    	;  167  
2052                    	;  168      return crcIn;
2053                    	;  169      }
2054                    	;  170  
2055                    	;  171  /* Send command to SD card and recieve answer.
2056                    	;  172   * A command is 5 bytes long and is followed by
2057                    	;  173   * a CRC7 checksum byte.
2058                    	;  174   * Returns a pointer to the response
2059                    	;  175   * or 0 if no response start bit found.
2060                    	;  176   */
2061                    	;  177  unsigned char *sdcommand(unsigned char *sdcmdp,
2062                    	;  178                           unsigned char *recbuf, int recbytes)
2063                    	;  179      {
2064                    	;  180      int searchn;  /* byte counter to search for response */
2065                    	;  181      int sdcbytes; /* byte counter for bytes to send */
2066                    	;  182      unsigned char *retptr; /* pointer used to store response */
2067                    	;  183      unsigned char rbyte;   /* recieved byte */
2068                    	;  184      unsigned char crc = 0; /* calculated CRC7 */
2069                    	;  185  
2070                    	;  186      /* send 8*2 clockpules */
2071                    	;  187      spiio(0xff);
2072                    	;  188      spiio(0xff);
2073                    	;  189      for (sdcbytes = 5; 0 < sdcbytes; sdcbytes--) /* send bytes */
2074                    	;  190          {
2075                    	;  191          crc = CRC7_one(crc, *sdcmdp);
2076                    	;  192          spiio(*sdcmdp++);
2077                    	;  193          }
2078                    	;  194      spiio(crc | 0x01);
2079                    	;  195      /* search for recieved byte with start bit
2080                    	;  196         for a maximum of 10 recieved bytes  */
2081                    	;  197      for (searchn = 10; 0 < searchn; searchn--)
2082                    	;  198          {
2083                    	;  199          rbyte = spiio(0xff);
2084                    	;  200          if ((rbyte & 0x80) == 0)
2085                    	;  201              break;
2086                    	;  202          }
2087                    	;  203      if (searchn == 0) /* no start bit found */
2088                    	;  204          return (NO);
2089                    	;  205      retptr = recbuf;
2090                    	;  206      *retptr++ = rbyte;
2091                    	;  207      for (; 1 < recbytes; recbytes--) /* recieve bytes */
2092                    	;  208          *retptr++ = spiio(0xff);
2093                    	;  209      return (recbuf);
2094                    	;  210      }
2095                    	;  211  
2096                    	;  212  /* Initialise SD card interface
2097                    	;  213   *
2098                    	;  214   * returns YES if ok and NO if not ok
2099                    	;  215   *
2100                    	;  216   * References:
2101                    	;  217   *   https://www.sdcard.org/downloads/pls/
2102                    	;  218   *      Physical Layer Simplified Specification version 8.0
2103                    	;  219   *
2104                    	;  220   * A nice flowchart how to initialize:
2105                    	;  221   *   https://www.totalphase.com/blog/2018/08/set-sdc-mmc-cards-spi-mode-verify-files-successfully-programmed/
2106                    	;  222   *
2107                    	;  223   */
2108                    	;  224  int sdinit()
2109                    	;  225      {
2110                    	;  226      int nbytes;  /* byte counter */
2111                    	;  227      int tries;   /* tries to get to active state or searching for data  */
2112                    	;  228      int wtloop;  /* timer loop when trying to enter active state */
2113                    	;  229      unsigned char cmdbuf[5];   /* buffer to build command in */
2114                    	;  230      unsigned char rstatbuf[5]; /* buffer to recieve status in */
2115                    	;  231      unsigned char *statptr;    /* pointer to returned status from SD command */
2116                    	;  232      unsigned char crc;         /* crc register for CID and CSD */
2117                    	;  233      unsigned char rbyte;       /* recieved byte */
2118                    	;  234      unsigned char *prtptr;     /* for debug printing */
2119                    	;  235  
2120                    	;  236      ledon();
2121                    	;  237      spideselect();
2122                    	;  238      sdinitok = NO;
2123                    	;  239  
2124                    	;  240      /* start to generate 9*8 clock pulses with not selected SD card */
2125                    	;  241      for (nbytes = 9; 0 < nbytes; nbytes--)
2126                    	;  242          spiio(0xff);
2127                    	;  243      if (sdtestflg)
2128                    	;  244          {
2129                    	;  245          printf("\nSent 8*8 (72) clock pulses, select not active\n");
2130                    	;  246          } /* sdtestflg */
2131                    	;  247      spiselect();
2132                    	;  248  
2133                    	;  249      /* CMD0: GO_IDLE_STATE */
2134                    	;  250      for (tries = 0; tries < 10; tries++)
2135                    	;  251          {
2136                    	;  252          memcpy(cmdbuf, cmd0, 5);
2137                    	;  253          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2138                    	;  254          if (sdtestflg)
2139                    	;  255              {
2140                    	;  256              if (!statptr)
2141                    	;  257                  printf("CMD0: no response\n");
2142                    	;  258              else
2143                    	;  259                  printf("CMD0: GO_IDLE_STATE, R1 response [%02x]\n", statptr[0]);
2144                    	;  260              } /* sdtestflg */
2145                    	;  261          if (!statptr)
2146                    	;  262              {
2147                    	;  263              spideselect();
2148                    	;  264              ledoff();
2149                    	;  265              return (NO);
2150                    	;  266              }
2151                    	;  267          if (statptr[0] == 0x01)
2152                    	;  268              break;
2153                    	;  269          for (wtloop = 0; wtloop < tries * 10; wtloop++)
2154                    	;  270              {
2155                    	;  271              /* wait loop, time increasing for each try */
2156                    	;  272              spiio(0xff);
2157                    	;  273              }
2158                    	;  274          }
2159                    	;  275  
2160                    	;  276      /* CMD8: SEND_IF_COND */
2161                    	;  277      memcpy(cmdbuf, cmd8, 5);
2162                    	;  278      statptr = sdcommand(cmdbuf, rstatbuf, R7_LEN);
2163                    	;  279      if (sdtestflg)
2164                    	;  280          {
2165                    	;  281          if (!statptr)
2166                    	;  282              printf("CMD8: no response\n");
2167                    	;  283          else
2168                    	;  284              {
2169                    	;  285              printf("CMD8: SEND_IF_COND, R7 response [%02x %02x %02x %02x %02x], ",
2170                    	;  286                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
2171                    	;  287              if (!(statptr[0] & 0xfe)) /* no error */
2172                    	;  288                  {
2173                    	;  289                  if (statptr[4] == 0xaa)
2174                    	;  290                      printf("echo back ok, ");
2175                    	;  291                  else
2176                    	;  292                      printf("invalid echo back\n");
2177                    	;  293                  }
2178                    	;  294              }
2179                    	;  295          } /* sdtestflg */
2180                    	;  296      if (!statptr || (statptr[0] & 0xfe)) /* if no answer or error */
2181                    	;  297          {
2182                    	;  298          sdver2 = NO;
2183                    	;  299          if (sdtestflg)
2184                    	;  300              {
2185                    	;  301              printf("probably SD ver. 1\n");
2186                    	;  302              } /* sdtestflg */
2187                    	;  303          }
2188                    	;  304      else
2189                    	;  305          {
2190                    	;  306          sdver2 = YES;
2191                    	;  307          if (statptr[4] != 0xaa) /* but invalid echo back */
2192                    	;  308              {
2193                    	;  309              spideselect();
2194                    	;  310              ledoff();
2195                    	;  311              return (NO);
2196                    	;  312              }
2197                    	;  313          if (sdtestflg)
2198                    	;  314              {
2199                    	;  315              printf("SD ver 2\n");
2200                    	;  316              } /* sdtestflg */
2201                    	;  317          }
2202                    	;  318  
2203                    	;  319      /* CMD55: APP_CMD followed by ACMD41: SEND_OP_COND until status is 0x00 */
2204                    	;  320      for (tries = 0; tries < 20; tries++)
2205                    	;  321          {
2206                    	;  322          memcpy(cmdbuf, cmd55, 5);
2207                    	;  323          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2208                    	;  324          if (sdtestflg)
2209                    	;  325              {
2210                    	;  326              if (!statptr)
2211                    	;  327                  printf("CMD55: no response\n");
2212                    	;  328              else
2213                    	;  329                  printf("CMD55: APP_CMD, R1 response [%02x]\n", statptr[0]);
2214                    	;  330              } /* sdtestflg */
2215                    	;  331          if (!statptr)
2216                    	;  332              {
2217                    	;  333              spideselect();
2218                    	;  334              ledoff();
2219                    	;  335              return (NO);
2220                    	;  336              }
2221                    	;  337          memcpy(cmdbuf, acmd41, 5);
2222                    	;  338          if (sdver2)
2223                    	;  339              cmdbuf[1] = 0x40;
2224                    	;  340          else
2225                    	;  341              cmdbuf[1] = 0x00;
2226                    	;  342          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2227                    	;  343          if (sdtestflg)
2228                    	;  344              {
2229                    	;  345              if (!statptr)
2230                    	;  346                  printf("ACMD41: no response\n");
2231                    	;  347              else
2232                    	;  348                  printf("ACMD41: SEND_OP_COND, R1 response [%02x]%s\n",
2233                    	;  349                         statptr[0], (statptr[0] == 0x00) ? " - ready" : "");
2234                    	;  350              } /* sdtestflg */
2235                    	;  351          if (!statptr)
2236                    	;  352              {
2237                    	;  353              spideselect();
2238                    	;  354              ledoff();
2239                    	;  355              return (NO);
2240                    	;  356              }
2241                    	;  357          if (statptr[0] == 0x00) /* now the SD card is ready */
2242                    	;  358              {
2243                    	;  359              break;
2244                    	;  360              }
2245                    	;  361          for (wtloop = 0; wtloop < tries * 10; wtloop++)
2246                    	;  362              {
2247                    	;  363              /* wait loop, time increasing for each try */
2248                    	;  364              spiio(0xff);
2249                    	;  365              }
2250                    	;  366          }
2251                    	;  367  
2252                    	;  368      /* CMD58: READ_OCR */
2253                    	;  369      /* According to the flow chart this should not work
2254                    	;  370         for SD ver. 1 but the response is ok anyway
2255                    	;  371         all tested SD cards  */
2256                    	;  372      memcpy(cmdbuf, cmd58, 5);
2257                    	;  373      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
2258                    	;  374      if (sdtestflg)
2259                    	;  375          {
2260                    	;  376          if (!statptr)
2261                    	;  377              printf("CMD58: no response\n");
2262                    	;  378          else
2263                    	;  379              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
2264                    	;  380                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
2265                    	;  381          } /* sdtestflg */
2266                    	;  382      if (!statptr)
2267                    	;  383          {
2268                    	;  384          spideselect();
2269                    	;  385          ledoff();
2270                    	;  386          return (NO);
2271                    	;  387          }
2272                    	;  388      memcpy(&ocrreg[0], &statptr[1], sizeof (ocrreg));
2273                    	;  389      blkmult = 1; /* assume block address */
2274                    	;  390      if (ocrreg[0] & 0x80)
2275                    	;  391          {
2276                    	;  392          /* SD Ver.2+ */
2277                    	;  393          if (!(ocrreg[0] & 0x40))
2278                    	;  394              {
2279                    	;  395              /* SD Ver.2+, Byte address */
2280                    	;  396              blkmult = 512;
2281                    	;  397              }
2282                    	;  398          }
2283                    	;  399  
2284                    	;  400      /* CMD 16: SET_BLOCKLEN, only if Byte addressing */
2285                    	;  401      if (blkmult == 512)
2286                    	;  402          {
2287                    	;  403          memcpy(cmdbuf, cmd16, 5);
2288                    	;  404          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2289                    	;  405          if (sdtestflg)
2290                    	;  406              {
2291                    	;  407              if (!statptr)
2292                    	;  408                  printf("CMD16: no response\n");
2293                    	;  409              else
2294                    	;  410                  printf("CMD16: SET_BLOCKLEN (to 512 bytes), R1 response [%02x]\n",
2295                    	;  411                         statptr[0]);
2296                    	;  412              } /* sdtestflg */
2297                    	;  413          if (!statptr)
2298                    	;  414              {
2299                    	;  415              spideselect();
2300                    	;  416              ledoff();
2301                    	;  417              return (NO);
2302                    	;  418              }
2303                    	;  419          }
2304                    	;  420      /* Register information:
2305                    	;  421       *   https://www.cameramemoryspeed.com/sd-memory-card-faq/reading-sd-card-cid-serial-psn-internal-numbers/
2306                    	;  422       */
2307                    	;  423  
2308                    	;  424      /* CMD10: SEND_CID */
2309                    	;  425      memcpy(cmdbuf, cmd10, 5);
2310                    	;  426      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2311                    	;  427      if (sdtestflg)
2312                    	;  428          {
2313                    	;  429          if (!statptr)
2314                    	;  430              printf("CMD10: no response\n");
2315                    	;  431          else
2316                    	;  432              printf("CMD10: SEND_CID, R1 response [%02x]\n", statptr[0]);
2317                    	;  433          } /* sdtestflg */
2318                    	;  434      if (!statptr)
2319                    	;  435          {
2320                    	;  436          spideselect();
2321                    	;  437          ledoff();
2322                    	;  438          return (NO);
2323                    	;  439          }
2324                    	;  440      /* looking for 0xfe that is the byte before data */
2325                    	;  441      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
2326                    	;  442          ;
2327                    	;  443      if (tries == 0) /* tried too many times */
2328                    	;  444          {
2329                    	;  445          if (sdtestflg)
2330                    	;  446              {
2331                    	;  447              printf("  No data found\n");
2332                    	;  448              } /* sdtestflg */
2333                    	;  449          spideselect();
2334                    	;  450          ledoff();
2335                    	;  451          return (NO);
2336                    	;  452          }
2337                    	;  453      else
2338                    	;  454          {
2339                    	;  455          crc = 0;
2340                    	;  456          for (nbytes = 0; nbytes < 15; nbytes++)
2341                    	;  457              {
2342                    	;  458              rbyte = spiio(0xff);
2343                    	;  459              cidreg[nbytes] = rbyte;
2344                    	;  460              crc = CRC7_one(crc, rbyte);
2345                    	;  461              }
2346                    	;  462          cidreg[15] = spiio(0xff);
2347                    	;  463          crc |= 0x01;
2348                    	;  464          /* some SD cards need additional clock pulses */
2349                    	;  465          for (nbytes = 9; 0 < nbytes; nbytes--)
2350                    	;  466              spiio(0xff);
2351                    	;  467          if (sdtestflg)
2352                    	;  468              {
2353                    	;  469              prtptr = &cidreg[0];
2354                    	;  470              printf("  CID: [");
2355                    	;  471              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
2356                    	;  472                  printf("%02x ", *prtptr);
2357                    	;  473              prtptr = &cidreg[0];
2358                    	;  474              printf("\b] |");
2359                    	;  475              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
2360                    	;  476                  {
2361                    	;  477                  if ((' ' <= *prtptr) && (*prtptr < 127))
2362                    	;  478                      putchar(*prtptr);
2363                    	;  479                  else
2364                    	;  480                      putchar('.');
2365                    	;  481                  }
2366                    	;  482              printf("|\n");
2367                    	;  483              if (crc == cidreg[15])
2368                    	;  484                  {
2369                    	;  485                  printf("CRC7 ok: [%02x]\n", crc);
2370                    	;  486                  }
2371                    	;  487              else
2372                    	;  488                  {
2373                    	;  489                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
2374                    	;  490                         crc, cidreg[15]);
2375                    	;  491                  /* could maybe return failure here */
2376                    	;  492                  }
2377                    	;  493              } /* sdtestflg */
2378                    	;  494          }
2379                    	;  495  
2380                    	;  496      /* CMD9: SEND_CSD */
2381                    	;  497      memcpy(cmdbuf, cmd9, 5);
2382                    	;  498      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2383                    	;  499      if (sdtestflg)
2384                    	;  500          {
2385                    	;  501          if (!statptr)
2386                    	;  502              printf("CMD9: no response\n");
2387                    	;  503          else
2388                    	;  504              printf("CMD9: SEND_CSD, R1 response [%02x]\n", statptr[0]);
2389                    	;  505          } /* sdtestflg */
2390                    	;  506      if (!statptr)
2391                    	;  507          {
2392                    	;  508          spideselect();
2393                    	;  509          ledoff();
2394                    	;  510          return (NO);
2395                    	;  511          }
2396                    	;  512      /* looking for 0xfe that is the byte before data */
2397                    	;  513      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
2398                    	;  514          ;
2399                    	;  515      if (tries == 0) /* tried too many times */
2400                    	;  516          {
2401                    	;  517          if (sdtestflg)
2402                    	;  518              {
2403                    	;  519              printf("  No data found\n");
2404                    	;  520              } /* sdtestflg */
2405                    	;  521          return (NO);
2406                    	;  522          }
2407                    	;  523      else
2408                    	;  524          {
2409                    	;  525          crc = 0;
2410                    	;  526          for (nbytes = 0; nbytes < 15; nbytes++)
2411                    	;  527              {
2412                    	;  528              rbyte = spiio(0xff);
2413                    	;  529              csdreg[nbytes] = rbyte;
2414                    	;  530              crc = CRC7_one(crc, rbyte);
2415                    	;  531              }
2416                    	;  532          csdreg[15] = spiio(0xff);
2417                    	;  533          crc |= 0x01;
2418                    	;  534          /* some SD cards need additional clock pulses */
2419                    	;  535          for (nbytes = 9; 0 < nbytes; nbytes--)
2420                    	;  536              spiio(0xff);
2421                    	;  537          if (sdtestflg)
2422                    	;  538              {
2423                    	;  539              prtptr = &csdreg[0];
2424                    	;  540              printf("  CSD: [");
2425                    	;  541              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
2426                    	;  542                  printf("%02x ", *prtptr);
2427                    	;  543              prtptr = &csdreg[0];
2428                    	;  544              printf("\b] |");
2429                    	;  545              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
2430                    	;  546                  {
2431                    	;  547                  if ((' ' <= *prtptr) && (*prtptr < 127))
2432                    	;  548                      putchar(*prtptr);
2433                    	;  549                  else
2434                    	;  550                      putchar('.');
2435                    	;  551                  }
2436                    	;  552              printf("|\n");
2437                    	;  553              if (crc == csdreg[15])
2438                    	;  554                  {
2439                    	;  555                  printf("CRC7 ok: [%02x]\n", crc);
2440                    	;  556                  }
2441                    	;  557              else
2442                    	;  558                  {
2443                    	;  559                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
2444                    	;  560                         crc, csdreg[15]);
2445                    	;  561                  /* could maybe return failure here */
2446                    	;  562                  }
2447                    	;  563              } /* sdtestflg */
2448                    	;  564          }
2449                    	;  565  
2450                    	;  566      for (nbytes = 9; 0 < nbytes; nbytes--)
2451                    	;  567          spiio(0xff);
2452                    	;  568      if (sdtestflg)
2453                    	;  569          {
2454                    	;  570          printf("Sent 9*8 (72) clock pulses, select active\n");
2455                    	;  571          } /* sdtestflg */
2456                    	;  572  
2457                    	;  573      sdinitok = YES;
2458                    	;  574  
2459                    	;  575      spideselect();
2460                    	;  576      ledoff();
2461                    	;  577  
2462                    	;  578      return (YES);
2463                    	;  579      }
2464                    	;  580  
2465                    	;  581  int sdprobe()
2466                    	;  582      {
2467                    	;  583      unsigned char cmdbuf[5];   /* buffer to build command in */
2468                    	;  584      unsigned char rstatbuf[5]; /* buffer to recieve status in */
2469                    	;  585      unsigned char *statptr;    /* pointer to returned status from SD command */
2470                    	;  586      int nbytes;  /* byte counter */
2471                    	;  587      int allzero = YES;
2472                    	;  588  
2473                    	;  589      ledon();
2474                    	;  590      spiselect();
2475                    	;  591  
2476                    	;  592      /* CMD58: READ_OCR */
2477                    	;  593      memcpy(cmdbuf, cmd58, 5);
2478                    	;  594      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
2479                    	;  595      for (nbytes = 0; nbytes < 5; nbytes++)
2480                    	;  596          {
2481                    	;  597          if (statptr[nbytes] != 0)
2482                    	;  598              allzero = NO;
2483                    	;  599          }
2484                    	;  600      if (sdtestflg)
2485                    	;  601          {
2486                    	;  602          if (!statptr)
2487                    	;  603              printf("CMD58: no response\n");
2488                    	;  604          else
2489                    	;  605              {
2490                    	;  606              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
2491                    	;  607                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
2492                    	;  608              if (allzero)
2493                    	;  609                  printf("SD card not inserted or not initialized\n");
2494                    	;  610              }
2495                    	;  611          } /* sdtestflg */
2496                    	;  612      if (!statptr || allzero)
2497                    	;  613          {
2498                    	;  614          sdinitok = NO;
2499                    	;  615          spideselect();
2500                    	;  616          ledoff();
2501                    	;  617          return (NO);
2502                    	;  618          }
2503                    	;  619  
2504                    	;  620      spideselect();
2505                    	;  621      ledoff();
2506                    	;  622  
2507                    	;  623      return (YES);
2508                    	;  624      }
2509                    	;  625  
2510                    	;  626  /* print OCR, CID and CSD registers*/
2511                    	;  627  void sdprtreg()
2512                    	;  628      {
2513                    	;  629      unsigned int n;
2514                    	;  630      unsigned int csize;
2515                    	;  631      unsigned long devsize;
2516                    	;  632      unsigned long capacity;
2517                    	;  633  
2518                    	;  634      if (!sdinitok)
2519                    	;  635          {
2520                    	;  636          printf("SD card not initialized\n");
2521                    	;  637          return;
2522                    	;  638          }
2523                    	;  639      printf("SD card information:");
2524                    	;  640      if (ocrreg[0] & 0x80)
2525                    	;  641          {
2526                    	;  642          if (ocrreg[0] & 0x40)
2527                    	;  643              printf("  SD card ver. 2+, Block address\n");
2528                    	;  644          else
2529                    	;  645              {
2530                    	;  646              if (sdver2)
2531                    	;  647                  printf("  SD card ver. 2+, Byte address\n");
2532                    	;  648              else
2533                    	;  649                  printf("  SD card ver. 1, Byte address\n");
2534                    	;  650              }
2535                    	;  651          }
2536                    	;  652      printf("  Manufacturer ID: 0x%02x, ", cidreg[0]);
2537                    	;  653      printf("OEM ID: %.2s, ", &cidreg[1]);
2538                    	;  654      printf("Product name: %.5s\n", &cidreg[3]);
2539                    	;  655      printf("  Product revision: %d.%d, ",
2540                    	;  656             (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
2541                    	;  657      printf("Serial number: %lu\n",
2542                    	;  658             (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
2543                    	;  659      printf("  Manufacturing date: %d-%d, ",
2544                    	;  660             2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
2545                    	;  661      if ((csdreg[0] & 0xc0) == 0x00) /* CSD version 1 */
2546                    	;  662          {
2547                    	;  663          n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
2548                    	;  664          csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
2549                    	;  665                  ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
2550                    	;  666          capacity = (unsigned long) csize << (n-10);
2551                    	;  667          printf("Device capacity: %lu MByte\n", capacity >> 10);
2552                    	;  668          }
2553                    	;  669      if ((csdreg[0] & 0xc0) == 0x40) /* CSD version 2 */
2554                    	;  670          {
2555                    	;  671          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
2556                    	;  672                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
2557                    	;  673          capacity = devsize << 9;
2558                    	;  674          printf("Device capacity: %lu MByte\n", capacity >> 10);
2559                    	;  675          }
2560                    	;  676      if ((csdreg[0] & 0xc0) == 0x80) /* CSD version 3 */
2561                    	;  677          {
2562                    	;  678          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
2563                    	;  679                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
2564                    	;  680          capacity = devsize << 9;
2565                    	;  681          printf("Device ultra capacity: %lu MByte\n", capacity >> 10);
2566                    	;  682          }
2567                    	;  683  
2568                    	;  684      if (sdtestflg)
2569                    	;  685          {
2570                    	;  686  
2571                    	;  687          printf("--------------------------------------\n");
2572                    	;  688          printf("OCR register:\n");
2573                    	;  689          if (ocrreg[2] & 0x80)
2574                    	;  690              printf("2.7-2.8V (bit 15) ");
2575                    	;  691          if (ocrreg[1] & 0x01)
2576                    	;  692              printf("2.8-2.9V (bit 16) ");
2577                    	;  693          if (ocrreg[1] & 0x02)
2578                    	;  694              printf("2.9-3.0V (bit 17) ");
2579                    	;  695          if (ocrreg[1] & 0x04)
2580                    	;  696              printf("3.0-3.1V (bit 18) \n");
2581                    	;  697          if (ocrreg[1] & 0x08)
2582                    	;  698              printf("3.1-3.2V (bit 19) ");
2583                    	;  699          if (ocrreg[1] & 0x10)
2584                    	;  700              printf("3.2-3.3V (bit 20) ");
2585                    	;  701          if (ocrreg[1] & 0x20)
2586                    	;  702              printf("3.3-3.4V (bit 21) ");
2587                    	;  703          if (ocrreg[1] & 0x40)
2588                    	;  704              printf("3.4-3.5V (bit 22) \n");
2589                    	;  705          if (ocrreg[1] & 0x80)
2590                    	;  706              printf("3.5-3.6V (bit 23) \n");
2591                    	;  707          if (ocrreg[0] & 0x01)
2592                    	;  708              printf("Switching to 1.8V Accepted (S18A) (bit 24) set ");
2593                    	;  709          if (ocrreg[0] & 0x08)
2594                    	;  710              printf("Over 2TB support Status (CO2T) (bit 27) set\n");
2595                    	;  711          if (ocrreg[0] & 0x20)
2596                    	;  712              printf("UHS-II Card Status (bit 29) set ");
2597                    	;  713          if (ocrreg[0] & 0x80)
2598                    	;  714              {
2599                    	;  715              if (ocrreg[0] & 0x40)
2600                    	;  716                  {
2601                    	;  717                  printf("Card Capacity Status (CCS) (bit 30) set\n");
2602                    	;  718                  printf("  SD Ver.2+, Block address");
2603                    	;  719                  }
2604                    	;  720              else
2605                    	;  721                  {
2606                    	;  722                  printf("Card Capacity Status (CCS) (bit 30) not set\n");
2607                    	;  723                  if (sdver2)
2608                    	;  724                      printf("  SD Ver.2+, Byte address");
2609                    	;  725                  else
2610                    	;  726                      printf("  SD Ver.1, Byte address");
2611                    	;  727                  }
2612                    	;  728              printf("\nCard power up status bit (busy) (bit 31) set\n");
2613                    	;  729              }
2614                    	;  730          else
2615                    	;  731              {
2616                    	;  732              printf("\nCard power up status bit (busy) (bit 31) not set.\n");
2617                    	;  733              printf("  This bit is not set if the card has not finished the power up routine.\n");
2618                    	;  734              }
2619                    	;  735          printf("--------------------------------------\n");
2620                    	;  736          printf("CID register:\n");
2621                    	;  737          printf("MID: 0x%02x, ", cidreg[0]);
2622                    	;  738          printf("OID: %.2s, ", &cidreg[1]);
2623                    	;  739          printf("PNM: %.5s, ", &cidreg[3]);
2624                    	;  740          printf("PRV: %d.%d, ",
2625                    	;  741                 (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
2626                    	;  742          printf("PSN: %lu, ",
2627                    	;  743                 (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
2628                    	;  744          printf("MDT: %d-%d\n",
2629                    	;  745                 2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
2630                    	;  746          printf("--------------------------------------\n");
2631                    	;  747          printf("CSD register:\n");
2632                    	;  748          if ((csdreg[0] & 0xc0) == 0x00)
2633                    	;  749              {
2634                    	;  750              printf("CSD Version 1.0, Standard Capacity\n");
2635                    	;  751              n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
2636                    	;  752              csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
2637                    	;  753                      ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
2638                    	;  754              capacity = (unsigned long) csize << (n-10);
2639                    	;  755              printf(" Device capacity: %lu KByte, %lu MByte\n",
2640                    	;  756                     capacity, capacity >> 10);
2641                    	;  757              }
2642                    	;  758          if ((csdreg[0] & 0xc0) == 0x40)
2643                    	;  759              {
2644                    	;  760              printf("CSD Version 2.0, High Capacity and Extended Capacity\n");
2645                    	;  761              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
2646                    	;  762                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
2647                    	;  763              capacity = devsize << 9;
2648                    	;  764              printf(" Device capacity: %lu KByte, %lu MByte\n",
2649                    	;  765                     capacity, capacity >> 10);
2650                    	;  766              }
2651                    	;  767          if ((csdreg[0] & 0xc0) == 0x80)
2652                    	;  768              {
2653                    	;  769              printf("CSD Version 3.0, Ultra Capacity (SDUC)\n");
2654                    	;  770              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
2655                    	;  771                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
2656                    	;  772              capacity = devsize << 9;
2657                    	;  773              printf(" Device capacity: %lu KByte, %lu MByte\n",
2658                    	;  774                     capacity, capacity >> 10);
2659                    	;  775              }
2660                    	;  776          printf("--------------------------------------\n");
2661                    	;  777  
2662                    	;  778          } /* sdtestflg */ /* SDTEST */
2663                    	;  779  
2664                    	;  780      }
2665                    	;  781  
2666                    	;  782  /* Read data block of 512 bytes to buffer
2667                    	;  783   * Returns YES if ok or NO if error
2668                    	;  784   */
2669                    	;  785  int sdread(unsigned char *rdbuf, unsigned long rdblkno)
2670                    	;  786      {
2671                    	;  787      unsigned char *statptr;
2672                    	;  788      unsigned char rbyte;
2673                    	;  789      unsigned char cmdbuf[5];   /* buffer to build command in */
2674                    	;  790      unsigned char rstatbuf[5]; /* buffer to recieve status in */
2675                    	;  791      int nbytes;
2676                    	;  792      int tries;
2677                    	;  793      unsigned long blktoread;
2678                    	;  794      unsigned int rxcrc16;
2679                    	;  795      unsigned int calcrc16;
2680                    	;  796  
2681                    	;  797      ledon();
2682                    	;  798      spiselect();
2683                    	;  799  
2684                    	;  800      if (!sdinitok)
2685                    	;  801          {
2686                    	;  802          if (sdtestflg)
2687                    	;  803              {
2688                    	;  804              printf("SD card not initialized\n");
2689                    	;  805              } /* sdtestflg */
2690                    	;  806          spideselect();
2691                    	;  807          ledoff();
2692                    	;  808          return (NO);
2693                    	;  809          }
2694                    	;  810  
2695                    	;  811      /* CMD17: READ_SINGLE_BLOCK */
2696                    	;  812      /* Insert block # into command */
2697                    	;  813      memcpy(cmdbuf, cmd17, 5);
2698                    	;  814      blktoread = blkmult * rdblkno;
2699                    	;  815      cmdbuf[4] = blktoread & 0xff;
2700                    	;  816      blktoread = blktoread >> 8;
2701                    	;  817      cmdbuf[3] = blktoread & 0xff;
2702                    	;  818      blktoread = blktoread >> 8;
2703                    	;  819      cmdbuf[2] = blktoread & 0xff;
2704                    	;  820      blktoread = blktoread >> 8;
2705                    	;  821      cmdbuf[1] = blktoread & 0xff;
2706                    	;  822  
2707                    	;  823      if (sdtestflg)
2708                    	;  824          {
2709                    	;  825          printf("\nCMD17: READ_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
2710                    	;  826                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
2711                    	;  827          } /* sdtestflg */
2712                    	;  828      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2713                    	;  829      if (sdtestflg)
2714                    	;  830          {
2715                    	;  831          printf("CMD17 R1 response [%02x]\n", statptr[0]);
2716                    	;  832          } /* sdtestflg */
2717                    	;  833      if (statptr[0])
2718                    	;  834          {
2719                    	;  835          if (sdtestflg)
2720                    	;  836              {
2721                    	;  837              printf("  could not read block\n");
2722                    	;  838              } /* sdtestflg */
2723                    	;  839          spideselect();
2724                    	;  840          ledoff();
2725                    	;  841          return (NO);
2726                    	;  842          }
2727                    	;  843      /* looking for 0xfe that is the byte before data */
2728                    	;  844      for (tries = 80; (0 < tries) && ((rbyte = spiio(0xff)) != 0xfe); tries--)
2729                    	;  845          {
2730                    	;  846          if ((rbyte & 0xe0) == 0x00)
2731                    	;  847              {
2732                    	;  848              /* If a read operation fails and the card cannot provide
2733                    	;  849                 the required data, it will send a data error token instead
2734                    	;  850               */
2735                    	;  851              if (sdtestflg)
2736                    	;  852                  {
2737                    	;  853                  printf("  read error: [%02x]\n", rbyte);
2738                    	;  854                  } /* sdtestflg */
2739                    	;  855              spideselect();
2740                    	;  856              ledoff();
2741                    	;  857              return (NO);
2742                    	;  858              }
2743                    	;  859          }
2744                    	;  860      if (tries == 0) /* tried too many times */
2745                    	;  861          {
2746                    	;  862          if (sdtestflg)
2747                    	;  863              {
2748                    	;  864              printf("  no data found\n");
2749                    	;  865              } /* sdtestflg */
2750                    	;  866          spideselect();
2751                    	;  867          ledoff();
2752                    	;  868          return (NO);
2753                    	;  869          }
2754                    	;  870      else
2755                    	;  871          {
2756                    	;  872          calcrc16 = 0;
2757                    	;  873          for (nbytes = 0; nbytes < 512; nbytes++)
2758                    	;  874              {
2759                    	;  875              rbyte = spiio(0xff);
2760                    	;  876              calcrc16 = CRC16_one(calcrc16, rbyte);
2761                    	;  877              rdbuf[nbytes] = rbyte;
2762                    	;  878              }
2763                    	;  879          rxcrc16 = spiio(0xff) << 8;
2764                    	;  880          rxcrc16 += spiio(0xff);
2765                    	;  881  
2766                    	;  882          if (sdtestflg)
2767                    	;  883              {
2768                    	;  884              printf("  read data block %ld:\n", rdblkno);
2769                    	;  885              } /* sdtestflg */
2770                    	;  886          if (rxcrc16 != calcrc16)
2771                    	;  887              {
2772                    	;  888              if (sdtestflg)
2773                    	;  889                  {
2774                    	;  890                  printf("  CRC16 error, recieved: 0x%04x, calc: 0x%04hi\n",
2775                    	;  891                         rxcrc16, calcrc16);
2776                    	;  892                  } /* sdtestflg */
2777                    	;  893              spideselect();
2778                    	;  894              ledoff();
2779                    	;  895              return (NO);
2780                    	;  896              }
2781                    	;  897          }
2782                    	;  898      spideselect();
2783                    	;  899      ledoff();
2784                    	;  900      return (YES);
2785                    	;  901      }
2786                    	;  902  
2787                    	;  903  /* Write data block of 512 bytes from buffer
2788                    	;  904   * Returns YES if ok or NO if error
2789                    	;  905   */
2790                    	;  906  int sdwrite(unsigned char *wrbuf, unsigned long wrblkno)
2791                    	;  907      {
2792                    	;  908      unsigned char *statptr;
2793                    	;  909      unsigned char rbyte;
2794                    	;  910      unsigned char tbyte;
2795                    	;  911      unsigned char cmdbuf[5];   /* buffer to build command in */
2796                    	;  912      unsigned char rstatbuf[5]; /* buffer to recieve status in */
2797                    	;  913      int nbytes;
2798                    	;  914      int tries;
2799                    	;  915      unsigned long blktowrite;
2800                    	;  916      unsigned int calcrc16;
2801                    	;  917  
2802                    	;  918      ledon();
2803                    	;  919      spiselect();
2804                    	;  920  
2805                    	;  921      if (!sdinitok)
2806                    	;  922          {
2807                    	;  923          if (sdtestflg)
2808                    	;  924              {
2809                    	;  925              printf("SD card not initialized\n");
2810                    	;  926              } /* sdtestflg */
2811                    	;  927          spideselect();
2812                    	;  928          ledoff();
2813                    	;  929          return (NO);
2814                    	;  930          }
2815                    	;  931  
2816                    	;  932      if (sdtestflg)
2817                    	;  933          {
2818                    	;  934          printf("  write data block %ld:\n", wrblkno);
2819                    	;  935          } /* sdtestflg */
2820                    	;  936      /* CMD24: WRITE_SINGLE_BLOCK */
2821                    	;  937      /* Insert block # into command */
2822                    	;  938      memcpy(cmdbuf, cmd24, 5);
2823                    	;  939      blktowrite = blkmult * wrblkno;
2824                    	;  940      cmdbuf[4] = blktowrite & 0xff;
2825                    	;  941      blktowrite = blktowrite >> 8;
2826                    	;  942      cmdbuf[3] = blktowrite & 0xff;
2827                    	;  943      blktowrite = blktowrite >> 8;
2828                    	;  944      cmdbuf[2] = blktowrite & 0xff;
2829                    	;  945      blktowrite = blktowrite >> 8;
2830                    	;  946      cmdbuf[1] = blktowrite & 0xff;
2831                    	;  947  
2832                    	;  948      if (sdtestflg)
2833                    	;  949          {
2834                    	;  950          printf("\nCMD24: WRITE_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
2835                    	;  951                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
2836                    	;  952          } /* sdtestflg */
2837                    	;  953      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2838                    	;  954      if (sdtestflg)
2839                    	;  955          {
2840                    	;  956          printf("CMD24 R1 response [%02x]\n", statptr[0]);
2841                    	;  957          } /* sdtestflg */
2842                    	;  958      if (statptr[0])
2843                    	;  959          {
2844                    	;  960          if (sdtestflg)
2845                    	;  961              {
2846                    	;  962              printf("  could not write block\n");
2847                    	;  963              } /* sdtestflg */
2848                    	;  964          spideselect();
2849                    	;  965          ledoff();
2850                    	;  966          return (NO);
2851                    	;  967          }
2852                    	;  968      /* send 0xfe, the byte before data */
2853                    	;  969      spiio(0xfe);
2854                    	;  970      /* initialize crc and send block */
2855                    	;  971      calcrc16 = 0;
2856                    	;  972      for (nbytes = 0; nbytes < 512; nbytes++)
2857                    	;  973          {
2858                    	;  974          tbyte = wrbuf[nbytes];
2859                    	;  975          spiio(tbyte);
2860                    	;  976          calcrc16 = CRC16_one(calcrc16, tbyte);
2861                    	;  977          }
2862                    	;  978      spiio((calcrc16 >> 8) & 0xff);
2863                    	;  979      spiio(calcrc16 & 0xff);
2864                    	;  980  
2865                    	;  981      /* check data resposnse */
2866                    	;  982      for (tries = 20;
2867                    	;  983              0 < tries && (((rbyte = spiio(0xff)) & 0x11) != 0x01);
2868                    	;  984              tries--)
2869                    	;  985          ;
2870                    	;  986      if (tries == 0)
2871                    	;  987          {
2872                    	;  988          if (sdtestflg)
2873                    	;  989              {
2874                    	;  990              printf("No data response\n");
2875                    	;  991              } /* sdtestflg */
2876                    	;  992          spideselect();
2877                    	;  993          ledoff();
2878                    	;  994          return (NO);
2879                    	;  995          }
2880                    	;  996      else
2881                    	;  997          {
2882                    	;  998          if (sdtestflg)
2883                    	;  999              {
2884                    	; 1000              printf("Data response [%02x]", 0x1f & rbyte);
2885                    	; 1001              } /* sdtestflg */
2886                    	; 1002          if ((0x1f & rbyte) == 0x05)
2887                    	; 1003              {
2888                    	; 1004              if (sdtestflg)
2889                    	; 1005                  {
2890                    	; 1006                  printf(", data accepted\n");
2891                    	; 1007                  } /* sdtestflg */
2892                    	; 1008              for (nbytes = 9; 0 < nbytes; nbytes--)
2893                    	; 1009                  spiio(0xff);
2894                    	; 1010              if (sdtestflg)
2895                    	; 1011                  {
2896                    	; 1012                  printf("Sent 9*8 (72) clock pulses, select active\n");
2897                    	; 1013                  } /* sdtestflg */
2898                    	; 1014              spideselect();
2899                    	; 1015              ledoff();
2900                    	; 1016              return (YES);
2901                    	; 1017              }
2902                    	; 1018          else
2903                    	; 1019              {
2904                    	; 1020              if (sdtestflg)
2905                    	; 1021                  {
2906                    	; 1022                  printf(", data not accepted\n");
2907                    	; 1023                  } /* sdtestflg */
2908                    	; 1024              spideselect();
2909                    	; 1025              ledoff();
2910                    	; 1026              return (NO);
2911                    	; 1027              }
2912                    	; 1028          }
2913                    	; 1029      }
2914                    	; 1030  
2915                    	; 1031  /* Print data in 512 byte buffer */
2916                    	; 1032  void sddatprt(unsigned char *prtbuf)
2917                    	; 1033      {
2918                    	; 1034      /* Variables used for "pretty-print" */
2919                    	; 1035      int allzero, dmpline, dotprted, lastallz, nbytes;
2920                    	; 1036      unsigned char *prtptr;
2921                    	; 1037  
2922                    	; 1038      prtptr = prtbuf;
2923                    	; 1039      dotprted = NO;
2924                    	; 1040      lastallz = NO;
2925                    	; 1041      for (dmpline = 0; dmpline < 32; dmpline++)
2926                    	; 1042          {
2927                    	; 1043          /* test if all 16 bytes are 0x00 */
2928                    	; 1044          allzero = YES;
2929                    	; 1045          for (nbytes = 0; nbytes < 16; nbytes++)
2930                    	; 1046              {
2931                    	; 1047              if (prtptr[nbytes] != 0)
2932                    	; 1048                  allzero = NO;
2933                    	; 1049              }
2934                    	; 1050          if (lastallz && allzero)
2935                    	; 1051              {
2936                    	; 1052              if (!dotprted)
2937                    	; 1053                  {
2938                    	; 1054                  printf("*\n");
2939                    	; 1055                  dotprted = YES;
2940                    	; 1056                  }
2941                    	; 1057              }
2942                    	; 1058          else
2943                    	; 1059              {
2944                    	; 1060              dotprted = NO;
2945                    	; 1061              /* print offset */
2946                    	; 1062              printf("%04x ", dmpline * 16);
2947                    	; 1063              /* print 16 bytes in hex */
2948                    	; 1064              for (nbytes = 0; nbytes < 16; nbytes++)
2949                    	; 1065                  printf("%02x ", prtptr[nbytes]);
2950                    	; 1066              /* print these bytes in ASCII if printable */
2951                    	; 1067              printf(" |");
2952                    	; 1068              for (nbytes = 0; nbytes < 16; nbytes++)
2953                    	; 1069                  {
2954                    	; 1070                  if ((' ' <= prtptr[nbytes]) && (prtptr[nbytes] < 127))
2955                    	; 1071                      putchar(prtptr[nbytes]);
2956                    	; 1072                  else
2957                    	; 1073                      putchar('.');
2958                    	; 1074                  }
2959                    	; 1075              printf("|\n");
2960                    	; 1076              }
2961                    	; 1077          prtptr += 16;
2962                    	; 1078          lastallz = allzero;
2963                    	; 1079          }
2964                    	; 1080      }
2965                    	; 1081  
2966                    	; 1082  /* Print GUID (mixed endian format)
2967                    	; 1083   */
2968                    	; 1084  void prtguid(unsigned char *guidptr)
2969                    	; 1085      {
2970                    	; 1086      int index;
2971                    	; 1087  
2972                    	; 1088      printf("%02x%02x%02x%02x-", guidptr[3], guidptr[2], guidptr[1], guidptr[0]);
2973                    	; 1089      printf("%02x%02x-", guidptr[5], guidptr[4]);
2974                    	; 1090      printf("%02x%02x-", guidptr[7], guidptr[6]);
2975                    	; 1091      printf("%02x%02x-", guidptr[8], guidptr[9]);
2976                    	; 1092      printf("%02x%02x%02x%02x%02x%02x",
2977                    	; 1093             guidptr[10], guidptr[11], guidptr[12], guidptr[13], guidptr[14], guidptr[15]);
2978                    	; 1094      }
2979                    	; 1095  
2980                    	; 1096  /* Analyze and print GPT entry
2981                    	; 1097   */
2982                    	; 1098  int prtgptent(unsigned int entryno)
2983                    	; 1099      {
2984                    	; 1100      int index;
2985                    	; 1101      int entryidx;
2986                    	; 1102      int hasname;
2987                    	; 1103      unsigned int block;
2988                    	; 1104      unsigned char *rxdata;
2989                    	; 1105      unsigned char *entryptr;
2990                    	; 1106      unsigned char tstzero = 0;
2991                    	; 1107      unsigned long flba;
2992                    	; 1108      unsigned long llba;
2993                    	; 1109  
2994                    	; 1110      block = 2 + (entryno / 4);
2995                    	; 1111      if ((curblkno != block) || !curblkok)
2996                    	; 1112          {
2997                    	; 1113          if (!sdread(sdrdbuf, block))
2998                    	; 1114              {
2999                    	; 1115              if (sdtestflg)
3000                    	; 1116                  {
3001                    	; 1117                  printf("Can't read GPT entry block\n");
3002                    	; 1118                  return (NO);
3003                    	; 1119                  } /* sdtestflg */
3004                    	; 1120              }
3005                    	; 1121          curblkno = block;
3006                    	; 1122          curblkok = YES;
3007                    	; 1123          }
3008                    	; 1124      rxdata = sdrdbuf;
3009                    	; 1125      entryptr = rxdata + (128 * (entryno % 4));
3010                    	; 1126      for (index = 0; index < 16; index++)
3011                    	; 1127          tstzero |= entryptr[index];
3012                    	; 1128      if (sdtestflg)
3013                    	; 1129          {
3014                    	; 1130          printf("GPT partition entry %d:", entryno + 1);
3015                    	; 1131          } /* sdtestflg */
3016                    	; 1132      if (!tstzero)
3017                    	; 1133          {
3018                    	; 1134          if (sdtestflg)
3019                    	; 1135              {
3020                    	; 1136              printf(" Not used entry\n");
3021                    	; 1137              } /* sdtestflg */
3022                    	; 1138          return (NO);
3023                    	; 1139          }
3024                    	; 1140      if (sdtestflg)
3025                    	; 1141          {
3026                    	; 1142          printf("\n  Partition type GUID: ");
3027                    	; 1143          prtguid(entryptr);
3028                    	; 1144          printf("\n  [");
3029                    	; 1145          for (index = 0; index < 16; index++)
3030                    	; 1146              printf("%02x ", entryptr[index]);
3031                    	; 1147          printf("\b]");
3032                    	; 1148          printf("\n  Unique partition GUID: ");
3033                    	; 1149          prtguid(entryptr + 16);
3034                    	; 1150          printf("\n  [");
3035                    	; 1151          for (index = 0; index < 16; index++)
3036                    	; 1152              printf("%02x ", (entryptr + 16)[index]);
3037                    	; 1153          printf("\b]");
3038                    	; 1154          printf("\n  First LBA: ");
3039                    	; 1155          /* lower 32 bits of LBA should be sufficient (I hope) */
3040                    	; 1156          } /* sdtestflg */
3041                    	; 1157      flba = (unsigned long)entryptr[32] + ((unsigned long)entryptr[33] << 8) +
3042                    	; 1158             ((unsigned long)entryptr[34] << 16) + ((unsigned long)entryptr[35] << 24);
3043                    	; 1159      if (sdtestflg)
3044                    	; 1160          {
3045                    	; 1161          printf("%lu", flba);
3046                    	; 1162          printf(" [");
3047                    	; 1163          for (index = 32; index < (32 + 8); index++)
3048                    	; 1164              printf("%02x ", entryptr[index]);
3049                    	; 1165          printf("\b]");
3050                    	; 1166          printf("\n  Last LBA: ");
3051                    	; 1167          } /* sdtestflg */
3052                    	; 1168      /* lower 32 bits of LBA should be sufficient (I hope) */
3053                    	; 1169      llba = (unsigned long)entryptr[40] + ((unsigned long)entryptr[41] << 8) +
3054                    	; 1170             ((unsigned long)entryptr[42] << 16) + ((unsigned long)entryptr[43] << 24);
3055                    	; 1171  
3056                    	; 1172      if (entryptr[48] & 0x04)
3057                    	; 1173          dskmap[partdsk].bootable = YES;
3058                    	; 1174      dskmap[partdsk].partype = PARTGPT;
3059                    	; 1175      dskmap[partdsk].dskletter = 'A' + partdsk;
3060                    	; 1176      dskmap[partdsk].dskstart = flba;
3061                    	; 1177      dskmap[partdsk].dskend = llba;
3062                    	; 1178      dskmap[partdsk].dsksize = llba - flba + 1;
3063                    	; 1179      memcpy(dskmap[partdsk].dsktype, entryptr, 16);
3064                    	; 1180      partdsk++;
3065                    	; 1181  
3066                    	; 1182      if (sdtestflg)
3067                    	; 1183          {
3068                    	; 1184          printf("%lu, size %lu MByte", llba, (llba - flba) >> 11);
3069                    	; 1185          printf(" [");
3070                    	; 1186          for (index = 40; index < (40 + 8); index++)
3071                    	; 1187              printf("%02x ", entryptr[index]);
3072                    	; 1188          printf("\b]");
3073                    	; 1189          printf("\n  Attribute flags: [");
3074                    	; 1190          /* bits 0 - 2 and 60 - 63 should be decoded */
3075                    	; 1191          for (index = 0; index < 8; index++)
3076                    	; 1192              {
3077                    	; 1193              entryidx = index + 48;
3078                    	; 1194              printf("%02x ", entryptr[entryidx]);
3079                    	; 1195              }
3080                    	; 1196          printf("\b]\n  Partition name:  ");
3081                    	; 1197          } /* sdtestflg */
3082                    	; 1198      /* partition name is in UTF-16LE code units */
3083                    	; 1199      hasname = NO;
3084                    	; 1200      for (index = 0; index < 72; index += 2)
3085                    	; 1201          {
3086                    	; 1202          entryidx = index + 56;
3087                    	; 1203          if ((entryptr[entryidx] | entryptr[entryidx + 1]) == 0)
3088                    	; 1204              break;
3089                    	; 1205          if (sdtestflg)
3090                    	; 1206              {
3091                    	; 1207              if ((' ' <= entryptr[entryidx]) && (entryptr[entryidx] < 127))
3092                    	; 1208                  putchar(entryptr[entryidx]);
3093                    	; 1209              else
3094                    	; 1210                  putchar('.');
3095                    	; 1211              } /* sdtestflg */
3096                    	; 1212          hasname = YES;
3097                    	; 1213          }
3098                    	; 1214      if (sdtestflg)
3099                    	; 1215          {
3100                    	; 1216          if (!hasname)
3101                    	; 1217              printf("name field empty");
3102                    	; 1218          printf("\n");
3103                    	; 1219          printf("   [");
3104                    	; 1220          for (index = 0; index < 72; index++)
3105                    	; 1221              {
3106                    	; 1222              if (((index & 0xf) == 0) && (index != 0))
3107                    	; 1223                  printf("\n    ");
3108                    	; 1224              entryidx = index + 56;
3109                    	; 1225              printf("%02x ", entryptr[entryidx]);
3110                    	; 1226              }
3111                    	; 1227          printf("\b]\n");
3112                    	; 1228          } /* sdtestflg */
3113                    	; 1229      return (YES);
3114                    	; 1230      }
3115                    	; 1231  
3116                    	; 1232  /* Analyze and print GPT header
3117                    	; 1233   */
3118                    	; 1234  void sdgpthdr(unsigned long block)
3119                    	; 1235      {
3120                    	; 1236      int index;
3121                    	; 1237      unsigned int partno;
3122                    	; 1238      unsigned char *rxdata;
3123                    	; 1239      unsigned long entries;
3124                    	; 1240  
3125                    	; 1241      if (sdtestflg)
3126                    	; 1242          {
3127                    	; 1243          printf("GPT header\n");
3128                    	; 1244          } /* sdtestflg */
3129                    	; 1245      if (!sdread(sdrdbuf, block))
3130                    	; 1246          {
3131                    	; 1247          if (sdtestflg)
3132                    	; 1248              {
3133                    	; 1249              printf("Can't read GPT partition table header\n");
3134                    	; 1250              } /* sdtestflg */
3135                    	; 1251          return;
3136                    	; 1252          }
3137                    	; 1253      curblkno = block;
3138                    	; 1254      curblkok = YES;
3139                    	; 1255  
3140                    	; 1256      rxdata = sdrdbuf;
3141                    	; 1257      if (sdtestflg)
3142                    	; 1258          {
3143                    	; 1259          printf("  Signature: %.8s\n", &rxdata[0]);
3144                    	; 1260          printf("  Revision: %d.%d [%02x %02x %02x %02x]\n",
3145                    	; 1261                 (int)rxdata[8] * ((int)rxdata[9] << 8),
3146                    	; 1262                 (int)rxdata[10] + ((int)rxdata[11] << 8),
3147                    	; 1263                 rxdata[8], rxdata[9], rxdata[10], rxdata[11]);
3148                    	; 1264          entries = (unsigned long)rxdata[80] + ((unsigned long)rxdata[81] << 8) +
3149                    	; 1265                    ((unsigned long)rxdata[82] << 16) + ((unsigned long)rxdata[83] << 24);
3150                    	; 1266          printf("  Number of partition entries: %lu (may be actual or maximum)\n", entries);
3151                    	; 1267          } /* sdtestflg */
3152                    	; 1268      for (partno = 0; (partno < 16) && (partdsk < 16); partno++)
3153                    	; 1269          {
3154                    	; 1270          if (!prtgptent(partno))
3155                    	; 1271              {
3156                    	; 1272              if (!sdtestflg)
3157                    	; 1273                  {
3158                    	; 1274                  /* go through all entries if compiled as test program */
3159                    	; 1275                  return;
3160                    	; 1276                  } /* sdtestflg */
3161                    	; 1277              }
3162                    	; 1278          }
3163                    	; 1279      if (sdtestflg)
3164                    	; 1280          {
3165                    	; 1281          printf("First 16 GPT entries scanned\n");
3166                    	; 1282          } /* sdtestflg */
3167                    	; 1283      }
3168                    	; 1284  
3169                    	; 1285  /* Analyze and print MBR partition entry
3170                    	; 1286   * Returns:
3171                    	; 1287   *    -1 if errror - should not happen
3172                    	; 1288   *     0 if not used entry
3173                    	; 1289   *     1 if MBR entry
3174                    	; 1290   *     2 if EBR entry
3175                    	; 1291   *     3 if GTP entry
3176                    	; 1292   */
3177                    	; 1293  int sdmbrentry(unsigned char *partptr)
3178                    	; 1294      {
3179                    	; 1295      int index;
3180                    	; 1296      int parttype;
3181                    	; 1297      unsigned long lbastart;
3182                    	; 1298      unsigned long lbasize;
3183                    	; 1299  
3184                    	; 1300      parttype = PARTMBR;
3185                    	; 1301      if (!partptr[4])
3186                    	; 1302          {
3187                    	; 1303          if (sdtestflg)
3188                    	; 1304              {
3189                    	; 1305              printf("Not used entry\n");
3190                    	; 1306              } /* sdtestflg */
3191                    	; 1307          return (PARTZRO);
3192                    	; 1308          }
3193                    	; 1309      if (sdtestflg)
3194                    	; 1310          {
3195                    	; 1311          printf("Boot indicator: 0x%02x, System ID: 0x%02x\n",
3196                    	; 1312                 partptr[0], partptr[4]);
3197                    	; 1313  
3198                    	; 1314          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f))
3199                    	; 1315              {
3200                    	; 1316              printf("  Extended partition entry\n");
3201                    	; 1317              }
3202                    	; 1318          if (partptr[0] & 0x01)
3203                    	; 1319              {
3204                    	; 1320              printf("  Unofficial 48 bit LBA Proposed MBR Format, no CHS\n");
3205                    	; 1321              /* this is however discussed
3206                    	; 1322                 https://wiki.osdev.org/Partition_Table#.22Unofficial.22_48_bit_LBA_Proposed_MBR_Format
3207                    	; 1323              */
3208                    	; 1324              }
3209                    	; 1325          else
3210                    	; 1326              {
3211                    	; 1327              printf("  begin CHS: 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
3212                    	; 1328                     partptr[1], partptr[2], partptr[3],
3213                    	; 1329                     ((partptr[2] & 0xc0) >> 2) + partptr[3],
3214                    	; 1330                     partptr[1],
3215                    	; 1331                     partptr[2] & 0x3f);
3216                    	; 1332              printf("  end CHS 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
3217                    	; 1333                     partptr[5], partptr[6], partptr[7],
3218                    	; 1334                     ((partptr[6] & 0xc0) >> 2) + partptr[7],
3219                    	; 1335                     partptr[5],
3220                    	; 1336                     partptr[6] & 0x3f);
3221                    	; 1337              }
3222                    	; 1338          } /* sdtestflg */
3223                    	; 1339      /* not showing high 16 bits if 48 bit LBA */
3224                    	; 1340      lbastart = (unsigned long)partptr[8] +
3225                    	; 1341                 ((unsigned long)partptr[9] << 8) +
3226                    	; 1342                 ((unsigned long)partptr[10] << 16) +
3227                    	; 1343                 ((unsigned long)partptr[11] << 24);
3228                    	; 1344      lbasize = (unsigned long)partptr[12] +
3229                    	; 1345                ((unsigned long)partptr[13] << 8) +
3230                    	; 1346                ((unsigned long)partptr[14] << 16) +
3231                    	; 1347                ((unsigned long)partptr[15] << 24);
3232                    	; 1348  
3233                    	; 1349      if (!(partptr[4] == 0xee)) /* not pointing to a GPT partition */
3234                    	; 1350          {
3235                    	; 1351          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f)) /* EBR partition */
3236                    	; 1352              {
3237                    	; 1353              parttype = PARTEBR;
3238                    	; 1354              if (curblkno == 0) /* points to EBR in the MBR */
3239                    	; 1355                  {
3240                    	; 1356                  ebrnext = 0;
3241                    	; 1357                  dskmap[partdsk].partype = EBRCONT;
3242                    	; 1358                  dskmap[partdsk].dskletter = 'A' + partdsk;
3243                    	; 1359                  dskmap[partdsk].dskstart = lbastart;
3244                    	; 1360                  dskmap[partdsk].dskend = lbastart + lbasize - 1;
3245                    	; 1361                  dskmap[partdsk].dsksize = lbasize;
3246                    	; 1362                  dskmap[partdsk].dsktype[0] = partptr[4];
3247                    	; 1363                  partdsk++;
3248                    	; 1364                  ebrrecs[ebrrecidx++] = lbastart; /* save to handle later */
3249                    	; 1365                  }
3250                    	; 1366              else
3251                    	; 1367                  {
3252                    	; 1368                  ebrnext = curblkno + lbastart;
3253                    	; 1369                  }
3254                    	; 1370              }
3255                    	; 1371          else
3256                    	; 1372              {
3257                    	; 1373              if (0 < lbasize) /* one more ugly hack to avoid empty partitions */
3258                    	; 1374                  {
3259                    	; 1375                  if (partptr[0] & 0x80)
3260                    	; 1376                      dskmap[partdsk].bootable = YES;
3261                    	; 1377                  if (curblkno == 0)
3262                    	; 1378                      dskmap[partdsk].partype = PARTMBR;
3263                    	; 1379                  else
3264                    	; 1380                      dskmap[partdsk].partype = PARTEBR;
3265                    	; 1381                  dskmap[partdsk].dskletter = 'A' + partdsk;
3266                    	; 1382                  dskmap[partdsk].dskstart = curblkno + lbastart;
3267                    	; 1383                  dskmap[partdsk].dskend = curblkno + lbastart + lbasize - 1;
3268                    	; 1384                  dskmap[partdsk].dsksize = lbasize;
3269                    	; 1385                  dskmap[partdsk].dsktype[0] = partptr[4];
3270                    	; 1386                  partdsk++;
3271                    	; 1387                  }
3272                    	; 1388              }
3273                    	; 1389          }
3274                    	; 1390  
3275                    	; 1391      if (sdtestflg)
3276                    	; 1392          {
3277                    	; 1393          printf("  partition start LBA: %lu [%08lx]\n",
3278                    	; 1394                 curblkno + lbastart, curblkno + lbastart);
3279                    	; 1395          printf("  partition size LBA: %lu [%08lx], %lu MByte\n",
3280                    	; 1396                 lbasize, lbasize, lbasize >> 11);
3281                    	; 1397          } /* sdtestflg */
3282                    	; 1398      if (partptr[4] == 0xee) /* GPT partitions */
3283                    	; 1399          {
3284                    	; 1400          parttype = PARTGPT;
3285                    	; 1401          if (sdtestflg)
3286                    	; 1402              {
3287                    	; 1403              printf("GTP partitions\n");
3288                    	; 1404              } /* sdtestflg */
3289                    	; 1405          sdgpthdr(lbastart); /* handle GTP partitions */
3290                    	; 1406          /* re-read MBR on sector 0
3291                    	; 1407             This is probably not needed as there
3292                    	; 1408             is only one entry (the first one)
3293                    	; 1409             in the MBR when using GPT */
3294                    	; 1410          if (sdread(sdrdbuf, 0))
3295                    	; 1411              {
3296                    	; 1412              curblkno = 0;
3297                    	; 1413              curblkok = YES;
3298                    	; 1414              }
3299                    	; 1415          else
3300                    	; 1416              {
3301                    	; 1417              if (sdtestflg)
3302                    	; 1418                  {
3303                    	; 1419                  printf("  can't read MBR on sector 0\n");
3304                    	; 1420                  } /* sdtestflg */
3305                    	; 1421              return(-1);
3306                    	; 1422              }
3307                    	; 1423          }
3308                    	; 1424      return (parttype);
3309                    	; 1425      }
3310                    	; 1426  
3311                    	; 1427  /* Read and analyze MBR/EBR partition sector block
3312                    	; 1428   * and go through and print partition entries.
3313                    	; 1429   */
3314                    	; 1430  void sdmbrpart(unsigned long sector)
3315                    	; 1431      {
3316                    	; 1432      int partidx;  /* partition index 1 - 4 */
3317                    	; 1433      int cpartidx; /* chain partition index 1 - 4 */
3318                    	; 1434      int chainidx;
3319                    	; 1435      int enttype;
3320                    	; 1436      unsigned char *entp; /* pointer to partition entry */
3321                    	; 1437      char *mbrebr;
3322                    	; 1438  
3323                    	; 1439      if (sdtestflg)
3324                    	; 1440          {
3325                    	; 1441          if (sector == 0) /* if sector 0 it is MBR else it is EBR */
3326                    	; 1442              mbrebr = "MBR";
3327                    	; 1443          else
3328                    	; 1444              mbrebr = "EBR";
3329                    	; 1445          printf("Read %s from sector %lu\n", mbrebr, sector);
3330                    	; 1446          } /* sdtestflg */
3331                    	; 1447      if (sdread(sdrdbuf, sector))
3332                    	; 1448          {
3333                    	; 1449          curblkno = sector;
3334                    	; 1450          curblkok = YES;
3335                    	; 1451          }
3336                    	; 1452      else
3337                    	; 1453          {
3338                    	; 1454          if (sdtestflg)
3339                    	; 1455              {
3340                    	; 1456              printf("  can't read %s sector %lu\n", mbrebr, sector);
3341                    	; 1457              } /* sdtestflg */
3342                    	; 1458          return;
3343                    	; 1459          }
3344                    	; 1460      if (!((sdrdbuf[0x1fe] == 0x55) && (sdrdbuf[0x1ff] == 0xaa)))
3345                    	; 1461          {
3346                    	; 1462          if (sdtestflg)
3347                    	; 1463              {
3348                    	; 1464              printf("  no %s boot signature found\n", mbrebr);
3349                    	; 1465              } /* sdtestflg */
3350                    	; 1466          return;
3351                    	; 1467          }
3352                    	; 1468      if (curblkno == 0)
3353                    	; 1469          {
3354                    	; 1470          memcpy(dsksign, &sdrdbuf[0x1b8], sizeof dsksign);
3355                    	; 1471          if (sdtestflg)
3356                    	; 1472              {
3357                    	; 1473  
3358                    	; 1474              printf("  disk identifier: 0x%02x%02x%02x%02x\n",
3359                    	; 1475                     dsksign[3], dsksign[2], dsksign[1], dsksign[0]);
3360                    	; 1476              } /* sdtestflg */
3361                    	; 1477          }
3362                    	; 1478      /* go through MBR partition entries until first empty */
3363                    	; 1479      /* !!as the MBR entry routine is called recusively a way is
3364                    	; 1480         needed to read sector 0 when going back to MBR if
3365                    	; 1481         there is a primary partition entry after an EBR entry!! */
3366                    	; 1482      entp = &sdrdbuf[0x01be] ;
3367                    	; 1483      for (partidx = 1; (partidx <= 4) && (partdsk < 16); partidx++, entp += 16)
3368                    	; 1484          {
3369                    	; 1485          if (sdtestflg)
3370                    	; 1486              {
3371                    	; 1487              printf("%s partition entry %d: ", mbrebr, partidx);
3372                    	; 1488              } /* sdtestflg */
3373                    	; 1489          enttype = sdmbrentry(entp);
3374                    	; 1490          if (enttype == -1) /* read error */
3375                    	; 1491                   return;
3376                    	; 1492          else if (enttype == PARTZRO)
3377                    	; 1493              {
3378                    	; 1494              if (!sdtestflg)
3379                    	; 1495                  {
3380                    	; 1496                  /* if compiled as test program show also empty partitions */
3381                    	; 1497                  break;
3382                    	; 1498                  } /* sdtestflg */
3383                    	; 1499              }
3384                    	; 1500          }
3385                    	; 1501      /* now handle the previously saved EBR partition sectors */
3386                    	; 1502      for (partidx = 0; (partidx < ebrrecidx) && (partdsk < 16); partidx++)
3387                    	; 1503          {
3388                    	; 1504          if (sdread(sdrdbuf, ebrrecs[partidx]))
3389                    	; 1505              {
3390                    	; 1506              curblkno = ebrrecs[partidx];
3391                    	; 1507              curblkok = YES;
3392                    	; 1508              }
3393                    	; 1509          else
3394                    	; 1510              {
3395                    	; 1511              if (sdtestflg)
3396                    	; 1512                  {
3397                    	; 1513                  printf("  can't read %s sector %lu\n", mbrebr, sector);
3398                    	; 1514                  } /* sdtestflg */
3399                    	; 1515              return;
3400                    	; 1516              }
3401                    	; 1517          entp = &sdrdbuf[0x01be] ;
3402                    	; 1518          for (partidx = 1; (partidx <= 4) && (partdsk < 16); partidx++, entp += 16)
3403                    	; 1519              {
3404                    	; 1520              if (sdtestflg)
3405                    	; 1521                  {
3406                    	; 1522                  printf("EBR partition entry %d: ", partidx);
3407                    	; 1523                  } /* sdtestflg */
3408                    	; 1524              enttype = sdmbrentry(entp);
3409                    	; 1525              if (enttype == -1) /* read error */
3410                    	; 1526                   return;
3411                    	; 1527              else if (enttype == PARTZRO) /* empty partition entry */
3412                    	; 1528                  {
3413                    	; 1529                  if (sdtestflg)
3414                    	; 1530                      {
3415                    	; 1531                      /* if compiled as test program show also empty partitions */
3416                    	; 1532                      printf("Empty partition entry\n");
3417                    	; 1533                      } /* sdtestflg */
3418                    	; 1534                  else
3419                    	; 1535                      break;
3420                    	; 1536                  }
3421                    	; 1537              else if (enttype == PARTEBR) /* next chained EBR */
3422                    	; 1538                  {
3423                    	; 1539                  if (sdtestflg)
3424                    	; 1540                      {
3425                    	; 1541                      printf("EBR chain\n");
3426                    	; 1542                      } /* sdtestflg */
3427                    	; 1543                  /* follow the EBR chain */
3428                    	; 1544                  for (chainidx = 0;
3429                    	; 1545                      ebrnext && (chainidx < 16) && (partdsk < 16);
3430                    	; 1546                      chainidx++)
3431                    	; 1547                      {
3432                    	; 1548                      /* ugly hack to stop reading the same sector */
3433                    	; 1549                      if (ebrnext == curblkno)
3434                    	; 1550                           break;
3435                    	; 1551                      if (sdread(sdrdbuf, ebrnext))
3436                    	; 1552                          {
3437                    	; 1553                          curblkno = ebrnext;
3438                    	; 1554                          curblkok = YES;
3439                    	; 1555                          }
3440                    	; 1556                      else
3441                    	; 1557                          {
3442                    	; 1558                          if (sdtestflg)
3443                    	; 1559                              {
3444                    	; 1560                              printf("  can't read %s sector %lu\n", mbrebr, sector);
3445                    	; 1561                              } /* sdtestflg */
3446                    	; 1562                          return;
3447                    	; 1563                          }
3448                    	; 1564                      entp = &sdrdbuf[0x01be] ;
3449                    	; 1565                      for (cpartidx = 1;
3450                    	; 1566                          (cpartidx <= 4) && (partdsk < 16);
3451                    	; 1567                          cpartidx++, entp += 16)
3452                    	; 1568                          {
3453                    	; 1569                          if (sdtestflg)
3454                    	; 1570                              {
3455                    	; 1571                              printf("EBR chained  partition entry %d: ",
3456                    	; 1572                                   cpartidx);
3457                    	; 1573                              } /* sdtestflg */
3458                    	; 1574                          enttype = sdmbrentry(entp);
3459                    	; 1575                          if (enttype == -1) /* read error */
3460                    	; 1576                              return;
3461    42AF  C30000    		jp	c.rets
3462                    	L5662:
3463    42B2  2C        		.byte	44
3464    42B3  20        		.byte	32
3465    42B4  65        		.byte	101
3466    42B5  78        		.byte	120
3467    42B6  65        		.byte	101
3468    42B7  63        		.byte	99
3469    42B8  75        		.byte	117
3470    42B9  74        		.byte	116
3471    42BA  69        		.byte	105
3472    42BB  6E        		.byte	110
3473    42BC  67        		.byte	103
3474    42BD  20        		.byte	32
3475    42BE  69        		.byte	105
3476    42BF  6E        		.byte	110
3477    42C0  3A        		.byte	58
3478    42C1  20        		.byte	32
3479    42C2  00        		.byte	0
3480                    	L5762:
3481    42C3  52        		.byte	82
3482    42C4  41        		.byte	65
3483    42C5  4D        		.byte	77
3484    42C6  0A        		.byte	10
3485    42C7  00        		.byte	0
3486                    	L5072:
3487    42C8  45        		.byte	69
3488    42C9  50        		.byte	80
3489    42CA  52        		.byte	82
3490    42CB  4F        		.byte	79
3491    42CC  4D        		.byte	77
3492    42CD  0A        		.byte	10
3493    42CE  00        		.byte	0
3494                    	; 1577                          }
3495                    	; 1578                      }
3496                    	; 1579                  }
3497                    	; 1580              }
3498                    	; 1581          }
3499                    	; 1582      }
3500                    	; 1583  
3501                    	; 1584  /* Executing in RAM or EPROM
3502                    	; 1585   */
3503                    	; 1586  void execin()
3504                    	; 1587      {
3505                    	_execin:
3506                    	; 1588      printf(", executing in: ");
3507    42CF  21B242    		ld	hl,L5662
3508    42D2  CD0000    		call	_printf
3509                    	; 1589      rampptr = &ramprobe;
3510    42D5  211700    		ld	hl,_ramprobe
3511                    	; 1590      *rampptr = 1; /* try to change const */
3512    42D8  224C02    		ld	(_rampptr),hl
3513    42DB  3601      		ld	(hl),1
3514    42DD  23        		inc	hl
3515    42DE  3600      		ld	(hl),0
3516                    	; 1591      if (ramprobe)
3517    42E0  2A1700    		ld	hl,(_ramprobe)
3518    42E3  7C        		ld	a,h
3519    42E4  B5        		or	l
3520    42E5  2808      		jr	z,L1026
3521                    	; 1592          printf("RAM\n");
3522    42E7  21C342    		ld	hl,L5762
3523    42EA  CD0000    		call	_printf
3524                    	; 1593      else
3525    42ED  1806      		jr	L1126
3526                    	L1026:
3527                    	; 1594          printf("EPROM\n");
3528    42EF  21C842    		ld	hl,L5072
3529    42F2  CD0000    		call	_printf
3530                    	L1126:
3531                    	; 1595      *rampptr = 0;
3532    42F5  2A4C02    		ld	hl,(_rampptr)
3533    42F8  3600      		ld	(hl),0
3534    42FA  23        		inc	hl
3535    42FB  3600      		ld	(hl),0
3536                    	; 1596      }
3537    42FD  C9        		ret 
3538                    	L5172:
3539    42FE  7A        		.byte	122
3540    42FF  38        		.byte	56
3541    4300  30        		.byte	48
3542    4301  73        		.byte	115
3543    4302  64        		.byte	100
3544    4303  62        		.byte	98
3545    4304  74        		.byte	116
3546    4305  20        		.byte	32
3547    4306  00        		.byte	0
3548                    	L5272:
3549    4307  76        		.byte	118
3550    4308  65        		.byte	101
3551    4309  72        		.byte	114
3552    430A  73        		.byte	115
3553    430B  69        		.byte	105
3554    430C  6F        		.byte	111
3555    430D  6E        		.byte	110
3556    430E  20        		.byte	32
3557    430F  30        		.byte	48
3558    4310  2E        		.byte	46
3559    4311  39        		.byte	57
3560    4312  2C        		.byte	44
3561    4313  20        		.byte	32
3562    4314  00        		.byte	0
3563                    	L5372:
3564    4315  62        		.byte	98
3565    4316  69        		.byte	105
3566    4317  6E        		.byte	110
3567    4318  73        		.byte	115
3568    4319  69        		.byte	105
3569    431A  7A        		.byte	122
3570    431B  65        		.byte	101
3571    431C  3A        		.byte	58
3572    431D  20        		.byte	32
3573    431E  30        		.byte	48
3574    431F  78        		.byte	120
3575    4320  25        		.byte	37
3576    4321  30        		.byte	48
3577    4322  34        		.byte	52
3578    4323  78        		.byte	120
3579    4324  20        		.byte	32
3580    4325  28        		.byte	40
3581    4326  25        		.byte	37
3582    4327  64        		.byte	100
3583    4328  29        		.byte	41
3584    4329  2C        		.byte	44
3585    432A  20        		.byte	32
3586    432B  62        		.byte	98
3587    432C  69        		.byte	105
3588    432D  6E        		.byte	110
3589    432E  73        		.byte	115
3590    432F  74        		.byte	116
3591    4330  61        		.byte	97
3592    4331  72        		.byte	114
3593    4332  74        		.byte	116
3594    4333  3A        		.byte	58
3595    4334  20        		.byte	32
3596    4335  30        		.byte	48
3597    4336  78        		.byte	120
3598    4337  25        		.byte	37
3599    4338  30        		.byte	48
3600    4339  34        		.byte	52
3601    433A  78        		.byte	120
3602    433B  0A        		.byte	10
3603    433C  00        		.byte	0
3604                    	L5472:
3605    433D  63        		.byte	99
3606    433E  6D        		.byte	109
3607    433F  64        		.byte	100
3608    4340  20        		.byte	32
3609    4341  28        		.byte	40
3610    4342  3F        		.byte	63
3611    4343  20        		.byte	32
3612    4344  66        		.byte	102
3613    4345  6F        		.byte	111
3614    4346  72        		.byte	114
3615    4347  20        		.byte	32
3616    4348  68        		.byte	104
3617    4349  65        		.byte	101
3618    434A  6C        		.byte	108
3619    434B  70        		.byte	112
3620    434C  29        		.byte	41
3621    434D  3A        		.byte	58
3622    434E  20        		.byte	32
3623    434F  00        		.byte	0
3624                    	L5572:
3625    4350  20        		.byte	32
3626    4351  3F        		.byte	63
3627    4352  20        		.byte	32
3628    4353  2D        		.byte	45
3629    4354  20        		.byte	32
3630    4355  68        		.byte	104
3631    4356  65        		.byte	101
3632    4357  6C        		.byte	108
3633    4358  70        		.byte	112
3634    4359  0A        		.byte	10
3635    435A  00        		.byte	0
3636                    	L5672:
3637    435B  7A        		.byte	122
3638    435C  38        		.byte	56
3639    435D  30        		.byte	48
3640    435E  73        		.byte	115
3641    435F  64        		.byte	100
3642    4360  62        		.byte	98
3643    4361  74        		.byte	116
3644    4362  20        		.byte	32
3645    4363  00        		.byte	0
3646                    	L5772:
3647    4364  76        		.byte	118
3648    4365  65        		.byte	101
3649    4366  72        		.byte	114
3650    4367  73        		.byte	115
3651    4368  69        		.byte	105
3652    4369  6F        		.byte	111
3653    436A  6E        		.byte	110
3654    436B  20        		.byte	32
3655    436C  30        		.byte	48
3656    436D  2E        		.byte	46
3657    436E  39        		.byte	57
3658    436F  2C        		.byte	44
3659    4370  20        		.byte	32
3660    4371  00        		.byte	0
3661                    	L5003:
3662    4372  43        		.byte	67
3663    4373  6F        		.byte	111
3664    4374  6D        		.byte	109
3665    4375  6D        		.byte	109
3666    4376  61        		.byte	97
3667    4377  6E        		.byte	110
3668    4378  64        		.byte	100
3669    4379  73        		.byte	115
3670    437A  3A        		.byte	58
3671    437B  0A        		.byte	10
3672    437C  00        		.byte	0
3673                    	L5103:
3674    437D  20        		.byte	32
3675    437E  20        		.byte	32
3676    437F  3F        		.byte	63
3677    4380  20        		.byte	32
3678    4381  2D        		.byte	45
3679    4382  20        		.byte	32
3680    4383  68        		.byte	104
3681    4384  65        		.byte	101
3682    4385  6C        		.byte	108
3683    4386  70        		.byte	112
3684    4387  0A        		.byte	10
3685    4388  00        		.byte	0
3686                    	L5203:
3687    4389  20        		.byte	32
3688    438A  20        		.byte	32
3689    438B  62        		.byte	98
3690    438C  20        		.byte	32
3691    438D  2D        		.byte	45
3692    438E  20        		.byte	32
3693    438F  62        		.byte	98
3694    4390  6F        		.byte	111
3695    4391  6F        		.byte	111
3696    4392  74        		.byte	116
3697    4393  20        		.byte	32
3698    4394  66        		.byte	102
3699    4395  72        		.byte	114
3700    4396  6F        		.byte	111
3701    4397  6D        		.byte	109
3702    4398  20        		.byte	32
3703    4399  53        		.byte	83
3704    439A  44        		.byte	68
3705    439B  20        		.byte	32
3706    439C  63        		.byte	99
3707    439D  61        		.byte	97
3708    439E  72        		.byte	114
3709    439F  64        		.byte	100
3710    43A0  0A        		.byte	10
3711    43A1  00        		.byte	0
3712                    	L5303:
3713    43A2  20        		.byte	32
3714    43A3  20        		.byte	32
3715    43A4  64        		.byte	100
3716    43A5  20        		.byte	32
3717    43A6  2D        		.byte	45
3718    43A7  20        		.byte	32
3719    43A8  64        		.byte	100
3720    43A9  65        		.byte	101
3721    43AA  62        		.byte	98
3722    43AB  75        		.byte	117
3723    43AC  67        		.byte	103
3724    43AD  20        		.byte	32
3725    43AE  6F        		.byte	111
3726    43AF  6E        		.byte	110
3727    43B0  2F        		.byte	47
3728    43B1  6F        		.byte	111
3729    43B2  66        		.byte	102
3730    43B3  66        		.byte	102
3731    43B4  0A        		.byte	10
3732    43B5  00        		.byte	0
3733                    	L5403:
3734    43B6  20        		.byte	32
3735    43B7  20        		.byte	32
3736    43B8  69        		.byte	105
3737    43B9  20        		.byte	32
3738    43BA  2D        		.byte	45
3739    43BB  20        		.byte	32
3740    43BC  69        		.byte	105
3741    43BD  6E        		.byte	110
3742    43BE  69        		.byte	105
3743    43BF  74        		.byte	116
3744    43C0  69        		.byte	105
3745    43C1  61        		.byte	97
3746    43C2  6C        		.byte	108
3747    43C3  69        		.byte	105
3748    43C4  7A        		.byte	122
3749    43C5  65        		.byte	101
3750    43C6  20        		.byte	32
3751    43C7  53        		.byte	83
3752    43C8  44        		.byte	68
3753    43C9  20        		.byte	32
3754    43CA  63        		.byte	99
3755    43CB  61        		.byte	97
3756    43CC  72        		.byte	114
3757    43CD  64        		.byte	100
3758    43CE  0A        		.byte	10
3759    43CF  00        		.byte	0
3760                    	L5503:
3761    43D0  20        		.byte	32
3762    43D1  20        		.byte	32
3763    43D2  6C        		.byte	108
3764    43D3  20        		.byte	32
3765    43D4  2D        		.byte	45
3766    43D5  20        		.byte	32
3767    43D6  70        		.byte	112
3768    43D7  72        		.byte	114
3769    43D8  69        		.byte	105
3770    43D9  6E        		.byte	110
3771    43DA  74        		.byte	116
3772    43DB  20        		.byte	32
3773    43DC  53        		.byte	83
3774    43DD  44        		.byte	68
3775    43DE  20        		.byte	32
3776    43DF  63        		.byte	99
3777    43E0  61        		.byte	97
3778    43E1  72        		.byte	114
3779    43E2  64        		.byte	100
3780    43E3  20        		.byte	32
3781    43E4  70        		.byte	112
3782    43E5  61        		.byte	97
3783    43E6  72        		.byte	114
3784    43E7  74        		.byte	116
3785    43E8  69        		.byte	105
3786    43E9  74        		.byte	116
3787    43EA  69        		.byte	105
3788    43EB  6F        		.byte	111
3789    43EC  6E        		.byte	110
3790    43ED  20        		.byte	32
3791    43EE  6C        		.byte	108
3792    43EF  61        		.byte	97
3793    43F0  79        		.byte	121
3794    43F1  6F        		.byte	111
3795    43F2  75        		.byte	117
3796    43F3  74        		.byte	116
3797    43F4  0A        		.byte	10
3798    43F5  00        		.byte	0
3799                    	L5603:
3800    43F6  20        		.byte	32
3801    43F7  20        		.byte	32
3802    43F8  6E        		.byte	110
3803    43F9  20        		.byte	32
3804    43FA  2D        		.byte	45
3805    43FB  20        		.byte	32
3806    43FC  73        		.byte	115
3807    43FD  65        		.byte	101
3808    43FE  74        		.byte	116
3809    43FF  2F        		.byte	47
3810    4400  73        		.byte	115
3811    4401  68        		.byte	104
3812    4402  6F        		.byte	111
3813    4403  77        		.byte	119
3814    4404  20        		.byte	32
3815    4405  73        		.byte	115
3816    4406  65        		.byte	101
3817    4407  63        		.byte	99
3818    4408  74        		.byte	116
3819    4409  6F        		.byte	111
3820    440A  72        		.byte	114
3821    440B  20        		.byte	32
3822    440C  23        		.byte	35
3823    440D  4E        		.byte	78
3824    440E  20        		.byte	32
3825    440F  74        		.byte	116
3826    4410  6F        		.byte	111
3827    4411  20        		.byte	32
3828    4412  72        		.byte	114
3829    4413  65        		.byte	101
3830    4414  61        		.byte	97
3831    4415  64        		.byte	100
3832    4416  2F        		.byte	47
3833    4417  77        		.byte	119
3834    4418  72        		.byte	114
3835    4419  69        		.byte	105
3836    441A  74        		.byte	116
3837    441B  65        		.byte	101
3838    441C  0A        		.byte	10
3839    441D  00        		.byte	0
3840                    	L5703:
3841    441E  20        		.byte	32
3842    441F  20        		.byte	32
3843    4420  70        		.byte	112
3844    4421  20        		.byte	32
3845    4422  2D        		.byte	45
3846    4423  20        		.byte	32
3847    4424  70        		.byte	112
3848    4425  72        		.byte	114
3849    4426  69        		.byte	105
3850    4427  6E        		.byte	110
3851    4428  74        		.byte	116
3852    4429  20        		.byte	32
3853    442A  73        		.byte	115
3854    442B  65        		.byte	101
3855    442C  63        		.byte	99
3856    442D  74        		.byte	116
3857    442E  6F        		.byte	111
3858    442F  72        		.byte	114
3859    4430  20        		.byte	32
3860    4431  6C        		.byte	108
3861    4432  61        		.byte	97
3862    4433  73        		.byte	115
3863    4434  74        		.byte	116
3864    4435  20        		.byte	32
3865    4436  72        		.byte	114
3866    4437  65        		.byte	101
3867    4438  61        		.byte	97
3868    4439  64        		.byte	100
3869    443A  2F        		.byte	47
3870    443B  74        		.byte	116
3871    443C  6F        		.byte	111
3872    443D  20        		.byte	32
3873    443E  77        		.byte	119
3874    443F  72        		.byte	114
3875    4440  69        		.byte	105
3876    4441  74        		.byte	116
3877    4442  65        		.byte	101
3878    4443  0A        		.byte	10
3879    4444  00        		.byte	0
3880                    	L5013:
3881    4445  20        		.byte	32
3882    4446  20        		.byte	32
3883    4447  72        		.byte	114
3884    4448  20        		.byte	32
3885    4449  2D        		.byte	45
3886    444A  20        		.byte	32
3887    444B  72        		.byte	114
3888    444C  65        		.byte	101
3889    444D  61        		.byte	97
3890    444E  64        		.byte	100
3891    444F  20        		.byte	32
3892    4450  73        		.byte	115
3893    4451  65        		.byte	101
3894    4452  63        		.byte	99
3895    4453  74        		.byte	116
3896    4454  6F        		.byte	111
3897    4455  72        		.byte	114
3898    4456  20        		.byte	32
3899    4457  23        		.byte	35
3900    4458  4E        		.byte	78
3901    4459  0A        		.byte	10
3902    445A  00        		.byte	0
3903                    	L5113:
3904    445B  20        		.byte	32
3905    445C  20        		.byte	32
3906    445D  73        		.byte	115
3907    445E  20        		.byte	32
3908    445F  2D        		.byte	45
3909    4460  20        		.byte	32
3910    4461  70        		.byte	112
3911    4462  72        		.byte	114
3912    4463  69        		.byte	105
3913    4464  6E        		.byte	110
3914    4465  74        		.byte	116
3915    4466  20        		.byte	32
3916    4467  53        		.byte	83
3917    4468  44        		.byte	68
3918    4469  20        		.byte	32
3919    446A  72        		.byte	114
3920    446B  65        		.byte	101
3921    446C  67        		.byte	103
3922    446D  69        		.byte	105
3923    446E  73        		.byte	115
3924    446F  74        		.byte	116
3925    4470  65        		.byte	101
3926    4471  72        		.byte	114
3927    4472  73        		.byte	115
3928    4473  0A        		.byte	10
3929    4474  00        		.byte	0
3930                    	L5213:
3931    4475  20        		.byte	32
3932    4476  20        		.byte	32
3933    4477  74        		.byte	116
3934    4478  20        		.byte	32
3935    4479  2D        		.byte	45
3936    447A  20        		.byte	32
3937    447B  74        		.byte	116
3938    447C  65        		.byte	101
3939    447D  73        		.byte	115
3940    447E  74        		.byte	116
3941    447F  20        		.byte	32
3942    4480  70        		.byte	112
3943    4481  72        		.byte	114
3944    4482  6F        		.byte	111
3945    4483  62        		.byte	98
3946    4484  65        		.byte	101
3947    4485  20        		.byte	32
3948    4486  53        		.byte	83
3949    4487  44        		.byte	68
3950    4488  20        		.byte	32
3951    4489  63        		.byte	99
3952    448A  61        		.byte	97
3953    448B  72        		.byte	114
3954    448C  64        		.byte	100
3955    448D  0A        		.byte	10
3956    448E  00        		.byte	0
3957                    	L5313:
3958    448F  20        		.byte	32
3959    4490  20        		.byte	32
3960    4491  75        		.byte	117
3961    4492  20        		.byte	32
3962    4493  2D        		.byte	45
3963    4494  20        		.byte	32
3964    4495  75        		.byte	117
3965    4496  70        		.byte	112
3966    4497  6C        		.byte	108
3967    4498  6F        		.byte	111
3968    4499  61        		.byte	97
3969    449A  64        		.byte	100
3970    449B  20        		.byte	32
3971    449C  63        		.byte	99
3972    449D  6F        		.byte	111
3973    449E  64        		.byte	100
3974    449F  65        		.byte	101
3975    44A0  20        		.byte	32
3976    44A1  77        		.byte	119
3977    44A2  69        		.byte	105
3978    44A3  74        		.byte	116
3979    44A4  68        		.byte	104
3980    44A5  20        		.byte	32
3981    44A6  58        		.byte	88
3982    44A7  6D        		.byte	109
3983    44A8  6F        		.byte	111
3984    44A9  64        		.byte	100
3985    44AA  65        		.byte	101
3986    44AB  6D        		.byte	109
3987    44AC  20        		.byte	32
3988    44AD  74        		.byte	116
3989    44AE  6F        		.byte	111
3990    44AF  20        		.byte	32
3991    44B0  52        		.byte	82
3992    44B1  41        		.byte	65
3993    44B2  4D        		.byte	77
3994    44B3  20        		.byte	32
3995    44B4  61        		.byte	97
3996    44B5  64        		.byte	100
3997    44B6  64        		.byte	100
3998    44B7  72        		.byte	114
3999    44B8  65        		.byte	101
4000    44B9  73        		.byte	115
4001    44BA  73        		.byte	115
4002    44BB  20        		.byte	32
4003    44BC  30        		.byte	48
4004    44BD  78        		.byte	120
4005    44BE  30        		.byte	48
4006    44BF  30        		.byte	48
4007    44C0  30        		.byte	48
4008    44C1  30        		.byte	48
4009    44C2  0A        		.byte	10
4010    44C3  00        		.byte	0
4011                    	L5413:
4012    44C4  20        		.byte	32
4013    44C5  20        		.byte	32
4014    44C6  77        		.byte	119
4015    44C7  20        		.byte	32
4016    44C8  2D        		.byte	45
4017    44C9  20        		.byte	32
4018    44CA  77        		.byte	119
4019    44CB  72        		.byte	114
4020    44CC  69        		.byte	105
4021    44CD  74        		.byte	116
4022    44CE  65        		.byte	101
4023    44CF  20        		.byte	32
4024    44D0  73        		.byte	115
4025    44D1  65        		.byte	101
4026    44D2  63        		.byte	99
4027    44D3  74        		.byte	116
4028    44D4  6F        		.byte	111
4029    44D5  72        		.byte	114
4030    44D6  20        		.byte	32
4031    44D7  23        		.byte	35
4032    44D8  4E        		.byte	78
4033    44D9  0A        		.byte	10
4034    44DA  00        		.byte	0
4035                    	L5513:
4036    44DB  20        		.byte	32
4037    44DC  20        		.byte	32
4038    44DD  43        		.byte	67
4039    44DE  74        		.byte	116
4040    44DF  72        		.byte	114
4041    44E0  6C        		.byte	108
4042    44E1  2D        		.byte	45
4043    44E2  43        		.byte	67
4044    44E3  20        		.byte	32
4045    44E4  74        		.byte	116
4046    44E5  6F        		.byte	111
4047    44E6  20        		.byte	32
4048    44E7  72        		.byte	114
4049    44E8  65        		.byte	101
4050    44E9  6C        		.byte	108
4051    44EA  6F        		.byte	111
4052    44EB  61        		.byte	97
4053    44EC  64        		.byte	100
4054    44ED  20        		.byte	32
4055    44EE  6D        		.byte	109
4056    44EF  6F        		.byte	111
4057    44F0  6E        		.byte	110
4058    44F1  69        		.byte	105
4059    44F2  74        		.byte	116
4060    44F3  6F        		.byte	111
4061    44F4  72        		.byte	114
4062    44F5  20        		.byte	32
4063    44F6  66        		.byte	102
4064    44F7  72        		.byte	114
4065    44F8  6F        		.byte	111
4066    44F9  6D        		.byte	109
4067    44FA  20        		.byte	32
4068    44FB  45        		.byte	69
4069    44FC  50        		.byte	80
4070    44FD  52        		.byte	82
4071    44FE  4F        		.byte	79
4072    44FF  4D        		.byte	77
4073    4500  0A        		.byte	10
4074    4501  00        		.byte	0
4075                    	L5613:
4076    4502  20        		.byte	32
4077    4503  64        		.byte	100
4078    4504  20        		.byte	32
4079    4505  2D        		.byte	45
4080    4506  20        		.byte	32
4081    4507  62        		.byte	98
4082    4508  6F        		.byte	111
4083    4509  6F        		.byte	111
4084    450A  74        		.byte	116
4085    450B  20        		.byte	32
4086    450C  66        		.byte	102
4087    450D  72        		.byte	114
4088    450E  6F        		.byte	111
4089    450F  6D        		.byte	109
4090    4510  20        		.byte	32
4091    4511  53        		.byte	83
4092    4512  44        		.byte	68
4093    4513  20        		.byte	32
4094    4514  63        		.byte	99
4095    4515  61        		.byte	97
   0    4516  72        		.byte	114
   1    4517  64        		.byte	100
   2    4518  20        		.byte	32
   3    4519  2D        		.byte	45
   4    451A  20        		.byte	32
   5    451B  00        		.byte	0
   6                    	L5713:
   7    451C  69        		.byte	105
   8    451D  6D        		.byte	109
   9    451E  70        		.byte	112
  10    451F  6C        		.byte	108
  11    4520  65        		.byte	101
  12    4521  6D        		.byte	109
  13    4522  65        		.byte	101
  14    4523  6E        		.byte	110
  15    4524  74        		.byte	116
  16    4525  61        		.byte	97
  17    4526  74        		.byte	116
  18    4527  69        		.byte	105
  19    4528  6F        		.byte	111
  20    4529  6E        		.byte	110
  21    452A  20        		.byte	32
  22    452B  6F        		.byte	111
  23    452C  6E        		.byte	110
  24    452D  67        		.byte	103
  25    452E  6F        		.byte	111
  26    452F  69        		.byte	105
  27    4530  6E        		.byte	110
  28    4531  67        		.byte	103
  29    4532  0A        		.byte	10
  30    4533  00        		.byte	0
  31                    	L5023:
  32    4534  20        		.byte	32
  33    4535  64        		.byte	100
  34    4536  20        		.byte	32
  35    4537  2D        		.byte	45
  36    4538  20        		.byte	32
  37    4539  74        		.byte	116
  38    453A  6F        		.byte	111
  39    453B  67        		.byte	103
  40    453C  67        		.byte	103
  41    453D  6C        		.byte	108
  42    453E  65        		.byte	101
  43    453F  20        		.byte	32
  44    4540  64        		.byte	100
  45    4541  65        		.byte	101
  46    4542  62        		.byte	98
  47    4543  75        		.byte	117
  48    4544  67        		.byte	103
  49    4545  20        		.byte	32
  50    4546  66        		.byte	102
  51    4547  6C        		.byte	108
  52    4548  61        		.byte	97
  53    4549  67        		.byte	103
  54    454A  20        		.byte	32
  55    454B  2D        		.byte	45
  56    454C  20        		.byte	32
  57    454D  00        		.byte	0
  58                    	L5123:
  59    454E  4F        		.byte	79
  60    454F  46        		.byte	70
  61    4550  46        		.byte	70
  62    4551  0A        		.byte	10
  63    4552  00        		.byte	0
  64                    	L5223:
  65    4553  4F        		.byte	79
  66    4554  4E        		.byte	78
  67    4555  0A        		.byte	10
  68    4556  00        		.byte	0
  69                    	L5323:
  70    4557  20        		.byte	32
  71    4558  69        		.byte	105
  72    4559  20        		.byte	32
  73    455A  2D        		.byte	45
  74    455B  20        		.byte	32
  75    455C  69        		.byte	105
  76    455D  6E        		.byte	110
  77    455E  69        		.byte	105
  78    455F  74        		.byte	116
  79    4560  69        		.byte	105
  80    4561  61        		.byte	97
  81    4562  6C        		.byte	108
  82    4563  69        		.byte	105
  83    4564  7A        		.byte	122
  84    4565  65        		.byte	101
  85    4566  20        		.byte	32
  86    4567  53        		.byte	83
  87    4568  44        		.byte	68
  88    4569  20        		.byte	32
  89    456A  63        		.byte	99
  90    456B  61        		.byte	97
  91    456C  72        		.byte	114
  92    456D  64        		.byte	100
  93    456E  00        		.byte	0
  94                    	L5423:
  95    456F  20        		.byte	32
  96    4570  2D        		.byte	45
  97    4571  20        		.byte	32
  98    4572  6F        		.byte	111
  99    4573  6B        		.byte	107
 100    4574  0A        		.byte	10
 101    4575  00        		.byte	0
 102                    	L5523:
 103    4576  20        		.byte	32
 104    4577  2D        		.byte	45
 105    4578  20        		.byte	32
 106    4579  6E        		.byte	110
 107    457A  6F        		.byte	111
 108    457B  74        		.byte	116
 109    457C  20        		.byte	32
 110    457D  69        		.byte	105
 111    457E  6E        		.byte	110
 112    457F  73        		.byte	115
 113    4580  65        		.byte	101
 114    4581  72        		.byte	114
 115    4582  74        		.byte	116
 116    4583  65        		.byte	101
 117    4584  64        		.byte	100
 118    4585  20        		.byte	32
 119    4586  6F        		.byte	111
 120    4587  72        		.byte	114
 121    4588  20        		.byte	32
 122    4589  66        		.byte	102
 123    458A  61        		.byte	97
 124    458B  75        		.byte	117
 125    458C  6C        		.byte	108
 126    458D  74        		.byte	116
 127    458E  79        		.byte	121
 128    458F  0A        		.byte	10
 129    4590  00        		.byte	0
 130                    	L5623:
 131    4591  20        		.byte	32
 132    4592  6C        		.byte	108
 133    4593  20        		.byte	32
 134    4594  2D        		.byte	45
 135    4595  20        		.byte	32
 136    4596  70        		.byte	112
 137    4597  72        		.byte	114
 138    4598  69        		.byte	105
 139    4599  6E        		.byte	110
 140    459A  74        		.byte	116
 141    459B  20        		.byte	32
 142    459C  70        		.byte	112
 143    459D  61        		.byte	97
 144    459E  72        		.byte	114
 145    459F  74        		.byte	116
 146    45A0  69        		.byte	105
 147    45A1  74        		.byte	116
 148    45A2  69        		.byte	105
 149    45A3  6F        		.byte	111
 150    45A4  6E        		.byte	110
 151    45A5  20        		.byte	32
 152    45A6  6C        		.byte	108
 153    45A7  61        		.byte	97
 154    45A8  79        		.byte	121
 155    45A9  6F        		.byte	111
 156    45AA  75        		.byte	117
 157    45AB  74        		.byte	116
 158    45AC  0A        		.byte	10
 159    45AD  00        		.byte	0
 160                    	L5723:
 161    45AE  20        		.byte	32
 162    45AF  2D        		.byte	45
 163    45B0  20        		.byte	32
 164    45B1  53        		.byte	83
 165    45B2  44        		.byte	68
 166    45B3  20        		.byte	32
 167    45B4  6E        		.byte	110
 168    45B5  6F        		.byte	111
 169    45B6  74        		.byte	116
 170    45B7  20        		.byte	32
 171    45B8  69        		.byte	105
 172    45B9  6E        		.byte	110
 173    45BA  69        		.byte	105
 174    45BB  74        		.byte	116
 175    45BC  69        		.byte	105
 176    45BD  61        		.byte	97
 177    45BE  6C        		.byte	108
 178    45BF  69        		.byte	105
 179    45C0  7A        		.byte	122
 180    45C1  65        		.byte	101
 181    45C2  64        		.byte	100
 182    45C3  20        		.byte	32
 183    45C4  6F        		.byte	111
 184    45C5  72        		.byte	114
 185    45C6  20        		.byte	32
 186    45C7  69        		.byte	105
 187    45C8  6E        		.byte	110
 188    45C9  73        		.byte	115
 189    45CA  65        		.byte	101
 190    45CB  72        		.byte	114
 191    45CC  74        		.byte	116
 192    45CD  65        		.byte	101
 193    45CE  64        		.byte	100
 194    45CF  20        		.byte	32
 195    45D0  6F        		.byte	111
 196    45D1  72        		.byte	114
 197    45D2  20        		.byte	32
 198    45D3  66        		.byte	102
 199    45D4  61        		.byte	97
 200    45D5  75        		.byte	117
 201    45D6  6C        		.byte	108
 202    45D7  74        		.byte	116
 203    45D8  79        		.byte	121
 204    45D9  0A        		.byte	10
 205    45DA  00        		.byte	0
 206                    	L412:
 207    45DB  00        		.byte	0
 208    45DC  00        		.byte	0
 209    45DD  00        		.byte	0
 210    45DE  00        		.byte	0
 211                    	L5033:
 212    45DF  20        		.byte	32
 213    45E0  20        		.byte	32
 214    45E1  20        		.byte	32
 215    45E2  20        		.byte	32
 216    45E3  20        		.byte	32
 217    45E4  20        		.byte	32
 218    45E5  44        		.byte	68
 219    45E6  69        		.byte	105
 220    45E7  73        		.byte	115
 221    45E8  6B        		.byte	107
 222    45E9  20        		.byte	32
 223    45EA  70        		.byte	112
 224    45EB  61        		.byte	97
 225    45EC  72        		.byte	114
 226    45ED  74        		.byte	116
 227    45EE  69        		.byte	105
 228    45EF  74        		.byte	116
 229    45F0  69        		.byte	105
 230    45F1  6F        		.byte	111
 231    45F2  6E        		.byte	110
 232    45F3  20        		.byte	32
 233    45F4  73        		.byte	115
 234    45F5  65        		.byte	101
 235    45F6  63        		.byte	99
 236    45F7  74        		.byte	116
 237    45F8  6F        		.byte	111
 238    45F9  72        		.byte	114
 239    45FA  73        		.byte	115
 240    45FB  20        		.byte	32
 241    45FC  6F        		.byte	111
 242    45FD  6E        		.byte	110
 243    45FE  20        		.byte	32
 244    45FF  53        		.byte	83
 245    4600  44        		.byte	68
 246    4601  20        		.byte	32
 247    4602  63        		.byte	99
 248    4603  61        		.byte	97
 249    4604  72        		.byte	114
 250    4605  64        		.byte	100
 251    4606  0A        		.byte	10
 252    4607  00        		.byte	0
 253                    	L5133:
 254    4608  20        		.byte	32
 255    4609  20        		.byte	32
 256    460A  20        		.byte	32
 257    460B  20        		.byte	32
 258    460C  20        		.byte	32
 259    460D  20        		.byte	32
 260    460E  20        		.byte	32
 261    460F  4D        		.byte	77
 262    4610  42        		.byte	66
 263    4611  52        		.byte	82
 264    4612  20        		.byte	32
 265    4613  64        		.byte	100
 266    4614  69        		.byte	105
 267    4615  73        		.byte	115
 268    4616  6B        		.byte	107
 269    4617  20        		.byte	32
 270    4618  69        		.byte	105
 271    4619  64        		.byte	100
 272    461A  65        		.byte	101
 273    461B  6E        		.byte	110
 274    461C  74        		.byte	116
 275    461D  69        		.byte	105
 276    461E  66        		.byte	102
 277    461F  69        		.byte	105
 278    4620  65        		.byte	101
 279    4621  72        		.byte	114
 280    4622  3A        		.byte	58
 281    4623  20        		.byte	32
 282    4624  30        		.byte	48
 283    4625  78        		.byte	120
 284    4626  25        		.byte	37
 285    4627  30        		.byte	48
 286    4628  32        		.byte	50
 287    4629  78        		.byte	120
 288    462A  25        		.byte	37
 289    462B  30        		.byte	48
 290    462C  32        		.byte	50
 291    462D  78        		.byte	120
 292    462E  25        		.byte	37
 293    462F  30        		.byte	48
 294    4630  32        		.byte	50
 295    4631  78        		.byte	120
 296    4632  25        		.byte	37
 297    4633  30        		.byte	48
 298    4634  32        		.byte	50
 299    4635  78        		.byte	120
 300    4636  0A        		.byte	10
 301    4637  00        		.byte	0
 302                    	L5233:
 303    4638  20        		.byte	32
 304    4639  44        		.byte	68
 305    463A  69        		.byte	105
 306    463B  73        		.byte	115
 307    463C  6B        		.byte	107
 308    463D  20        		.byte	32
 309    463E  20        		.byte	32
 310    463F  20        		.byte	32
 311    4640  20        		.byte	32
 312    4641  20        		.byte	32
 313    4642  53        		.byte	83
 314    4643  74        		.byte	116
 315    4644  61        		.byte	97
 316    4645  72        		.byte	114
 317    4646  74        		.byte	116
 318    4647  20        		.byte	32
 319    4648  20        		.byte	32
 320    4649  20        		.byte	32
 321    464A  20        		.byte	32
 322    464B  20        		.byte	32
 323    464C  20        		.byte	32
 324    464D  45        		.byte	69
 325    464E  6E        		.byte	110
 326    464F  64        		.byte	100
 327    4650  20        		.byte	32
 328    4651  20        		.byte	32
 329    4652  20        		.byte	32
 330    4653  20        		.byte	32
 331    4654  20        		.byte	32
 332    4655  53        		.byte	83
 333    4656  69        		.byte	105
 334    4657  7A        		.byte	122
 335    4658  65        		.byte	101
 336    4659  20        		.byte	32
 337    465A  50        		.byte	80
 338    465B  61        		.byte	97
 339    465C  72        		.byte	114
 340    465D  74        		.byte	116
 341    465E  20        		.byte	32
 342    465F  54        		.byte	84
 343    4660  79        		.byte	121
 344    4661  70        		.byte	112
 345    4662  65        		.byte	101
 346    4663  20        		.byte	32
 347    4664  49        		.byte	73
 348    4665  64        		.byte	100
 349    4666  0A        		.byte	10
 350    4667  00        		.byte	0
 351                    	L5333:
 352    4668  20        		.byte	32
 353    4669  2D        		.byte	45
 354    466A  2D        		.byte	45
 355    466B  2D        		.byte	45
 356    466C  2D        		.byte	45
 357    466D  20        		.byte	32
 358    466E  20        		.byte	32
 359    466F  20        		.byte	32
 360    4670  20        		.byte	32
 361    4671  20        		.byte	32
 362    4672  2D        		.byte	45
 363    4673  2D        		.byte	45
 364    4674  2D        		.byte	45
 365    4675  2D        		.byte	45
 366    4676  2D        		.byte	45
 367    4677  20        		.byte	32
 368    4678  20        		.byte	32
 369    4679  20        		.byte	32
 370    467A  20        		.byte	32
 371    467B  20        		.byte	32
 372    467C  20        		.byte	32
 373    467D  2D        		.byte	45
 374    467E  2D        		.byte	45
 375    467F  2D        		.byte	45
 376    4680  20        		.byte	32
 377    4681  20        		.byte	32
 378    4682  20        		.byte	32
 379    4683  20        		.byte	32
 380    4684  20        		.byte	32
 381    4685  2D        		.byte	45
 382    4686  2D        		.byte	45
 383    4687  2D        		.byte	45
 384    4688  2D        		.byte	45
 385    4689  20        		.byte	32
 386    468A  2D        		.byte	45
 387    468B  2D        		.byte	45
 388    468C  2D        		.byte	45
 389    468D  2D        		.byte	45
 390    468E  20        		.byte	32
 391    468F  2D        		.byte	45
 392    4690  2D        		.byte	45
 393    4691  2D        		.byte	45
 394    4692  2D        		.byte	45
 395    4693  20        		.byte	32
 396    4694  2D        		.byte	45
 397    4695  2D        		.byte	45
 398    4696  0A        		.byte	10
 399    4697  00        		.byte	0
 400                    	L5433:
 401    4698  25        		.byte	37
 402    4699  32        		.byte	50
 403    469A  64        		.byte	100
 404    469B  20        		.byte	32
 405    469C  28        		.byte	40
 406    469D  25        		.byte	37
 407    469E  63        		.byte	99
 408    469F  29        		.byte	41
 409    46A0  25        		.byte	37
 410    46A1  63        		.byte	99
 411    46A2  00        		.byte	0
 412                    	L5533:
 413    46A3  25        		.byte	37
 414    46A4  38        		.byte	56
 415    46A5  6C        		.byte	108
 416    46A6  75        		.byte	117
 417    46A7  20        		.byte	32
 418    46A8  25        		.byte	37
 419    46A9  38        		.byte	56
 420    46AA  6C        		.byte	108
 421    46AB  75        		.byte	117
 422    46AC  20        		.byte	32
 423    46AD  25        		.byte	37
 424    46AE  38        		.byte	56
 425    46AF  6C        		.byte	108
 426    46B0  75        		.byte	117
 427    46B1  20        		.byte	32
 428    46B2  00        		.byte	0
 429                    	L5633:
 430    46B3  20        		.byte	32
 431    46B4  45        		.byte	69
 432    46B5  42        		.byte	66
 433    46B6  52        		.byte	82
 434    46B7  20        		.byte	32
 435    46B8  63        		.byte	99
 436    46B9  6F        		.byte	111
 437    46BA  6E        		.byte	110
 438    46BB  74        		.byte	116
 439    46BC  61        		.byte	97
 440    46BD  69        		.byte	105
 441    46BE  6E        		.byte	110
 442    46BF  65        		.byte	101
 443    46C0  72        		.byte	114
 444    46C1  0A        		.byte	10
 445    46C2  00        		.byte	0
 446                    	L5733:
 447    46C3  20        		.byte	32
 448    46C4  47        		.byte	71
 449    46C5  50        		.byte	80
 450    46C6  54        		.byte	84
 451    46C7  20        		.byte	32
 452    46C8  00        		.byte	0
 453                    	L5043:
 454    46C9  43        		.byte	67
 455    46CA  50        		.byte	80
 456    46CB  2F        		.byte	47
 457    46CC  4D        		.byte	77
 458    46CD  20        		.byte	32
 459    46CE  00        		.byte	0
 460                    	L5143:
 461    46CF  20        		.byte	32
 462    46D0  3F        		.byte	63
 463    46D1  3F        		.byte	63
 464    46D2  20        		.byte	32
 465    46D3  20        		.byte	32
 466    46D4  00        		.byte	0
 467                    	L5243:
 468    46D5  20        		.byte	32
 469    46D6  45        		.byte	69
 470    46D7  42        		.byte	66
 471    46D8  52        		.byte	82
 472    46D9  20        		.byte	32
 473    46DA  00        		.byte	0
 474                    	L5343:
 475    46DB  20        		.byte	32
 476    46DC  4D        		.byte	77
 477    46DD  42        		.byte	66
 478    46DE  52        		.byte	82
 479    46DF  20        		.byte	32
 480    46E0  00        		.byte	0
 481                    	L5443:
 482    46E1  43        		.byte	67
 483    46E2  50        		.byte	80
 484    46E3  2F        		.byte	47
 485    46E4  4D        		.byte	77
 486    46E5  20        		.byte	32
 487    46E6  00        		.byte	0
 488                    	L5543:
 489    46E7  43        		.byte	67
 490    46E8  6F        		.byte	111
 491    46E9  64        		.byte	100
 492    46EA  65        		.byte	101
 493    46EB  20        		.byte	32
 494    46EC  00        		.byte	0
 495                    	L5643:
 496    46ED  20        		.byte	32
 497    46EE  3F        		.byte	63
 498    46EF  3F        		.byte	63
 499    46F0  20        		.byte	32
 500    46F1  20        		.byte	32
 501    46F2  00        		.byte	0
 502                    	L5743:
 503    46F3  30        		.byte	48
 504    46F4  78        		.byte	120
 505    46F5  25        		.byte	37
 506    46F6  30        		.byte	48
 507    46F7  32        		.byte	50
 508    46F8  78        		.byte	120
 509    46F9  00        		.byte	0
 510                    	L5053:
 511    46FA  0A        		.byte	10
 512    46FB  00        		.byte	0
 513                    	L5153:
 514    46FC  20        		.byte	32
 515    46FD  6E        		.byte	110
 516    46FE  20        		.byte	32
 517    46FF  2D        		.byte	45
 518    4700  20        		.byte	32
 519    4701  73        		.byte	115
 520    4702  65        		.byte	101
 521    4703  63        		.byte	99
 522    4704  74        		.byte	116
 523    4705  6F        		.byte	111
 524    4706  72        		.byte	114
 525    4707  20        		.byte	32
 526    4708  6E        		.byte	110
 527    4709  75        		.byte	117
 528    470A  6D        		.byte	109
 529    470B  62        		.byte	98
 530    470C  65        		.byte	101
 531    470D  72        		.byte	114
 532    470E  3A        		.byte	58
 533    470F  20        		.byte	32
 534    4710  00        		.byte	0
 535                    	L5253:
 536    4711  25        		.byte	37
 537    4712  6C        		.byte	108
 538    4713  75        		.byte	117
 539    4714  00        		.byte	0
 540                    	L5353:
 541    4715  25        		.byte	37
 542    4716  6C        		.byte	108
 543    4717  75        		.byte	117
 544    4718  00        		.byte	0
 545                    	L5453:
 546    4719  0A        		.byte	10
 547    471A  00        		.byte	0
 548                    	L5553:
 549    471B  20        		.byte	32
 550    471C  70        		.byte	112
 551    471D  20        		.byte	32
 552    471E  2D        		.byte	45
 553    471F  20        		.byte	32
 554    4720  70        		.byte	112
 555    4721  72        		.byte	114
 556    4722  69        		.byte	105
 557    4723  6E        		.byte	110
 558    4724  74        		.byte	116
 559    4725  20        		.byte	32
 560    4726  64        		.byte	100
 561    4727  61        		.byte	97
 562    4728  74        		.byte	116
 563    4729  61        		.byte	97
 564    472A  20        		.byte	32
 565    472B  73        		.byte	115
 566    472C  65        		.byte	101
 567    472D  63        		.byte	99
 568    472E  74        		.byte	116
 569    472F  6F        		.byte	111
 570    4730  72        		.byte	114
 571    4731  20        		.byte	32
 572    4732  25        		.byte	37
 573    4733  6C        		.byte	108
 574    4734  75        		.byte	117
 575    4735  0A        		.byte	10
 576    4736  00        		.byte	0
 577                    	L5653:
 578    4737  20        		.byte	32
 579    4738  72        		.byte	114
 580    4739  20        		.byte	32
 581    473A  2D        		.byte	45
 582    473B  20        		.byte	32
 583    473C  72        		.byte	114
 584    473D  65        		.byte	101
 585    473E  61        		.byte	97
 586    473F  64        		.byte	100
 587    4740  20        		.byte	32
 588    4741  73        		.byte	115
 589    4742  65        		.byte	101
 590    4743  63        		.byte	99
 591    4744  74        		.byte	116
 592    4745  6F        		.byte	111
 593    4746  72        		.byte	114
 594    4747  00        		.byte	0
 595                    	L5753:
 596    4748  20        		.byte	32
 597    4749  2D        		.byte	45
 598    474A  20        		.byte	32
 599    474B  6E        		.byte	110
 600    474C  6F        		.byte	111
 601    474D  74        		.byte	116
 602    474E  20        		.byte	32
 603    474F  69        		.byte	105
 604    4750  6E        		.byte	110
 605    4751  69        		.byte	105
 606    4752  74        		.byte	116
 607    4753  69        		.byte	105
 608    4754  61        		.byte	97
 609    4755  6C        		.byte	108
 610    4756  69        		.byte	105
 611    4757  7A        		.byte	122
 612    4758  65        		.byte	101
 613    4759  64        		.byte	100
 614    475A  20        		.byte	32
 615    475B  6F        		.byte	111
 616    475C  72        		.byte	114
 617    475D  20        		.byte	32
 618    475E  69        		.byte	105
 619    475F  6E        		.byte	110
 620    4760  73        		.byte	115
 621    4761  65        		.byte	101
 622    4762  72        		.byte	114
 623    4763  74        		.byte	116
 624    4764  65        		.byte	101
 625    4765  64        		.byte	100
 626    4766  20        		.byte	32
 627    4767  6F        		.byte	111
 628    4768  72        		.byte	114
 629    4769  20        		.byte	32
 630    476A  66        		.byte	102
 631    476B  61        		.byte	97
 632    476C  75        		.byte	117
 633    476D  6C        		.byte	108
 634    476E  74        		.byte	116
 635    476F  79        		.byte	121
 636    4770  0A        		.byte	10
 637    4771  00        		.byte	0
 638                    	L5063:
 639    4772  20        		.byte	32
 640    4773  2D        		.byte	45
 641    4774  20        		.byte	32
 642    4775  6F        		.byte	111
 643    4776  6B        		.byte	107
 644    4777  0A        		.byte	10
 645    4778  00        		.byte	0
 646                    	L5163:
 647    4779  20        		.byte	32
 648    477A  2D        		.byte	45
 649    477B  20        		.byte	32
 650    477C  72        		.byte	114
 651    477D  65        		.byte	101
 652    477E  61        		.byte	97
 653    477F  64        		.byte	100
 654    4780  20        		.byte	32
 655    4781  65        		.byte	101
 656    4782  72        		.byte	114
 657    4783  72        		.byte	114
 658    4784  6F        		.byte	111
 659    4785  72        		.byte	114
 660    4786  0A        		.byte	10
 661    4787  00        		.byte	0
 662                    	L5263:
 663    4788  20        		.byte	32
 664    4789  73        		.byte	115
 665    478A  20        		.byte	32
 666    478B  2D        		.byte	45
 667    478C  20        		.byte	32
 668    478D  70        		.byte	112
 669    478E  72        		.byte	114
 670    478F  69        		.byte	105
 671    4790  6E        		.byte	110
 672    4791  74        		.byte	116
 673    4792  20        		.byte	32
 674    4793  53        		.byte	83
 675    4794  44        		.byte	68
 676    4795  20        		.byte	32
 677    4796  72        		.byte	114
 678    4797  65        		.byte	101
 679    4798  67        		.byte	103
 680    4799  69        		.byte	105
 681    479A  73        		.byte	115
 682    479B  74        		.byte	116
 683    479C  65        		.byte	101
 684    479D  72        		.byte	114
 685    479E  73        		.byte	115
 686    479F  0A        		.byte	10
 687    47A0  00        		.byte	0
 688                    	L5363:
 689    47A1  20        		.byte	32
 690    47A2  74        		.byte	116
 691    47A3  20        		.byte	32
 692    47A4  2D        		.byte	45
 693    47A5  20        		.byte	32
 694    47A6  74        		.byte	116
 695    47A7  65        		.byte	101
 696    47A8  73        		.byte	115
 697    47A9  74        		.byte	116
 698    47AA  20        		.byte	32
 699    47AB  69        		.byte	105
 700    47AC  66        		.byte	102
 701    47AD  20        		.byte	32
 702    47AE  63        		.byte	99
 703    47AF  61        		.byte	97
 704    47B0  72        		.byte	114
 705    47B1  64        		.byte	100
 706    47B2  20        		.byte	32
 707    47B3  69        		.byte	105
 708    47B4  6E        		.byte	110
 709    47B5  73        		.byte	115
 710    47B6  65        		.byte	101
 711    47B7  72        		.byte	114
 712    47B8  74        		.byte	116
 713    47B9  65        		.byte	101
 714    47BA  64        		.byte	100
 715    47BB  0A        		.byte	10
 716    47BC  00        		.byte	0
 717                    	L5463:
 718    47BD  20        		.byte	32
 719    47BE  2D        		.byte	45
 720    47BF  20        		.byte	32
 721    47C0  6F        		.byte	111
 722    47C1  6B        		.byte	107
 723    47C2  0A        		.byte	10
 724    47C3  00        		.byte	0
 725                    	L5563:
 726    47C4  20        		.byte	32
 727    47C5  2D        		.byte	45
 728    47C6  20        		.byte	32
 729    47C7  6E        		.byte	110
 730    47C8  6F        		.byte	111
 731    47C9  74        		.byte	116
 732    47CA  20        		.byte	32
 733    47CB  69        		.byte	105
 734    47CC  6E        		.byte	110
 735    47CD  69        		.byte	105
 736    47CE  74        		.byte	116
 737    47CF  69        		.byte	105
 738    47D0  61        		.byte	97
 739    47D1  6C        		.byte	108
 740    47D2  69        		.byte	105
 741    47D3  7A        		.byte	122
 742    47D4  65        		.byte	101
 743    47D5  64        		.byte	100
 744    47D6  20        		.byte	32
 745    47D7  6F        		.byte	111
 746    47D8  72        		.byte	114
 747    47D9  20        		.byte	32
 748    47DA  69        		.byte	105
 749    47DB  6E        		.byte	110
 750    47DC  73        		.byte	115
 751    47DD  65        		.byte	101
 752    47DE  72        		.byte	114
 753    47DF  74        		.byte	116
 754    47E0  65        		.byte	101
 755    47E1  64        		.byte	100
 756    47E2  20        		.byte	32
 757    47E3  6F        		.byte	111
 758    47E4  72        		.byte	114
 759    47E5  20        		.byte	32
 760    47E6  66        		.byte	102
 761    47E7  61        		.byte	97
 762    47E8  75        		.byte	117
 763    47E9  6C        		.byte	108
 764    47EA  74        		.byte	116
 765    47EB  79        		.byte	121
 766    47EC  0A        		.byte	10
 767    47ED  00        		.byte	0
 768                    	L5663:
 769    47EE  20        		.byte	32
 770    47EF  75        		.byte	117
 771    47F0  20        		.byte	32
 772    47F1  2D        		.byte	45
 773    47F2  20        		.byte	32
 774    47F3  75        		.byte	117
 775    47F4  70        		.byte	112
 776    47F5  6C        		.byte	108
 777    47F6  6F        		.byte	111
 778    47F7  61        		.byte	97
 779    47F8  64        		.byte	100
 780    47F9  20        		.byte	32
 781    47FA  77        		.byte	119
 782    47FB  69        		.byte	105
 783    47FC  74        		.byte	116
 784    47FD  68        		.byte	104
 785    47FE  20        		.byte	32
 786    47FF  58        		.byte	88
 787    4800  6D        		.byte	109
 788    4801  6F        		.byte	111
 789    4802  64        		.byte	100
 790    4803  65        		.byte	101
 791    4804  6D        		.byte	109
 792    4805  0A        		.byte	10
 793    4806  00        		.byte	0
 794                    	L5763:
 795    4807  43        		.byte	67
 796    4808  6F        		.byte	111
 797    4809  70        		.byte	112
 798    480A  79        		.byte	121
 799    480B  20        		.byte	32
 800    480C  66        		.byte	102
 801    480D  72        		.byte	114
 802    480E  6F        		.byte	111
 803    480F  6D        		.byte	109
 804    4810  3A        		.byte	58
 805    4811  20        		.byte	32
 806    4812  30        		.byte	48
 807    4813  78        		.byte	120
 808    4814  25        		.byte	37
 809    4815  30        		.byte	48
 810    4816  34        		.byte	52
 811    4817  78        		.byte	120
 812    4818  2C        		.byte	44
 813    4819  20        		.byte	32
 814    481A  74        		.byte	116
 815    481B  6F        		.byte	111
 816    481C  3A        		.byte	58
 817    481D  20        		.byte	32
 818    481E  30        		.byte	48
 819    481F  78        		.byte	120
 820    4820  25        		.byte	37
 821    4821  30        		.byte	48
 822    4822  34        		.byte	52
 823    4823  78        		.byte	120
 824    4824  2C        		.byte	44
 825    4825  20        		.byte	32
 826    4826  73        		.byte	115
 827    4827  69        		.byte	105
 828    4828  7A        		.byte	122
 829    4829  65        		.byte	101
 830    482A  3A        		.byte	58
 831    482B  20        		.byte	32
 832    482C  25        		.byte	37
 833    482D  64        		.byte	100
 834    482E  0A        		.byte	10
 835    482F  00        		.byte	0
 836                    	L5073:
 837    4830  20        		.byte	32
 838    4831  77        		.byte	119
 839    4832  20        		.byte	32
 840    4833  2D        		.byte	45
 841    4834  20        		.byte	32
 842    4835  77        		.byte	119
 843    4836  72        		.byte	114
 844    4837  69        		.byte	105
 845    4838  74        		.byte	116
 846    4839  65        		.byte	101
 847    483A  20        		.byte	32
 848    483B  73        		.byte	115
 849    483C  65        		.byte	101
 850    483D  63        		.byte	99
 851    483E  74        		.byte	116
 852    483F  6F        		.byte	111
 853    4840  72        		.byte	114
 854    4841  00        		.byte	0
 855                    	L5173:
 856    4842  20        		.byte	32
 857    4843  2D        		.byte	45
 858    4844  20        		.byte	32
 859    4845  6E        		.byte	110
 860    4846  6F        		.byte	111
 861    4847  74        		.byte	116
 862    4848  20        		.byte	32
 863    4849  69        		.byte	105
 864    484A  6E        		.byte	110
 865    484B  69        		.byte	105
 866    484C  74        		.byte	116
 867    484D  69        		.byte	105
 868    484E  61        		.byte	97
 869    484F  6C        		.byte	108
 870    4850  69        		.byte	105
 871    4851  7A        		.byte	122
 872    4852  65        		.byte	101
 873    4853  64        		.byte	100
 874    4854  20        		.byte	32
 875    4855  6F        		.byte	111
 876    4856  72        		.byte	114
 877    4857  20        		.byte	32
 878    4858  69        		.byte	105
 879    4859  6E        		.byte	110
 880    485A  73        		.byte	115
 881    485B  65        		.byte	101
 882    485C  72        		.byte	114
 883    485D  74        		.byte	116
 884    485E  65        		.byte	101
 885    485F  64        		.byte	100
 886    4860  20        		.byte	32
 887    4861  6F        		.byte	111
 888    4862  72        		.byte	114
 889    4863  20        		.byte	32
 890    4864  66        		.byte	102
 891    4865  61        		.byte	97
 892    4866  75        		.byte	117
 893    4867  6C        		.byte	108
 894    4868  74        		.byte	116
 895    4869  79        		.byte	121
 896    486A  0A        		.byte	10
 897    486B  00        		.byte	0
 898                    	L5273:
 899    486C  20        		.byte	32
 900    486D  2D        		.byte	45
 901    486E  20        		.byte	32
 902    486F  6F        		.byte	111
 903    4870  6B        		.byte	107
 904    4871  0A        		.byte	10
 905    4872  00        		.byte	0
 906                    	L5373:
 907    4873  20        		.byte	32
 908    4874  2D        		.byte	45
 909    4875  20        		.byte	32
 910    4876  77        		.byte	119
 911    4877  72        		.byte	114
 912    4878  69        		.byte	105
 913    4879  74        		.byte	116
 914    487A  65        		.byte	101
 915    487B  20        		.byte	32
 916    487C  65        		.byte	101
 917    487D  72        		.byte	114
 918    487E  72        		.byte	114
 919    487F  6F        		.byte	111
 920    4880  72        		.byte	114
 921    4881  0A        		.byte	10
 922    4882  00        		.byte	0
 923                    	L5473:
 924    4883  72        		.byte	114
 925    4884  65        		.byte	101
 926    4885  6C        		.byte	108
 927    4886  6F        		.byte	111
 928    4887  61        		.byte	97
 929    4888  64        		.byte	100
 930    4889  69        		.byte	105
 931    488A  6E        		.byte	110
 932    488B  67        		.byte	103
 933    488C  20        		.byte	32
 934    488D  6D        		.byte	109
 935    488E  6F        		.byte	111
 936    488F  6E        		.byte	110
 937    4890  69        		.byte	105
 938    4891  74        		.byte	116
 939    4892  6F        		.byte	111
 940    4893  72        		.byte	114
 941    4894  20        		.byte	32
 942    4895  66        		.byte	102
 943    4896  72        		.byte	114
 944    4897  6F        		.byte	111
 945    4898  6D        		.byte	109
 946    4899  20        		.byte	32
 947    489A  45        		.byte	69
 948    489B  50        		.byte	80
 949    489C  52        		.byte	82
 950    489D  4F        		.byte	79
 951    489E  4D        		.byte	77
 952    489F  0A        		.byte	10
 953    48A0  00        		.byte	0
 954                    	L5573:
 955    48A1  20        		.byte	32
 956    48A2  69        		.byte	105
 957    48A3  6E        		.byte	110
 958    48A4  76        		.byte	118
 959    48A5  61        		.byte	97
 960    48A6  6C        		.byte	108
 961    48A7  69        		.byte	105
 962    48A8  64        		.byte	100
 963    48A9  20        		.byte	32
 964    48AA  63        		.byte	99
 965    48AB  6F        		.byte	111
 966    48AC  6D        		.byte	109
 967    48AD  6D        		.byte	109
 968    48AE  61        		.byte	97
 969    48AF  6E        		.byte	110
 970    48B0  64        		.byte	100
 971    48B1  0A        		.byte	10
 972    48B2  00        		.byte	0
 973                    	L1426:
 974    48B3  0C        		.byte	12
 975    48B4  00        		.byte	0
 976    48B5  6C        		.byte	108
 977    48B6  00        		.byte	0
 978    48B7  234A      		.word	L1636
 979    48B9  3D4E      		.word	L1407
 980    48BB  BB4C      		.word	L1166
 981    48BD  3D4E      		.word	L1407
 982    48BF  0D4D      		.word	L1466
 983    48C1  3D4E      		.word	L1407
 984    48C3  2A4D      		.word	L1566
 985    48C5  7C4D      		.word	L1176
 986    48C7  884D      		.word	L1276
 987    48C9  A74D      		.word	L1576
 988    48CB  3D4E      		.word	L1407
 989    48CD  E24D      		.word	L1776
 990    48CF  00        		.byte	0
 991    48D0  00        		.byte	0
 992    48D1  05        		.byte	5
 993    48D2  00        		.byte	0
 994    48D3  314E      		.word	L1307
 995    48D5  0300      		.word	3
 996    48D7  5849      		.word	L1626
 997    48D9  3F00      		.word	63
 998    48DB  CA49      		.word	L1726
 999    48DD  6200      		.word	98
1000    48DF  D949      		.word	L1036
1001    48E1  6400      		.word	100
1002    48E3  044A      		.word	L1336
1003    48E5  6900      		.word	105
1004    48E7  3D4E      		.word	L1407
1005                    	; 1597  
1006                    	; 1598  /* Test init, read and partitions on SD card over the SPI interface,
1007                    	; 1599   * boot from SD card, upload with Xmodem
1008                    	; 1600   */
1009                    	; 1601  int main()
1010                    	; 1602      {
1011                    	_main:
1012    48E9  CD0000    		call	c.savs0
1013    48EC  21E2FF    		ld	hl,65506
1014    48EF  39        		add	hl,sp
1015    48F0  F9        		ld	sp,hl
1016                    	; 1603      char txtin[10];
1017                    	; 1604      int cmdin;
1018                    	; 1605      int idx;
1019                    	; 1606      int cmpidx;
1020                    	; 1607      unsigned char *cmpptr;
1021                    	; 1608      int inlength;
1022                    	; 1609      unsigned long blockno;
1023                    	; 1610  
1024                    	; 1611      blockno = 0;
1025    48F1  97        		sub	a
1026    48F2  DD77E2    		ld	(ix-30),a
1027    48F5  DD77E3    		ld	(ix-29),a
1028    48F8  DD77E4    		ld	(ix-28),a
1029    48FB  DD77E5    		ld	(ix-27),a
1030                    	; 1612      curblkno = 0;
1031                    	; 1613      curblkok = NO;
1032    48FE  210000    		ld	hl,0
1033                    	;    1  /*  z80sdbt.c Boot and SD card test program.
1034                    	;    2   *
1035                    	;    3   *  Boot code for my DIY Z80 Computer. This
1036                    	;    4   *  program is compiled with Whitesmiths/COSMIC
1037                    	;    5   *  C compiler for Z80.
1038                    	;    6   *
1039                    	;    7   *  Initializes the hardware and detects the
1040                    	;    8   *  presence and partitioning of an attached SD card.
1041                    	;    9   *
1042                    	;   10   *  You are free to use, modify, and redistribute
1043                    	;   11   *  this source code. No warranties are given.
1044                    	;   12   *  Hastily Cobbled Together 2021 and 2022
1045                    	;   13   *  by Hans-Ake Lund
1046                    	;   14   *
1047                    	;   15   */
1048                    	;   16  
1049                    	;   17  #include <std.h>
1050                    	;   18  #include "z80computer.h"
1051                    	;   19  #include "builddate.h"
1052                    	;   20  
1053                    	;   21  /* Program name and version */
1054                    	;   22  #define PRGNAME "z80sdbt "
1055                    	;   23  #define VERSION "version 0.9, "
1056                    	;   24  /* Address in high RAM where to copy uploader */
1057                    	;   25  #define UPLADDR 0xf000
1058                    	;   26  
1059                    	;   27  /* This code should be cleaned up when
1060                    	;   28     remaining functions are implemented
1061                    	;   29   */
1062                    	;   30  #define PARTZRO 0  /* Empty partition entry */
1063                    	;   31  #define PARTMBR 1  /* MBR partition */
1064                    	;   32  #define PARTEBR 2  /* EBR logical partition */
1065                    	;   33  #define PARTGPT 3  /* GPT partition */
1066                    	;   34  #define EBRCONT 20 /* EBR container partition in MBR */
1067                    	;   35  
1068                    	;   36  struct partentry
1069                    	;   37      {
1070                    	;   38      char partype;
1071                    	;   39      char dskletter;
1072                    	;   40      int bootable;
1073                    	;   41      unsigned long dskstart;
1074                    	;   42      unsigned long dskend;
1075                    	;   43      unsigned long dsksize;
1076                    	;   44      unsigned char dsktype[16];
1077                    	;   45      } dskmap[16];
1078                    	;   46  
1079                    	;   47  unsigned char dsksign[4]; /* MBR/EBR disk signature */
1080                    	;   48  
1081                    	;   49  /* Function prototypes */
1082                    	;   50  void sdmbrpart(unsigned long);
1083                    	;   51  
1084                    	;   52  /* External data */
1085                    	;   53  extern const char upload[];
1086                    	;   54  extern const int upload_size;
1087                    	;   55  extern const int binsize;
1088                    	;   56  extern const int binstart;
1089                    	;   57  
1090                    	;   58  /* RAM/EPROM probe */
1091                    	;   59  const int ramprobe = 0;
1092                    	;   60  int *rampptr;
1093                    	;   61  
1094                    	;   62  /* Response length in bytes
1095                    	;   63   */
1096                    	;   64  #define R1_LEN 1
1097                    	;   65  #define R3_LEN 5
1098                    	;   66  #define R7_LEN 5
1099                    	;   67  
1100                    	;   68  /* The SD card commands (5 bytes) and a CRC7 byte as the last byte.
1101                    	;   69   * (The CRC7 byte in the tables below are only for information,
1102                    	;   70   * it is calculated by the sdcommand routine.)
1103                    	;   71   */
1104                    	;   72  const unsigned char cmd0[] = {0x40, 0x00, 0x00, 0x00, 0x00, 0x95};
1105                    	;   73  const unsigned char cmd8[] = {0x48, 0x00, 0x00, 0x01, 0xaa, 0x87};
1106                    	;   74  const unsigned char cmd9[] = {0x49, 0x00, 0x00, 0x00, 0x00, 0xaf};
1107                    	;   75  const unsigned char cmd10[] = {0x4a, 0x00, 0x00, 0x00, 0x00, 0x1b};
1108                    	;   76  const unsigned char cmd16[] = {0x50, 0x00, 0x00, 0x02, 0x00, 0x15};
1109                    	;   77  const unsigned char cmd17[] = {0x51, 0x00, 0x00, 0x00, 0x00, 0x55};
1110                    	;   78  const unsigned char cmd24[] = {0x58, 0x00, 0x00, 0x00, 0x00, 0x6f};
1111                    	;   79  const unsigned char cmd55[] = {0x77, 0x00, 0x00, 0x00, 0x00, 0x65};
1112                    	;   80  const unsigned char cmd58[] = {0x7a, 0x00, 0x00, 0x00, 0x00, 0xfd};
1113                    	;   81  const unsigned char acmd41[] = {0x69, 0x40, 0x00, 0x01, 0xaa, 0x33};
1114                    	;   82  
1115                    	;   83  /* Partition identifiers
1116                    	;   84   */
1117                    	;   85  /* For GPT I have decided that a CP/M partition
1118                    	;   86   * has GUID: AC7176FD-8D55-4FFF-86A5-A36D6368D0CB
1119                    	;   87   */
1120                    	;   88  const unsigned char gptcpm[] =
1121                    	;   89      {
1122                    	;   90      0xfd, 0x76, 0x71, 0xac, 0x55, 0x8d, 0xff, 0x4f,
1123                    	;   91      0x86, 0xa5, 0xa3, 0x6d, 0x63, 0x68, 0xd0, 0xcb
1124                    	;   92      };
1125                    	;   93  /* For MBR/EBR the partition type for CP/M is 0x52
1126                    	;   94   * according to: https://en.wikipedia.org/wiki/Partition_type
1127                    	;   95   */
1128                    	;   96  const unsigned char mbrcpm = 0x52;    /* CP/M partition */
1129                    	;   97  const unsigned char mbrexcode = 0x5f; /* Z80 executable code partition */
1130                    	;   98  /* has a special format that */
1131                    	;   99  /* includes number of sectors to */
1132                    	;  100  /* load and a signature, TBD */
1133                    	;  101  
1134                    	;  102  /* Buffers
1135                    	;  103   */
1136                    	;  104  unsigned char sdrdbuf[512];  /* recieved data from the SD card */
1137                    	;  105  
1138                    	;  106  unsigned char ocrreg[4];     /* SD card OCR register */
1139                    	;  107  unsigned char cidreg[16];    /* SD card CID register */
1140                    	;  108  unsigned char csdreg[16];    /* SD card CSD register */
1141                    	;  109  unsigned long ebrrecs[4];    /* detected EBR records to process */
1142                    	;  110  int ebrrecidx; /* how many EBR records that are populated */
1143                    	;  111  unsigned long ebrnext; /* next chained ebr record */
1144                    	;  112  
1145                    	;  113  /* Variables
1146                    	;  114   */
1147                    	;  115  int curblkok;  /* if YES curblockno is read into buffer */
1148                    	;  116  int partdsk;   /* partition/disk number, 0 = disk A */
1149                    	;  117  int sdinitok;  /* SD card initialized and ready */
1150                    	;  118  int sdver2;    /* SD card version 2 if YES, version 1 if NO */
1151                    	;  119  unsigned long blkmult;   /* block address multiplier */
1152                    	;  120  unsigned long curblkno;  /* block in buffer if curblkok == YES */
1153                    	;  121  
1154                    	;  122  /* debug bool */
1155                    	;  123  int sdtestflg;
1156                    	;  124  
1157                    	;  125  /* CRC routines from:
1158                    	;  126   * https://github.com/LonelyWolf/stm32/blob/master/stm32l-dosfs/sdcard.c
1159                    	;  127   */
1160                    	;  128  
1161                    	;  129  /*
1162                    	;  130  // Calculate CRC7
1163                    	;  131  // It's a 7 bit CRC with polynomial x^7 + x^3 + 1
1164                    	;  132  // input:
1165                    	;  133  //   crcIn - the CRC before (0 for first step)
1166                    	;  134  //   data - byte for CRC calculation
1167                    	;  135  // return: the new CRC7
1168                    	;  136  */
1169                    	;  137  unsigned char CRC7_one(unsigned char crcIn, unsigned char data)
1170                    	;  138      {
1171                    	;  139      const unsigned char g = 0x89;
1172                    	;  140      unsigned char i;
1173                    	;  141  
1174                    	;  142      crcIn ^= data;
1175                    	;  143      for (i = 0; i < 8; i++)
1176                    	;  144          {
1177                    	;  145          if (crcIn & 0x80) crcIn ^= g;
1178                    	;  146          crcIn <<= 1;
1179                    	;  147          }
1180                    	;  148  
1181                    	;  149      return crcIn;
1182                    	;  150      }
1183                    	;  151  
1184                    	;  152  /*
1185                    	;  153  // Calculate CRC16 CCITT
1186                    	;  154  // It's a 16 bit CRC with polynomial x^16 + x^12 + x^5 + 1
1187                    	;  155  // input:
1188                    	;  156  //   crcIn - the CRC before (0 for rist step)
1189                    	;  157  //   data - byte for CRC calculation
1190                    	;  158  // return: the CRC16 value
1191                    	;  159  */
1192                    	;  160  unsigned int CRC16_one(unsigned int crcIn, unsigned char data)
1193                    	;  161      {
1194                    	;  162      crcIn  = (unsigned char)(crcIn >> 8)|(crcIn << 8);
1195                    	;  163      crcIn ^=  data;
1196                    	;  164      crcIn ^= (unsigned char)(crcIn & 0xff) >> 4;
1197                    	;  165      crcIn ^= (crcIn << 8) << 4;
1198                    	;  166      crcIn ^= ((crcIn & 0xff) << 4) << 1;
1199                    	;  167  
1200                    	;  168      return crcIn;
1201                    	;  169      }
1202                    	;  170  
1203                    	;  171  /* Send command to SD card and recieve answer.
1204                    	;  172   * A command is 5 bytes long and is followed by
1205                    	;  173   * a CRC7 checksum byte.
1206                    	;  174   * Returns a pointer to the response
1207                    	;  175   * or 0 if no response start bit found.
1208                    	;  176   */
1209                    	;  177  unsigned char *sdcommand(unsigned char *sdcmdp,
1210                    	;  178                           unsigned char *recbuf, int recbytes)
1211                    	;  179      {
1212                    	;  180      int searchn;  /* byte counter to search for response */
1213                    	;  181      int sdcbytes; /* byte counter for bytes to send */
1214                    	;  182      unsigned char *retptr; /* pointer used to store response */
1215                    	;  183      unsigned char rbyte;   /* recieved byte */
1216                    	;  184      unsigned char crc = 0; /* calculated CRC7 */
1217                    	;  185  
1218                    	;  186      /* send 8*2 clockpules */
1219                    	;  187      spiio(0xff);
1220                    	;  188      spiio(0xff);
1221                    	;  189      for (sdcbytes = 5; 0 < sdcbytes; sdcbytes--) /* send bytes */
1222                    	;  190          {
1223                    	;  191          crc = CRC7_one(crc, *sdcmdp);
1224                    	;  192          spiio(*sdcmdp++);
1225                    	;  193          }
1226                    	;  194      spiio(crc | 0x01);
1227                    	;  195      /* search for recieved byte with start bit
1228                    	;  196         for a maximum of 10 recieved bytes  */
1229                    	;  197      for (searchn = 10; 0 < searchn; searchn--)
1230                    	;  198          {
1231                    	;  199          rbyte = spiio(0xff);
1232                    	;  200          if ((rbyte & 0x80) == 0)
1233                    	;  201              break;
1234                    	;  202          }
1235                    	;  203      if (searchn == 0) /* no start bit found */
1236                    	;  204          return (NO);
1237                    	;  205      retptr = recbuf;
1238                    	;  206      *retptr++ = rbyte;
1239                    	;  207      for (; 1 < recbytes; recbytes--) /* recieve bytes */
1240                    	;  208          *retptr++ = spiio(0xff);
1241                    	;  209      return (recbuf);
1242                    	;  210      }
1243                    	;  211  
1244                    	;  212  /* Initialise SD card interface
1245                    	;  213   *
1246                    	;  214   * returns YES if ok and NO if not ok
1247                    	;  215   *
1248                    	;  216   * References:
1249                    	;  217   *   https://www.sdcard.org/downloads/pls/
1250                    	;  218   *      Physical Layer Simplified Specification version 8.0
1251                    	;  219   *
1252                    	;  220   * A nice flowchart how to initialize:
1253                    	;  221   *   https://www.totalphase.com/blog/2018/08/set-sdc-mmc-cards-spi-mode-verify-files-successfully-programmed/
1254                    	;  222   *
1255                    	;  223   */
1256                    	;  224  int sdinit()
1257                    	;  225      {
1258                    	;  226      int nbytes;  /* byte counter */
1259                    	;  227      int tries;   /* tries to get to active state or searching for data  */
1260                    	;  228      int wtloop;  /* timer loop when trying to enter active state */
1261                    	;  229      unsigned char cmdbuf[5];   /* buffer to build command in */
1262                    	;  230      unsigned char rstatbuf[5]; /* buffer to recieve status in */
1263                    	;  231      unsigned char *statptr;    /* pointer to returned status from SD command */
1264                    	;  232      unsigned char crc;         /* crc register for CID and CSD */
1265                    	;  233      unsigned char rbyte;       /* recieved byte */
1266                    	;  234      unsigned char *prtptr;     /* for debug printing */
1267                    	;  235  
1268                    	;  236      ledon();
1269                    	;  237      spideselect();
1270                    	;  238      sdinitok = NO;
1271                    	;  239  
1272                    	;  240      /* start to generate 9*8 clock pulses with not selected SD card */
1273                    	;  241      for (nbytes = 9; 0 < nbytes; nbytes--)
1274                    	;  242          spiio(0xff);
1275                    	;  243      if (sdtestflg)
1276                    	;  244          {
1277                    	;  245          printf("\nSent 8*8 (72) clock pulses, select not active\n");
1278                    	;  246          } /* sdtestflg */
1279                    	;  247      spiselect();
1280                    	;  248  
1281                    	;  249      /* CMD0: GO_IDLE_STATE */
1282                    	;  250      for (tries = 0; tries < 10; tries++)
1283                    	;  251          {
1284                    	;  252          memcpy(cmdbuf, cmd0, 5);
1285                    	;  253          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1286                    	;  254          if (sdtestflg)
1287                    	;  255              {
1288                    	;  256              if (!statptr)
1289                    	;  257                  printf("CMD0: no response\n");
1290                    	;  258              else
1291                    	;  259                  printf("CMD0: GO_IDLE_STATE, R1 response [%02x]\n", statptr[0]);
1292                    	;  260              } /* sdtestflg */
1293                    	;  261          if (!statptr)
1294                    	;  262              {
1295                    	;  263              spideselect();
1296                    	;  264              ledoff();
1297                    	;  265              return (NO);
1298                    	;  266              }
1299                    	;  267          if (statptr[0] == 0x01)
1300                    	;  268              break;
1301                    	;  269          for (wtloop = 0; wtloop < tries * 10; wtloop++)
1302                    	;  270              {
1303                    	;  271              /* wait loop, time increasing for each try */
1304                    	;  272              spiio(0xff);
1305                    	;  273              }
1306                    	;  274          }
1307                    	;  275  
1308                    	;  276      /* CMD8: SEND_IF_COND */
1309                    	;  277      memcpy(cmdbuf, cmd8, 5);
1310                    	;  278      statptr = sdcommand(cmdbuf, rstatbuf, R7_LEN);
1311                    	;  279      if (sdtestflg)
1312                    	;  280          {
1313                    	;  281          if (!statptr)
1314                    	;  282              printf("CMD8: no response\n");
1315                    	;  283          else
1316                    	;  284              {
1317                    	;  285              printf("CMD8: SEND_IF_COND, R7 response [%02x %02x %02x %02x %02x], ",
1318                    	;  286                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
1319                    	;  287              if (!(statptr[0] & 0xfe)) /* no error */
1320                    	;  288                  {
1321                    	;  289                  if (statptr[4] == 0xaa)
1322                    	;  290                      printf("echo back ok, ");
1323                    	;  291                  else
1324                    	;  292                      printf("invalid echo back\n");
1325                    	;  293                  }
1326                    	;  294              }
1327                    	;  295          } /* sdtestflg */
1328                    	;  296      if (!statptr || (statptr[0] & 0xfe)) /* if no answer or error */
1329                    	;  297          {
1330                    	;  298          sdver2 = NO;
1331                    	;  299          if (sdtestflg)
1332                    	;  300              {
1333                    	;  301              printf("probably SD ver. 1\n");
1334                    	;  302              } /* sdtestflg */
1335                    	;  303          }
1336                    	;  304      else
1337                    	;  305          {
1338                    	;  306          sdver2 = YES;
1339                    	;  307          if (statptr[4] != 0xaa) /* but invalid echo back */
1340                    	;  308              {
1341                    	;  309              spideselect();
1342                    	;  310              ledoff();
1343                    	;  311              return (NO);
1344                    	;  312              }
1345                    	;  313          if (sdtestflg)
1346                    	;  314              {
1347                    	;  315              printf("SD ver 2\n");
1348                    	;  316              } /* sdtestflg */
1349                    	;  317          }
1350                    	;  318  
1351                    	;  319      /* CMD55: APP_CMD followed by ACMD41: SEND_OP_COND until status is 0x00 */
1352                    	;  320      for (tries = 0; tries < 20; tries++)
1353                    	;  321          {
1354                    	;  322          memcpy(cmdbuf, cmd55, 5);
1355                    	;  323          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1356                    	;  324          if (sdtestflg)
1357                    	;  325              {
1358                    	;  326              if (!statptr)
1359                    	;  327                  printf("CMD55: no response\n");
1360                    	;  328              else
1361                    	;  329                  printf("CMD55: APP_CMD, R1 response [%02x]\n", statptr[0]);
1362                    	;  330              } /* sdtestflg */
1363                    	;  331          if (!statptr)
1364                    	;  332              {
1365                    	;  333              spideselect();
1366                    	;  334              ledoff();
1367                    	;  335              return (NO);
1368                    	;  336              }
1369                    	;  337          memcpy(cmdbuf, acmd41, 5);
1370                    	;  338          if (sdver2)
1371                    	;  339              cmdbuf[1] = 0x40;
1372                    	;  340          else
1373                    	;  341              cmdbuf[1] = 0x00;
1374                    	;  342          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1375                    	;  343          if (sdtestflg)
1376                    	;  344              {
1377                    	;  345              if (!statptr)
1378                    	;  346                  printf("ACMD41: no response\n");
1379                    	;  347              else
1380                    	;  348                  printf("ACMD41: SEND_OP_COND, R1 response [%02x]%s\n",
1381                    	;  349                         statptr[0], (statptr[0] == 0x00) ? " - ready" : "");
1382                    	;  350              } /* sdtestflg */
1383                    	;  351          if (!statptr)
1384                    	;  352              {
1385                    	;  353              spideselect();
1386                    	;  354              ledoff();
1387                    	;  355              return (NO);
1388                    	;  356              }
1389                    	;  357          if (statptr[0] == 0x00) /* now the SD card is ready */
1390                    	;  358              {
1391                    	;  359              break;
1392                    	;  360              }
1393                    	;  361          for (wtloop = 0; wtloop < tries * 10; wtloop++)
1394                    	;  362              {
1395                    	;  363              /* wait loop, time increasing for each try */
1396                    	;  364              spiio(0xff);
1397                    	;  365              }
1398                    	;  366          }
1399                    	;  367  
1400                    	;  368      /* CMD58: READ_OCR */
1401                    	;  369      /* According to the flow chart this should not work
1402                    	;  370         for SD ver. 1 but the response is ok anyway
1403                    	;  371         all tested SD cards  */
1404                    	;  372      memcpy(cmdbuf, cmd58, 5);
1405                    	;  373      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
1406                    	;  374      if (sdtestflg)
1407                    	;  375          {
1408                    	;  376          if (!statptr)
1409                    	;  377              printf("CMD58: no response\n");
1410                    	;  378          else
1411                    	;  379              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
1412                    	;  380                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
1413                    	;  381          } /* sdtestflg */
1414                    	;  382      if (!statptr)
1415                    	;  383          {
1416                    	;  384          spideselect();
1417                    	;  385          ledoff();
1418                    	;  386          return (NO);
1419                    	;  387          }
1420                    	;  388      memcpy(&ocrreg[0], &statptr[1], sizeof (ocrreg));
1421                    	;  389      blkmult = 1; /* assume block address */
1422                    	;  390      if (ocrreg[0] & 0x80)
1423                    	;  391          {
1424                    	;  392          /* SD Ver.2+ */
1425                    	;  393          if (!(ocrreg[0] & 0x40))
1426                    	;  394              {
1427                    	;  395              /* SD Ver.2+, Byte address */
1428                    	;  396              blkmult = 512;
1429                    	;  397              }
1430                    	;  398          }
1431                    	;  399  
1432                    	;  400      /* CMD 16: SET_BLOCKLEN, only if Byte addressing */
1433                    	;  401      if (blkmult == 512)
1434                    	;  402          {
1435                    	;  403          memcpy(cmdbuf, cmd16, 5);
1436                    	;  404          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1437                    	;  405          if (sdtestflg)
1438                    	;  406              {
1439                    	;  407              if (!statptr)
1440                    	;  408                  printf("CMD16: no response\n");
1441                    	;  409              else
1442                    	;  410                  printf("CMD16: SET_BLOCKLEN (to 512 bytes), R1 response [%02x]\n",
1443                    	;  411                         statptr[0]);
1444                    	;  412              } /* sdtestflg */
1445                    	;  413          if (!statptr)
1446                    	;  414              {
1447                    	;  415              spideselect();
1448                    	;  416              ledoff();
1449                    	;  417              return (NO);
1450                    	;  418              }
1451                    	;  419          }
1452                    	;  420      /* Register information:
1453                    	;  421       *   https://www.cameramemoryspeed.com/sd-memory-card-faq/reading-sd-card-cid-serial-psn-internal-numbers/
1454                    	;  422       */
1455                    	;  423  
1456                    	;  424      /* CMD10: SEND_CID */
1457                    	;  425      memcpy(cmdbuf, cmd10, 5);
1458                    	;  426      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1459                    	;  427      if (sdtestflg)
1460                    	;  428          {
1461                    	;  429          if (!statptr)
1462                    	;  430              printf("CMD10: no response\n");
1463                    	;  431          else
1464                    	;  432              printf("CMD10: SEND_CID, R1 response [%02x]\n", statptr[0]);
1465                    	;  433          } /* sdtestflg */
1466                    	;  434      if (!statptr)
1467                    	;  435          {
1468                    	;  436          spideselect();
1469                    	;  437          ledoff();
1470                    	;  438          return (NO);
1471                    	;  439          }
1472                    	;  440      /* looking for 0xfe that is the byte before data */
1473                    	;  441      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
1474                    	;  442          ;
1475                    	;  443      if (tries == 0) /* tried too many times */
1476                    	;  444          {
1477                    	;  445          if (sdtestflg)
1478                    	;  446              {
1479                    	;  447              printf("  No data found\n");
1480                    	;  448              } /* sdtestflg */
1481                    	;  449          spideselect();
1482                    	;  450          ledoff();
1483                    	;  451          return (NO);
1484                    	;  452          }
1485                    	;  453      else
1486                    	;  454          {
1487                    	;  455          crc = 0;
1488                    	;  456          for (nbytes = 0; nbytes < 15; nbytes++)
1489                    	;  457              {
1490                    	;  458              rbyte = spiio(0xff);
1491                    	;  459              cidreg[nbytes] = rbyte;
1492                    	;  460              crc = CRC7_one(crc, rbyte);
1493                    	;  461              }
1494                    	;  462          cidreg[15] = spiio(0xff);
1495                    	;  463          crc |= 0x01;
1496                    	;  464          /* some SD cards need additional clock pulses */
1497                    	;  465          for (nbytes = 9; 0 < nbytes; nbytes--)
1498                    	;  466              spiio(0xff);
1499                    	;  467          if (sdtestflg)
1500                    	;  468              {
1501                    	;  469              prtptr = &cidreg[0];
1502                    	;  470              printf("  CID: [");
1503                    	;  471              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
1504                    	;  472                  printf("%02x ", *prtptr);
1505                    	;  473              prtptr = &cidreg[0];
1506                    	;  474              printf("\b] |");
1507                    	;  475              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
1508                    	;  476                  {
1509                    	;  477                  if ((' ' <= *prtptr) && (*prtptr < 127))
1510                    	;  478                      putchar(*prtptr);
1511                    	;  479                  else
1512                    	;  480                      putchar('.');
1513                    	;  481                  }
1514                    	;  482              printf("|\n");
1515                    	;  483              if (crc == cidreg[15])
1516                    	;  484                  {
1517                    	;  485                  printf("CRC7 ok: [%02x]\n", crc);
1518                    	;  486                  }
1519                    	;  487              else
1520                    	;  488                  {
1521                    	;  489                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
1522                    	;  490                         crc, cidreg[15]);
1523                    	;  491                  /* could maybe return failure here */
1524                    	;  492                  }
1525                    	;  493              } /* sdtestflg */
1526                    	;  494          }
1527                    	;  495  
1528                    	;  496      /* CMD9: SEND_CSD */
1529                    	;  497      memcpy(cmdbuf, cmd9, 5);
1530                    	;  498      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1531                    	;  499      if (sdtestflg)
1532                    	;  500          {
1533                    	;  501          if (!statptr)
1534                    	;  502              printf("CMD9: no response\n");
1535                    	;  503          else
1536                    	;  504              printf("CMD9: SEND_CSD, R1 response [%02x]\n", statptr[0]);
1537                    	;  505          } /* sdtestflg */
1538                    	;  506      if (!statptr)
1539                    	;  507          {
1540                    	;  508          spideselect();
1541                    	;  509          ledoff();
1542                    	;  510          return (NO);
1543                    	;  511          }
1544                    	;  512      /* looking for 0xfe that is the byte before data */
1545                    	;  513      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
1546                    	;  514          ;
1547                    	;  515      if (tries == 0) /* tried too many times */
1548                    	;  516          {
1549                    	;  517          if (sdtestflg)
1550                    	;  518              {
1551                    	;  519              printf("  No data found\n");
1552                    	;  520              } /* sdtestflg */
1553                    	;  521          return (NO);
1554                    	;  522          }
1555                    	;  523      else
1556                    	;  524          {
1557                    	;  525          crc = 0;
1558                    	;  526          for (nbytes = 0; nbytes < 15; nbytes++)
1559                    	;  527              {
1560                    	;  528              rbyte = spiio(0xff);
1561                    	;  529              csdreg[nbytes] = rbyte;
1562                    	;  530              crc = CRC7_one(crc, rbyte);
1563                    	;  531              }
1564                    	;  532          csdreg[15] = spiio(0xff);
1565                    	;  533          crc |= 0x01;
1566                    	;  534          /* some SD cards need additional clock pulses */
1567                    	;  535          for (nbytes = 9; 0 < nbytes; nbytes--)
1568                    	;  536              spiio(0xff);
1569                    	;  537          if (sdtestflg)
1570                    	;  538              {
1571                    	;  539              prtptr = &csdreg[0];
1572                    	;  540              printf("  CSD: [");
1573                    	;  541              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
1574                    	;  542                  printf("%02x ", *prtptr);
1575                    	;  543              prtptr = &csdreg[0];
1576                    	;  544              printf("\b] |");
1577                    	;  545              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
1578                    	;  546                  {
1579                    	;  547                  if ((' ' <= *prtptr) && (*prtptr < 127))
1580                    	;  548                      putchar(*prtptr);
1581                    	;  549                  else
1582                    	;  550                      putchar('.');
1583                    	;  551                  }
1584                    	;  552              printf("|\n");
1585                    	;  553              if (crc == csdreg[15])
1586                    	;  554                  {
1587                    	;  555                  printf("CRC7 ok: [%02x]\n", crc);
1588                    	;  556                  }
1589                    	;  557              else
1590                    	;  558                  {
1591                    	;  559                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
1592                    	;  560                         crc, csdreg[15]);
1593                    	;  561                  /* could maybe return failure here */
1594                    	;  562                  }
1595                    	;  563              } /* sdtestflg */
1596                    	;  564          }
1597                    	;  565  
1598                    	;  566      for (nbytes = 9; 0 < nbytes; nbytes--)
1599                    	;  567          spiio(0xff);
1600                    	;  568      if (sdtestflg)
1601                    	;  569          {
1602                    	;  570          printf("Sent 9*8 (72) clock pulses, select active\n");
1603                    	;  571          } /* sdtestflg */
1604                    	;  572  
1605                    	;  573      sdinitok = YES;
1606                    	;  574  
1607                    	;  575      spideselect();
1608                    	;  576      ledoff();
1609                    	;  577  
1610                    	;  578      return (YES);
1611                    	;  579      }
1612                    	;  580  
1613                    	;  581  int sdprobe()
1614                    	;  582      {
1615                    	;  583      unsigned char cmdbuf[5];   /* buffer to build command in */
1616                    	;  584      unsigned char rstatbuf[5]; /* buffer to recieve status in */
1617                    	;  585      unsigned char *statptr;    /* pointer to returned status from SD command */
1618                    	;  586      int nbytes;  /* byte counter */
1619                    	;  587      int allzero = YES;
1620                    	;  588  
1621                    	;  589      ledon();
1622                    	;  590      spiselect();
1623                    	;  591  
1624                    	;  592      /* CMD58: READ_OCR */
1625                    	;  593      memcpy(cmdbuf, cmd58, 5);
1626                    	;  594      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
1627                    	;  595      for (nbytes = 0; nbytes < 5; nbytes++)
1628                    	;  596          {
1629                    	;  597          if (statptr[nbytes] != 0)
1630                    	;  598              allzero = NO;
1631                    	;  599          }
1632                    	;  600      if (sdtestflg)
1633                    	;  601          {
1634                    	;  602          if (!statptr)
1635                    	;  603              printf("CMD58: no response\n");
1636                    	;  604          else
1637                    	;  605              {
1638                    	;  606              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
1639                    	;  607                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
1640                    	;  608              if (allzero)
1641                    	;  609                  printf("SD card not inserted or not initialized\n");
1642                    	;  610              }
1643                    	;  611          } /* sdtestflg */
1644                    	;  612      if (!statptr || allzero)
1645                    	;  613          {
1646                    	;  614          sdinitok = NO;
1647                    	;  615          spideselect();
1648                    	;  616          ledoff();
1649                    	;  617          return (NO);
1650                    	;  618          }
1651                    	;  619  
1652                    	;  620      spideselect();
1653                    	;  621      ledoff();
1654                    	;  622  
1655                    	;  623      return (YES);
1656                    	;  624      }
1657                    	;  625  
1658                    	;  626  /* print OCR, CID and CSD registers*/
1659                    	;  627  void sdprtreg()
1660                    	;  628      {
1661                    	;  629      unsigned int n;
1662                    	;  630      unsigned int csize;
1663                    	;  631      unsigned long devsize;
1664                    	;  632      unsigned long capacity;
1665                    	;  633  
1666                    	;  634      if (!sdinitok)
1667                    	;  635          {
1668                    	;  636          printf("SD card not initialized\n");
1669                    	;  637          return;
1670                    	;  638          }
1671                    	;  639      printf("SD card information:");
1672                    	;  640      if (ocrreg[0] & 0x80)
1673                    	;  641          {
1674                    	;  642          if (ocrreg[0] & 0x40)
1675                    	;  643              printf("  SD card ver. 2+, Block address\n");
1676                    	;  644          else
1677                    	;  645              {
1678                    	;  646              if (sdver2)
1679                    	;  647                  printf("  SD card ver. 2+, Byte address\n");
1680                    	;  648              else
1681                    	;  649                  printf("  SD card ver. 1, Byte address\n");
1682                    	;  650              }
1683                    	;  651          }
1684                    	;  652      printf("  Manufacturer ID: 0x%02x, ", cidreg[0]);
1685                    	;  653      printf("OEM ID: %.2s, ", &cidreg[1]);
1686                    	;  654      printf("Product name: %.5s\n", &cidreg[3]);
1687                    	;  655      printf("  Product revision: %d.%d, ",
1688                    	;  656             (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
1689                    	;  657      printf("Serial number: %lu\n",
1690                    	;  658             (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
1691                    	;  659      printf("  Manufacturing date: %d-%d, ",
1692                    	;  660             2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
1693                    	;  661      if ((csdreg[0] & 0xc0) == 0x00) /* CSD version 1 */
1694                    	;  662          {
1695                    	;  663          n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
1696                    	;  664          csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
1697                    	;  665                  ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
1698                    	;  666          capacity = (unsigned long) csize << (n-10);
1699                    	;  667          printf("Device capacity: %lu MByte\n", capacity >> 10);
1700                    	;  668          }
1701                    	;  669      if ((csdreg[0] & 0xc0) == 0x40) /* CSD version 2 */
1702                    	;  670          {
1703                    	;  671          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
1704                    	;  672                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
1705                    	;  673          capacity = devsize << 9;
1706                    	;  674          printf("Device capacity: %lu MByte\n", capacity >> 10);
1707                    	;  675          }
1708                    	;  676      if ((csdreg[0] & 0xc0) == 0x80) /* CSD version 3 */
1709                    	;  677          {
1710                    	;  678          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
1711                    	;  679                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
1712                    	;  680          capacity = devsize << 9;
1713                    	;  681          printf("Device ultra capacity: %lu MByte\n", capacity >> 10);
1714                    	;  682          }
1715                    	;  683  
1716                    	;  684      if (sdtestflg)
1717                    	;  685          {
1718                    	;  686  
1719                    	;  687          printf("--------------------------------------\n");
1720                    	;  688          printf("OCR register:\n");
1721                    	;  689          if (ocrreg[2] & 0x80)
1722                    	;  690              printf("2.7-2.8V (bit 15) ");
1723                    	;  691          if (ocrreg[1] & 0x01)
1724                    	;  692              printf("2.8-2.9V (bit 16) ");
1725                    	;  693          if (ocrreg[1] & 0x02)
1726                    	;  694              printf("2.9-3.0V (bit 17) ");
1727                    	;  695          if (ocrreg[1] & 0x04)
1728                    	;  696              printf("3.0-3.1V (bit 18) \n");
1729                    	;  697          if (ocrreg[1] & 0x08)
1730                    	;  698              printf("3.1-3.2V (bit 19) ");
1731                    	;  699          if (ocrreg[1] & 0x10)
1732                    	;  700              printf("3.2-3.3V (bit 20) ");
1733                    	;  701          if (ocrreg[1] & 0x20)
1734                    	;  702              printf("3.3-3.4V (bit 21) ");
1735                    	;  703          if (ocrreg[1] & 0x40)
1736                    	;  704              printf("3.4-3.5V (bit 22) \n");
1737                    	;  705          if (ocrreg[1] & 0x80)
1738                    	;  706              printf("3.5-3.6V (bit 23) \n");
1739                    	;  707          if (ocrreg[0] & 0x01)
1740                    	;  708              printf("Switching to 1.8V Accepted (S18A) (bit 24) set ");
1741                    	;  709          if (ocrreg[0] & 0x08)
1742                    	;  710              printf("Over 2TB support Status (CO2T) (bit 27) set\n");
1743                    	;  711          if (ocrreg[0] & 0x20)
1744                    	;  712              printf("UHS-II Card Status (bit 29) set ");
1745                    	;  713          if (ocrreg[0] & 0x80)
1746                    	;  714              {
1747                    	;  715              if (ocrreg[0] & 0x40)
1748                    	;  716                  {
1749                    	;  717                  printf("Card Capacity Status (CCS) (bit 30) set\n");
1750                    	;  718                  printf("  SD Ver.2+, Block address");
1751                    	;  719                  }
1752                    	;  720              else
1753                    	;  721                  {
1754                    	;  722                  printf("Card Capacity Status (CCS) (bit 30) not set\n");
1755                    	;  723                  if (sdver2)
1756                    	;  724                      printf("  SD Ver.2+, Byte address");
1757                    	;  725                  else
1758                    	;  726                      printf("  SD Ver.1, Byte address");
1759                    	;  727                  }
1760                    	;  728              printf("\nCard power up status bit (busy) (bit 31) set\n");
1761                    	;  729              }
1762                    	;  730          else
1763                    	;  731              {
1764                    	;  732              printf("\nCard power up status bit (busy) (bit 31) not set.\n");
1765                    	;  733              printf("  This bit is not set if the card has not finished the power up routine.\n");
1766                    	;  734              }
1767                    	;  735          printf("--------------------------------------\n");
1768                    	;  736          printf("CID register:\n");
1769                    	;  737          printf("MID: 0x%02x, ", cidreg[0]);
1770                    	;  738          printf("OID: %.2s, ", &cidreg[1]);
1771                    	;  739          printf("PNM: %.5s, ", &cidreg[3]);
1772                    	;  740          printf("PRV: %d.%d, ",
1773                    	;  741                 (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
1774                    	;  742          printf("PSN: %lu, ",
1775                    	;  743                 (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
1776                    	;  744          printf("MDT: %d-%d\n",
1777                    	;  745                 2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
1778                    	;  746          printf("--------------------------------------\n");
1779                    	;  747          printf("CSD register:\n");
1780                    	;  748          if ((csdreg[0] & 0xc0) == 0x00)
1781                    	;  749              {
1782                    	;  750              printf("CSD Version 1.0, Standard Capacity\n");
1783                    	;  751              n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
1784                    	;  752              csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
1785                    	;  753                      ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
1786                    	;  754              capacity = (unsigned long) csize << (n-10);
1787                    	;  755              printf(" Device capacity: %lu KByte, %lu MByte\n",
1788                    	;  756                     capacity, capacity >> 10);
1789                    	;  757              }
1790                    	;  758          if ((csdreg[0] & 0xc0) == 0x40)
1791                    	;  759              {
1792                    	;  760              printf("CSD Version 2.0, High Capacity and Extended Capacity\n");
1793                    	;  761              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
1794                    	;  762                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
1795                    	;  763              capacity = devsize << 9;
1796                    	;  764              printf(" Device capacity: %lu KByte, %lu MByte\n",
1797                    	;  765                     capacity, capacity >> 10);
1798                    	;  766              }
1799                    	;  767          if ((csdreg[0] & 0xc0) == 0x80)
1800                    	;  768              {
1801                    	;  769              printf("CSD Version 3.0, Ultra Capacity (SDUC)\n");
1802                    	;  770              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
1803                    	;  771                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
1804                    	;  772              capacity = devsize << 9;
1805                    	;  773              printf(" Device capacity: %lu KByte, %lu MByte\n",
1806                    	;  774                     capacity, capacity >> 10);
1807                    	;  775              }
1808                    	;  776          printf("--------------------------------------\n");
1809                    	;  777  
1810                    	;  778          } /* sdtestflg */ /* SDTEST */
1811                    	;  779  
1812                    	;  780      }
1813                    	;  781  
1814                    	;  782  /* Read data block of 512 bytes to buffer
1815                    	;  783   * Returns YES if ok or NO if error
1816                    	;  784   */
1817                    	;  785  int sdread(unsigned char *rdbuf, unsigned long rdblkno)
1818                    	;  786      {
1819                    	;  787      unsigned char *statptr;
1820                    	;  788      unsigned char rbyte;
1821                    	;  789      unsigned char cmdbuf[5];   /* buffer to build command in */
1822                    	;  790      unsigned char rstatbuf[5]; /* buffer to recieve status in */
1823                    	;  791      int nbytes;
1824                    	;  792      int tries;
1825                    	;  793      unsigned long blktoread;
1826                    	;  794      unsigned int rxcrc16;
1827                    	;  795      unsigned int calcrc16;
1828                    	;  796  
1829                    	;  797      ledon();
1830                    	;  798      spiselect();
1831                    	;  799  
1832                    	;  800      if (!sdinitok)
1833                    	;  801          {
1834                    	;  802          if (sdtestflg)
1835                    	;  803              {
1836                    	;  804              printf("SD card not initialized\n");
1837                    	;  805              } /* sdtestflg */
1838                    	;  806          spideselect();
1839                    	;  807          ledoff();
1840                    	;  808          return (NO);
1841                    	;  809          }
1842                    	;  810  
1843                    	;  811      /* CMD17: READ_SINGLE_BLOCK */
1844                    	;  812      /* Insert block # into command */
1845                    	;  813      memcpy(cmdbuf, cmd17, 5);
1846                    	;  814      blktoread = blkmult * rdblkno;
1847                    	;  815      cmdbuf[4] = blktoread & 0xff;
1848                    	;  816      blktoread = blktoread >> 8;
1849                    	;  817      cmdbuf[3] = blktoread & 0xff;
1850                    	;  818      blktoread = blktoread >> 8;
1851                    	;  819      cmdbuf[2] = blktoread & 0xff;
1852                    	;  820      blktoread = blktoread >> 8;
1853                    	;  821      cmdbuf[1] = blktoread & 0xff;
1854                    	;  822  
1855                    	;  823      if (sdtestflg)
1856                    	;  824          {
1857                    	;  825          printf("\nCMD17: READ_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
1858                    	;  826                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
1859                    	;  827          } /* sdtestflg */
1860                    	;  828      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1861                    	;  829      if (sdtestflg)
1862                    	;  830          {
1863                    	;  831          printf("CMD17 R1 response [%02x]\n", statptr[0]);
1864                    	;  832          } /* sdtestflg */
1865                    	;  833      if (statptr[0])
1866                    	;  834          {
1867                    	;  835          if (sdtestflg)
1868                    	;  836              {
1869                    	;  837              printf("  could not read block\n");
1870                    	;  838              } /* sdtestflg */
1871                    	;  839          spideselect();
1872                    	;  840          ledoff();
1873                    	;  841          return (NO);
1874                    	;  842          }
1875                    	;  843      /* looking for 0xfe that is the byte before data */
1876                    	;  844      for (tries = 80; (0 < tries) && ((rbyte = spiio(0xff)) != 0xfe); tries--)
1877                    	;  845          {
1878                    	;  846          if ((rbyte & 0xe0) == 0x00)
1879                    	;  847              {
1880                    	;  848              /* If a read operation fails and the card cannot provide
1881                    	;  849                 the required data, it will send a data error token instead
1882                    	;  850               */
1883                    	;  851              if (sdtestflg)
1884                    	;  852                  {
1885                    	;  853                  printf("  read error: [%02x]\n", rbyte);
1886                    	;  854                  } /* sdtestflg */
1887                    	;  855              spideselect();
1888                    	;  856              ledoff();
1889                    	;  857              return (NO);
1890                    	;  858              }
1891                    	;  859          }
1892                    	;  860      if (tries == 0) /* tried too many times */
1893                    	;  861          {
1894                    	;  862          if (sdtestflg)
1895                    	;  863              {
1896                    	;  864              printf("  no data found\n");
1897                    	;  865              } /* sdtestflg */
1898                    	;  866          spideselect();
1899                    	;  867          ledoff();
1900                    	;  868          return (NO);
1901                    	;  869          }
1902                    	;  870      else
1903                    	;  871          {
1904                    	;  872          calcrc16 = 0;
1905                    	;  873          for (nbytes = 0; nbytes < 512; nbytes++)
1906                    	;  874              {
1907                    	;  875              rbyte = spiio(0xff);
1908                    	;  876              calcrc16 = CRC16_one(calcrc16, rbyte);
1909                    	;  877              rdbuf[nbytes] = rbyte;
1910                    	;  878              }
1911                    	;  879          rxcrc16 = spiio(0xff) << 8;
1912                    	;  880          rxcrc16 += spiio(0xff);
1913                    	;  881  
1914                    	;  882          if (sdtestflg)
1915                    	;  883              {
1916                    	;  884              printf("  read data block %ld:\n", rdblkno);
1917                    	;  885              } /* sdtestflg */
1918                    	;  886          if (rxcrc16 != calcrc16)
1919                    	;  887              {
1920                    	;  888              if (sdtestflg)
1921                    	;  889                  {
1922                    	;  890                  printf("  CRC16 error, recieved: 0x%04x, calc: 0x%04hi\n",
1923                    	;  891                         rxcrc16, calcrc16);
1924                    	;  892                  } /* sdtestflg */
1925                    	;  893              spideselect();
1926                    	;  894              ledoff();
1927                    	;  895              return (NO);
1928                    	;  896              }
1929                    	;  897          }
1930                    	;  898      spideselect();
1931                    	;  899      ledoff();
1932                    	;  900      return (YES);
1933                    	;  901      }
1934                    	;  902  
1935                    	;  903  /* Write data block of 512 bytes from buffer
1936                    	;  904   * Returns YES if ok or NO if error
1937                    	;  905   */
1938                    	;  906  int sdwrite(unsigned char *wrbuf, unsigned long wrblkno)
1939                    	;  907      {
1940                    	;  908      unsigned char *statptr;
1941                    	;  909      unsigned char rbyte;
1942                    	;  910      unsigned char tbyte;
1943                    	;  911      unsigned char cmdbuf[5];   /* buffer to build command in */
1944                    	;  912      unsigned char rstatbuf[5]; /* buffer to recieve status in */
1945                    	;  913      int nbytes;
1946                    	;  914      int tries;
1947                    	;  915      unsigned long blktowrite;
1948                    	;  916      unsigned int calcrc16;
1949                    	;  917  
1950                    	;  918      ledon();
1951                    	;  919      spiselect();
1952                    	;  920  
1953                    	;  921      if (!sdinitok)
1954                    	;  922          {
1955                    	;  923          if (sdtestflg)
1956                    	;  924              {
1957                    	;  925              printf("SD card not initialized\n");
1958                    	;  926              } /* sdtestflg */
1959                    	;  927          spideselect();
1960                    	;  928          ledoff();
1961                    	;  929          return (NO);
1962                    	;  930          }
1963                    	;  931  
1964                    	;  932      if (sdtestflg)
1965                    	;  933          {
1966                    	;  934          printf("  write data block %ld:\n", wrblkno);
1967                    	;  935          } /* sdtestflg */
1968                    	;  936      /* CMD24: WRITE_SINGLE_BLOCK */
1969                    	;  937      /* Insert block # into command */
1970                    	;  938      memcpy(cmdbuf, cmd24, 5);
1971                    	;  939      blktowrite = blkmult * wrblkno;
1972                    	;  940      cmdbuf[4] = blktowrite & 0xff;
1973                    	;  941      blktowrite = blktowrite >> 8;
1974                    	;  942      cmdbuf[3] = blktowrite & 0xff;
1975                    	;  943      blktowrite = blktowrite >> 8;
1976                    	;  944      cmdbuf[2] = blktowrite & 0xff;
1977                    	;  945      blktowrite = blktowrite >> 8;
1978                    	;  946      cmdbuf[1] = blktowrite & 0xff;
1979                    	;  947  
1980                    	;  948      if (sdtestflg)
1981                    	;  949          {
1982                    	;  950          printf("\nCMD24: WRITE_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
1983                    	;  951                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
1984                    	;  952          } /* sdtestflg */
1985                    	;  953      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1986                    	;  954      if (sdtestflg)
1987                    	;  955          {
1988                    	;  956          printf("CMD24 R1 response [%02x]\n", statptr[0]);
1989                    	;  957          } /* sdtestflg */
1990                    	;  958      if (statptr[0])
1991                    	;  959          {
1992                    	;  960          if (sdtestflg)
1993                    	;  961              {
1994                    	;  962              printf("  could not write block\n");
1995                    	;  963              } /* sdtestflg */
1996                    	;  964          spideselect();
1997                    	;  965          ledoff();
1998                    	;  966          return (NO);
1999                    	;  967          }
2000                    	;  968      /* send 0xfe, the byte before data */
2001                    	;  969      spiio(0xfe);
2002                    	;  970      /* initialize crc and send block */
2003                    	;  971      calcrc16 = 0;
2004                    	;  972      for (nbytes = 0; nbytes < 512; nbytes++)
2005                    	;  973          {
2006                    	;  974          tbyte = wrbuf[nbytes];
2007                    	;  975          spiio(tbyte);
2008                    	;  976          calcrc16 = CRC16_one(calcrc16, tbyte);
2009                    	;  977          }
2010                    	;  978      spiio((calcrc16 >> 8) & 0xff);
2011                    	;  979      spiio(calcrc16 & 0xff);
2012                    	;  980  
2013                    	;  981      /* check data resposnse */
2014                    	;  982      for (tries = 20;
2015                    	;  983              0 < tries && (((rbyte = spiio(0xff)) & 0x11) != 0x01);
2016                    	;  984              tries--)
2017                    	;  985          ;
2018                    	;  986      if (tries == 0)
2019                    	;  987          {
2020                    	;  988          if (sdtestflg)
2021                    	;  989              {
2022                    	;  990              printf("No data response\n");
2023                    	;  991              } /* sdtestflg */
2024                    	;  992          spideselect();
2025                    	;  993          ledoff();
2026                    	;  994          return (NO);
2027                    	;  995          }
2028                    	;  996      else
2029                    	;  997          {
2030                    	;  998          if (sdtestflg)
2031                    	;  999              {
2032                    	; 1000              printf("Data response [%02x]", 0x1f & rbyte);
2033                    	; 1001              } /* sdtestflg */
2034                    	; 1002          if ((0x1f & rbyte) == 0x05)
2035                    	; 1003              {
2036                    	; 1004              if (sdtestflg)
2037                    	; 1005                  {
2038                    	; 1006                  printf(", data accepted\n");
2039                    	; 1007                  } /* sdtestflg */
2040                    	; 1008              for (nbytes = 9; 0 < nbytes; nbytes--)
2041                    	; 1009                  spiio(0xff);
2042                    	; 1010              if (sdtestflg)
2043                    	; 1011                  {
2044                    	; 1012                  printf("Sent 9*8 (72) clock pulses, select active\n");
2045                    	; 1013                  } /* sdtestflg */
2046                    	; 1014              spideselect();
2047                    	; 1015              ledoff();
2048                    	; 1016              return (YES);
2049                    	; 1017              }
2050                    	; 1018          else
2051                    	; 1019              {
2052                    	; 1020              if (sdtestflg)
2053                    	; 1021                  {
2054                    	; 1022                  printf(", data not accepted\n");
2055                    	; 1023                  } /* sdtestflg */
2056                    	; 1024              spideselect();
2057                    	; 1025              ledoff();
2058                    	; 1026              return (NO);
2059                    	; 1027              }
2060                    	; 1028          }
2061                    	; 1029      }
2062                    	; 1030  
2063                    	; 1031  /* Print data in 512 byte buffer */
2064                    	; 1032  void sddatprt(unsigned char *prtbuf)
2065                    	; 1033      {
2066                    	; 1034      /* Variables used for "pretty-print" */
2067                    	; 1035      int allzero, dmpline, dotprted, lastallz, nbytes;
2068                    	; 1036      unsigned char *prtptr;
2069                    	; 1037  
2070                    	; 1038      prtptr = prtbuf;
2071                    	; 1039      dotprted = NO;
2072                    	; 1040      lastallz = NO;
2073                    	; 1041      for (dmpline = 0; dmpline < 32; dmpline++)
2074                    	; 1042          {
2075                    	; 1043          /* test if all 16 bytes are 0x00 */
2076                    	; 1044          allzero = YES;
2077                    	; 1045          for (nbytes = 0; nbytes < 16; nbytes++)
2078                    	; 1046              {
2079                    	; 1047              if (prtptr[nbytes] != 0)
2080                    	; 1048                  allzero = NO;
2081                    	; 1049              }
2082                    	; 1050          if (lastallz && allzero)
2083                    	; 1051              {
2084                    	; 1052              if (!dotprted)
2085                    	; 1053                  {
2086                    	; 1054                  printf("*\n");
2087                    	; 1055                  dotprted = YES;
2088                    	; 1056                  }
2089                    	; 1057              }
2090                    	; 1058          else
2091                    	; 1059              {
2092                    	; 1060              dotprted = NO;
2093                    	; 1061              /* print offset */
2094                    	; 1062              printf("%04x ", dmpline * 16);
2095                    	; 1063              /* print 16 bytes in hex */
2096                    	; 1064              for (nbytes = 0; nbytes < 16; nbytes++)
2097                    	; 1065                  printf("%02x ", prtptr[nbytes]);
2098                    	; 1066              /* print these bytes in ASCII if printable */
2099                    	; 1067              printf(" |");
2100                    	; 1068              for (nbytes = 0; nbytes < 16; nbytes++)
2101                    	; 1069                  {
2102                    	; 1070                  if ((' ' <= prtptr[nbytes]) && (prtptr[nbytes] < 127))
2103                    	; 1071                      putchar(prtptr[nbytes]);
2104                    	; 1072                  else
2105                    	; 1073                      putchar('.');
2106                    	; 1074                  }
2107                    	; 1075              printf("|\n");
2108                    	; 1076              }
2109                    	; 1077          prtptr += 16;
2110                    	; 1078          lastallz = allzero;
2111                    	; 1079          }
2112                    	; 1080      }
2113                    	; 1081  
2114                    	; 1082  /* Print GUID (mixed endian format)
2115                    	; 1083   */
2116                    	; 1084  void prtguid(unsigned char *guidptr)
2117                    	; 1085      {
2118                    	; 1086      int index;
2119                    	; 1087  
2120                    	; 1088      printf("%02x%02x%02x%02x-", guidptr[3], guidptr[2], guidptr[1], guidptr[0]);
2121                    	; 1089      printf("%02x%02x-", guidptr[5], guidptr[4]);
2122                    	; 1090      printf("%02x%02x-", guidptr[7], guidptr[6]);
2123                    	; 1091      printf("%02x%02x-", guidptr[8], guidptr[9]);
2124                    	; 1092      printf("%02x%02x%02x%02x%02x%02x",
2125                    	; 1093             guidptr[10], guidptr[11], guidptr[12], guidptr[13], guidptr[14], guidptr[15]);
2126                    	; 1094      }
2127                    	; 1095  
2128                    	; 1096  /* Analyze and print GPT entry
2129                    	; 1097   */
2130                    	; 1098  int prtgptent(unsigned int entryno)
2131                    	; 1099      {
2132                    	; 1100      int index;
2133                    	; 1101      int entryidx;
2134                    	; 1102      int hasname;
2135                    	; 1103      unsigned int block;
2136                    	; 1104      unsigned char *rxdata;
2137                    	; 1105      unsigned char *entryptr;
2138                    	; 1106      unsigned char tstzero = 0;
2139                    	; 1107      unsigned long flba;
2140                    	; 1108      unsigned long llba;
2141                    	; 1109  
2142                    	; 1110      block = 2 + (entryno / 4);
2143                    	; 1111      if ((curblkno != block) || !curblkok)
2144                    	; 1112          {
2145                    	; 1113          if (!sdread(sdrdbuf, block))
2146                    	; 1114              {
2147                    	; 1115              if (sdtestflg)
2148                    	; 1116                  {
2149                    	; 1117                  printf("Can't read GPT entry block\n");
2150                    	; 1118                  return (NO);
2151                    	; 1119                  } /* sdtestflg */
2152                    	; 1120              }
2153                    	; 1121          curblkno = block;
2154                    	; 1122          curblkok = YES;
2155                    	; 1123          }
2156                    	; 1124      rxdata = sdrdbuf;
2157                    	; 1125      entryptr = rxdata + (128 * (entryno % 4));
2158                    	; 1126      for (index = 0; index < 16; index++)
2159                    	; 1127          tstzero |= entryptr[index];
2160                    	; 1128      if (sdtestflg)
2161                    	; 1129          {
2162                    	; 1130          printf("GPT partition entry %d:", entryno + 1);
2163                    	; 1131          } /* sdtestflg */
2164                    	; 1132      if (!tstzero)
2165                    	; 1133          {
2166                    	; 1134          if (sdtestflg)
2167                    	; 1135              {
2168                    	; 1136              printf(" Not used entry\n");
2169                    	; 1137              } /* sdtestflg */
2170                    	; 1138          return (NO);
2171                    	; 1139          }
2172                    	; 1140      if (sdtestflg)
2173                    	; 1141          {
2174                    	; 1142          printf("\n  Partition type GUID: ");
2175                    	; 1143          prtguid(entryptr);
2176                    	; 1144          printf("\n  [");
2177                    	; 1145          for (index = 0; index < 16; index++)
2178                    	; 1146              printf("%02x ", entryptr[index]);
2179                    	; 1147          printf("\b]");
2180                    	; 1148          printf("\n  Unique partition GUID: ");
2181                    	; 1149          prtguid(entryptr + 16);
2182                    	; 1150          printf("\n  [");
2183                    	; 1151          for (index = 0; index < 16; index++)
2184                    	; 1152              printf("%02x ", (entryptr + 16)[index]);
2185                    	; 1153          printf("\b]");
2186                    	; 1154          printf("\n  First LBA: ");
2187                    	; 1155          /* lower 32 bits of LBA should be sufficient (I hope) */
2188                    	; 1156          } /* sdtestflg */
2189                    	; 1157      flba = (unsigned long)entryptr[32] + ((unsigned long)entryptr[33] << 8) +
2190                    	; 1158             ((unsigned long)entryptr[34] << 16) + ((unsigned long)entryptr[35] << 24);
2191                    	; 1159      if (sdtestflg)
2192                    	; 1160          {
2193                    	; 1161          printf("%lu", flba);
2194                    	; 1162          printf(" [");
2195                    	; 1163          for (index = 32; index < (32 + 8); index++)
2196                    	; 1164              printf("%02x ", entryptr[index]);
2197                    	; 1165          printf("\b]");
2198                    	; 1166          printf("\n  Last LBA: ");
2199                    	; 1167          } /* sdtestflg */
2200                    	; 1168      /* lower 32 bits of LBA should be sufficient (I hope) */
2201                    	; 1169      llba = (unsigned long)entryptr[40] + ((unsigned long)entryptr[41] << 8) +
2202                    	; 1170             ((unsigned long)entryptr[42] << 16) + ((unsigned long)entryptr[43] << 24);
2203                    	; 1171  
2204                    	; 1172      if (entryptr[48] & 0x04)
2205                    	; 1173          dskmap[partdsk].bootable = YES;
2206                    	; 1174      dskmap[partdsk].partype = PARTGPT;
2207                    	; 1175      dskmap[partdsk].dskletter = 'A' + partdsk;
2208                    	; 1176      dskmap[partdsk].dskstart = flba;
2209                    	; 1177      dskmap[partdsk].dskend = llba;
2210                    	; 1178      dskmap[partdsk].dsksize = llba - flba + 1;
2211                    	; 1179      memcpy(dskmap[partdsk].dsktype, entryptr, 16);
2212                    	; 1180      partdsk++;
2213                    	; 1181  
2214                    	; 1182      if (sdtestflg)
2215                    	; 1183          {
2216                    	; 1184          printf("%lu, size %lu MByte", llba, (llba - flba) >> 11);
2217                    	; 1185          printf(" [");
2218                    	; 1186          for (index = 40; index < (40 + 8); index++)
2219                    	; 1187              printf("%02x ", entryptr[index]);
2220                    	; 1188          printf("\b]");
2221                    	; 1189          printf("\n  Attribute flags: [");
2222                    	; 1190          /* bits 0 - 2 and 60 - 63 should be decoded */
2223                    	; 1191          for (index = 0; index < 8; index++)
2224                    	; 1192              {
2225                    	; 1193              entryidx = index + 48;
2226                    	; 1194              printf("%02x ", entryptr[entryidx]);
2227                    	; 1195              }
2228                    	; 1196          printf("\b]\n  Partition name:  ");
2229                    	; 1197          } /* sdtestflg */
2230                    	; 1198      /* partition name is in UTF-16LE code units */
2231                    	; 1199      hasname = NO;
2232                    	; 1200      for (index = 0; index < 72; index += 2)
2233                    	; 1201          {
2234                    	; 1202          entryidx = index + 56;
2235                    	; 1203          if ((entryptr[entryidx] | entryptr[entryidx + 1]) == 0)
2236                    	; 1204              break;
2237                    	; 1205          if (sdtestflg)
2238                    	; 1206              {
2239                    	; 1207              if ((' ' <= entryptr[entryidx]) && (entryptr[entryidx] < 127))
2240                    	; 1208                  putchar(entryptr[entryidx]);
2241                    	; 1209              else
2242                    	; 1210                  putchar('.');
2243                    	; 1211              } /* sdtestflg */
2244                    	; 1212          hasname = YES;
2245                    	; 1213          }
2246                    	; 1214      if (sdtestflg)
2247                    	; 1215          {
2248                    	; 1216          if (!hasname)
2249                    	; 1217              printf("name field empty");
2250                    	; 1218          printf("\n");
2251                    	; 1219          printf("   [");
2252                    	; 1220          for (index = 0; index < 72; index++)
2253                    	; 1221              {
2254                    	; 1222              if (((index & 0xf) == 0) && (index != 0))
2255                    	; 1223                  printf("\n    ");
2256                    	; 1224              entryidx = index + 56;
2257                    	; 1225              printf("%02x ", entryptr[entryidx]);
2258                    	; 1226              }
2259                    	; 1227          printf("\b]\n");
2260                    	; 1228          } /* sdtestflg */
2261                    	; 1229      return (YES);
2262                    	; 1230      }
2263                    	; 1231  
2264                    	; 1232  /* Analyze and print GPT header
2265                    	; 1233   */
2266                    	; 1234  void sdgpthdr(unsigned long block)
2267                    	; 1235      {
2268                    	; 1236      int index;
2269                    	; 1237      unsigned int partno;
2270                    	; 1238      unsigned char *rxdata;
2271                    	; 1239      unsigned long entries;
2272                    	; 1240  
2273                    	; 1241      if (sdtestflg)
2274                    	; 1242          {
2275                    	; 1243          printf("GPT header\n");
2276                    	; 1244          } /* sdtestflg */
2277                    	; 1245      if (!sdread(sdrdbuf, block))
2278                    	; 1246          {
2279                    	; 1247          if (sdtestflg)
2280                    	; 1248              {
2281                    	; 1249              printf("Can't read GPT partition table header\n");
2282                    	; 1250              } /* sdtestflg */
2283                    	; 1251          return;
2284                    	; 1252          }
2285                    	; 1253      curblkno = block;
2286                    	; 1254      curblkok = YES;
2287                    	; 1255  
2288                    	; 1256      rxdata = sdrdbuf;
2289                    	; 1257      if (sdtestflg)
2290                    	; 1258          {
2291                    	; 1259          printf("  Signature: %.8s\n", &rxdata[0]);
2292                    	; 1260          printf("  Revision: %d.%d [%02x %02x %02x %02x]\n",
2293                    	; 1261                 (int)rxdata[8] * ((int)rxdata[9] << 8),
2294                    	; 1262                 (int)rxdata[10] + ((int)rxdata[11] << 8),
2295                    	; 1263                 rxdata[8], rxdata[9], rxdata[10], rxdata[11]);
2296                    	; 1264          entries = (unsigned long)rxdata[80] + ((unsigned long)rxdata[81] << 8) +
2297                    	; 1265                    ((unsigned long)rxdata[82] << 16) + ((unsigned long)rxdata[83] << 24);
2298                    	; 1266          printf("  Number of partition entries: %lu (may be actual or maximum)\n", entries);
2299                    	; 1267          } /* sdtestflg */
2300                    	; 1268      for (partno = 0; (partno < 16) && (partdsk < 16); partno++)
2301                    	; 1269          {
2302                    	; 1270          if (!prtgptent(partno))
2303                    	; 1271              {
2304                    	; 1272              if (!sdtestflg)
2305                    	; 1273                  {
2306                    	; 1274                  /* go through all entries if compiled as test program */
2307                    	; 1275                  return;
2308                    	; 1276                  } /* sdtestflg */
2309                    	; 1277              }
2310                    	; 1278          }
2311                    	; 1279      if (sdtestflg)
2312                    	; 1280          {
2313                    	; 1281          printf("First 16 GPT entries scanned\n");
2314                    	; 1282          } /* sdtestflg */
2315                    	; 1283      }
2316                    	; 1284  
2317                    	; 1285  /* Analyze and print MBR partition entry
2318                    	; 1286   * Returns:
2319                    	; 1287   *    -1 if errror - should not happen
2320                    	; 1288   *     0 if not used entry
2321                    	; 1289   *     1 if MBR entry
2322                    	; 1290   *     2 if EBR entry
2323                    	; 1291   *     3 if GTP entry
2324                    	; 1292   */
2325                    	; 1293  int sdmbrentry(unsigned char *partptr)
2326                    	; 1294      {
2327                    	; 1295      int index;
2328                    	; 1296      int parttype;
2329                    	; 1297      unsigned long lbastart;
2330                    	; 1298      unsigned long lbasize;
2331                    	; 1299  
2332                    	; 1300      parttype = PARTMBR;
2333                    	; 1301      if (!partptr[4])
2334                    	; 1302          {
2335                    	; 1303          if (sdtestflg)
2336                    	; 1304              {
2337                    	; 1305              printf("Not used entry\n");
2338                    	; 1306              } /* sdtestflg */
2339                    	; 1307          return (PARTZRO);
2340                    	; 1308          }
2341                    	; 1309      if (sdtestflg)
2342                    	; 1310          {
2343                    	; 1311          printf("Boot indicator: 0x%02x, System ID: 0x%02x\n",
2344                    	; 1312                 partptr[0], partptr[4]);
2345                    	; 1313  
2346                    	; 1314          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f))
2347                    	; 1315              {
2348                    	; 1316              printf("  Extended partition entry\n");
2349                    	; 1317              }
2350                    	; 1318          if (partptr[0] & 0x01)
2351                    	; 1319              {
2352                    	; 1320              printf("  Unofficial 48 bit LBA Proposed MBR Format, no CHS\n");
2353                    	; 1321              /* this is however discussed
2354                    	; 1322                 https://wiki.osdev.org/Partition_Table#.22Unofficial.22_48_bit_LBA_Proposed_MBR_Format
2355                    	; 1323              */
2356                    	; 1324              }
2357                    	; 1325          else
2358                    	; 1326              {
2359                    	; 1327              printf("  begin CHS: 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
2360                    	; 1328                     partptr[1], partptr[2], partptr[3],
2361                    	; 1329                     ((partptr[2] & 0xc0) >> 2) + partptr[3],
2362                    	; 1330                     partptr[1],
2363                    	; 1331                     partptr[2] & 0x3f);
2364                    	; 1332              printf("  end CHS 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
2365                    	; 1333                     partptr[5], partptr[6], partptr[7],
2366                    	; 1334                     ((partptr[6] & 0xc0) >> 2) + partptr[7],
2367                    	; 1335                     partptr[5],
2368                    	; 1336                     partptr[6] & 0x3f);
2369                    	; 1337              }
2370                    	; 1338          } /* sdtestflg */
2371                    	; 1339      /* not showing high 16 bits if 48 bit LBA */
2372                    	; 1340      lbastart = (unsigned long)partptr[8] +
2373                    	; 1341                 ((unsigned long)partptr[9] << 8) +
2374                    	; 1342                 ((unsigned long)partptr[10] << 16) +
2375                    	; 1343                 ((unsigned long)partptr[11] << 24);
2376                    	; 1344      lbasize = (unsigned long)partptr[12] +
2377                    	; 1345                ((unsigned long)partptr[13] << 8) +
2378                    	; 1346                ((unsigned long)partptr[14] << 16) +
2379                    	; 1347                ((unsigned long)partptr[15] << 24);
2380                    	; 1348  
2381                    	; 1349      if (!(partptr[4] == 0xee)) /* not pointing to a GPT partition */
2382                    	; 1350          {
2383                    	; 1351          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f)) /* EBR partition */
2384                    	; 1352              {
2385                    	; 1353              parttype = PARTEBR;
2386                    	; 1354              if (curblkno == 0) /* points to EBR in the MBR */
2387                    	; 1355                  {
2388                    	; 1356                  ebrnext = 0;
2389                    	; 1357                  dskmap[partdsk].partype = EBRCONT;
2390                    	; 1358                  dskmap[partdsk].dskletter = 'A' + partdsk;
2391                    	; 1359                  dskmap[partdsk].dskstart = lbastart;
2392                    	; 1360                  dskmap[partdsk].dskend = lbastart + lbasize - 1;
2393                    	; 1361                  dskmap[partdsk].dsksize = lbasize;
2394                    	; 1362                  dskmap[partdsk].dsktype[0] = partptr[4];
2395                    	; 1363                  partdsk++;
2396                    	; 1364                  ebrrecs[ebrrecidx++] = lbastart; /* save to handle later */
2397                    	; 1365                  }
2398                    	; 1366              else
2399                    	; 1367                  {
2400                    	; 1368                  ebrnext = curblkno + lbastart;
2401                    	; 1369                  }
2402                    	; 1370              }
2403                    	; 1371          else
2404                    	; 1372              {
2405                    	; 1373              if (0 < lbasize) /* one more ugly hack to avoid empty partitions */
2406                    	; 1374                  {
2407                    	; 1375                  if (partptr[0] & 0x80)
2408                    	; 1376                      dskmap[partdsk].bootable = YES;
2409                    	; 1377                  if (curblkno == 0)
2410                    	; 1378                      dskmap[partdsk].partype = PARTMBR;
2411                    	; 1379                  else
2412                    	; 1380                      dskmap[partdsk].partype = PARTEBR;
2413                    	; 1381                  dskmap[partdsk].dskletter = 'A' + partdsk;
2414                    	; 1382                  dskmap[partdsk].dskstart = curblkno + lbastart;
2415                    	; 1383                  dskmap[partdsk].dskend = curblkno + lbastart + lbasize - 1;
2416                    	; 1384                  dskmap[partdsk].dsksize = lbasize;
2417                    	; 1385                  dskmap[partdsk].dsktype[0] = partptr[4];
2418                    	; 1386                  partdsk++;
2419                    	; 1387                  }
2420                    	; 1388              }
2421                    	; 1389          }
2422                    	; 1390  
2423                    	; 1391      if (sdtestflg)
2424                    	; 1392          {
2425                    	; 1393          printf("  partition start LBA: %lu [%08lx]\n",
2426                    	; 1394                 curblkno + lbastart, curblkno + lbastart);
2427                    	; 1395          printf("  partition size LBA: %lu [%08lx], %lu MByte\n",
2428                    	; 1396                 lbasize, lbasize, lbasize >> 11);
2429                    	; 1397          } /* sdtestflg */
2430                    	; 1398      if (partptr[4] == 0xee) /* GPT partitions */
2431                    	; 1399          {
2432                    	; 1400          parttype = PARTGPT;
2433                    	; 1401          if (sdtestflg)
2434                    	; 1402              {
2435                    	; 1403              printf("GTP partitions\n");
2436                    	; 1404              } /* sdtestflg */
2437                    	; 1405          sdgpthdr(lbastart); /* handle GTP partitions */
2438                    	; 1406          /* re-read MBR on sector 0
2439                    	; 1407             This is probably not needed as there
2440                    	; 1408             is only one entry (the first one)
2441                    	; 1409             in the MBR when using GPT */
2442                    	; 1410          if (sdread(sdrdbuf, 0))
2443                    	; 1411              {
2444                    	; 1412              curblkno = 0;
2445                    	; 1413              curblkok = YES;
2446                    	; 1414              }
2447                    	; 1415          else
2448                    	; 1416              {
2449                    	; 1417              if (sdtestflg)
2450                    	; 1418                  {
2451                    	; 1419                  printf("  can't read MBR on sector 0\n");
2452                    	; 1420                  } /* sdtestflg */
2453                    	; 1421              return(-1);
2454                    	; 1422              }
2455                    	; 1423          }
2456                    	; 1424      return (parttype);
2457                    	; 1425      }
2458                    	; 1426  
2459                    	; 1427  /* Read and analyze MBR/EBR partition sector block
2460                    	; 1428   * and go through and print partition entries.
2461                    	; 1429   */
2462                    	; 1430  void sdmbrpart(unsigned long sector)
2463                    	; 1431      {
2464                    	; 1432      int partidx;  /* partition index 1 - 4 */
2465                    	; 1433      int cpartidx; /* chain partition index 1 - 4 */
2466                    	; 1434      int chainidx;
2467                    	; 1435      int enttype;
2468                    	; 1436      unsigned char *entp; /* pointer to partition entry */
2469                    	; 1437      char *mbrebr;
2470                    	; 1438  
2471                    	; 1439      if (sdtestflg)
2472                    	; 1440          {
2473                    	; 1441          if (sector == 0) /* if sector 0 it is MBR else it is EBR */
2474                    	; 1442              mbrebr = "MBR";
2475                    	; 1443          else
2476                    	; 1444              mbrebr = "EBR";
2477                    	; 1445          printf("Read %s from sector %lu\n", mbrebr, sector);
2478                    	; 1446          } /* sdtestflg */
2479                    	; 1447      if (sdread(sdrdbuf, sector))
2480                    	; 1448          {
2481                    	; 1449          curblkno = sector;
2482                    	; 1450          curblkok = YES;
2483                    	; 1451          }
2484                    	; 1452      else
2485                    	; 1453          {
2486                    	; 1454          if (sdtestflg)
2487                    	; 1455              {
2488                    	; 1456              printf("  can't read %s sector %lu\n", mbrebr, sector);
2489                    	; 1457              } /* sdtestflg */
2490                    	; 1458          return;
2491                    	; 1459          }
2492                    	; 1460      if (!((sdrdbuf[0x1fe] == 0x55) && (sdrdbuf[0x1ff] == 0xaa)))
2493                    	; 1461          {
2494                    	; 1462          if (sdtestflg)
2495                    	; 1463              {
2496                    	; 1464              printf("  no %s boot signature found\n", mbrebr);
2497                    	; 1465              } /* sdtestflg */
2498                    	; 1466          return;
2499                    	; 1467          }
2500                    	; 1468      if (curblkno == 0)
2501                    	; 1469          {
2502                    	; 1470          memcpy(dsksign, &sdrdbuf[0x1b8], sizeof dsksign);
2503                    	; 1471          if (sdtestflg)
2504                    	; 1472              {
2505                    	; 1473  
2506                    	; 1474              printf("  disk identifier: 0x%02x%02x%02x%02x\n",
2507                    	; 1475                     dsksign[3], dsksign[2], dsksign[1], dsksign[0]);
2508                    	; 1476              } /* sdtestflg */
2509                    	; 1477          }
2510                    	; 1478      /* go through MBR partition entries until first empty */
2511                    	; 1479      /* !!as the MBR entry routine is called recusively a way is
2512                    	; 1480         needed to read sector 0 when going back to MBR if
2513                    	; 1481         there is a primary partition entry after an EBR entry!! */
2514                    	; 1482      entp = &sdrdbuf[0x01be] ;
2515                    	; 1483      for (partidx = 1; (partidx <= 4) && (partdsk < 16); partidx++, entp += 16)
2516                    	; 1484          {
2517                    	; 1485          if (sdtestflg)
2518                    	; 1486              {
2519                    	; 1487              printf("%s partition entry %d: ", mbrebr, partidx);
2520                    	; 1488              } /* sdtestflg */
2521                    	; 1489          enttype = sdmbrentry(entp);
2522                    	; 1490          if (enttype == -1) /* read error */
2523                    	; 1491                   return;
2524                    	; 1492          else if (enttype == PARTZRO)
2525                    	; 1493              {
2526                    	; 1494              if (!sdtestflg)
2527                    	; 1495                  {
2528                    	; 1496                  /* if compiled as test program show also empty partitions */
2529                    	; 1497                  break;
2530                    	; 1498                  } /* sdtestflg */
2531                    	; 1499              }
2532                    	; 1500          }
2533                    	; 1501      /* now handle the previously saved EBR partition sectors */
2534                    	; 1502      for (partidx = 0; (partidx < ebrrecidx) && (partdsk < 16); partidx++)
2535                    	; 1503          {
2536                    	; 1504          if (sdread(sdrdbuf, ebrrecs[partidx]))
2537                    	; 1505              {
2538                    	; 1506              curblkno = ebrrecs[partidx];
2539                    	; 1507              curblkok = YES;
2540                    	; 1508              }
2541                    	; 1509          else
2542                    	; 1510              {
2543                    	; 1511              if (sdtestflg)
2544                    	; 1512                  {
2545                    	; 1513                  printf("  can't read %s sector %lu\n", mbrebr, sector);
2546                    	; 1514                  } /* sdtestflg */
2547                    	; 1515              return;
2548                    	; 1516              }
2549                    	; 1517          entp = &sdrdbuf[0x01be] ;
2550                    	; 1518          for (partidx = 1; (partidx <= 4) && (partdsk < 16); partidx++, entp += 16)
2551                    	; 1519              {
2552                    	; 1520              if (sdtestflg)
2553                    	; 1521                  {
2554                    	; 1522                  printf("EBR partition entry %d: ", partidx);
2555                    	; 1523                  } /* sdtestflg */
2556                    	; 1524              enttype = sdmbrentry(entp);
2557                    	; 1525              if (enttype == -1) /* read error */
2558                    	; 1526                   return;
2559                    	; 1527              else if (enttype == PARTZRO) /* empty partition entry */
2560                    	; 1528                  {
2561                    	; 1529                  if (sdtestflg)
2562                    	; 1530                      {
2563                    	; 1531                      /* if compiled as test program show also empty partitions */
2564                    	; 1532                      printf("Empty partition entry\n");
2565                    	; 1533                      } /* sdtestflg */
2566                    	; 1534                  else
2567                    	; 1535                      break;
2568                    	; 1536                  }
2569                    	; 1537              else if (enttype == PARTEBR) /* next chained EBR */
2570                    	; 1538                  {
2571                    	; 1539                  if (sdtestflg)
2572                    	; 1540                      {
2573                    	; 1541                      printf("EBR chain\n");
2574                    	; 1542                      } /* sdtestflg */
2575                    	; 1543                  /* follow the EBR chain */
2576                    	; 1544                  for (chainidx = 0;
2577                    	; 1545                      ebrnext && (chainidx < 16) && (partdsk < 16);
2578                    	; 1546                      chainidx++)
2579                    	; 1547                      {
2580                    	; 1548                      /* ugly hack to stop reading the same sector */
2581                    	; 1549                      if (ebrnext == curblkno)
2582                    	; 1550                           break;
2583                    	; 1551                      if (sdread(sdrdbuf, ebrnext))
2584                    	; 1552                          {
2585                    	; 1553                          curblkno = ebrnext;
2586                    	; 1554                          curblkok = YES;
2587                    	; 1555                          }
2588                    	; 1556                      else
2589                    	; 1557                          {
2590                    	; 1558                          if (sdtestflg)
2591                    	; 1559                              {
2592                    	; 1560                              printf("  can't read %s sector %lu\n", mbrebr, sector);
2593                    	; 1561                              } /* sdtestflg */
2594                    	; 1562                          return;
2595                    	; 1563                          }
2596                    	; 1564                      entp = &sdrdbuf[0x01be] ;
2597                    	; 1565                      for (cpartidx = 1;
2598                    	; 1566                          (cpartidx <= 4) && (partdsk < 16);
2599                    	; 1567                          cpartidx++, entp += 16)
2600                    	; 1568                          {
2601                    	; 1569                          if (sdtestflg)
2602                    	; 1570                              {
2603                    	; 1571                              printf("EBR chained  partition entry %d: ",
2604                    	; 1572                                   cpartidx);
2605                    	; 1573                              } /* sdtestflg */
2606                    	; 1574                          enttype = sdmbrentry(entp);
2607                    	; 1575                          if (enttype == -1) /* read error */
2608                    	; 1576                              return;
2609                    	; 1577                          }
2610                    	; 1578                      }
2611                    	; 1579                  }
2612                    	; 1580              }
2613                    	; 1581          }
2614                    	; 1582      }
2615                    	; 1583  
2616                    	; 1584  /* Executing in RAM or EPROM
2617                    	; 1585   */
2618                    	; 1586  void execin()
2619                    	; 1587      {
2620                    	; 1588      printf(", executing in: ");
2621                    	; 1589      rampptr = &ramprobe;
2622                    	; 1590      *rampptr = 1; /* try to change const */
2623                    	; 1591      if (ramprobe)
2624                    	; 1592          printf("RAM\n");
2625                    	; 1593      else
2626                    	; 1594          printf("EPROM\n");
2627                    	; 1595      *rampptr = 0;
2628                    	; 1596      }
2629                    	; 1597  
2630                    	; 1598  /* Test init, read and partitions on SD card over the SPI interface,
2631                    	; 1599   * boot from SD card, upload with Xmodem
2632                    	; 1600   */
2633                    	; 1601  int main()
2634                    	; 1602      {
2635                    	; 1603      char txtin[10];
2636                    	; 1604      int cmdin;
2637                    	; 1605      int idx;
2638                    	; 1606      int cmpidx;
2639                    	; 1607      unsigned char *cmpptr;
2640                    	; 1608      int inlength;
2641                    	; 1609      unsigned long blockno;
2642                    	; 1610  
2643                    	; 1611      blockno = 0;
2644                    	; 1612      curblkno = 0;
2645    4901  320200    		ld	(_curblkno),a
2646    4904  320300    		ld	(_curblkno+1),a
2647    4907  320400    		ld	(_curblkno+2),a
2648    490A  320500    		ld	(_curblkno+3),a
2649    490D  221000    		ld	(_curblkok),hl
2650                    	; 1613      curblkok = NO;
2651                    	; 1614      sdinitok = NO; /* SD card not initialized yet */
2652    4910  210000    		ld	hl,0
2653    4913  220C00    		ld	(_sdinitok),hl
2654                    	; 1615  
2655                    	; 1616      printf(PRGNAME);
2656    4916  21FE42    		ld	hl,L5172
2657    4919  CD0000    		call	_printf
2658                    	; 1617      printf(VERSION);
2659    491C  210743    		ld	hl,L5272
2660    491F  CD0000    		call	_printf
2661                    	; 1618      printf(builddate);
2662    4922  210000    		ld	hl,_builddate
2663    4925  CD0000    		call	_printf
2664                    	; 1619      execin();
2665    4928  CDCF42    		call	_execin
2666                    	; 1620      printf("binsize: 0x%04x (%d), binstart: 0x%04x\n", binsize, binsize, binstart);
2667    492B  2A0000    		ld	hl,(_binstart)
2668    492E  E5        		push	hl
2669    492F  2A0000    		ld	hl,(_binsize)
2670    4932  E5        		push	hl
2671    4933  E5        		push	hl
2672    4934  211543    		ld	hl,L5372
2673    4937  CD0000    		call	_printf
2674    493A  F1        		pop	af
2675    493B  F1        		pop	af
2676    493C  F1        		pop	af
2677                    	L1226:
2678                    	; 1621      while (YES) /* forever (until Ctrl-C) */
2679                    	; 1622          {
2680                    	; 1623          printf("cmd (? for help): ");
2681    493D  213D43    		ld	hl,L5472
2682    4940  CD0000    		call	_printf
2683                    	; 1624  
2684                    	; 1625          cmdin = getchar();
2685    4943  CD0000    		call	_getchar
2686    4946  DD71EE    		ld	(ix-18),c
2687    4949  DD70EF    		ld	(ix-17),b
2688                    	; 1626          switch (cmdin)
2689    494C  DD4EEE    		ld	c,(ix-18)
2690    494F  DD46EF    		ld	b,(ix-17)
2691    4952  21B348    		ld	hl,L1426
2692    4955  C30000    		jp	c.jtab
2693                    	L1626:
2694                    	; 1627              {
2695                    	; 1628              case '?':
2696                    	; 1629                  printf(" ? - help\n");
2697    4958  215043    		ld	hl,L5572
2698    495B  CD0000    		call	_printf
2699                    	; 1630                  printf(PRGNAME);
2700    495E  215B43    		ld	hl,L5672
2701    4961  CD0000    		call	_printf
2702                    	; 1631                  printf(VERSION);
2703    4964  216443    		ld	hl,L5772
2704    4967  CD0000    		call	_printf
2705                    	; 1632                  printf(builddate);
2706    496A  210000    		ld	hl,_builddate
2707    496D  CD0000    		call	_printf
2708                    	; 1633                  execin();
2709    4970  CDCF42    		call	_execin
2710                    	; 1634                  printf("Commands:\n");
2711    4973  217243    		ld	hl,L5003
2712    4976  CD0000    		call	_printf
2713                    	; 1635                  printf("  ? - help\n");
2714    4979  217D43    		ld	hl,L5103
2715    497C  CD0000    		call	_printf
2716                    	; 1636                  printf("  b - boot from SD card\n");
2717    497F  218943    		ld	hl,L5203
2718    4982  CD0000    		call	_printf
2719                    	; 1637                  printf("  d - debug on/off\n");
2720    4985  21A243    		ld	hl,L5303
2721    4988  CD0000    		call	_printf
2722                    	; 1638                  printf("  i - initialize SD card\n");
2723    498B  21B643    		ld	hl,L5403
2724    498E  CD0000    		call	_printf
2725                    	; 1639                  printf("  l - print SD card partition layout\n");
2726    4991  21D043    		ld	hl,L5503
2727    4994  CD0000    		call	_printf
2728                    	; 1640                  printf("  n - set/show sector #N to read/write\n");
2729    4997  21F643    		ld	hl,L5603
2730    499A  CD0000    		call	_printf
2731                    	; 1641                  printf("  p - print sector last read/to write\n");
2732    499D  211E44    		ld	hl,L5703
2733    49A0  CD0000    		call	_printf
2734                    	; 1642                  printf("  r - read sector #N\n");
2735    49A3  214544    		ld	hl,L5013
2736    49A6  CD0000    		call	_printf
2737                    	; 1643                  printf("  s - print SD registers\n");
2738    49A9  215B44    		ld	hl,L5113
2739    49AC  CD0000    		call	_printf
2740                    	; 1644                  printf("  t - test probe SD card\n");
2741    49AF  217544    		ld	hl,L5213
2742    49B2  CD0000    		call	_printf
2743                    	; 1645                  printf("  u - upload code with Xmodem to RAM address 0x0000\n");
2744    49B5  218F44    		ld	hl,L5313
2745    49B8  CD0000    		call	_printf
2746                    	; 1646                  printf("  w - write sector #N\n");
2747    49BB  21C444    		ld	hl,L5413
2748    49BE  CD0000    		call	_printf
2749                    	; 1647                  printf("  Ctrl-C to reload monitor from EPROM\n");
2750    49C1  21DB44    		ld	hl,L5513
2751    49C4  CD0000    		call	_printf
2752                    	; 1648                  break;
2753    49C7  C33D49    		jp	L1226
2754                    	L1726:
2755                    	; 1649              case 'b':
2756                    	; 1650                  printf(" d - boot from SD card - ");
2757    49CA  210245    		ld	hl,L5613
2758    49CD  CD0000    		call	_printf
2759                    	; 1651                  printf("implementation ongoing\n");
2760    49D0  211C45    		ld	hl,L5713
2761    49D3  CD0000    		call	_printf
2762                    	; 1652                  break;
2763    49D6  C33D49    		jp	L1226
2764                    	L1036:
2765                    	; 1653              case 'd':
2766                    	; 1654                  printf(" d - toggle debug flag - ");
2767    49D9  213445    		ld	hl,L5023
2768    49DC  CD0000    		call	_printf
2769                    	; 1655                  if (sdtestflg)
2770    49DF  2A0000    		ld	hl,(_sdtestflg)
2771    49E2  7C        		ld	a,h
2772    49E3  B5        		or	l
2773    49E4  280F      		jr	z,L1136
2774                    	; 1656                      {
2775                    	; 1657                      sdtestflg = NO;
2776    49E6  210000    		ld	hl,0
2777    49E9  220000    		ld	(_sdtestflg),hl
2778                    	; 1658                      printf("OFF\n");
2779    49EC  214E45    		ld	hl,L5123
2780    49EF  CD0000    		call	_printf
2781                    	; 1659                      }
2782                    	; 1660                  else
2783    49F2  C33D49    		jp	L1226
2784                    	L1136:
2785                    	; 1661                      {
2786                    	; 1662                      sdtestflg = YES;
2787    49F5  210100    		ld	hl,1
2788    49F8  220000    		ld	(_sdtestflg),hl
2789                    	; 1663                      printf("ON\n");
2790    49FB  215345    		ld	hl,L5223
2791    49FE  CD0000    		call	_printf
2792    4A01  C33D49    		jp	L1226
2793                    	L1336:
2794                    	; 1664                      }
2795                    	; 1665                  break;
2796                    	; 1666              case 'i':
2797                    	; 1667                  printf(" i - initialize SD card");
2798    4A04  215745    		ld	hl,L5323
2799    4A07  CD0000    		call	_printf
2800                    	; 1668                  if (sdinit())
2801    4A0A  CD0A06    		call	_sdinit
2802    4A0D  79        		ld	a,c
2803    4A0E  B0        		or	b
2804    4A0F  2809      		jr	z,L1436
2805                    	; 1669                      printf(" - ok\n");
2806    4A11  216F45    		ld	hl,L5423
2807    4A14  CD0000    		call	_printf
2808                    	; 1670                  else
2809    4A17  C33D49    		jp	L1226
2810                    	L1436:
2811                    	; 1671                      printf(" - not inserted or faulty\n");
2812    4A1A  217645    		ld	hl,L5523
2813    4A1D  CD0000    		call	_printf
2814    4A20  C33D49    		jp	L1226
2815                    	L1636:
2816                    	; 1672                  break;
2817                    	; 1673              case 'l':
2818                    	; 1674                  printf(" l - print partition layout\n");
2819    4A23  219145    		ld	hl,L5623
2820    4A26  CD0000    		call	_printf
2821                    	; 1675                  if (!sdprobe())
2822    4A29  CD0B10    		call	_sdprobe
2823    4A2C  79        		ld	a,c
2824    4A2D  B0        		or	b
2825    4A2E  2009      		jr	nz,L1736
2826                    	; 1676                      {
2827                    	; 1677                      printf(" - SD not initialized or inserted or faulty\n");
2828    4A30  21AE45    		ld	hl,L5723
2829    4A33  CD0000    		call	_printf
2830                    	; 1678                      break;
2831    4A36  C33D49    		jp	L1226
2832                    	L1736:
2833                    	; 1679                      }
2834                    	; 1680                  ebrrecidx = 0;
2835                    	; 1681                  partdsk = 0;
2836                    	;    1  /*  z80sdbt.c Boot and SD card test program.
2837                    	;    2   *
2838                    	;    3   *  Boot code for my DIY Z80 Computer. This
2839                    	;    4   *  program is compiled with Whitesmiths/COSMIC
2840                    	;    5   *  C compiler for Z80.
2841                    	;    6   *
2842                    	;    7   *  Initializes the hardware and detects the
2843                    	;    8   *  presence and partitioning of an attached SD card.
2844                    	;    9   *
2845                    	;   10   *  You are free to use, modify, and redistribute
2846                    	;   11   *  this source code. No warranties are given.
2847                    	;   12   *  Hastily Cobbled Together 2021 and 2022
2848                    	;   13   *  by Hans-Ake Lund
2849                    	;   14   *
2850                    	;   15   */
2851                    	;   16  
2852                    	;   17  #include <std.h>
2853                    	;   18  #include "z80computer.h"
2854                    	;   19  #include "builddate.h"
2855                    	;   20  
2856                    	;   21  /* Program name and version */
2857                    	;   22  #define PRGNAME "z80sdbt "
2858                    	;   23  #define VERSION "version 0.9, "
2859                    	;   24  /* Address in high RAM where to copy uploader */
2860                    	;   25  #define UPLADDR 0xf000
2861                    	;   26  
2862                    	;   27  /* This code should be cleaned up when
2863                    	;   28     remaining functions are implemented
2864                    	;   29   */
2865                    	;   30  #define PARTZRO 0  /* Empty partition entry */
2866                    	;   31  #define PARTMBR 1  /* MBR partition */
2867                    	;   32  #define PARTEBR 2  /* EBR logical partition */
2868                    	;   33  #define PARTGPT 3  /* GPT partition */
2869                    	;   34  #define EBRCONT 20 /* EBR container partition in MBR */
2870                    	;   35  
2871                    	;   36  struct partentry
2872                    	;   37      {
2873                    	;   38      char partype;
2874                    	;   39      char dskletter;
2875                    	;   40      int bootable;
2876                    	;   41      unsigned long dskstart;
2877                    	;   42      unsigned long dskend;
2878                    	;   43      unsigned long dsksize;
2879                    	;   44      unsigned char dsktype[16];
2880                    	;   45      } dskmap[16];
2881                    	;   46  
2882                    	;   47  unsigned char dsksign[4]; /* MBR/EBR disk signature */
2883                    	;   48  
2884                    	;   49  /* Function prototypes */
2885                    	;   50  void sdmbrpart(unsigned long);
2886                    	;   51  
2887                    	;   52  /* External data */
2888                    	;   53  extern const char upload[];
2889                    	;   54  extern const int upload_size;
2890                    	;   55  extern const int binsize;
2891                    	;   56  extern const int binstart;
2892                    	;   57  
2893                    	;   58  /* RAM/EPROM probe */
2894                    	;   59  const int ramprobe = 0;
2895                    	;   60  int *rampptr;
2896                    	;   61  
2897                    	;   62  /* Response length in bytes
2898                    	;   63   */
2899                    	;   64  #define R1_LEN 1
2900                    	;   65  #define R3_LEN 5
2901                    	;   66  #define R7_LEN 5
2902                    	;   67  
2903                    	;   68  /* The SD card commands (5 bytes) and a CRC7 byte as the last byte.
2904                    	;   69   * (The CRC7 byte in the tables below are only for information,
2905                    	;   70   * it is calculated by the sdcommand routine.)
2906                    	;   71   */
2907                    	;   72  const unsigned char cmd0[] = {0x40, 0x00, 0x00, 0x00, 0x00, 0x95};
2908                    	;   73  const unsigned char cmd8[] = {0x48, 0x00, 0x00, 0x01, 0xaa, 0x87};
2909                    	;   74  const unsigned char cmd9[] = {0x49, 0x00, 0x00, 0x00, 0x00, 0xaf};
2910                    	;   75  const unsigned char cmd10[] = {0x4a, 0x00, 0x00, 0x00, 0x00, 0x1b};
2911                    	;   76  const unsigned char cmd16[] = {0x50, 0x00, 0x00, 0x02, 0x00, 0x15};
2912                    	;   77  const unsigned char cmd17[] = {0x51, 0x00, 0x00, 0x00, 0x00, 0x55};
2913                    	;   78  const unsigned char cmd24[] = {0x58, 0x00, 0x00, 0x00, 0x00, 0x6f};
2914                    	;   79  const unsigned char cmd55[] = {0x77, 0x00, 0x00, 0x00, 0x00, 0x65};
2915                    	;   80  const unsigned char cmd58[] = {0x7a, 0x00, 0x00, 0x00, 0x00, 0xfd};
2916                    	;   81  const unsigned char acmd41[] = {0x69, 0x40, 0x00, 0x01, 0xaa, 0x33};
2917                    	;   82  
2918                    	;   83  /* Partition identifiers
2919                    	;   84   */
2920                    	;   85  /* For GPT I have decided that a CP/M partition
2921                    	;   86   * has GUID: AC7176FD-8D55-4FFF-86A5-A36D6368D0CB
2922                    	;   87   */
2923                    	;   88  const unsigned char gptcpm[] =
2924                    	;   89      {
2925                    	;   90      0xfd, 0x76, 0x71, 0xac, 0x55, 0x8d, 0xff, 0x4f,
2926                    	;   91      0x86, 0xa5, 0xa3, 0x6d, 0x63, 0x68, 0xd0, 0xcb
2927                    	;   92      };
2928                    	;   93  /* For MBR/EBR the partition type for CP/M is 0x52
2929                    	;   94   * according to: https://en.wikipedia.org/wiki/Partition_type
2930                    	;   95   */
2931                    	;   96  const unsigned char mbrcpm = 0x52;    /* CP/M partition */
2932                    	;   97  const unsigned char mbrexcode = 0x5f; /* Z80 executable code partition */
2933                    	;   98  /* has a special format that */
2934                    	;   99  /* includes number of sectors to */
2935                    	;  100  /* load and a signature, TBD */
2936                    	;  101  
2937                    	;  102  /* Buffers
2938                    	;  103   */
2939                    	;  104  unsigned char sdrdbuf[512];  /* recieved data from the SD card */
2940                    	;  105  
2941                    	;  106  unsigned char ocrreg[4];     /* SD card OCR register */
2942                    	;  107  unsigned char cidreg[16];    /* SD card CID register */
2943                    	;  108  unsigned char csdreg[16];    /* SD card CSD register */
2944                    	;  109  unsigned long ebrrecs[4];    /* detected EBR records to process */
2945                    	;  110  int ebrrecidx; /* how many EBR records that are populated */
2946                    	;  111  unsigned long ebrnext; /* next chained ebr record */
2947                    	;  112  
2948                    	;  113  /* Variables
2949                    	;  114   */
2950                    	;  115  int curblkok;  /* if YES curblockno is read into buffer */
2951                    	;  116  int partdsk;   /* partition/disk number, 0 = disk A */
2952                    	;  117  int sdinitok;  /* SD card initialized and ready */
2953                    	;  118  int sdver2;    /* SD card version 2 if YES, version 1 if NO */
2954                    	;  119  unsigned long blkmult;   /* block address multiplier */
2955                    	;  120  unsigned long curblkno;  /* block in buffer if curblkok == YES */
2956                    	;  121  
2957                    	;  122  /* debug bool */
2958                    	;  123  int sdtestflg;
2959                    	;  124  
2960                    	;  125  /* CRC routines from:
2961                    	;  126   * https://github.com/LonelyWolf/stm32/blob/master/stm32l-dosfs/sdcard.c
2962                    	;  127   */
2963                    	;  128  
2964                    	;  129  /*
2965                    	;  130  // Calculate CRC7
2966                    	;  131  // It's a 7 bit CRC with polynomial x^7 + x^3 + 1
2967                    	;  132  // input:
2968                    	;  133  //   crcIn - the CRC before (0 for first step)
2969                    	;  134  //   data - byte for CRC calculation
2970                    	;  135  // return: the new CRC7
2971                    	;  136  */
2972                    	;  137  unsigned char CRC7_one(unsigned char crcIn, unsigned char data)
2973                    	;  138      {
2974                    	;  139      const unsigned char g = 0x89;
2975                    	;  140      unsigned char i;
2976                    	;  141  
2977                    	;  142      crcIn ^= data;
2978                    	;  143      for (i = 0; i < 8; i++)
2979                    	;  144          {
2980                    	;  145          if (crcIn & 0x80) crcIn ^= g;
2981                    	;  146          crcIn <<= 1;
2982                    	;  147          }
2983                    	;  148  
2984                    	;  149      return crcIn;
2985                    	;  150      }
2986                    	;  151  
2987                    	;  152  /*
2988                    	;  153  // Calculate CRC16 CCITT
2989                    	;  154  // It's a 16 bit CRC with polynomial x^16 + x^12 + x^5 + 1
2990                    	;  155  // input:
2991                    	;  156  //   crcIn - the CRC before (0 for rist step)
2992                    	;  157  //   data - byte for CRC calculation
2993                    	;  158  // return: the CRC16 value
2994                    	;  159  */
2995                    	;  160  unsigned int CRC16_one(unsigned int crcIn, unsigned char data)
2996                    	;  161      {
2997                    	;  162      crcIn  = (unsigned char)(crcIn >> 8)|(crcIn << 8);
2998                    	;  163      crcIn ^=  data;
2999                    	;  164      crcIn ^= (unsigned char)(crcIn & 0xff) >> 4;
3000                    	;  165      crcIn ^= (crcIn << 8) << 4;
3001                    	;  166      crcIn ^= ((crcIn & 0xff) << 4) << 1;
3002                    	;  167  
3003                    	;  168      return crcIn;
3004                    	;  169      }
3005                    	;  170  
3006                    	;  171  /* Send command to SD card and recieve answer.
3007                    	;  172   * A command is 5 bytes long and is followed by
3008                    	;  173   * a CRC7 checksum byte.
3009                    	;  174   * Returns a pointer to the response
3010                    	;  175   * or 0 if no response start bit found.
3011                    	;  176   */
3012                    	;  177  unsigned char *sdcommand(unsigned char *sdcmdp,
3013                    	;  178                           unsigned char *recbuf, int recbytes)
3014                    	;  179      {
3015                    	;  180      int searchn;  /* byte counter to search for response */
3016                    	;  181      int sdcbytes; /* byte counter for bytes to send */
3017                    	;  182      unsigned char *retptr; /* pointer used to store response */
3018                    	;  183      unsigned char rbyte;   /* recieved byte */
3019                    	;  184      unsigned char crc = 0; /* calculated CRC7 */
3020                    	;  185  
3021                    	;  186      /* send 8*2 clockpules */
3022                    	;  187      spiio(0xff);
3023                    	;  188      spiio(0xff);
3024                    	;  189      for (sdcbytes = 5; 0 < sdcbytes; sdcbytes--) /* send bytes */
3025                    	;  190          {
3026                    	;  191          crc = CRC7_one(crc, *sdcmdp);
3027                    	;  192          spiio(*sdcmdp++);
3028                    	;  193          }
3029                    	;  194      spiio(crc | 0x01);
3030                    	;  195      /* search for recieved byte with start bit
3031                    	;  196         for a maximum of 10 recieved bytes  */
3032                    	;  197      for (searchn = 10; 0 < searchn; searchn--)
3033                    	;  198          {
3034                    	;  199          rbyte = spiio(0xff);
3035                    	;  200          if ((rbyte & 0x80) == 0)
3036                    	;  201              break;
3037                    	;  202          }
3038                    	;  203      if (searchn == 0) /* no start bit found */
3039                    	;  204          return (NO);
3040                    	;  205      retptr = recbuf;
3041                    	;  206      *retptr++ = rbyte;
3042                    	;  207      for (; 1 < recbytes; recbytes--) /* recieve bytes */
3043                    	;  208          *retptr++ = spiio(0xff);
3044                    	;  209      return (recbuf);
3045                    	;  210      }
3046                    	;  211  
3047                    	;  212  /* Initialise SD card interface
3048                    	;  213   *
3049                    	;  214   * returns YES if ok and NO if not ok
3050                    	;  215   *
3051                    	;  216   * References:
3052                    	;  217   *   https://www.sdcard.org/downloads/pls/
3053                    	;  218   *      Physical Layer Simplified Specification version 8.0
3054                    	;  219   *
3055                    	;  220   * A nice flowchart how to initialize:
3056                    	;  221   *   https://www.totalphase.com/blog/2018/08/set-sdc-mmc-cards-spi-mode-verify-files-successfully-programmed/
3057                    	;  222   *
3058                    	;  223   */
3059                    	;  224  int sdinit()
3060                    	;  225      {
3061                    	;  226      int nbytes;  /* byte counter */
3062                    	;  227      int tries;   /* tries to get to active state or searching for data  */
3063                    	;  228      int wtloop;  /* timer loop when trying to enter active state */
3064                    	;  229      unsigned char cmdbuf[5];   /* buffer to build command in */
3065                    	;  230      unsigned char rstatbuf[5]; /* buffer to recieve status in */
3066                    	;  231      unsigned char *statptr;    /* pointer to returned status from SD command */
3067                    	;  232      unsigned char crc;         /* crc register for CID and CSD */
3068                    	;  233      unsigned char rbyte;       /* recieved byte */
3069                    	;  234      unsigned char *prtptr;     /* for debug printing */
3070                    	;  235  
3071                    	;  236      ledon();
3072                    	;  237      spideselect();
3073                    	;  238      sdinitok = NO;
3074                    	;  239  
3075                    	;  240      /* start to generate 9*8 clock pulses with not selected SD card */
3076                    	;  241      for (nbytes = 9; 0 < nbytes; nbytes--)
3077                    	;  242          spiio(0xff);
3078                    	;  243      if (sdtestflg)
3079                    	;  244          {
3080                    	;  245          printf("\nSent 8*8 (72) clock pulses, select not active\n");
3081                    	;  246          } /* sdtestflg */
3082                    	;  247      spiselect();
3083                    	;  248  
3084                    	;  249      /* CMD0: GO_IDLE_STATE */
3085                    	;  250      for (tries = 0; tries < 10; tries++)
3086                    	;  251          {
3087                    	;  252          memcpy(cmdbuf, cmd0, 5);
3088                    	;  253          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3089                    	;  254          if (sdtestflg)
3090                    	;  255              {
3091                    	;  256              if (!statptr)
3092                    	;  257                  printf("CMD0: no response\n");
3093                    	;  258              else
3094                    	;  259                  printf("CMD0: GO_IDLE_STATE, R1 response [%02x]\n", statptr[0]);
3095                    	;  260              } /* sdtestflg */
3096                    	;  261          if (!statptr)
3097                    	;  262              {
3098                    	;  263              spideselect();
3099                    	;  264              ledoff();
3100                    	;  265              return (NO);
3101                    	;  266              }
3102                    	;  267          if (statptr[0] == 0x01)
3103                    	;  268              break;
3104                    	;  269          for (wtloop = 0; wtloop < tries * 10; wtloop++)
3105                    	;  270              {
3106                    	;  271              /* wait loop, time increasing for each try */
3107                    	;  272              spiio(0xff);
3108                    	;  273              }
3109                    	;  274          }
3110                    	;  275  
3111                    	;  276      /* CMD8: SEND_IF_COND */
3112                    	;  277      memcpy(cmdbuf, cmd8, 5);
3113                    	;  278      statptr = sdcommand(cmdbuf, rstatbuf, R7_LEN);
3114                    	;  279      if (sdtestflg)
3115                    	;  280          {
3116                    	;  281          if (!statptr)
3117                    	;  282              printf("CMD8: no response\n");
3118                    	;  283          else
3119                    	;  284              {
3120                    	;  285              printf("CMD8: SEND_IF_COND, R7 response [%02x %02x %02x %02x %02x], ",
3121                    	;  286                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
3122                    	;  287              if (!(statptr[0] & 0xfe)) /* no error */
3123                    	;  288                  {
3124                    	;  289                  if (statptr[4] == 0xaa)
3125                    	;  290                      printf("echo back ok, ");
3126                    	;  291                  else
3127                    	;  292                      printf("invalid echo back\n");
3128                    	;  293                  }
3129                    	;  294              }
3130                    	;  295          } /* sdtestflg */
3131                    	;  296      if (!statptr || (statptr[0] & 0xfe)) /* if no answer or error */
3132                    	;  297          {
3133                    	;  298          sdver2 = NO;
3134                    	;  299          if (sdtestflg)
3135                    	;  300              {
3136                    	;  301              printf("probably SD ver. 1\n");
3137                    	;  302              } /* sdtestflg */
3138                    	;  303          }
3139                    	;  304      else
3140                    	;  305          {
3141                    	;  306          sdver2 = YES;
3142                    	;  307          if (statptr[4] != 0xaa) /* but invalid echo back */
3143                    	;  308              {
3144                    	;  309              spideselect();
3145                    	;  310              ledoff();
3146                    	;  311              return (NO);
3147                    	;  312              }
3148                    	;  313          if (sdtestflg)
3149                    	;  314              {
3150                    	;  315              printf("SD ver 2\n");
3151                    	;  316              } /* sdtestflg */
3152                    	;  317          }
3153                    	;  318  
3154                    	;  319      /* CMD55: APP_CMD followed by ACMD41: SEND_OP_COND until status is 0x00 */
3155                    	;  320      for (tries = 0; tries < 20; tries++)
3156                    	;  321          {
3157                    	;  322          memcpy(cmdbuf, cmd55, 5);
3158                    	;  323          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3159                    	;  324          if (sdtestflg)
3160                    	;  325              {
3161                    	;  326              if (!statptr)
3162                    	;  327                  printf("CMD55: no response\n");
3163                    	;  328              else
3164                    	;  329                  printf("CMD55: APP_CMD, R1 response [%02x]\n", statptr[0]);
3165                    	;  330              } /* sdtestflg */
3166                    	;  331          if (!statptr)
3167                    	;  332              {
3168                    	;  333              spideselect();
3169                    	;  334              ledoff();
3170                    	;  335              return (NO);
3171                    	;  336              }
3172                    	;  337          memcpy(cmdbuf, acmd41, 5);
3173                    	;  338          if (sdver2)
3174                    	;  339              cmdbuf[1] = 0x40;
3175                    	;  340          else
3176                    	;  341              cmdbuf[1] = 0x00;
3177                    	;  342          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3178                    	;  343          if (sdtestflg)
3179                    	;  344              {
3180                    	;  345              if (!statptr)
3181                    	;  346                  printf("ACMD41: no response\n");
3182                    	;  347              else
3183                    	;  348                  printf("ACMD41: SEND_OP_COND, R1 response [%02x]%s\n",
3184                    	;  349                         statptr[0], (statptr[0] == 0x00) ? " - ready" : "");
3185                    	;  350              } /* sdtestflg */
3186                    	;  351          if (!statptr)
3187                    	;  352              {
3188                    	;  353              spideselect();
3189                    	;  354              ledoff();
3190                    	;  355              return (NO);
3191                    	;  356              }
3192                    	;  357          if (statptr[0] == 0x00) /* now the SD card is ready */
3193                    	;  358              {
3194                    	;  359              break;
3195                    	;  360              }
3196                    	;  361          for (wtloop = 0; wtloop < tries * 10; wtloop++)
3197                    	;  362              {
3198                    	;  363              /* wait loop, time increasing for each try */
3199                    	;  364              spiio(0xff);
3200                    	;  365              }
3201                    	;  366          }
3202                    	;  367  
3203                    	;  368      /* CMD58: READ_OCR */
3204                    	;  369      /* According to the flow chart this should not work
3205                    	;  370         for SD ver. 1 but the response is ok anyway
3206                    	;  371         all tested SD cards  */
3207                    	;  372      memcpy(cmdbuf, cmd58, 5);
3208                    	;  373      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
3209                    	;  374      if (sdtestflg)
3210                    	;  375          {
3211                    	;  376          if (!statptr)
3212                    	;  377              printf("CMD58: no response\n");
3213                    	;  378          else
3214                    	;  379              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
3215                    	;  380                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
3216                    	;  381          } /* sdtestflg */
3217                    	;  382      if (!statptr)
3218                    	;  383          {
3219                    	;  384          spideselect();
3220                    	;  385          ledoff();
3221                    	;  386          return (NO);
3222                    	;  387          }
3223                    	;  388      memcpy(&ocrreg[0], &statptr[1], sizeof (ocrreg));
3224                    	;  389      blkmult = 1; /* assume block address */
3225                    	;  390      if (ocrreg[0] & 0x80)
3226                    	;  391          {
3227                    	;  392          /* SD Ver.2+ */
3228                    	;  393          if (!(ocrreg[0] & 0x40))
3229                    	;  394              {
3230                    	;  395              /* SD Ver.2+, Byte address */
3231                    	;  396              blkmult = 512;
3232                    	;  397              }
3233                    	;  398          }
3234                    	;  399  
3235                    	;  400      /* CMD 16: SET_BLOCKLEN, only if Byte addressing */
3236                    	;  401      if (blkmult == 512)
3237                    	;  402          {
3238                    	;  403          memcpy(cmdbuf, cmd16, 5);
3239                    	;  404          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3240                    	;  405          if (sdtestflg)
3241                    	;  406              {
3242                    	;  407              if (!statptr)
3243                    	;  408                  printf("CMD16: no response\n");
3244                    	;  409              else
3245                    	;  410                  printf("CMD16: SET_BLOCKLEN (to 512 bytes), R1 response [%02x]\n",
3246                    	;  411                         statptr[0]);
3247                    	;  412              } /* sdtestflg */
3248                    	;  413          if (!statptr)
3249                    	;  414              {
3250                    	;  415              spideselect();
3251                    	;  416              ledoff();
3252                    	;  417              return (NO);
3253                    	;  418              }
3254                    	;  419          }
3255                    	;  420      /* Register information:
3256                    	;  421       *   https://www.cameramemoryspeed.com/sd-memory-card-faq/reading-sd-card-cid-serial-psn-internal-numbers/
3257                    	;  422       */
3258                    	;  423  
3259                    	;  424      /* CMD10: SEND_CID */
3260                    	;  425      memcpy(cmdbuf, cmd10, 5);
3261                    	;  426      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3262                    	;  427      if (sdtestflg)
3263                    	;  428          {
3264                    	;  429          if (!statptr)
3265                    	;  430              printf("CMD10: no response\n");
3266                    	;  431          else
3267                    	;  432              printf("CMD10: SEND_CID, R1 response [%02x]\n", statptr[0]);
3268                    	;  433          } /* sdtestflg */
3269                    	;  434      if (!statptr)
3270                    	;  435          {
3271                    	;  436          spideselect();
3272                    	;  437          ledoff();
3273                    	;  438          return (NO);
3274                    	;  439          }
3275                    	;  440      /* looking for 0xfe that is the byte before data */
3276                    	;  441      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
3277                    	;  442          ;
3278                    	;  443      if (tries == 0) /* tried too many times */
3279                    	;  444          {
3280                    	;  445          if (sdtestflg)
3281                    	;  446              {
3282                    	;  447              printf("  No data found\n");
3283                    	;  448              } /* sdtestflg */
3284                    	;  449          spideselect();
3285                    	;  450          ledoff();
3286                    	;  451          return (NO);
3287                    	;  452          }
3288                    	;  453      else
3289                    	;  454          {
3290                    	;  455          crc = 0;
3291                    	;  456          for (nbytes = 0; nbytes < 15; nbytes++)
3292                    	;  457              {
3293                    	;  458              rbyte = spiio(0xff);
3294                    	;  459              cidreg[nbytes] = rbyte;
3295                    	;  460              crc = CRC7_one(crc, rbyte);
3296                    	;  461              }
3297                    	;  462          cidreg[15] = spiio(0xff);
3298                    	;  463          crc |= 0x01;
3299                    	;  464          /* some SD cards need additional clock pulses */
3300                    	;  465          for (nbytes = 9; 0 < nbytes; nbytes--)
3301                    	;  466              spiio(0xff);
3302                    	;  467          if (sdtestflg)
3303                    	;  468              {
3304                    	;  469              prtptr = &cidreg[0];
3305                    	;  470              printf("  CID: [");
3306                    	;  471              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
3307                    	;  472                  printf("%02x ", *prtptr);
3308                    	;  473              prtptr = &cidreg[0];
3309                    	;  474              printf("\b] |");
3310                    	;  475              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
3311                    	;  476                  {
3312                    	;  477                  if ((' ' <= *prtptr) && (*prtptr < 127))
3313                    	;  478                      putchar(*prtptr);
3314                    	;  479                  else
3315                    	;  480                      putchar('.');
3316                    	;  481                  }
3317                    	;  482              printf("|\n");
3318                    	;  483              if (crc == cidreg[15])
3319                    	;  484                  {
3320                    	;  485                  printf("CRC7 ok: [%02x]\n", crc);
3321                    	;  486                  }
3322                    	;  487              else
3323                    	;  488                  {
3324                    	;  489                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
3325                    	;  490                         crc, cidreg[15]);
3326                    	;  491                  /* could maybe return failure here */
3327                    	;  492                  }
3328                    	;  493              } /* sdtestflg */
3329                    	;  494          }
3330                    	;  495  
3331                    	;  496      /* CMD9: SEND_CSD */
3332                    	;  497      memcpy(cmdbuf, cmd9, 5);
3333                    	;  498      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3334                    	;  499      if (sdtestflg)
3335                    	;  500          {
3336                    	;  501          if (!statptr)
3337                    	;  502              printf("CMD9: no response\n");
3338                    	;  503          else
3339                    	;  504              printf("CMD9: SEND_CSD, R1 response [%02x]\n", statptr[0]);
3340                    	;  505          } /* sdtestflg */
3341                    	;  506      if (!statptr)
3342                    	;  507          {
3343                    	;  508          spideselect();
3344                    	;  509          ledoff();
3345                    	;  510          return (NO);
3346                    	;  511          }
3347                    	;  512      /* looking for 0xfe that is the byte before data */
3348                    	;  513      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
3349                    	;  514          ;
3350                    	;  515      if (tries == 0) /* tried too many times */
3351                    	;  516          {
3352                    	;  517          if (sdtestflg)
3353                    	;  518              {
3354                    	;  519              printf("  No data found\n");
3355                    	;  520              } /* sdtestflg */
3356                    	;  521          return (NO);
3357                    	;  522          }
3358                    	;  523      else
3359                    	;  524          {
3360                    	;  525          crc = 0;
3361                    	;  526          for (nbytes = 0; nbytes < 15; nbytes++)
3362                    	;  527              {
3363                    	;  528              rbyte = spiio(0xff);
3364                    	;  529              csdreg[nbytes] = rbyte;
3365                    	;  530              crc = CRC7_one(crc, rbyte);
3366                    	;  531              }
3367                    	;  532          csdreg[15] = spiio(0xff);
3368                    	;  533          crc |= 0x01;
3369                    	;  534          /* some SD cards need additional clock pulses */
3370                    	;  535          for (nbytes = 9; 0 < nbytes; nbytes--)
3371                    	;  536              spiio(0xff);
3372                    	;  537          if (sdtestflg)
3373                    	;  538              {
3374                    	;  539              prtptr = &csdreg[0];
3375                    	;  540              printf("  CSD: [");
3376                    	;  541              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
3377                    	;  542                  printf("%02x ", *prtptr);
3378                    	;  543              prtptr = &csdreg[0];
3379                    	;  544              printf("\b] |");
3380                    	;  545              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
3381                    	;  546                  {
3382                    	;  547                  if ((' ' <= *prtptr) && (*prtptr < 127))
3383                    	;  548                      putchar(*prtptr);
3384                    	;  549                  else
3385                    	;  550                      putchar('.');
3386                    	;  551                  }
3387                    	;  552              printf("|\n");
3388                    	;  553              if (crc == csdreg[15])
3389                    	;  554                  {
3390                    	;  555                  printf("CRC7 ok: [%02x]\n", crc);
3391                    	;  556                  }
3392                    	;  557              else
3393                    	;  558                  {
3394                    	;  559                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
3395                    	;  560                         crc, csdreg[15]);
3396                    	;  561                  /* could maybe return failure here */
3397                    	;  562                  }
3398                    	;  563              } /* sdtestflg */
3399                    	;  564          }
3400                    	;  565  
3401                    	;  566      for (nbytes = 9; 0 < nbytes; nbytes--)
3402                    	;  567          spiio(0xff);
3403                    	;  568      if (sdtestflg)
3404                    	;  569          {
3405                    	;  570          printf("Sent 9*8 (72) clock pulses, select active\n");
3406                    	;  571          } /* sdtestflg */
3407                    	;  572  
3408                    	;  573      sdinitok = YES;
3409                    	;  574  
3410                    	;  575      spideselect();
3411                    	;  576      ledoff();
3412                    	;  577  
3413                    	;  578      return (YES);
3414                    	;  579      }
3415                    	;  580  
3416                    	;  581  int sdprobe()
3417                    	;  582      {
3418                    	;  583      unsigned char cmdbuf[5];   /* buffer to build command in */
3419                    	;  584      unsigned char rstatbuf[5]; /* buffer to recieve status in */
3420                    	;  585      unsigned char *statptr;    /* pointer to returned status from SD command */
3421                    	;  586      int nbytes;  /* byte counter */
3422                    	;  587      int allzero = YES;
3423                    	;  588  
3424                    	;  589      ledon();
3425                    	;  590      spiselect();
3426                    	;  591  
3427                    	;  592      /* CMD58: READ_OCR */
3428                    	;  593      memcpy(cmdbuf, cmd58, 5);
3429                    	;  594      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
3430                    	;  595      for (nbytes = 0; nbytes < 5; nbytes++)
3431                    	;  596          {
3432                    	;  597          if (statptr[nbytes] != 0)
3433                    	;  598              allzero = NO;
3434                    	;  599          }
3435                    	;  600      if (sdtestflg)
3436                    	;  601          {
3437                    	;  602          if (!statptr)
3438                    	;  603              printf("CMD58: no response\n");
3439                    	;  604          else
3440                    	;  605              {
3441                    	;  606              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
3442                    	;  607                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
3443                    	;  608              if (allzero)
3444                    	;  609                  printf("SD card not inserted or not initialized\n");
3445                    	;  610              }
3446                    	;  611          } /* sdtestflg */
3447                    	;  612      if (!statptr || allzero)
3448                    	;  613          {
3449                    	;  614          sdinitok = NO;
3450                    	;  615          spideselect();
3451                    	;  616          ledoff();
3452                    	;  617          return (NO);
3453                    	;  618          }
3454                    	;  619  
3455                    	;  620      spideselect();
3456                    	;  621      ledoff();
3457                    	;  622  
3458                    	;  623      return (YES);
3459                    	;  624      }
3460                    	;  625  
3461                    	;  626  /* print OCR, CID and CSD registers*/
3462                    	;  627  void sdprtreg()
3463                    	;  628      {
3464                    	;  629      unsigned int n;
3465                    	;  630      unsigned int csize;
3466                    	;  631      unsigned long devsize;
3467                    	;  632      unsigned long capacity;
3468                    	;  633  
3469                    	;  634      if (!sdinitok)
3470                    	;  635          {
3471                    	;  636          printf("SD card not initialized\n");
3472                    	;  637          return;
3473                    	;  638          }
3474                    	;  639      printf("SD card information:");
3475                    	;  640      if (ocrreg[0] & 0x80)
3476                    	;  641          {
3477                    	;  642          if (ocrreg[0] & 0x40)
3478                    	;  643              printf("  SD card ver. 2+, Block address\n");
3479                    	;  644          else
3480                    	;  645              {
3481                    	;  646              if (sdver2)
3482                    	;  647                  printf("  SD card ver. 2+, Byte address\n");
3483                    	;  648              else
3484                    	;  649                  printf("  SD card ver. 1, Byte address\n");
3485                    	;  650              }
3486                    	;  651          }
3487                    	;  652      printf("  Manufacturer ID: 0x%02x, ", cidreg[0]);
3488                    	;  653      printf("OEM ID: %.2s, ", &cidreg[1]);
3489                    	;  654      printf("Product name: %.5s\n", &cidreg[3]);
3490                    	;  655      printf("  Product revision: %d.%d, ",
3491                    	;  656             (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
3492                    	;  657      printf("Serial number: %lu\n",
3493                    	;  658             (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
3494                    	;  659      printf("  Manufacturing date: %d-%d, ",
3495                    	;  660             2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
3496                    	;  661      if ((csdreg[0] & 0xc0) == 0x00) /* CSD version 1 */
3497                    	;  662          {
3498                    	;  663          n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
3499                    	;  664          csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
3500                    	;  665                  ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
3501                    	;  666          capacity = (unsigned long) csize << (n-10);
3502                    	;  667          printf("Device capacity: %lu MByte\n", capacity >> 10);
3503                    	;  668          }
3504                    	;  669      if ((csdreg[0] & 0xc0) == 0x40) /* CSD version 2 */
3505                    	;  670          {
3506                    	;  671          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
3507                    	;  672                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
3508                    	;  673          capacity = devsize << 9;
3509                    	;  674          printf("Device capacity: %lu MByte\n", capacity >> 10);
3510                    	;  675          }
3511                    	;  676      if ((csdreg[0] & 0xc0) == 0x80) /* CSD version 3 */
3512                    	;  677          {
3513                    	;  678          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
3514                    	;  679                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
3515                    	;  680          capacity = devsize << 9;
3516                    	;  681          printf("Device ultra capacity: %lu MByte\n", capacity >> 10);
3517                    	;  682          }
3518                    	;  683  
3519                    	;  684      if (sdtestflg)
3520                    	;  685          {
3521                    	;  686  
3522                    	;  687          printf("--------------------------------------\n");
3523                    	;  688          printf("OCR register:\n");
3524                    	;  689          if (ocrreg[2] & 0x80)
3525                    	;  690              printf("2.7-2.8V (bit 15) ");
3526                    	;  691          if (ocrreg[1] & 0x01)
3527                    	;  692              printf("2.8-2.9V (bit 16) ");
3528                    	;  693          if (ocrreg[1] & 0x02)
3529                    	;  694              printf("2.9-3.0V (bit 17) ");
3530                    	;  695          if (ocrreg[1] & 0x04)
3531                    	;  696              printf("3.0-3.1V (bit 18) \n");
3532                    	;  697          if (ocrreg[1] & 0x08)
3533                    	;  698              printf("3.1-3.2V (bit 19) ");
3534                    	;  699          if (ocrreg[1] & 0x10)
3535                    	;  700              printf("3.2-3.3V (bit 20) ");
3536                    	;  701          if (ocrreg[1] & 0x20)
3537                    	;  702              printf("3.3-3.4V (bit 21) ");
3538                    	;  703          if (ocrreg[1] & 0x40)
3539                    	;  704              printf("3.4-3.5V (bit 22) \n");
3540                    	;  705          if (ocrreg[1] & 0x80)
3541                    	;  706              printf("3.5-3.6V (bit 23) \n");
3542                    	;  707          if (ocrreg[0] & 0x01)
3543                    	;  708              printf("Switching to 1.8V Accepted (S18A) (bit 24) set ");
3544                    	;  709          if (ocrreg[0] & 0x08)
3545                    	;  710              printf("Over 2TB support Status (CO2T) (bit 27) set\n");
3546                    	;  711          if (ocrreg[0] & 0x20)
3547                    	;  712              printf("UHS-II Card Status (bit 29) set ");
3548                    	;  713          if (ocrreg[0] & 0x80)
3549                    	;  714              {
3550                    	;  715              if (ocrreg[0] & 0x40)
3551                    	;  716                  {
3552                    	;  717                  printf("Card Capacity Status (CCS) (bit 30) set\n");
3553                    	;  718                  printf("  SD Ver.2+, Block address");
3554                    	;  719                  }
3555                    	;  720              else
3556                    	;  721                  {
3557                    	;  722                  printf("Card Capacity Status (CCS) (bit 30) not set\n");
3558                    	;  723                  if (sdver2)
3559                    	;  724                      printf("  SD Ver.2+, Byte address");
3560                    	;  725                  else
3561                    	;  726                      printf("  SD Ver.1, Byte address");
3562                    	;  727                  }
3563                    	;  728              printf("\nCard power up status bit (busy) (bit 31) set\n");
3564                    	;  729              }
3565                    	;  730          else
3566                    	;  731              {
3567                    	;  732              printf("\nCard power up status bit (busy) (bit 31) not set.\n");
3568                    	;  733              printf("  This bit is not set if the card has not finished the power up routine.\n");
3569                    	;  734              }
3570                    	;  735          printf("--------------------------------------\n");
3571                    	;  736          printf("CID register:\n");
3572                    	;  737          printf("MID: 0x%02x, ", cidreg[0]);
3573                    	;  738          printf("OID: %.2s, ", &cidreg[1]);
3574                    	;  739          printf("PNM: %.5s, ", &cidreg[3]);
3575                    	;  740          printf("PRV: %d.%d, ",
3576                    	;  741                 (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
3577                    	;  742          printf("PSN: %lu, ",
3578                    	;  743                 (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
3579                    	;  744          printf("MDT: %d-%d\n",
3580                    	;  745                 2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
3581                    	;  746          printf("--------------------------------------\n");
3582                    	;  747          printf("CSD register:\n");
3583                    	;  748          if ((csdreg[0] & 0xc0) == 0x00)
3584                    	;  749              {
3585                    	;  750              printf("CSD Version 1.0, Standard Capacity\n");
3586                    	;  751              n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
3587                    	;  752              csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
3588                    	;  753                      ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
3589                    	;  754              capacity = (unsigned long) csize << (n-10);
3590                    	;  755              printf(" Device capacity: %lu KByte, %lu MByte\n",
3591                    	;  756                     capacity, capacity >> 10);
3592                    	;  757              }
3593                    	;  758          if ((csdreg[0] & 0xc0) == 0x40)
3594                    	;  759              {
3595                    	;  760              printf("CSD Version 2.0, High Capacity and Extended Capacity\n");
3596                    	;  761              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
3597                    	;  762                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
3598                    	;  763              capacity = devsize << 9;
3599                    	;  764              printf(" Device capacity: %lu KByte, %lu MByte\n",
3600                    	;  765                     capacity, capacity >> 10);
3601                    	;  766              }
3602                    	;  767          if ((csdreg[0] & 0xc0) == 0x80)
3603                    	;  768              {
3604                    	;  769              printf("CSD Version 3.0, Ultra Capacity (SDUC)\n");
3605                    	;  770              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
3606                    	;  771                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
3607                    	;  772              capacity = devsize << 9;
3608                    	;  773              printf(" Device capacity: %lu KByte, %lu MByte\n",
3609                    	;  774                     capacity, capacity >> 10);
3610                    	;  775              }
3611                    	;  776          printf("--------------------------------------\n");
3612                    	;  777  
3613                    	;  778          } /* sdtestflg */ /* SDTEST */
3614                    	;  779  
3615                    	;  780      }
3616                    	;  781  
3617                    	;  782  /* Read data block of 512 bytes to buffer
3618                    	;  783   * Returns YES if ok or NO if error
3619                    	;  784   */
3620                    	;  785  int sdread(unsigned char *rdbuf, unsigned long rdblkno)
3621                    	;  786      {
3622                    	;  787      unsigned char *statptr;
3623                    	;  788      unsigned char rbyte;
3624                    	;  789      unsigned char cmdbuf[5];   /* buffer to build command in */
3625                    	;  790      unsigned char rstatbuf[5]; /* buffer to recieve status in */
3626                    	;  791      int nbytes;
3627                    	;  792      int tries;
3628                    	;  793      unsigned long blktoread;
3629                    	;  794      unsigned int rxcrc16;
3630                    	;  795      unsigned int calcrc16;
3631                    	;  796  
3632                    	;  797      ledon();
3633                    	;  798      spiselect();
3634                    	;  799  
3635                    	;  800      if (!sdinitok)
3636                    	;  801          {
3637                    	;  802          if (sdtestflg)
3638                    	;  803              {
3639                    	;  804              printf("SD card not initialized\n");
3640                    	;  805              } /* sdtestflg */
3641                    	;  806          spideselect();
3642                    	;  807          ledoff();
3643                    	;  808          return (NO);
3644                    	;  809          }
3645                    	;  810  
3646                    	;  811      /* CMD17: READ_SINGLE_BLOCK */
3647                    	;  812      /* Insert block # into command */
3648                    	;  813      memcpy(cmdbuf, cmd17, 5);
3649                    	;  814      blktoread = blkmult * rdblkno;
3650                    	;  815      cmdbuf[4] = blktoread & 0xff;
3651                    	;  816      blktoread = blktoread >> 8;
3652                    	;  817      cmdbuf[3] = blktoread & 0xff;
3653                    	;  818      blktoread = blktoread >> 8;
3654                    	;  819      cmdbuf[2] = blktoread & 0xff;
3655                    	;  820      blktoread = blktoread >> 8;
3656                    	;  821      cmdbuf[1] = blktoread & 0xff;
3657                    	;  822  
3658                    	;  823      if (sdtestflg)
3659                    	;  824          {
3660                    	;  825          printf("\nCMD17: READ_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
3661                    	;  826                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
3662                    	;  827          } /* sdtestflg */
3663                    	;  828      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3664                    	;  829      if (sdtestflg)
3665                    	;  830          {
3666                    	;  831          printf("CMD17 R1 response [%02x]\n", statptr[0]);
3667                    	;  832          } /* sdtestflg */
3668                    	;  833      if (statptr[0])
3669                    	;  834          {
3670                    	;  835          if (sdtestflg)
3671                    	;  836              {
3672                    	;  837              printf("  could not read block\n");
3673                    	;  838              } /* sdtestflg */
3674                    	;  839          spideselect();
3675                    	;  840          ledoff();
3676                    	;  841          return (NO);
3677                    	;  842          }
3678                    	;  843      /* looking for 0xfe that is the byte before data */
3679                    	;  844      for (tries = 80; (0 < tries) && ((rbyte = spiio(0xff)) != 0xfe); tries--)
3680                    	;  845          {
3681                    	;  846          if ((rbyte & 0xe0) == 0x00)
3682                    	;  847              {
3683                    	;  848              /* If a read operation fails and the card cannot provide
3684                    	;  849                 the required data, it will send a data error token instead
3685                    	;  850               */
3686                    	;  851              if (sdtestflg)
3687                    	;  852                  {
3688                    	;  853                  printf("  read error: [%02x]\n", rbyte);
3689                    	;  854                  } /* sdtestflg */
3690                    	;  855              spideselect();
3691                    	;  856              ledoff();
3692                    	;  857              return (NO);
3693                    	;  858              }
3694                    	;  859          }
3695                    	;  860      if (tries == 0) /* tried too many times */
3696                    	;  861          {
3697                    	;  862          if (sdtestflg)
3698                    	;  863              {
3699                    	;  864              printf("  no data found\n");
3700                    	;  865              } /* sdtestflg */
3701                    	;  866          spideselect();
3702                    	;  867          ledoff();
3703                    	;  868          return (NO);
3704                    	;  869          }
3705                    	;  870      else
3706                    	;  871          {
3707                    	;  872          calcrc16 = 0;
3708                    	;  873          for (nbytes = 0; nbytes < 512; nbytes++)
3709                    	;  874              {
3710                    	;  875              rbyte = spiio(0xff);
3711                    	;  876              calcrc16 = CRC16_one(calcrc16, rbyte);
3712                    	;  877              rdbuf[nbytes] = rbyte;
3713                    	;  878              }
3714                    	;  879          rxcrc16 = spiio(0xff) << 8;
3715                    	;  880          rxcrc16 += spiio(0xff);
3716                    	;  881  
3717                    	;  882          if (sdtestflg)
3718                    	;  883              {
3719                    	;  884              printf("  read data block %ld:\n", rdblkno);
3720                    	;  885              } /* sdtestflg */
3721                    	;  886          if (rxcrc16 != calcrc16)
3722                    	;  887              {
3723                    	;  888              if (sdtestflg)
3724                    	;  889                  {
3725                    	;  890                  printf("  CRC16 error, recieved: 0x%04x, calc: 0x%04hi\n",
3726                    	;  891                         rxcrc16, calcrc16);
3727                    	;  892                  } /* sdtestflg */
3728                    	;  893              spideselect();
3729                    	;  894              ledoff();
3730                    	;  895              return (NO);
3731                    	;  896              }
3732                    	;  897          }
3733                    	;  898      spideselect();
3734                    	;  899      ledoff();
3735                    	;  900      return (YES);
3736                    	;  901      }
3737                    	;  902  
3738                    	;  903  /* Write data block of 512 bytes from buffer
3739                    	;  904   * Returns YES if ok or NO if error
3740                    	;  905   */
3741                    	;  906  int sdwrite(unsigned char *wrbuf, unsigned long wrblkno)
3742                    	;  907      {
3743                    	;  908      unsigned char *statptr;
3744                    	;  909      unsigned char rbyte;
3745                    	;  910      unsigned char tbyte;
3746                    	;  911      unsigned char cmdbuf[5];   /* buffer to build command in */
3747                    	;  912      unsigned char rstatbuf[5]; /* buffer to recieve status in */
3748                    	;  913      int nbytes;
3749                    	;  914      int tries;
3750                    	;  915      unsigned long blktowrite;
3751                    	;  916      unsigned int calcrc16;
3752                    	;  917  
3753                    	;  918      ledon();
3754                    	;  919      spiselect();
3755                    	;  920  
3756                    	;  921      if (!sdinitok)
3757                    	;  922          {
3758                    	;  923          if (sdtestflg)
3759                    	;  924              {
3760                    	;  925              printf("SD card not initialized\n");
3761                    	;  926              } /* sdtestflg */
3762                    	;  927          spideselect();
3763                    	;  928          ledoff();
3764                    	;  929          return (NO);
3765                    	;  930          }
3766                    	;  931  
3767                    	;  932      if (sdtestflg)
3768                    	;  933          {
3769                    	;  934          printf("  write data block %ld:\n", wrblkno);
3770                    	;  935          } /* sdtestflg */
3771                    	;  936      /* CMD24: WRITE_SINGLE_BLOCK */
3772                    	;  937      /* Insert block # into command */
3773                    	;  938      memcpy(cmdbuf, cmd24, 5);
3774                    	;  939      blktowrite = blkmult * wrblkno;
3775                    	;  940      cmdbuf[4] = blktowrite & 0xff;
3776                    	;  941      blktowrite = blktowrite >> 8;
3777                    	;  942      cmdbuf[3] = blktowrite & 0xff;
3778                    	;  943      blktowrite = blktowrite >> 8;
3779                    	;  944      cmdbuf[2] = blktowrite & 0xff;
3780                    	;  945      blktowrite = blktowrite >> 8;
3781                    	;  946      cmdbuf[1] = blktowrite & 0xff;
3782                    	;  947  
3783                    	;  948      if (sdtestflg)
3784                    	;  949          {
3785                    	;  950          printf("\nCMD24: WRITE_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
3786                    	;  951                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
3787                    	;  952          } /* sdtestflg */
3788                    	;  953      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3789                    	;  954      if (sdtestflg)
3790                    	;  955          {
3791                    	;  956          printf("CMD24 R1 response [%02x]\n", statptr[0]);
3792                    	;  957          } /* sdtestflg */
3793                    	;  958      if (statptr[0])
3794                    	;  959          {
3795                    	;  960          if (sdtestflg)
3796                    	;  961              {
3797                    	;  962              printf("  could not write block\n");
3798                    	;  963              } /* sdtestflg */
3799                    	;  964          spideselect();
3800                    	;  965          ledoff();
3801                    	;  966          return (NO);
3802                    	;  967          }
3803                    	;  968      /* send 0xfe, the byte before data */
3804                    	;  969      spiio(0xfe);
3805                    	;  970      /* initialize crc and send block */
3806                    	;  971      calcrc16 = 0;
3807                    	;  972      for (nbytes = 0; nbytes < 512; nbytes++)
3808                    	;  973          {
3809                    	;  974          tbyte = wrbuf[nbytes];
3810                    	;  975          spiio(tbyte);
3811                    	;  976          calcrc16 = CRC16_one(calcrc16, tbyte);
3812                    	;  977          }
3813                    	;  978      spiio((calcrc16 >> 8) & 0xff);
3814                    	;  979      spiio(calcrc16 & 0xff);
3815                    	;  980  
3816                    	;  981      /* check data resposnse */
3817                    	;  982      for (tries = 20;
3818                    	;  983              0 < tries && (((rbyte = spiio(0xff)) & 0x11) != 0x01);
3819                    	;  984              tries--)
3820                    	;  985          ;
3821                    	;  986      if (tries == 0)
3822                    	;  987          {
3823                    	;  988          if (sdtestflg)
3824                    	;  989              {
3825                    	;  990              printf("No data response\n");
3826                    	;  991              } /* sdtestflg */
3827                    	;  992          spideselect();
3828                    	;  993          ledoff();
3829                    	;  994          return (NO);
3830                    	;  995          }
3831                    	;  996      else
3832                    	;  997          {
3833                    	;  998          if (sdtestflg)
3834                    	;  999              {
3835                    	; 1000              printf("Data response [%02x]", 0x1f & rbyte);
3836                    	; 1001              } /* sdtestflg */
3837                    	; 1002          if ((0x1f & rbyte) == 0x05)
3838                    	; 1003              {
3839                    	; 1004              if (sdtestflg)
3840                    	; 1005                  {
3841                    	; 1006                  printf(", data accepted\n");
3842                    	; 1007                  } /* sdtestflg */
3843                    	; 1008              for (nbytes = 9; 0 < nbytes; nbytes--)
3844                    	; 1009                  spiio(0xff);
3845                    	; 1010              if (sdtestflg)
3846                    	; 1011                  {
3847                    	; 1012                  printf("Sent 9*8 (72) clock pulses, select active\n");
3848                    	; 1013                  } /* sdtestflg */
3849                    	; 1014              spideselect();
3850                    	; 1015              ledoff();
3851                    	; 1016              return (YES);
3852                    	; 1017              }
3853                    	; 1018          else
3854                    	; 1019              {
3855                    	; 1020              if (sdtestflg)
3856                    	; 1021                  {
3857                    	; 1022                  printf(", data not accepted\n");
3858                    	; 1023                  } /* sdtestflg */
3859                    	; 1024              spideselect();
3860                    	; 1025              ledoff();
3861                    	; 1026              return (NO);
3862                    	; 1027              }
3863                    	; 1028          }
3864                    	; 1029      }
3865                    	; 1030  
3866                    	; 1031  /* Print data in 512 byte buffer */
3867                    	; 1032  void sddatprt(unsigned char *prtbuf)
3868                    	; 1033      {
3869                    	; 1034      /* Variables used for "pretty-print" */
3870                    	; 1035      int allzero, dmpline, dotprted, lastallz, nbytes;
3871                    	; 1036      unsigned char *prtptr;
3872                    	; 1037  
3873                    	; 1038      prtptr = prtbuf;
3874                    	; 1039      dotprted = NO;
3875                    	; 1040      lastallz = NO;
3876                    	; 1041      for (dmpline = 0; dmpline < 32; dmpline++)
3877                    	; 1042          {
3878                    	; 1043          /* test if all 16 bytes are 0x00 */
3879                    	; 1044          allzero = YES;
3880                    	; 1045          for (nbytes = 0; nbytes < 16; nbytes++)
3881                    	; 1046              {
3882                    	; 1047              if (prtptr[nbytes] != 0)
3883                    	; 1048                  allzero = NO;
3884                    	; 1049              }
3885                    	; 1050          if (lastallz && allzero)
3886                    	; 1051              {
3887                    	; 1052              if (!dotprted)
3888                    	; 1053                  {
3889                    	; 1054                  printf("*\n");
3890                    	; 1055                  dotprted = YES;
3891                    	; 1056                  }
3892                    	; 1057              }
3893                    	; 1058          else
3894                    	; 1059              {
3895                    	; 1060              dotprted = NO;
3896                    	; 1061              /* print offset */
3897                    	; 1062              printf("%04x ", dmpline * 16);
3898                    	; 1063              /* print 16 bytes in hex */
3899                    	; 1064              for (nbytes = 0; nbytes < 16; nbytes++)
3900                    	; 1065                  printf("%02x ", prtptr[nbytes]);
3901                    	; 1066              /* print these bytes in ASCII if printable */
3902                    	; 1067              printf(" |");
3903                    	; 1068              for (nbytes = 0; nbytes < 16; nbytes++)
3904                    	; 1069                  {
3905                    	; 1070                  if ((' ' <= prtptr[nbytes]) && (prtptr[nbytes] < 127))
3906                    	; 1071                      putchar(prtptr[nbytes]);
3907                    	; 1072                  else
3908                    	; 1073                      putchar('.');
3909                    	; 1074                  }
3910                    	; 1075              printf("|\n");
3911                    	; 1076              }
3912                    	; 1077          prtptr += 16;
3913                    	; 1078          lastallz = allzero;
3914                    	; 1079          }
3915                    	; 1080      }
3916                    	; 1081  
3917                    	; 1082  /* Print GUID (mixed endian format)
3918                    	; 1083   */
3919                    	; 1084  void prtguid(unsigned char *guidptr)
3920                    	; 1085      {
3921                    	; 1086      int index;
3922                    	; 1087  
3923                    	; 1088      printf("%02x%02x%02x%02x-", guidptr[3], guidptr[2], guidptr[1], guidptr[0]);
3924                    	; 1089      printf("%02x%02x-", guidptr[5], guidptr[4]);
3925                    	; 1090      printf("%02x%02x-", guidptr[7], guidptr[6]);
3926                    	; 1091      printf("%02x%02x-", guidptr[8], guidptr[9]);
3927                    	; 1092      printf("%02x%02x%02x%02x%02x%02x",
3928                    	; 1093             guidptr[10], guidptr[11], guidptr[12], guidptr[13], guidptr[14], guidptr[15]);
3929                    	; 1094      }
3930                    	; 1095  
3931                    	; 1096  /* Analyze and print GPT entry
3932                    	; 1097   */
3933                    	; 1098  int prtgptent(unsigned int entryno)
3934                    	; 1099      {
3935                    	; 1100      int index;
3936                    	; 1101      int entryidx;
3937                    	; 1102      int hasname;
3938                    	; 1103      unsigned int block;
3939                    	; 1104      unsigned char *rxdata;
3940                    	; 1105      unsigned char *entryptr;
3941                    	; 1106      unsigned char tstzero = 0;
3942                    	; 1107      unsigned long flba;
3943                    	; 1108      unsigned long llba;
3944                    	; 1109  
3945                    	; 1110      block = 2 + (entryno / 4);
3946                    	; 1111      if ((curblkno != block) || !curblkok)
3947                    	; 1112          {
3948                    	; 1113          if (!sdread(sdrdbuf, block))
3949                    	; 1114              {
3950                    	; 1115              if (sdtestflg)
3951                    	; 1116                  {
3952                    	; 1117                  printf("Can't read GPT entry block\n");
3953                    	; 1118                  return (NO);
3954                    	; 1119                  } /* sdtestflg */
3955                    	; 1120              }
3956                    	; 1121          curblkno = block;
3957                    	; 1122          curblkok = YES;
3958                    	; 1123          }
3959                    	; 1124      rxdata = sdrdbuf;
3960                    	; 1125      entryptr = rxdata + (128 * (entryno % 4));
3961                    	; 1126      for (index = 0; index < 16; index++)
3962                    	; 1127          tstzero |= entryptr[index];
3963                    	; 1128      if (sdtestflg)
3964                    	; 1129          {
3965                    	; 1130          printf("GPT partition entry %d:", entryno + 1);
3966                    	; 1131          } /* sdtestflg */
3967                    	; 1132      if (!tstzero)
3968                    	; 1133          {
3969                    	; 1134          if (sdtestflg)
3970                    	; 1135              {
3971                    	; 1136              printf(" Not used entry\n");
3972                    	; 1137              } /* sdtestflg */
3973                    	; 1138          return (NO);
3974                    	; 1139          }
3975                    	; 1140      if (sdtestflg)
3976                    	; 1141          {
3977                    	; 1142          printf("\n  Partition type GUID: ");
3978                    	; 1143          prtguid(entryptr);
3979                    	; 1144          printf("\n  [");
3980                    	; 1145          for (index = 0; index < 16; index++)
3981                    	; 1146              printf("%02x ", entryptr[index]);
3982                    	; 1147          printf("\b]");
3983                    	; 1148          printf("\n  Unique partition GUID: ");
3984                    	; 1149          prtguid(entryptr + 16);
3985                    	; 1150          printf("\n  [");
3986                    	; 1151          for (index = 0; index < 16; index++)
3987                    	; 1152              printf("%02x ", (entryptr + 16)[index]);
3988                    	; 1153          printf("\b]");
3989                    	; 1154          printf("\n  First LBA: ");
3990                    	; 1155          /* lower 32 bits of LBA should be sufficient (I hope) */
3991                    	; 1156          } /* sdtestflg */
3992                    	; 1157      flba = (unsigned long)entryptr[32] + ((unsigned long)entryptr[33] << 8) +
3993                    	; 1158             ((unsigned long)entryptr[34] << 16) + ((unsigned long)entryptr[35] << 24);
3994                    	; 1159      if (sdtestflg)
3995                    	; 1160          {
3996                    	; 1161          printf("%lu", flba);
3997                    	; 1162          printf(" [");
3998                    	; 1163          for (index = 32; index < (32 + 8); index++)
3999                    	; 1164              printf("%02x ", entryptr[index]);
4000                    	; 1165          printf("\b]");
4001                    	; 1166          printf("\n  Last LBA: ");
4002                    	; 1167          } /* sdtestflg */
4003                    	; 1168      /* lower 32 bits of LBA should be sufficient (I hope) */
4004                    	; 1169      llba = (unsigned long)entryptr[40] + ((unsigned long)entryptr[41] << 8) +
4005                    	; 1170             ((unsigned long)entryptr[42] << 16) + ((unsigned long)entryptr[43] << 24);
4006                    	; 1171  
4007                    	; 1172      if (entryptr[48] & 0x04)
4008                    	; 1173          dskmap[partdsk].bootable = YES;
4009                    	; 1174      dskmap[partdsk].partype = PARTGPT;
4010                    	; 1175      dskmap[partdsk].dskletter = 'A' + partdsk;
4011                    	; 1176      dskmap[partdsk].dskstart = flba;
4012                    	; 1177      dskmap[partdsk].dskend = llba;
4013                    	; 1178      dskmap[partdsk].dsksize = llba - flba + 1;
4014                    	; 1179      memcpy(dskmap[partdsk].dsktype, entryptr, 16);
4015                    	; 1180      partdsk++;
4016                    	; 1181  
4017                    	; 1182      if (sdtestflg)
4018                    	; 1183          {
4019                    	; 1184          printf("%lu, size %lu MByte", llba, (llba - flba) >> 11);
4020                    	; 1185          printf(" [");
4021                    	; 1186          for (index = 40; index < (40 + 8); index++)
4022                    	; 1187              printf("%02x ", entryptr[index]);
4023                    	; 1188          printf("\b]");
4024                    	; 1189          printf("\n  Attribute flags: [");
4025                    	; 1190          /* bits 0 - 2 and 60 - 63 should be decoded */
4026                    	; 1191          for (index = 0; index < 8; index++)
4027                    	; 1192              {
4028                    	; 1193              entryidx = index + 48;
4029                    	; 1194              printf("%02x ", entryptr[entryidx]);
4030                    	; 1195              }
4031                    	; 1196          printf("\b]\n  Partition name:  ");
4032                    	; 1197          } /* sdtestflg */
4033                    	; 1198      /* partition name is in UTF-16LE code units */
4034                    	; 1199      hasname = NO;
4035                    	; 1200      for (index = 0; index < 72; index += 2)
4036                    	; 1201          {
4037                    	; 1202          entryidx = index + 56;
4038                    	; 1203          if ((entryptr[entryidx] | entryptr[entryidx + 1]) == 0)
4039                    	; 1204              break;
4040                    	; 1205          if (sdtestflg)
4041                    	; 1206              {
4042                    	; 1207              if ((' ' <= entryptr[entryidx]) && (entryptr[entryidx] < 127))
4043                    	; 1208                  putchar(entryptr[entryidx]);
4044                    	; 1209              else
4045                    	; 1210                  putchar('.');
4046                    	; 1211              } /* sdtestflg */
4047                    	; 1212          hasname = YES;
4048                    	; 1213          }
4049                    	; 1214      if (sdtestflg)
4050                    	; 1215          {
4051                    	; 1216          if (!hasname)
4052                    	; 1217              printf("name field empty");
4053                    	; 1218          printf("\n");
4054                    	; 1219          printf("   [");
4055                    	; 1220          for (index = 0; index < 72; index++)
4056                    	; 1221              {
4057                    	; 1222              if (((index & 0xf) == 0) && (index != 0))
4058                    	; 1223                  printf("\n    ");
4059                    	; 1224              entryidx = index + 56;
4060                    	; 1225              printf("%02x ", entryptr[entryidx]);
4061                    	; 1226              }
4062                    	; 1227          printf("\b]\n");
4063                    	; 1228          } /* sdtestflg */
4064                    	; 1229      return (YES);
4065                    	; 1230      }
4066                    	; 1231  
4067                    	; 1232  /* Analyze and print GPT header
4068                    	; 1233   */
4069                    	; 1234  void sdgpthdr(unsigned long block)
4070                    	; 1235      {
4071                    	; 1236      int index;
4072                    	; 1237      unsigned int partno;
4073                    	; 1238      unsigned char *rxdata;
4074                    	; 1239      unsigned long entries;
4075                    	; 1240  
4076                    	; 1241      if (sdtestflg)
4077                    	; 1242          {
4078                    	; 1243          printf("GPT header\n");
4079                    	; 1244          } /* sdtestflg */
4080                    	; 1245      if (!sdread(sdrdbuf, block))
4081                    	; 1246          {
4082                    	; 1247          if (sdtestflg)
4083                    	; 1248              {
4084                    	; 1249              printf("Can't read GPT partition table header\n");
4085                    	; 1250              } /* sdtestflg */
4086                    	; 1251          return;
4087                    	; 1252          }
4088                    	; 1253      curblkno = block;
4089                    	; 1254      curblkok = YES;
4090                    	; 1255  
4091                    	; 1256      rxdata = sdrdbuf;
4092                    	; 1257      if (sdtestflg)
4093                    	; 1258          {
4094                    	; 1259          printf("  Signature: %.8s\n", &rxdata[0]);
4095                    	; 1260          printf("  Revision: %d.%d [%02x %02x %02x %02x]\n",
   0                    	; 1261                 (int)rxdata[8] * ((int)rxdata[9] << 8),
   1                    	; 1262                 (int)rxdata[10] + ((int)rxdata[11] << 8),
   2                    	; 1263                 rxdata[8], rxdata[9], rxdata[10], rxdata[11]);
   3                    	; 1264          entries = (unsigned long)rxdata[80] + ((unsigned long)rxdata[81] << 8) +
   4                    	; 1265                    ((unsigned long)rxdata[82] << 16) + ((unsigned long)rxdata[83] << 24);
   5                    	; 1266          printf("  Number of partition entries: %lu (may be actual or maximum)\n", entries);
   6                    	; 1267          } /* sdtestflg */
   7                    	; 1268      for (partno = 0; (partno < 16) && (partdsk < 16); partno++)
   8                    	; 1269          {
   9                    	; 1270          if (!prtgptent(partno))
  10                    	; 1271              {
  11                    	; 1272              if (!sdtestflg)
  12                    	; 1273                  {
  13                    	; 1274                  /* go through all entries if compiled as test program */
  14                    	; 1275                  return;
  15                    	; 1276                  } /* sdtestflg */
  16                    	; 1277              }
  17                    	; 1278          }
  18                    	; 1279      if (sdtestflg)
  19                    	; 1280          {
  20                    	; 1281          printf("First 16 GPT entries scanned\n");
  21                    	; 1282          } /* sdtestflg */
  22                    	; 1283      }
  23                    	; 1284  
  24                    	; 1285  /* Analyze and print MBR partition entry
  25                    	; 1286   * Returns:
  26                    	; 1287   *    -1 if errror - should not happen
  27                    	; 1288   *     0 if not used entry
  28                    	; 1289   *     1 if MBR entry
  29                    	; 1290   *     2 if EBR entry
  30                    	; 1291   *     3 if GTP entry
  31                    	; 1292   */
  32                    	; 1293  int sdmbrentry(unsigned char *partptr)
  33                    	; 1294      {
  34                    	; 1295      int index;
  35                    	; 1296      int parttype;
  36                    	; 1297      unsigned long lbastart;
  37                    	; 1298      unsigned long lbasize;
  38                    	; 1299  
  39                    	; 1300      parttype = PARTMBR;
  40                    	; 1301      if (!partptr[4])
  41                    	; 1302          {
  42                    	; 1303          if (sdtestflg)
  43                    	; 1304              {
  44                    	; 1305              printf("Not used entry\n");
  45                    	; 1306              } /* sdtestflg */
  46                    	; 1307          return (PARTZRO);
  47                    	; 1308          }
  48                    	; 1309      if (sdtestflg)
  49                    	; 1310          {
  50                    	; 1311          printf("Boot indicator: 0x%02x, System ID: 0x%02x\n",
  51                    	; 1312                 partptr[0], partptr[4]);
  52                    	; 1313  
  53                    	; 1314          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f))
  54                    	; 1315              {
  55                    	; 1316              printf("  Extended partition entry\n");
  56                    	; 1317              }
  57                    	; 1318          if (partptr[0] & 0x01)
  58                    	; 1319              {
  59                    	; 1320              printf("  Unofficial 48 bit LBA Proposed MBR Format, no CHS\n");
  60                    	; 1321              /* this is however discussed
  61                    	; 1322                 https://wiki.osdev.org/Partition_Table#.22Unofficial.22_48_bit_LBA_Proposed_MBR_Format
  62                    	; 1323              */
  63                    	; 1324              }
  64                    	; 1325          else
  65                    	; 1326              {
  66                    	; 1327              printf("  begin CHS: 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
  67                    	; 1328                     partptr[1], partptr[2], partptr[3],
  68                    	; 1329                     ((partptr[2] & 0xc0) >> 2) + partptr[3],
  69                    	; 1330                     partptr[1],
  70                    	; 1331                     partptr[2] & 0x3f);
  71                    	; 1332              printf("  end CHS 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
  72                    	; 1333                     partptr[5], partptr[6], partptr[7],
  73                    	; 1334                     ((partptr[6] & 0xc0) >> 2) + partptr[7],
  74                    	; 1335                     partptr[5],
  75                    	; 1336                     partptr[6] & 0x3f);
  76                    	; 1337              }
  77                    	; 1338          } /* sdtestflg */
  78                    	; 1339      /* not showing high 16 bits if 48 bit LBA */
  79                    	; 1340      lbastart = (unsigned long)partptr[8] +
  80                    	; 1341                 ((unsigned long)partptr[9] << 8) +
  81                    	; 1342                 ((unsigned long)partptr[10] << 16) +
  82                    	; 1343                 ((unsigned long)partptr[11] << 24);
  83                    	; 1344      lbasize = (unsigned long)partptr[12] +
  84                    	; 1345                ((unsigned long)partptr[13] << 8) +
  85                    	; 1346                ((unsigned long)partptr[14] << 16) +
  86                    	; 1347                ((unsigned long)partptr[15] << 24);
  87                    	; 1348  
  88                    	; 1349      if (!(partptr[4] == 0xee)) /* not pointing to a GPT partition */
  89                    	; 1350          {
  90                    	; 1351          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f)) /* EBR partition */
  91                    	; 1352              {
  92                    	; 1353              parttype = PARTEBR;
  93                    	; 1354              if (curblkno == 0) /* points to EBR in the MBR */
  94                    	; 1355                  {
  95                    	; 1356                  ebrnext = 0;
  96                    	; 1357                  dskmap[partdsk].partype = EBRCONT;
  97                    	; 1358                  dskmap[partdsk].dskletter = 'A' + partdsk;
  98                    	; 1359                  dskmap[partdsk].dskstart = lbastart;
  99                    	; 1360                  dskmap[partdsk].dskend = lbastart + lbasize - 1;
 100                    	; 1361                  dskmap[partdsk].dsksize = lbasize;
 101                    	; 1362                  dskmap[partdsk].dsktype[0] = partptr[4];
 102                    	; 1363                  partdsk++;
 103                    	; 1364                  ebrrecs[ebrrecidx++] = lbastart; /* save to handle later */
 104                    	; 1365                  }
 105                    	; 1366              else
 106                    	; 1367                  {
 107                    	; 1368                  ebrnext = curblkno + lbastart;
 108                    	; 1369                  }
 109                    	; 1370              }
 110                    	; 1371          else
 111                    	; 1372              {
 112                    	; 1373              if (0 < lbasize) /* one more ugly hack to avoid empty partitions */
 113                    	; 1374                  {
 114                    	; 1375                  if (partptr[0] & 0x80)
 115                    	; 1376                      dskmap[partdsk].bootable = YES;
 116                    	; 1377                  if (curblkno == 0)
 117                    	; 1378                      dskmap[partdsk].partype = PARTMBR;
 118                    	; 1379                  else
 119                    	; 1380                      dskmap[partdsk].partype = PARTEBR;
 120                    	; 1381                  dskmap[partdsk].dskletter = 'A' + partdsk;
 121                    	; 1382                  dskmap[partdsk].dskstart = curblkno + lbastart;
 122                    	; 1383                  dskmap[partdsk].dskend = curblkno + lbastart + lbasize - 1;
 123                    	; 1384                  dskmap[partdsk].dsksize = lbasize;
 124                    	; 1385                  dskmap[partdsk].dsktype[0] = partptr[4];
 125                    	; 1386                  partdsk++;
 126                    	; 1387                  }
 127                    	; 1388              }
 128                    	; 1389          }
 129                    	; 1390  
 130                    	; 1391      if (sdtestflg)
 131                    	; 1392          {
 132                    	; 1393          printf("  partition start LBA: %lu [%08lx]\n",
 133                    	; 1394                 curblkno + lbastart, curblkno + lbastart);
 134                    	; 1395          printf("  partition size LBA: %lu [%08lx], %lu MByte\n",
 135                    	; 1396                 lbasize, lbasize, lbasize >> 11);
 136                    	; 1397          } /* sdtestflg */
 137                    	; 1398      if (partptr[4] == 0xee) /* GPT partitions */
 138                    	; 1399          {
 139                    	; 1400          parttype = PARTGPT;
 140                    	; 1401          if (sdtestflg)
 141                    	; 1402              {
 142                    	; 1403              printf("GTP partitions\n");
 143                    	; 1404              } /* sdtestflg */
 144                    	; 1405          sdgpthdr(lbastart); /* handle GTP partitions */
 145                    	; 1406          /* re-read MBR on sector 0
 146                    	; 1407             This is probably not needed as there
 147                    	; 1408             is only one entry (the first one)
 148                    	; 1409             in the MBR when using GPT */
 149                    	; 1410          if (sdread(sdrdbuf, 0))
 150                    	; 1411              {
 151                    	; 1412              curblkno = 0;
 152                    	; 1413              curblkok = YES;
 153                    	; 1414              }
 154                    	; 1415          else
 155                    	; 1416              {
 156                    	; 1417              if (sdtestflg)
 157                    	; 1418                  {
 158                    	; 1419                  printf("  can't read MBR on sector 0\n");
 159                    	; 1420                  } /* sdtestflg */
 160                    	; 1421              return(-1);
 161                    	; 1422              }
 162                    	; 1423          }
 163                    	; 1424      return (parttype);
 164                    	; 1425      }
 165                    	; 1426  
 166                    	; 1427  /* Read and analyze MBR/EBR partition sector block
 167                    	; 1428   * and go through and print partition entries.
 168                    	; 1429   */
 169                    	; 1430  void sdmbrpart(unsigned long sector)
 170                    	; 1431      {
 171                    	; 1432      int partidx;  /* partition index 1 - 4 */
 172                    	; 1433      int cpartidx; /* chain partition index 1 - 4 */
 173                    	; 1434      int chainidx;
 174                    	; 1435      int enttype;
 175                    	; 1436      unsigned char *entp; /* pointer to partition entry */
 176                    	; 1437      char *mbrebr;
 177                    	; 1438  
 178                    	; 1439      if (sdtestflg)
 179                    	; 1440          {
 180                    	; 1441          if (sector == 0) /* if sector 0 it is MBR else it is EBR */
 181                    	; 1442              mbrebr = "MBR";
 182                    	; 1443          else
 183                    	; 1444              mbrebr = "EBR";
 184                    	; 1445          printf("Read %s from sector %lu\n", mbrebr, sector);
 185                    	; 1446          } /* sdtestflg */
 186                    	; 1447      if (sdread(sdrdbuf, sector))
 187                    	; 1448          {
 188                    	; 1449          curblkno = sector;
 189                    	; 1450          curblkok = YES;
 190                    	; 1451          }
 191                    	; 1452      else
 192                    	; 1453          {
 193                    	; 1454          if (sdtestflg)
 194                    	; 1455              {
 195                    	; 1456              printf("  can't read %s sector %lu\n", mbrebr, sector);
 196                    	; 1457              } /* sdtestflg */
 197                    	; 1458          return;
 198                    	; 1459          }
 199                    	; 1460      if (!((sdrdbuf[0x1fe] == 0x55) && (sdrdbuf[0x1ff] == 0xaa)))
 200                    	; 1461          {
 201                    	; 1462          if (sdtestflg)
 202                    	; 1463              {
 203                    	; 1464              printf("  no %s boot signature found\n", mbrebr);
 204                    	; 1465              } /* sdtestflg */
 205                    	; 1466          return;
 206                    	; 1467          }
 207                    	; 1468      if (curblkno == 0)
 208                    	; 1469          {
 209                    	; 1470          memcpy(dsksign, &sdrdbuf[0x1b8], sizeof dsksign);
 210                    	; 1471          if (sdtestflg)
 211                    	; 1472              {
 212                    	; 1473  
 213                    	; 1474              printf("  disk identifier: 0x%02x%02x%02x%02x\n",
 214                    	; 1475                     dsksign[3], dsksign[2], dsksign[1], dsksign[0]);
 215                    	; 1476              } /* sdtestflg */
 216                    	; 1477          }
 217                    	; 1478      /* go through MBR partition entries until first empty */
 218                    	; 1479      /* !!as the MBR entry routine is called recusively a way is
 219                    	; 1480         needed to read sector 0 when going back to MBR if
 220                    	; 1481         there is a primary partition entry after an EBR entry!! */
 221                    	; 1482      entp = &sdrdbuf[0x01be] ;
 222                    	; 1483      for (partidx = 1; (partidx <= 4) && (partdsk < 16); partidx++, entp += 16)
 223                    	; 1484          {
 224                    	; 1485          if (sdtestflg)
 225                    	; 1486              {
 226                    	; 1487              printf("%s partition entry %d: ", mbrebr, partidx);
 227                    	; 1488              } /* sdtestflg */
 228                    	; 1489          enttype = sdmbrentry(entp);
 229                    	; 1490          if (enttype == -1) /* read error */
 230                    	; 1491                   return;
 231                    	; 1492          else if (enttype == PARTZRO)
 232                    	; 1493              {
 233                    	; 1494              if (!sdtestflg)
 234                    	; 1495                  {
 235                    	; 1496                  /* if compiled as test program show also empty partitions */
 236                    	; 1497                  break;
 237                    	; 1498                  } /* sdtestflg */
 238                    	; 1499              }
 239                    	; 1500          }
 240                    	; 1501      /* now handle the previously saved EBR partition sectors */
 241                    	; 1502      for (partidx = 0; (partidx < ebrrecidx) && (partdsk < 16); partidx++)
 242                    	; 1503          {
 243                    	; 1504          if (sdread(sdrdbuf, ebrrecs[partidx]))
 244                    	; 1505              {
 245                    	; 1506              curblkno = ebrrecs[partidx];
 246                    	; 1507              curblkok = YES;
 247                    	; 1508              }
 248                    	; 1509          else
 249                    	; 1510              {
 250                    	; 1511              if (sdtestflg)
 251                    	; 1512                  {
 252                    	; 1513                  printf("  can't read %s sector %lu\n", mbrebr, sector);
 253                    	; 1514                  } /* sdtestflg */
 254                    	; 1515              return;
 255                    	; 1516              }
 256                    	; 1517          entp = &sdrdbuf[0x01be] ;
 257                    	; 1518          for (partidx = 1; (partidx <= 4) && (partdsk < 16); partidx++, entp += 16)
 258                    	; 1519              {
 259                    	; 1520              if (sdtestflg)
 260                    	; 1521                  {
 261                    	; 1522                  printf("EBR partition entry %d: ", partidx);
 262                    	; 1523                  } /* sdtestflg */
 263                    	; 1524              enttype = sdmbrentry(entp);
 264                    	; 1525              if (enttype == -1) /* read error */
 265                    	; 1526                   return;
 266                    	; 1527              else if (enttype == PARTZRO) /* empty partition entry */
 267                    	; 1528                  {
 268                    	; 1529                  if (sdtestflg)
 269                    	; 1530                      {
 270                    	; 1531                      /* if compiled as test program show also empty partitions */
 271                    	; 1532                      printf("Empty partition entry\n");
 272                    	; 1533                      } /* sdtestflg */
 273                    	; 1534                  else
 274                    	; 1535                      break;
 275                    	; 1536                  }
 276                    	; 1537              else if (enttype == PARTEBR) /* next chained EBR */
 277                    	; 1538                  {
 278                    	; 1539                  if (sdtestflg)
 279                    	; 1540                      {
 280                    	; 1541                      printf("EBR chain\n");
 281                    	; 1542                      } /* sdtestflg */
 282                    	; 1543                  /* follow the EBR chain */
 283                    	; 1544                  for (chainidx = 0;
 284                    	; 1545                      ebrnext && (chainidx < 16) && (partdsk < 16);
 285                    	; 1546                      chainidx++)
 286                    	; 1547                      {
 287                    	; 1548                      /* ugly hack to stop reading the same sector */
 288                    	; 1549                      if (ebrnext == curblkno)
 289                    	; 1550                           break;
 290                    	; 1551                      if (sdread(sdrdbuf, ebrnext))
 291                    	; 1552                          {
 292                    	; 1553                          curblkno = ebrnext;
 293                    	; 1554                          curblkok = YES;
 294                    	; 1555                          }
 295                    	; 1556                      else
 296                    	; 1557                          {
 297                    	; 1558                          if (sdtestflg)
 298                    	; 1559                              {
 299                    	; 1560                              printf("  can't read %s sector %lu\n", mbrebr, sector);
 300                    	; 1561                              } /* sdtestflg */
 301                    	; 1562                          return;
 302                    	; 1563                          }
 303                    	; 1564                      entp = &sdrdbuf[0x01be] ;
 304                    	; 1565                      for (cpartidx = 1;
 305                    	; 1566                          (cpartidx <= 4) && (partdsk < 16);
 306                    	; 1567                          cpartidx++, entp += 16)
 307                    	; 1568                          {
 308                    	; 1569                          if (sdtestflg)
 309                    	; 1570                              {
 310                    	; 1571                              printf("EBR chained  partition entry %d: ",
 311                    	; 1572                                   cpartidx);
 312                    	; 1573                              } /* sdtestflg */
 313                    	; 1574                          enttype = sdmbrentry(entp);
 314                    	; 1575                          if (enttype == -1) /* read error */
 315                    	; 1576                              return;
 316                    	; 1577                          }
 317                    	; 1578                      }
 318                    	; 1579                  }
 319                    	; 1580              }
 320                    	; 1581          }
 321                    	; 1582      }
 322                    	; 1583  
 323                    	; 1584  /* Executing in RAM or EPROM
 324                    	; 1585   */
 325                    	; 1586  void execin()
 326                    	; 1587      {
 327                    	; 1588      printf(", executing in: ");
 328                    	; 1589      rampptr = &ramprobe;
 329                    	; 1590      *rampptr = 1; /* try to change const */
 330                    	; 1591      if (ramprobe)
 331                    	; 1592          printf("RAM\n");
 332                    	; 1593      else
 333                    	; 1594          printf("EPROM\n");
 334                    	; 1595      *rampptr = 0;
 335                    	; 1596      }
 336                    	; 1597  
 337                    	; 1598  /* Test init, read and partitions on SD card over the SPI interface,
 338                    	; 1599   * boot from SD card, upload with Xmodem
 339                    	; 1600   */
 340                    	; 1601  int main()
 341                    	; 1602      {
 342                    	; 1603      char txtin[10];
 343                    	; 1604      int cmdin;
 344                    	; 1605      int idx;
 345                    	; 1606      int cmpidx;
 346                    	; 1607      unsigned char *cmpptr;
 347                    	; 1608      int inlength;
 348                    	; 1609      unsigned long blockno;
 349                    	; 1610  
 350                    	; 1611      blockno = 0;
 351                    	; 1612      curblkno = 0;
 352                    	; 1613      curblkok = NO;
 353                    	; 1614      sdinitok = NO; /* SD card not initialized yet */
 354                    	; 1615  
 355                    	; 1616      printf(PRGNAME);
 356                    	; 1617      printf(VERSION);
 357                    	; 1618      printf(builddate);
 358                    	; 1619      execin();
 359                    	; 1620      printf("binsize: 0x%04x (%d), binstart: 0x%04x\n", binsize, binsize, binstart);
 360                    	; 1621      while (YES) /* forever (until Ctrl-C) */
 361                    	; 1622          {
 362                    	; 1623          printf("cmd (? for help): ");
 363                    	; 1624  
 364                    	; 1625          cmdin = getchar();
 365                    	; 1626          switch (cmdin)
 366                    	; 1627              {
 367                    	; 1628              case '?':
 368                    	; 1629                  printf(" ? - help\n");
 369                    	; 1630                  printf(PRGNAME);
 370                    	; 1631                  printf(VERSION);
 371                    	; 1632                  printf(builddate);
 372                    	; 1633                  execin();
 373                    	; 1634                  printf("Commands:\n");
 374                    	; 1635                  printf("  ? - help\n");
 375                    	; 1636                  printf("  b - boot from SD card\n");
 376                    	; 1637                  printf("  d - debug on/off\n");
 377                    	; 1638                  printf("  i - initialize SD card\n");
 378                    	; 1639                  printf("  l - print SD card partition layout\n");
 379                    	; 1640                  printf("  n - set/show sector #N to read/write\n");
 380                    	; 1641                  printf("  p - print sector last read/to write\n");
 381                    	; 1642                  printf("  r - read sector #N\n");
 382                    	; 1643                  printf("  s - print SD registers\n");
 383                    	; 1644                  printf("  t - test probe SD card\n");
 384                    	; 1645                  printf("  u - upload code with Xmodem to RAM address 0x0000\n");
 385                    	; 1646                  printf("  w - write sector #N\n");
 386                    	; 1647                  printf("  Ctrl-C to reload monitor from EPROM\n");
 387                    	; 1648                  break;
 388                    	; 1649              case 'b':
 389                    	; 1650                  printf(" d - boot from SD card - ");
 390                    	; 1651                  printf("implementation ongoing\n");
 391                    	; 1652                  break;
 392                    	; 1653              case 'd':
 393                    	; 1654                  printf(" d - toggle debug flag - ");
 394                    	; 1655                  if (sdtestflg)
 395                    	; 1656                      {
 396                    	; 1657                      sdtestflg = NO;
 397                    	; 1658                      printf("OFF\n");
 398                    	; 1659                      }
 399                    	; 1660                  else
 400                    	; 1661                      {
 401                    	; 1662                      sdtestflg = YES;
 402                    	; 1663                      printf("ON\n");
 403                    	; 1664                      }
 404                    	; 1665                  break;
 405                    	; 1666              case 'i':
 406                    	; 1667                  printf(" i - initialize SD card");
 407                    	; 1668                  if (sdinit())
 408                    	; 1669                      printf(" - ok\n");
 409                    	; 1670                  else
 410                    	; 1671                      printf(" - not inserted or faulty\n");
 411                    	; 1672                  break;
 412                    	; 1673              case 'l':
 413                    	; 1674                  printf(" l - print partition layout\n");
 414                    	; 1675                  if (!sdprobe())
 415                    	; 1676                      {
 416                    	; 1677                      printf(" - SD not initialized or inserted or faulty\n");
 417                    	; 1678                      break;
 418                    	; 1679                      }
 419                    	; 1680                  ebrrecidx = 0;
 420    4A39  210000    		ld	hl,0
 421    4A3C  221600    		ld	(_ebrrecidx),hl
 422    4A3F  220E00    		ld	(_partdsk),hl
 423                    	; 1681                  partdsk = 0;
 424                    	; 1682                  memset(dskmap, 0, sizeof dskmap);
 425    4A42  210002    		ld	hl,512
 426    4A45  E5        		push	hl
 427    4A46  210000    		ld	hl,0
 428    4A49  E5        		push	hl
 429    4A4A  215202    		ld	hl,_dskmap
 430    4A4D  CD0000    		call	_memset
 431    4A50  F1        		pop	af
 432    4A51  F1        		pop	af
 433                    	; 1683                  sdmbrpart(0);
 434    4A52  21DE45    		ld	hl,L412+3
 435    4A55  46        		ld	b,(hl)
 436    4A56  2B        		dec	hl
 437    4A57  4E        		ld	c,(hl)
 438    4A58  C5        		push	bc
 439    4A59  2B        		dec	hl
 440    4A5A  46        		ld	b,(hl)
 441    4A5B  2B        		dec	hl
 442    4A5C  4E        		ld	c,(hl)
 443    4A5D  C5        		push	bc
 444    4A5E  E1        		pop	hl
 445    4A5F  CD963E    		call	_sdmbrpart
 446    4A62  F1        		pop	af
 447                    	; 1684                  printf("      Disk partition sectors on SD card\n");
 448    4A63  21DF45    		ld	hl,L5033
 449    4A66  CD0000    		call	_printf
 450                    	; 1685                  printf("       MBR disk identifier: 0x%02x%02x%02x%02x\n",
 451                    	; 1686                         dsksign[3], dsksign[2], dsksign[1], dsksign[0]);
 452    4A69  3A4E02    		ld	a,(_dsksign)
 453    4A6C  4F        		ld	c,a
 454    4A6D  97        		sub	a
 455    4A6E  47        		ld	b,a
 456    4A6F  C5        		push	bc
 457    4A70  3A4F02    		ld	a,(_dsksign+1)
 458    4A73  4F        		ld	c,a
 459    4A74  97        		sub	a
 460    4A75  47        		ld	b,a
 461    4A76  C5        		push	bc
 462    4A77  3A5002    		ld	a,(_dsksign+2)
 463    4A7A  4F        		ld	c,a
 464    4A7B  97        		sub	a
 465    4A7C  47        		ld	b,a
 466    4A7D  C5        		push	bc
 467    4A7E  3A5102    		ld	a,(_dsksign+3)
 468    4A81  4F        		ld	c,a
 469    4A82  97        		sub	a
 470    4A83  47        		ld	b,a
 471    4A84  C5        		push	bc
 472    4A85  210846    		ld	hl,L5133
 473    4A88  CD0000    		call	_printf
 474    4A8B  F1        		pop	af
 475    4A8C  F1        		pop	af
 476    4A8D  F1        		pop	af
 477    4A8E  F1        		pop	af
 478                    	; 1687                  printf(" Disk     Start      End     Size Part Type Id\n");
 479    4A8F  213846    		ld	hl,L5233
 480    4A92  CD0000    		call	_printf
 481                    	; 1688                  printf(" ----     -----      ---     ---- ---- ---- --\n");
 482    4A95  216846    		ld	hl,L5333
 483    4A98  CD0000    		call	_printf
 484                    	; 1689                  for (idx = 0; idx < 16; idx++)
 485    4A9B  DD36EC00  		ld	(ix-20),0
 486    4A9F  DD36ED00  		ld	(ix-19),0
 487                    	L1046:
 488    4AA3  DD7EEC    		ld	a,(ix-20)
 489    4AA6  D610      		sub	16
 490    4AA8  DD7EED    		ld	a,(ix-19)
 491    4AAB  DE00      		sbc	a,0
 492    4AAD  F23D49    		jp	p,L1226
 493                    	; 1690                      {
 494                    	; 1691                      if (dskmap[idx].dskletter)
 495    4AB0  DD6EEC    		ld	l,(ix-20)
 496    4AB3  DD66ED    		ld	h,(ix-19)
 497    4AB6  E5        		push	hl
 498    4AB7  212000    		ld	hl,32
 499    4ABA  E5        		push	hl
 500    4ABB  CD0000    		call	c.imul
 501    4ABE  E1        		pop	hl
 502    4ABF  015302    		ld	bc,_dskmap+1
 503    4AC2  09        		add	hl,bc
 504    4AC3  7E        		ld	a,(hl)
 505    4AC4  B7        		or	a
 506    4AC5  CAAD4B    		jp	z,L1246
 507                    	; 1692                          {
 508                    	; 1693                          printf("%2d (%c)%c", dskmap[idx].dskletter - 'A' + 1,
 509                    	; 1694                                 dskmap[idx].dskletter,
 510                    	; 1695                                 dskmap[idx].bootable ? '*' : ' ');
 511    4AC8  DD6EEC    		ld	l,(ix-20)
 512    4ACB  DD66ED    		ld	h,(ix-19)
 513    4ACE  E5        		push	hl
 514    4ACF  212000    		ld	hl,32
 515    4AD2  E5        		push	hl
 516    4AD3  CD0000    		call	c.imul
 517    4AD6  E1        		pop	hl
 518    4AD7  015402    		ld	bc,_dskmap+2
 519    4ADA  09        		add	hl,bc
 520    4ADB  7E        		ld	a,(hl)
 521    4ADC  23        		inc	hl
 522    4ADD  B6        		or	(hl)
 523    4ADE  2805      		jr	z,L022
 524    4AE0  012A00    		ld	bc,42
 525    4AE3  1803      		jr	L222
 526                    	L022:
 527    4AE5  012000    		ld	bc,32
 528                    	L222:
 529    4AE8  C5        		push	bc
 530    4AE9  DD6EEC    		ld	l,(ix-20)
 531    4AEC  DD66ED    		ld	h,(ix-19)
 532    4AEF  E5        		push	hl
 533    4AF0  212000    		ld	hl,32
 534    4AF3  E5        		push	hl
 535    4AF4  CD0000    		call	c.imul
 536    4AF7  E1        		pop	hl
 537    4AF8  015302    		ld	bc,_dskmap+1
 538    4AFB  09        		add	hl,bc
 539    4AFC  4E        		ld	c,(hl)
 540    4AFD  97        		sub	a
 541    4AFE  47        		ld	b,a
 542    4AFF  C5        		push	bc
 543    4B00  DD6EEC    		ld	l,(ix-20)
 544    4B03  DD66ED    		ld	h,(ix-19)
 545    4B06  E5        		push	hl
 546    4B07  212000    		ld	hl,32
 547    4B0A  E5        		push	hl
 548    4B0B  CD0000    		call	c.imul
 549    4B0E  E1        		pop	hl
 550    4B0F  015302    		ld	bc,_dskmap+1
 551    4B12  09        		add	hl,bc
 552    4B13  6E        		ld	l,(hl)
 553    4B14  97        		sub	a
 554    4B15  67        		ld	h,a
 555    4B16  01C0FF    		ld	bc,65472
 556    4B19  09        		add	hl,bc
 557    4B1A  E5        		push	hl
 558    4B1B  219846    		ld	hl,L5433
 559    4B1E  CD0000    		call	_printf
 560    4B21  F1        		pop	af
 561    4B22  F1        		pop	af
 562    4B23  F1        		pop	af
 563                    	; 1696                          printf("%8lu %8lu %8lu ",
 564                    	; 1697                                 dskmap[idx].dskstart, dskmap[idx].dskend,
 565                    	; 1698                                 dskmap[idx].dsksize);
 566    4B24  DD6EEC    		ld	l,(ix-20)
 567    4B27  DD66ED    		ld	h,(ix-19)
 568    4B2A  E5        		push	hl
 569    4B2B  212000    		ld	hl,32
 570    4B2E  E5        		push	hl
 571    4B2F  CD0000    		call	c.imul
 572    4B32  E1        		pop	hl
 573    4B33  015E02    		ld	bc,_dskmap+12
 574    4B36  09        		add	hl,bc
 575    4B37  23        		inc	hl
 576    4B38  23        		inc	hl
 577    4B39  4E        		ld	c,(hl)
 578    4B3A  23        		inc	hl
 579    4B3B  46        		ld	b,(hl)
 580    4B3C  C5        		push	bc
 581    4B3D  2B        		dec	hl
 582    4B3E  2B        		dec	hl
 583    4B3F  2B        		dec	hl
 584    4B40  4E        		ld	c,(hl)
 585    4B41  23        		inc	hl
 586    4B42  46        		ld	b,(hl)
 587    4B43  C5        		push	bc
 588    4B44  DD6EEC    		ld	l,(ix-20)
 589    4B47  DD66ED    		ld	h,(ix-19)
 590    4B4A  E5        		push	hl
 591    4B4B  212000    		ld	hl,32
 592    4B4E  E5        		push	hl
 593    4B4F  CD0000    		call	c.imul
 594    4B52  E1        		pop	hl
 595    4B53  015A02    		ld	bc,_dskmap+8
 596    4B56  09        		add	hl,bc
 597    4B57  23        		inc	hl
 598    4B58  23        		inc	hl
 599    4B59  4E        		ld	c,(hl)
 600    4B5A  23        		inc	hl
 601    4B5B  46        		ld	b,(hl)
 602    4B5C  C5        		push	bc
 603    4B5D  2B        		dec	hl
 604    4B5E  2B        		dec	hl
 605    4B5F  2B        		dec	hl
 606    4B60  4E        		ld	c,(hl)
 607    4B61  23        		inc	hl
 608    4B62  46        		ld	b,(hl)
 609    4B63  C5        		push	bc
 610    4B64  DD6EEC    		ld	l,(ix-20)
 611    4B67  DD66ED    		ld	h,(ix-19)
 612    4B6A  E5        		push	hl
 613    4B6B  212000    		ld	hl,32
 614    4B6E  E5        		push	hl
 615    4B6F  CD0000    		call	c.imul
 616    4B72  E1        		pop	hl
 617    4B73  015602    		ld	bc,_dskmap+4
 618    4B76  09        		add	hl,bc
 619    4B77  23        		inc	hl
 620    4B78  23        		inc	hl
 621    4B79  4E        		ld	c,(hl)
 622    4B7A  23        		inc	hl
 623    4B7B  46        		ld	b,(hl)
 624    4B7C  C5        		push	bc
 625    4B7D  2B        		dec	hl
 626    4B7E  2B        		dec	hl
 627    4B7F  2B        		dec	hl
 628    4B80  4E        		ld	c,(hl)
 629    4B81  23        		inc	hl
 630    4B82  46        		ld	b,(hl)
 631    4B83  C5        		push	bc
 632    4B84  21A346    		ld	hl,L5533
 633    4B87  CD0000    		call	_printf
 634    4B8A  210C00    		ld	hl,12
 635    4B8D  39        		add	hl,sp
 636    4B8E  F9        		ld	sp,hl
 637                    	; 1699                          if (dskmap[idx].partype == EBRCONT)
 638    4B8F  DD6EEC    		ld	l,(ix-20)
 639    4B92  DD66ED    		ld	h,(ix-19)
 640    4B95  E5        		push	hl
 641    4B96  212000    		ld	hl,32
 642    4B99  E5        		push	hl
 643    4B9A  CD0000    		call	c.imul
 644    4B9D  E1        		pop	hl
 645    4B9E  015202    		ld	bc,_dskmap
 646    4BA1  09        		add	hl,bc
 647    4BA2  7E        		ld	a,(hl)
 648    4BA3  FE14      		cp	20
 649    4BA5  2011      		jr	nz,L1546
 650                    	; 1700                              {
 651                    	; 1701                              printf(" EBR container\n");
 652    4BA7  21B346    		ld	hl,L5633
 653    4BAA  CD0000    		call	_printf
 654                    	; 1702                              }
 655                    	; 1703                          else
 656                    	L1246:
 657    4BAD  DD34EC    		inc	(ix-20)
 658    4BB0  2003      		jr	nz,L612
 659    4BB2  DD34ED    		inc	(ix-19)
 660                    	L612:
 661    4BB5  C3A34A    		jp	L1046
 662                    	L1546:
 663                    	; 1704                              {
 664                    	; 1705                              if (dskmap[idx].partype == PARTGPT)
 665    4BB8  DD6EEC    		ld	l,(ix-20)
 666    4BBB  DD66ED    		ld	h,(ix-19)
 667    4BBE  E5        		push	hl
 668    4BBF  212000    		ld	hl,32
 669    4BC2  E5        		push	hl
 670    4BC3  CD0000    		call	c.imul
 671    4BC6  E1        		pop	hl
 672    4BC7  015202    		ld	bc,_dskmap
 673    4BCA  09        		add	hl,bc
 674    4BCB  7E        		ld	a,(hl)
 675    4BCC  FE03      		cp	3
 676    4BCE  C2224C    		jp	nz,L1746
 677                    	; 1706                                  {
 678                    	; 1707                                  printf(" GPT ");
 679    4BD1  21C346    		ld	hl,L5733
 680    4BD4  CD0000    		call	_printf
 681                    	; 1708                                  if (!memcmp(dskmap[idx].dsktype, gptcpm, 16))
 682    4BD7  211000    		ld	hl,16
 683    4BDA  E5        		push	hl
 684    4BDB  215500    		ld	hl,_gptcpm
 685    4BDE  E5        		push	hl
 686    4BDF  DD6EEC    		ld	l,(ix-20)
 687    4BE2  DD66ED    		ld	h,(ix-19)
 688    4BE5  E5        		push	hl
 689    4BE6  212000    		ld	hl,32
 690    4BE9  E5        		push	hl
 691    4BEA  CD0000    		call	c.imul
 692    4BED  E1        		pop	hl
 693    4BEE  016202    		ld	bc,_dskmap+16
 694    4BF1  09        		add	hl,bc
 695    4BF2  CD0000    		call	_memcmp
 696    4BF5  F1        		pop	af
 697    4BF6  F1        		pop	af
 698    4BF7  79        		ld	a,c
 699    4BF8  B0        		or	b
 700    4BF9  2008      		jr	nz,L1056
 701                    	; 1709                                      printf("CP/M ");
 702    4BFB  21C946    		ld	hl,L5043
 703    4BFE  CD0000    		call	_printf
 704                    	; 1710                                  else
 705    4C01  1806      		jr	L1156
 706                    	L1056:
 707                    	; 1711                                      printf(" ??  ");
 708    4C03  21CF46    		ld	hl,L5143
 709    4C06  CD0000    		call	_printf
 710                    	L1156:
 711                    	; 1712                                  prtguid(dskmap[idx].dsktype);
 712    4C09  DD6EEC    		ld	l,(ix-20)
 713    4C0C  DD66ED    		ld	h,(ix-19)
 714    4C0F  E5        		push	hl
 715    4C10  212000    		ld	hl,32
 716    4C13  E5        		push	hl
 717    4C14  CD0000    		call	c.imul
 718    4C17  E1        		pop	hl
 719    4C18  016202    		ld	bc,_dskmap+16
 720    4C1B  09        		add	hl,bc
 721    4C1C  CD6829    		call	_prtguid
 722                    	; 1713                                  }
 723                    	; 1714                              else
 724    4C1F  C3B24C    		jp	L1256
 725                    	L1746:
 726                    	; 1715                                  {
 727                    	; 1716                                  if (dskmap[idx].partype == PARTEBR)
 728    4C22  DD6EEC    		ld	l,(ix-20)
 729    4C25  DD66ED    		ld	h,(ix-19)
 730    4C28  E5        		push	hl
 731    4C29  212000    		ld	hl,32
 732    4C2C  E5        		push	hl
 733    4C2D  CD0000    		call	c.imul
 734    4C30  E1        		pop	hl
 735    4C31  015202    		ld	bc,_dskmap
 736    4C34  09        		add	hl,bc
 737    4C35  7E        		ld	a,(hl)
 738    4C36  FE02      		cp	2
 739    4C38  2008      		jr	nz,L1356
 740                    	; 1717                                      printf(" EBR ");
 741    4C3A  21D546    		ld	hl,L5243
 742    4C3D  CD0000    		call	_printf
 743                    	; 1718                                  else
 744    4C40  1806      		jr	L1456
 745                    	L1356:
 746                    	; 1719                                      printf(" MBR ");
 747    4C42  21DB46    		ld	hl,L5343
 748    4C45  CD0000    		call	_printf
 749                    	L1456:
 750                    	; 1720                                  if (dskmap[idx].dsktype[0] == mbrcpm)
 751    4C48  DD6EEC    		ld	l,(ix-20)
 752    4C4B  DD66ED    		ld	h,(ix-19)
 753    4C4E  E5        		push	hl
 754    4C4F  212000    		ld	hl,32
 755    4C52  E5        		push	hl
 756    4C53  CD0000    		call	c.imul
 757    4C56  E1        		pop	hl
 758    4C57  016202    		ld	bc,_dskmap+16
 759    4C5A  09        		add	hl,bc
 760    4C5B  3A6500    		ld	a,(_mbrcpm)
 761    4C5E  4F        		ld	c,a
 762    4C5F  7E        		ld	a,(hl)
 763    4C60  B9        		cp	c
 764    4C61  2008      		jr	nz,L1556
 765                    	; 1721                                      printf("CP/M ");
 766    4C63  21E146    		ld	hl,L5443
 767    4C66  CD0000    		call	_printf
 768                    	; 1722                                  else if (dskmap[idx].dsktype[0] == mbrexcode)
 769    4C69  1829      		jr	L1656
 770                    	L1556:
 771    4C6B  DD6EEC    		ld	l,(ix-20)
 772    4C6E  DD66ED    		ld	h,(ix-19)
 773    4C71  E5        		push	hl
 774    4C72  212000    		ld	hl,32
 775    4C75  E5        		push	hl
 776    4C76  CD0000    		call	c.imul
 777    4C79  E1        		pop	hl
 778    4C7A  016202    		ld	bc,_dskmap+16
 779    4C7D  09        		add	hl,bc
 780    4C7E  3A6600    		ld	a,(_mbrexcode)
 781    4C81  4F        		ld	c,a
 782    4C82  7E        		ld	a,(hl)
 783    4C83  B9        		cp	c
 784    4C84  2008      		jr	nz,L1756
 785                    	; 1723                                      printf("Code ");
 786    4C86  21E746    		ld	hl,L5543
 787    4C89  CD0000    		call	_printf
 788                    	; 1724                                  else
 789    4C8C  1806      		jr	L1656
 790                    	L1756:
 791                    	; 1725                                      printf(" ??  ");
 792    4C8E  21ED46    		ld	hl,L5643
 793    4C91  CD0000    		call	_printf
 794                    	L1656:
 795                    	; 1726                                  printf("0x%02x", dskmap[idx].dsktype[0]);
 796    4C94  DD6EEC    		ld	l,(ix-20)
 797    4C97  DD66ED    		ld	h,(ix-19)
 798    4C9A  E5        		push	hl
 799    4C9B  212000    		ld	hl,32
 800    4C9E  E5        		push	hl
 801    4C9F  CD0000    		call	c.imul
 802    4CA2  E1        		pop	hl
 803    4CA3  016202    		ld	bc,_dskmap+16
 804    4CA6  09        		add	hl,bc
 805    4CA7  4E        		ld	c,(hl)
 806    4CA8  97        		sub	a
 807    4CA9  47        		ld	b,a
 808    4CAA  C5        		push	bc
 809    4CAB  21F346    		ld	hl,L5743
 810    4CAE  CD0000    		call	_printf
 811    4CB1  F1        		pop	af
 812                    	L1256:
 813                    	; 1727                                  }
 814                    	; 1728                              printf("\n");
 815    4CB2  21FA46    		ld	hl,L5053
 816    4CB5  CD0000    		call	_printf
 817    4CB8  C3AD4B    		jp	L1246
 818                    	L1166:
 819                    	; 1729                              }
 820                    	; 1730                          }
 821                    	; 1731                      }
 822                    	; 1732                  break;
 823                    	; 1733              case 'n':
 824                    	; 1734                  printf(" n - sector number: ");
 825    4CBB  21FC46    		ld	hl,L5153
 826    4CBE  CD0000    		call	_printf
 827                    	; 1735                  if (getkline(txtin, sizeof txtin))
 828    4CC1  210A00    		ld	hl,10
 829    4CC4  E5        		push	hl
 830    4CC5  DDE5      		push	ix
 831    4CC7  C1        		pop	bc
 832    4CC8  21F0FF    		ld	hl,65520
 833    4CCB  09        		add	hl,bc
 834    4CCC  CD0000    		call	_getkline
 835    4CCF  F1        		pop	af
 836    4CD0  79        		ld	a,c
 837    4CD1  B0        		or	b
 838    4CD2  281A      		jr	z,L1266
 839                    	; 1736                      sscanf(txtin, "%lu", &blockno);
 840    4CD4  DDE5      		push	ix
 841    4CD6  C1        		pop	bc
 842    4CD7  21E2FF    		ld	hl,65506
 843    4CDA  09        		add	hl,bc
 844    4CDB  E5        		push	hl
 845    4CDC  211147    		ld	hl,L5253
 846    4CDF  E5        		push	hl
 847    4CE0  DDE5      		push	ix
 848    4CE2  C1        		pop	bc
 849    4CE3  21F0FF    		ld	hl,65520
 850    4CE6  09        		add	hl,bc
 851    4CE7  CD0000    		call	_sscanf
 852    4CEA  F1        		pop	af
 853    4CEB  F1        		pop	af
 854                    	; 1737                  else
 855    4CEC  1816      		jr	L1366
 856                    	L1266:
 857                    	; 1738                      printf("%lu", blockno);
 858    4CEE  DD66E5    		ld	h,(ix-27)
 859    4CF1  DD6EE4    		ld	l,(ix-28)
 860    4CF4  E5        		push	hl
 861    4CF5  DD66E3    		ld	h,(ix-29)
 862    4CF8  DD6EE2    		ld	l,(ix-30)
 863    4CFB  E5        		push	hl
 864    4CFC  211547    		ld	hl,L5353
 865    4CFF  CD0000    		call	_printf
 866    4D02  F1        		pop	af
 867    4D03  F1        		pop	af
 868                    	L1366:
 869                    	; 1739                  printf("\n");
 870    4D04  211947    		ld	hl,L5453
 871    4D07  CD0000    		call	_printf
 872                    	; 1740                  break;
 873    4D0A  C33D49    		jp	L1226
 874                    	L1466:
 875                    	; 1741              case 'p':
 876                    	; 1742                  printf(" p - print data sector %lu\n", curblkno);
 877    4D0D  210500    		ld	hl,_curblkno+3
 878    4D10  46        		ld	b,(hl)
 879    4D11  2B        		dec	hl
 880    4D12  4E        		ld	c,(hl)
 881    4D13  C5        		push	bc
 882    4D14  2B        		dec	hl
 883    4D15  46        		ld	b,(hl)
 884    4D16  2B        		dec	hl
 885    4D17  4E        		ld	c,(hl)
 886    4D18  C5        		push	bc
 887    4D19  211B47    		ld	hl,L5553
 888    4D1C  CD0000    		call	_printf
 889    4D1F  F1        		pop	af
 890    4D20  F1        		pop	af
 891                    	; 1743                  sddatprt(sdrdbuf);
 892    4D21  214C00    		ld	hl,_sdrdbuf
 893    4D24  CD8F27    		call	_sddatprt
 894                    	; 1744                  break;
 895    4D27  C33D49    		jp	L1226
 896                    	L1566:
 897                    	; 1745              case 'r':
 898                    	; 1746                  printf(" r - read sector");
 899    4D2A  213747    		ld	hl,L5653
 900    4D2D  CD0000    		call	_printf
 901                    	; 1747                  if (!sdprobe())
 902    4D30  CD0B10    		call	_sdprobe
 903    4D33  79        		ld	a,c
 904    4D34  B0        		or	b
 905    4D35  2009      		jr	nz,L1666
 906                    	; 1748                      {
 907                    	; 1749                      printf(" - not initialized or inserted or faulty\n");
 908    4D37  214847    		ld	hl,L5753
 909    4D3A  CD0000    		call	_printf
 910                    	; 1750                      break;
 911    4D3D  C33D49    		jp	L1226
 912                    	L1666:
 913                    	; 1751                      }
 914                    	; 1752                  if (sdread(sdrdbuf, blockno))
 915    4D40  DD66E5    		ld	h,(ix-27)
 916    4D43  DD6EE4    		ld	l,(ix-28)
 917    4D46  E5        		push	hl
 918    4D47  DD66E3    		ld	h,(ix-29)
 919    4D4A  DD6EE2    		ld	l,(ix-30)
 920    4D4D  E5        		push	hl
 921    4D4E  214C00    		ld	hl,_sdrdbuf
 922    4D51  CDE320    		call	_sdread
 923    4D54  F1        		pop	af
 924    4D55  F1        		pop	af
 925    4D56  79        		ld	a,c
 926    4D57  B0        		or	b
 927    4D58  2819      		jr	z,L1766
 928                    	; 1753                      {
 929                    	; 1754                      printf(" - ok\n");
 930    4D5A  217247    		ld	hl,L5063
 931    4D5D  CD0000    		call	_printf
 932                    	; 1755                      curblkno = blockno;
 933    4D60  210200    		ld	hl,_curblkno
 934    4D63  E5        		push	hl
 935    4D64  DDE5      		push	ix
 936    4D66  C1        		pop	bc
 937    4D67  21E2FF    		ld	hl,65506
 938    4D6A  09        		add	hl,bc
 939    4D6B  E5        		push	hl
 940    4D6C  CD0000    		call	c.mvl
 941    4D6F  F1        		pop	af
 942                    	; 1756                      }
 943                    	; 1757                  else
 944    4D70  C33D49    		jp	L1226
 945                    	L1766:
 946                    	; 1758                      printf(" - read error\n");
 947    4D73  217947    		ld	hl,L5163
 948    4D76  CD0000    		call	_printf
 949    4D79  C33D49    		jp	L1226
 950                    	L1176:
 951                    	; 1759                  break;
 952                    	; 1760              case 's':
 953                    	; 1761                  printf(" s - print SD registers\n");
 954    4D7C  218847    		ld	hl,L5263
 955    4D7F  CD0000    		call	_printf
 956                    	; 1762                  sdprtreg();
 957    4D82  CD2D17    		call	_sdprtreg
 958                    	; 1763                  break;
 959    4D85  C33D49    		jp	L1226
 960                    	L1276:
 961                    	; 1764              case 't':
 962                    	; 1765                  printf(" t - test if card inserted\n");
 963    4D88  21A147    		ld	hl,L5363
 964    4D8B  CD0000    		call	_printf
 965                    	; 1766                  if (sdprobe())
 966    4D8E  CD0B10    		call	_sdprobe
 967    4D91  79        		ld	a,c
 968    4D92  B0        		or	b
 969    4D93  2809      		jr	z,L1376
 970                    	; 1767                      printf(" - ok\n");
 971    4D95  21BD47    		ld	hl,L5463
 972    4D98  CD0000    		call	_printf
 973                    	; 1768                  else
 974    4D9B  C33D49    		jp	L1226
 975                    	L1376:
 976                    	; 1769                      printf(" - not initialized or inserted or faulty\n");
 977    4D9E  21C447    		ld	hl,L5563
 978    4DA1  CD0000    		call	_printf
 979    4DA4  C33D49    		jp	L1226
 980                    	L1576:
 981                    	; 1770                  break;
 982                    	; 1771              case 'u':
 983                    	; 1772                  printf(" u - upload with Xmodem\n");
 984    4DA7  21EE47    		ld	hl,L5663
 985    4DAA  CD0000    		call	_printf
 986                    	; 1773                  if (sdtestflg)
 987    4DAD  2A0000    		ld	hl,(_sdtestflg)
 988    4DB0  7C        		ld	a,h
 989    4DB1  B5        		or	l
 990    4DB2  2815      		jr	z,L1676
 991                    	; 1774                      {
 992                    	; 1775                      printf("Copy from: 0x%04x, to: 0x%04x, size: %d\n",
 993                    	; 1776                          upload, UPLADDR, upload_size);
 994    4DB4  2A0000    		ld	hl,(_upload_size)
 995    4DB7  E5        		push	hl
 996    4DB8  2100F0    		ld	hl,61440
 997    4DBB  E5        		push	hl
 998    4DBC  210000    		ld	hl,_upload
 999    4DBF  E5        		push	hl
1000    4DC0  210748    		ld	hl,L5763
1001    4DC3  CD0000    		call	_printf
1002    4DC6  F1        		pop	af
1003    4DC7  F1        		pop	af
1004    4DC8  F1        		pop	af
1005                    	L1676:
1006                    	; 1777                      } /* sdtestflg */
1007                    	; 1778                  memcpy(UPLADDR, upload, upload_size);
1008    4DC9  2A0000    		ld	hl,(_upload_size)
1009    4DCC  E5        		push	hl
1010    4DCD  210000    		ld	hl,_upload
1011    4DD0  E5        		push	hl
1012    4DD1  2100F0    		ld	hl,61440
1013    4DD4  CD0000    		call	_memcpy
1014    4DD7  F1        		pop	af
1015    4DD8  F1        		pop	af
1016                    	; 1779                  jumpto(UPLADDR);
1017    4DD9  2100F0    		ld	hl,61440
1018    4DDC  CD0000    		call	_jumpto
1019                    	; 1780                  break;
1020    4DDF  C33D49    		jp	L1226
1021                    	L1776:
1022                    	; 1781              case 'w':
1023                    	; 1782                  printf(" w - write sector");
1024    4DE2  213048    		ld	hl,L5073
1025    4DE5  CD0000    		call	_printf
1026                    	; 1783                  if (!sdprobe())
1027    4DE8  CD0B10    		call	_sdprobe
1028    4DEB  79        		ld	a,c
1029    4DEC  B0        		or	b
1030    4DED  2006      		jr	nz,L1007
1031                    	; 1784                      printf(" - not initialized or inserted or faulty\n");
1032    4DEF  214248    		ld	hl,L5173
1033    4DF2  CD0000    		call	_printf
1034                    	L1007:
1035                    	; 1785                  if (sdwrite(sdrdbuf, blockno))
1036    4DF5  DD66E5    		ld	h,(ix-27)
1037    4DF8  DD6EE4    		ld	l,(ix-28)
1038    4DFB  E5        		push	hl
1039    4DFC  DD66E3    		ld	h,(ix-29)
1040    4DFF  DD6EE2    		ld	l,(ix-30)
1041    4E02  E5        		push	hl
1042    4E03  214C00    		ld	hl,_sdrdbuf
1043    4E06  CDA024    		call	_sdwrite
1044    4E09  F1        		pop	af
1045    4E0A  F1        		pop	af
1046    4E0B  79        		ld	a,c
1047    4E0C  B0        		or	b
1048    4E0D  2819      		jr	z,L1107
1049                    	; 1786                      {
1050                    	; 1787                      printf(" - ok\n");
1051    4E0F  216C48    		ld	hl,L5273
1052    4E12  CD0000    		call	_printf
1053                    	; 1788                      curblkno = blockno;
1054    4E15  210200    		ld	hl,_curblkno
1055    4E18  E5        		push	hl
1056    4E19  DDE5      		push	ix
1057    4E1B  C1        		pop	bc
1058    4E1C  21E2FF    		ld	hl,65506
1059    4E1F  09        		add	hl,bc
1060    4E20  E5        		push	hl
1061    4E21  CD0000    		call	c.mvl
1062    4E24  F1        		pop	af
1063                    	; 1789                      }
1064                    	; 1790                  else
1065    4E25  C33D49    		jp	L1226
1066                    	L1107:
1067                    	; 1791                      printf(" - write error\n");
1068    4E28  217348    		ld	hl,L5373
1069    4E2B  CD0000    		call	_printf
1070    4E2E  C33D49    		jp	L1226
1071                    	L1307:
1072                    	; 1792                  break;
1073                    	; 1793              case 0x03: /* Ctrl-C */
1074                    	; 1794                  printf("reloading monitor from EPROM\n");
1075    4E31  218348    		ld	hl,L5473
1076    4E34  CD0000    		call	_printf
1077                    	; 1795                  reload();
1078    4E37  CD0000    		call	_reload
1079                    	; 1796                  break; /* not really needed, will never get here */
1080    4E3A  C33D49    		jp	L1226
1081                    	L1407:
1082                    	; 1797              default:
1083                    	; 1798                  printf(" invalid command\n");
1084    4E3D  21A148    		ld	hl,L5573
1085    4E40  CD0000    		call	_printf
1086    4E43  C33D49    		jp	L1226
1087                    	L1526:
1088                    	; 1799              }
1089                    	; 1800          }
1090    4E46  C33D49    		jp	L1226
1091                    	; 1801      }
1092                    	; 1802  
1093                    		.psect	_bss
1094                    	_sdtestflg:
1095                    		.byte	[2]
1096                    	_curblkno:
1097                    		.byte	[4]
1098                    	_blkmult:
1099                    		.byte	[4]
1100                    	_sdver2:
1101                    		.byte	[2]
1102                    	_sdinitok:
1103                    		.byte	[2]
1104                    	_partdsk:
1105                    		.byte	[2]
1106                    	_curblkok:
1107                    		.byte	[2]
1108                    	_ebrnext:
1109                    		.byte	[4]
1110                    	_ebrrecidx:
1111                    		.byte	[2]
1112                    	_ebrrecs:
1113                    		.byte	[16]
1114                    	_csdreg:
1115                    		.byte	[16]
1116                    	_cidreg:
1117                    		.byte	[16]
1118                    	_ocrreg:
1119                    		.byte	[4]
1120                    	_sdrdbuf:
1121                    		.byte	[512]
1122                    	_rampptr:
1123                    		.byte	[2]
1124                    	_dsksign:
1125                    		.byte	[4]
1126                    	_dskmap:
1127                    		.byte	[512]
1128                    		.public	_sdgpthdr
1129                    		.public	_curblkno
1130                    		.external	c.ulrsh
1131                    		.external	c.rets0
1132                    		.public	_CRC16_one
1133                    		.external	_jumpto
1134                    		.external	_upload_size
1135                    		.external	c.savs0
1136                    		.external	_getchar
1137                    		.external	c.lcmp
1138                    		.public	_cmd55
1139                    		.public	_curblkok
1140                    		.public	_cmd17
1141                    		.public	_cmd16
1142                    		.public	_cmd24
1143                    		.public	_ramprobe
1144                    		.public	_sdver2
1145                    		.external	c.r1
1146                    		.external	_spideselect
1147                    		.public	_cmd10
1148                    		.external	c.r0
1149                    		.external	_getkline
1150                    		.external	c.jtab
1151                    		.external	_printf
1152                    		.external	_ledon
1153                    		.public	_sdtestflg
1154                    		.public	_sdmbrpart
1155                    		.external	_spiselect
1156                    		.external	_memset
1157                    		.external	_memcpy
1158                    		.public	_sdinit
1159                    		.public	_gptcpm
1160                    		.public	_sdmbrentry
1161                    		.external	c.ladd
1162                    		.public	_rampptr
1163                    		.external	_upload
1164                    		.public	_sdwrite
1165                    		.public	_ocrreg
1166                    		.external	c.mvl
1167                    		.public	_mbrcpm
1168                    		.public	_dskmap
1169                    		.external	_memcmp
1170                    		.public	_prtguid
1171                    		.external	_sscanf
1172                    		.public	_execin
1173                    		.public	_blkmult
1174                    		.public	_acmd41
1175                    		.public	_partdsk
1176                    		.public	_mbrexcode
1177                    		.public	_ebrrecidx
1178                    		.public	_ebrnext
1179                    		.public	_csdreg
1180                    		.external	_reload
1181                    		.external	_putchar
1182                    		.public	_sdcommand
1183                    		.external	_binsize
1184                    		.external	c.ursh
1185                    		.public	_dsksign
1186                    		.public	_sdread
1187                    		.external	_ledoff
1188                    		.external	c.rets
1189                    		.public	_CRC7_one
1190                    		.public	_sdprobe
1191                    		.external	c.savs
1192                    		.public	_cidreg
1193                    		.public	_builddate
1194                    		.public	_cmd9
1195                    		.external	c.lmul
1196                    		.public	_cmd8
1197                    		.external	c.0mvf
1198                    		.public	_sdprtreg
1199                    		.public	_sdrdbuf
1200                    		.external	c.udiv
1201                    		.external	c.imul
1202                    		.external	c.lsub
1203                    		.public	_prtgptent
1204                    		.external	c.irsh
1205                    		.external	_binstart
1206                    		.external	c.umod
1207                    		.public	_ebrrecs
1208                    		.public	_sddatprt
1209                    		.public	_main
1210                    		.external	c.llsh
1211                    		.public	_sdinitok
1212                    		.external	_spiio
1213                    		.public	_cmd0
1214                    		.external	c.ilsh
1215                    		.public	_cmd58
1216                    		.end
