   1                    	;    1  /*  z80sdbt.c Boot and SD card test program.
   2                    	;    2   *
   3                    	;    3   *  Boot code for my DIY Z80 Computer. This
   4                    	;    4   *  program is compiled with Whitesmiths/COSMIC
   5                    	;    5   *  C compiler for Z80.
   6                    	;    6   *
   7                    	;    7   *  Initializes the hardware and detects the
   8                    	;    8   *  presence and partitioning of an attached SD card.
   9                    	;    9   *
  10                    	;   10   *  You are free to use, modify, and redistribute
  11                    	;   11   *  this source code. No warranties are given.
  12                    	;   12   *  Hastily Cobbled Together 2021 and 2022
  13                    	;   13   *  by Hans-Ake Lund
  14                    	;   14   *
  15                    	;   15   */
  16                    	;   16  
  17                    	;   17  #include <std.h>
  18                    	;   18  #include "z80computer.h"
  19                    	;   19  #include "builddate.h"
  20                    		.psect	_text
  21                    	_builddate:
  22    0000  62        		.byte	98
  23    0001  75        		.byte	117
  24    0002  69        		.byte	105
  25    0003  6C        		.byte	108
  26    0004  74        		.byte	116
  27    0005  20        		.byte	32
  28    0006  32        		.byte	50
  29    0007  30        		.byte	48
  30    0008  32        		.byte	50
  31    0009  32        		.byte	50
  32    000A  2D        		.byte	45
  33    000B  30        		.byte	48
  34    000C  31        		.byte	49
  35    000D  2D        		.byte	45
  36    000E  32        		.byte	50
  37    000F  39        		.byte	57
  38    0010  20        		.byte	32
  39    0011  31        		.byte	49
  40    0012  35        		.byte	53
  41    0013  3A        		.byte	58
  42    0014  32        		.byte	50
  43    0015  37        		.byte	55
  44    0016  00        		.byte	0
  45                    	;   20  
  46                    	;   21  /* Program name and version */
  47                    	;   22  #define PRGNAME "z80sdbt "
  48                    	;   23  #define VERSION "version 0.8, "
  49                    	;   24  /* Address in high RAM where to copy uploader */
  50                    	;   25  #define UPLADDR 0xf000
  51                    	;   26  
  52                    	;   27  /* This code should be cleaned up when
  53                    	;   28     remaining functions are implemented
  54                    	;   29   */
  55                    	;   30  #define PARTZRO 0  /* Empty partition entry */
  56                    	;   31  #define PARTMBR 1  /* MBR partition */
  57                    	;   32  #define PARTEBR 2  /* EBR logical partition */
  58                    	;   33  #define PARTGPT 3  /* GPT partition */
  59                    	;   34  #define EBRCONT 20 /* EBR container partition in MBR */
  60                    	;   35  
  61                    	;   36  struct partentry
  62                    	;   37      {
  63                    	;   38      char partype;
  64                    	;   39      char dskletter;
  65                    	;   40      int bootable;
  66                    	;   41      unsigned long dskstart;
  67                    	;   42      unsigned long dskend;
  68                    	;   43      unsigned long dsksize;
  69                    	;   44      unsigned char dsktype[16];
  70                    	;   45      } dskmap[16];
  71                    	;   46  
  72                    	;   47  unsigned char dsksign[4]; /* MBR/EBR disk signature */
  73                    	;   48  
  74                    	;   49  /* Function prototypes */
  75                    	;   50  void sdmbrpart(unsigned long);
  76                    	;   51  
  77                    	;   52  /* External data */
  78                    	;   53  extern const char upload[];
  79                    	;   54  extern const int upload_size;
  80                    	;   55  
  81                    	;   56  /* RAM/EPROM probe */
  82                    	;   57  const int ramprobe = 0;
  83                    	_ramprobe:
  84                    		.byte	[2]
  85                    	;   58  int *rampptr;
  86                    	;   59  
  87                    	;   60  /* Response length in bytes
  88                    	;   61   */
  89                    	;   62  #define R1_LEN 1
  90                    	;   63  #define R3_LEN 5
  91                    	;   64  #define R7_LEN 5
  92                    	;   65  
  93                    	;   66  /* The SD card commands (5 bytes) and a CRC7 byte as the last byte.
  94                    	;   67   * (The CRC7 byte in the tables below are only for information,
  95                    	;   68   * it is calculated by the sdcommand routine.)
  96                    	;   69   */
  97                    	;   70  const unsigned char cmd0[] = {0x40, 0x00, 0x00, 0x00, 0x00, 0x95};
  98                    	_cmd0:
  99    0019  40        		.byte	64
 100                    		.byte	[1]
 101                    		.byte	[1]
 102                    		.byte	[1]
 103                    		.byte	[1]
 104    001E  95        		.byte	149
 105                    	;   71  const unsigned char cmd8[] = {0x48, 0x00, 0x00, 0x01, 0xaa, 0x87};
 106                    	_cmd8:
 107    001F  48        		.byte	72
 108                    		.byte	[1]
 109                    		.byte	[1]
 110    0022  01        		.byte	1
 111    0023  AA        		.byte	170
 112    0024  87        		.byte	135
 113                    	;   72  const unsigned char cmd9[] = {0x49, 0x00, 0x00, 0x00, 0x00, 0xaf};
 114                    	_cmd9:
 115    0025  49        		.byte	73
 116                    		.byte	[1]
 117                    		.byte	[1]
 118                    		.byte	[1]
 119                    		.byte	[1]
 120    002A  AF        		.byte	175
 121                    	;   73  const unsigned char cmd10[] = {0x4a, 0x00, 0x00, 0x00, 0x00, 0x1b};
 122                    	_cmd10:
 123    002B  4A        		.byte	74
 124                    		.byte	[1]
 125                    		.byte	[1]
 126                    		.byte	[1]
 127                    		.byte	[1]
 128    0030  1B        		.byte	27
 129                    	;   74  const unsigned char cmd16[] = {0x50, 0x00, 0x00, 0x02, 0x00, 0x15};
 130                    	_cmd16:
 131    0031  50        		.byte	80
 132                    		.byte	[1]
 133                    		.byte	[1]
 134    0034  02        		.byte	2
 135                    		.byte	[1]
 136    0036  15        		.byte	21
 137                    	;   75  const unsigned char cmd17[] = {0x51, 0x00, 0x00, 0x00, 0x00, 0x55};
 138                    	_cmd17:
 139    0037  51        		.byte	81
 140                    		.byte	[1]
 141                    		.byte	[1]
 142                    		.byte	[1]
 143                    		.byte	[1]
 144    003C  55        		.byte	85
 145                    	;   76  const unsigned char cmd24[] = {0x58, 0x00, 0x00, 0x00, 0x00, 0x6f};
 146                    	_cmd24:
 147    003D  58        		.byte	88
 148                    		.byte	[1]
 149                    		.byte	[1]
 150                    		.byte	[1]
 151                    		.byte	[1]
 152    0042  6F        		.byte	111
 153                    	;   77  const unsigned char cmd55[] = {0x77, 0x00, 0x00, 0x00, 0x00, 0x65};
 154                    	_cmd55:
 155    0043  77        		.byte	119
 156                    		.byte	[1]
 157                    		.byte	[1]
 158                    		.byte	[1]
 159                    		.byte	[1]
 160    0048  65        		.byte	101
 161                    	;   78  const unsigned char cmd58[] = {0x7a, 0x00, 0x00, 0x00, 0x00, 0xfd};
 162                    	_cmd58:
 163    0049  7A        		.byte	122
 164                    		.byte	[1]
 165                    		.byte	[1]
 166                    		.byte	[1]
 167                    		.byte	[1]
 168    004E  FD        		.byte	253
 169                    	;   79  const unsigned char acmd41[] = {0x69, 0x40, 0x00, 0x01, 0xaa, 0x33};
 170                    	_acmd41:
 171    004F  69        		.byte	105
 172    0050  40        		.byte	64
 173                    		.byte	[1]
 174    0052  01        		.byte	1
 175    0053  AA        		.byte	170
 176    0054  33        		.byte	51
 177                    	;   80  
 178                    	;   81  /* Partition identifiers
 179                    	;   82   */
 180                    	;   83  /* For GPT I have decided that a CP/M partition
 181                    	;   84   * has GUID: AC7176FD-8D55-4FFF-86A5-A36D6368D0CB
 182                    	;   85   */
 183                    	;   86  const unsigned char gptcpm[] =
 184                    	;   87      {
 185                    	_gptcpm:
 186                    	;   88      0xfd, 0x76, 0x71, 0xac, 0x55, 0x8d, 0xff, 0x4f,
 187    0055  FD        		.byte	253
 188    0056  76        		.byte	118
 189    0057  71        		.byte	113
 190    0058  AC        		.byte	172
 191    0059  55        		.byte	85
 192    005A  8D        		.byte	141
 193    005B  FF        		.byte	255
 194    005C  4F        		.byte	79
 195                    	;   89      0x86, 0xa5, 0xa3, 0x6d, 0x63, 0x68, 0xd0, 0xcb
 196    005D  86        		.byte	134
 197    005E  A5        		.byte	165
 198    005F  A3        		.byte	163
 199    0060  6D        		.byte	109
 200    0061  63        		.byte	99
 201    0062  68        		.byte	104
 202    0063  D0        		.byte	208
 203                    	;   90      };
 204    0064  CB        		.byte	203
 205                    	;   91  /* For MBR/EBR the partition type for CP/M is 0x52
 206                    	;   92   * according to: https://en.wikipedia.org/wiki/Partition_type
 207                    	;   93   */
 208                    	;   94  const unsigned char mbrcpm = 0x52;    /* CP/M partition */
 209                    	_mbrcpm:
 210    0065  52        		.byte	82
 211                    	;   95  const unsigned char mbrexcode = 0x5f; /* Z80 executable code partition */
 212                    	_mbrexcode:
 213    0066  5F        		.byte	95
 214                    	;   96  /* has a special format that */
 215                    	;   97  /* includes number of sectors to */
 216                    	;   98  /* load and a signature, TBD */
 217                    	;   99  
 218                    	;  100  /* Buffers
 219                    	;  101   */
 220                    	;  102  unsigned char sdrdbuf[512];  /* recieved data from the SD card */
 221                    	;  103  
 222                    	;  104  unsigned char ocrreg[4];     /* SD card OCR register */
 223                    	;  105  unsigned char cidreg[16];    /* SD card CID register */
 224                    	;  106  unsigned char csdreg[16];    /* SD card CSD register */
 225                    	;  107  unsigned long ebrrecs[4];    /* detected EBR records to process */
 226                    	;  108  int ebrrecidx; /* how many EBR records that are populated */
 227                    	;  109  unsigned long ebrnext; /* next chained ebr record */
 228                    	;  110  
 229                    	;  111  /* Variables
 230                    	;  112   */
 231                    	;  113  int curblkok;  /* if YES curblockno is read into buffer */
 232                    	;  114  int partdsk;   /* partition/disk number, 0 = disk A */
 233                    	;  115  int sdinitok;  /* SD card initialized and ready */
 234                    	;  116  int sdver2;    /* SD card version 2 if YES, version 1 if NO */
 235                    	;  117  unsigned long blkmult;   /* block address multiplier */
 236                    	;  118  unsigned long curblkno;  /* block in buffer if curblkok == YES */
 237                    	;  119  
 238                    	;  120  /* debug bool */
 239                    	;  121  int sdtestflg;
 240                    	;  122  
 241                    	;  123  /* CRC routines from:
 242                    	;  124   * https://github.com/LonelyWolf/stm32/blob/master/stm32l-dosfs/sdcard.c
 243                    	;  125   */
 244                    	;  126  
 245                    	;  127  /*
 246                    	;  128  // Calculate CRC7
 247                    	;  129  // It's a 7 bit CRC with polynomial x^7 + x^3 + 1
 248                    	;  130  // input:
 249                    	;  131  //   crcIn - the CRC before (0 for first step)
 250                    	;  132  //   data - byte for CRC calculation
 251                    	;  133  // return: the new CRC7
 252                    	;  134  */
 253                    	;  135  unsigned char CRC7_one(unsigned char crcIn, unsigned char data)
 254                    	;  136      {
 255                    	_CRC7_one:
 256    0067  CD0000    		call	c.savs
 257    006A  F5        		push	af
 258    006B  F5        		push	af
 259    006C  F5        		push	af
 260    006D  F5        		push	af
 261                    	;  137      const unsigned char g = 0x89;
 262    006E  DD36F989  		ld	(ix-7),137
 263                    	;  138      unsigned char i;
 264                    	;  139  
 265                    	;  140      crcIn ^= data;
 266    0072  DD7E04    		ld	a,(ix+4)
 267    0075  DDAE06    		xor	(ix+6)
 268    0078  DD7704    		ld	(ix+4),a
 269    007B  DD7E05    		ld	a,(ix+5)
 270    007E  DDAE07    		xor	(ix+7)
 271    0081  DD7705    		ld	(ix+5),a
 272                    	;  141      for (i = 0; i < 8; i++)
 273    0084  DD36F800  		ld	(ix-8),0
 274                    	L1:
 275    0088  DD7EF8    		ld	a,(ix-8)
 276    008B  FE08      		cp	8
 277    008D  302F      		jr	nc,L11
 278                    	;  142          {
 279                    	;  143          if (crcIn & 0x80) crcIn ^= g;
 280    008F  DD6E04    		ld	l,(ix+4)
 281    0092  DD6605    		ld	h,(ix+5)
 282    0095  CB7D      		bit	7,l
 283    0097  2813      		jr	z,L14
 284    0099  DD6EF9    		ld	l,(ix-7)
 285    009C  97        		sub	a
 286    009D  67        		ld	h,a
 287    009E  DD7E04    		ld	a,(ix+4)
 288    00A1  AD        		xor	l
 289    00A2  DD7704    		ld	(ix+4),a
 290    00A5  DD7E05    		ld	a,(ix+5)
 291    00A8  AC        		xor	h
 292    00A9  DD7705    		ld	(ix+5),a
 293                    	L14:
 294                    	;  144          crcIn <<= 1;
 295    00AC  DD6E04    		ld	l,(ix+4)
 296    00AF  DD6605    		ld	h,(ix+5)
 297    00B2  29        		add	hl,hl
 298    00B3  DD7504    		ld	(ix+4),l
 299    00B6  DD7405    		ld	(ix+5),h
 300                    	;  145          }
 301    00B9  DD34F8    		inc	(ix-8)
 302    00BC  18CA      		jr	L1
 303                    	L11:
 304                    	;  146  
 305                    	;  147      return crcIn;
 306    00BE  DD6E04    		ld	l,(ix+4)
 307    00C1  DD6605    		ld	h,(ix+5)
 308    00C4  4D        		ld	c,l
 309    00C5  44        		ld	b,h
 310    00C6  C30000    		jp	c.rets
 311                    	;  148      }
 312                    	;  149  
 313                    	;  150  /*
 314                    	;  151  // Calculate CRC16 CCITT
 315                    	;  152  // It's a 16 bit CRC with polynomial x^16 + x^12 + x^5 + 1
 316                    	;  153  // input:
 317                    	;  154  //   crcIn - the CRC before (0 for rist step)
 318                    	;  155  //   data - byte for CRC calculation
 319                    	;  156  // return: the CRC16 value
 320                    	;  157  */
 321                    	;  158  unsigned int CRC16_one(unsigned int crcIn, unsigned char data)
 322                    	;  159      {
 323                    	_CRC16_one:
 324    00C9  CD0000    		call	c.savs
 325                    	;  160      crcIn  = (unsigned char)(crcIn >> 8)|(crcIn << 8);
 326    00CC  DD6E04    		ld	l,(ix+4)
 327    00CF  DD6605    		ld	h,(ix+5)
 328    00D2  E5        		push	hl
 329    00D3  210800    		ld	hl,8
 330    00D6  E5        		push	hl
 331    00D7  CD0000    		call	c.ursh
 332    00DA  E1        		pop	hl
 333    00DB  E5        		push	hl
 334    00DC  DD6E04    		ld	l,(ix+4)
 335    00DF  DD6605    		ld	h,(ix+5)
 336    00E2  29        		add	hl,hl
 337    00E3  29        		add	hl,hl
 338    00E4  29        		add	hl,hl
 339    00E5  29        		add	hl,hl
 340    00E6  29        		add	hl,hl
 341    00E7  29        		add	hl,hl
 342    00E8  29        		add	hl,hl
 343    00E9  29        		add	hl,hl
 344    00EA  C1        		pop	bc
 345    00EB  79        		ld	a,c
 346    00EC  B5        		or	l
 347    00ED  4F        		ld	c,a
 348    00EE  78        		ld	a,b
 349    00EF  B4        		or	h
 350    00F0  47        		ld	b,a
 351    00F1  DD7104    		ld	(ix+4),c
 352    00F4  DD7005    		ld	(ix+5),b
 353                    	;  161      crcIn ^=  data;
 354    00F7  DD7E04    		ld	a,(ix+4)
 355    00FA  DDAE06    		xor	(ix+6)
 356    00FD  DD7704    		ld	(ix+4),a
 357    0100  DD7E05    		ld	a,(ix+5)
 358    0103  DDAE07    		xor	(ix+7)
 359    0106  DD7705    		ld	(ix+5),a
 360                    	;  162      crcIn ^= (unsigned char)(crcIn & 0xff) >> 4;
 361    0109  DD6E04    		ld	l,(ix+4)
 362    010C  DD6605    		ld	h,(ix+5)
 363    010F  7D        		ld	a,l
 364    0110  E6FF      		and	255
 365    0112  6F        		ld	l,a
 366    0113  97        		sub	a
 367    0114  67        		ld	h,a
 368    0115  4D        		ld	c,l
 369    0116  97        		sub	a
 370    0117  47        		ld	b,a
 371    0118  C5        		push	bc
 372    0119  210400    		ld	hl,4
 373    011C  E5        		push	hl
 374    011D  CD0000    		call	c.irsh
 375    0120  E1        		pop	hl
 376    0121  DD7E04    		ld	a,(ix+4)
 377    0124  AD        		xor	l
 378    0125  DD7704    		ld	(ix+4),a
 379    0128  DD7E05    		ld	a,(ix+5)
 380    012B  AC        		xor	h
 381    012C  DD7705    		ld	(ix+5),a
 382                    	;  163      crcIn ^= (crcIn << 8) << 4;
 383    012F  DD6E04    		ld	l,(ix+4)
 384    0132  DD6605    		ld	h,(ix+5)
 385    0135  29        		add	hl,hl
 386    0136  29        		add	hl,hl
 387    0137  29        		add	hl,hl
 388    0138  29        		add	hl,hl
 389    0139  29        		add	hl,hl
 390    013A  29        		add	hl,hl
 391    013B  29        		add	hl,hl
 392    013C  29        		add	hl,hl
 393    013D  29        		add	hl,hl
 394    013E  29        		add	hl,hl
 395    013F  29        		add	hl,hl
 396    0140  29        		add	hl,hl
 397    0141  DD7E04    		ld	a,(ix+4)
 398    0144  AD        		xor	l
 399    0145  DD7704    		ld	(ix+4),a
 400    0148  DD7E05    		ld	a,(ix+5)
 401    014B  AC        		xor	h
 402    014C  DD7705    		ld	(ix+5),a
 403                    	;  164      crcIn ^= ((crcIn & 0xff) << 4) << 1;
 404    014F  DD6E04    		ld	l,(ix+4)
 405    0152  DD6605    		ld	h,(ix+5)
 406    0155  7D        		ld	a,l
 407    0156  E6FF      		and	255
 408    0158  6F        		ld	l,a
 409    0159  97        		sub	a
 410    015A  67        		ld	h,a
 411    015B  29        		add	hl,hl
 412    015C  29        		add	hl,hl
 413    015D  29        		add	hl,hl
 414    015E  29        		add	hl,hl
 415    015F  29        		add	hl,hl
 416    0160  DD7E04    		ld	a,(ix+4)
 417    0163  AD        		xor	l
 418    0164  DD7704    		ld	(ix+4),a
 419    0167  DD7E05    		ld	a,(ix+5)
 420    016A  AC        		xor	h
 421    016B  DD7705    		ld	(ix+5),a
 422                    	;  165  
 423                    	;  166      return crcIn;
 424    016E  DD4E04    		ld	c,(ix+4)
 425    0171  DD4605    		ld	b,(ix+5)
 426    0174  C30000    		jp	c.rets
 427                    	;  167      }
 428                    	;  168  
 429                    	;  169  /* Send command to SD card and recieve answer.
 430                    	;  170   * A command is 5 bytes long and is followed by
 431                    	;  171   * a CRC7 checksum byte.
 432                    	;  172   * Returns a pointer to the response
 433                    	;  173   * or 0 if no response start bit found.
 434                    	;  174   */
 435                    	;  175  unsigned char *sdcommand(unsigned char *sdcmdp,
 436                    	;  176                           unsigned char *recbuf, int recbytes)
 437                    	;  177      {
 438                    	_sdcommand:
 439    0177  CD0000    		call	c.savs
 440    017A  21F2FF    		ld	hl,65522
 441    017D  39        		add	hl,sp
 442    017E  F9        		ld	sp,hl
 443                    	;  178      int searchn;  /* byte counter to search for response */
 444                    	;  179      int sdcbytes; /* byte counter for bytes to send */
 445                    	;  180      unsigned char *retptr; /* pointer used to store response */
 446                    	;  181      unsigned char rbyte;   /* recieved byte */
 447                    	;  182      unsigned char crc = 0; /* calculated CRC7 */
 448    017F  DD36F200  		ld	(ix-14),0
 449                    	;  183  
 450                    	;  184      /* send 8*2 clockpules */
 451                    	;  185      spiio(0xff);
 452    0183  21FF00    		ld	hl,255
 453    0186  CD0000    		call	_spiio
 454                    	;  186      spiio(0xff);
 455    0189  21FF00    		ld	hl,255
 456    018C  CD0000    		call	_spiio
 457                    	;  187      for (sdcbytes = 5; 0 < sdcbytes; sdcbytes--) /* send bytes */
 458    018F  DD36F605  		ld	(ix-10),5
 459    0193  DD36F700  		ld	(ix-9),0
 460                    	L15:
 461    0197  97        		sub	a
 462    0198  DD96F6    		sub	(ix-10)
 463    019B  3E00      		ld	a,0
 464    019D  DD9EF7    		sbc	a,(ix-9)
 465    01A0  F2DC01    		jp	p,L16
 466                    	;  188          {
 467                    	;  189          crc = CRC7_one(crc, *sdcmdp);
 468    01A3  DD6E04    		ld	l,(ix+4)
 469    01A6  DD6605    		ld	h,(ix+5)
 470    01A9  6E        		ld	l,(hl)
 471    01AA  97        		sub	a
 472    01AB  67        		ld	h,a
 473    01AC  E5        		push	hl
 474    01AD  DD6EF2    		ld	l,(ix-14)
 475    01B0  97        		sub	a
 476    01B1  67        		ld	h,a
 477    01B2  CD6700    		call	_CRC7_one
 478    01B5  F1        		pop	af
 479    01B6  DD71F2    		ld	(ix-14),c
 480                    	;  190          spiio(*sdcmdp++);
 481    01B9  DD6E04    		ld	l,(ix+4)
 482    01BC  DD6605    		ld	h,(ix+5)
 483    01BF  DD3404    		inc	(ix+4)
 484    01C2  2003      		jr	nz,L01
 485    01C4  DD3405    		inc	(ix+5)
 486                    	L01:
 487    01C7  6E        		ld	l,(hl)
 488    01C8  97        		sub	a
 489    01C9  67        		ld	h,a
 490    01CA  CD0000    		call	_spiio
 491                    	;  191          }
 492    01CD  DD6EF6    		ld	l,(ix-10)
 493    01D0  DD66F7    		ld	h,(ix-9)
 494    01D3  2B        		dec	hl
 495    01D4  DD75F6    		ld	(ix-10),l
 496    01D7  DD74F7    		ld	(ix-9),h
 497    01DA  18BB      		jr	L15
 498                    	L16:
 499                    	;  192      spiio(crc | 0x01);
 500    01DC  DD6EF2    		ld	l,(ix-14)
 501    01DF  97        		sub	a
 502    01E0  67        		ld	h,a
 503    01E1  CBC5      		set	0,l
 504    01E3  CD0000    		call	_spiio
 505                    	;  193      /* search for recieved byte with start bit
 506                    	;  194         for a maximum of 10 recieved bytes  */
 507                    	;  195      for (searchn = 10; 0 < searchn; searchn--)
 508    01E6  DD36F80A  		ld	(ix-8),10
 509    01EA  DD36F900  		ld	(ix-7),0
 510                    	L111:
 511    01EE  97        		sub	a
 512    01EF  DD96F8    		sub	(ix-8)
 513    01F2  3E00      		ld	a,0
 514    01F4  DD9EF9    		sbc	a,(ix-7)
 515    01F7  F21902    		jp	p,L121
 516                    	;  196          {
 517                    	;  197          rbyte = spiio(0xff);
 518    01FA  21FF00    		ld	hl,255
 519    01FD  CD0000    		call	_spiio
 520    0200  DD71F3    		ld	(ix-13),c
 521                    	;  198          if ((rbyte & 0x80) == 0)
 522    0203  DD6EF3    		ld	l,(ix-13)
 523    0206  CB7D      		bit	7,l
 524    0208  280F      		jr	z,L121
 525                    	;  199              break;
 526                    	L131:
 527    020A  DD6EF8    		ld	l,(ix-8)
 528    020D  DD66F9    		ld	h,(ix-7)
 529    0210  2B        		dec	hl
 530    0211  DD75F8    		ld	(ix-8),l
 531    0214  DD74F9    		ld	(ix-7),h
 532    0217  18D5      		jr	L111
 533                    	L121:
 534                    	;  200          }
 535                    	;  201      if (searchn == 0) /* no start bit found */
 536    0219  DD7EF8    		ld	a,(ix-8)
 537    021C  DDB6F9    		or	(ix-7)
 538    021F  2006      		jr	nz,L161
 539                    	;  202          return (NO);
 540    0221  010000    		ld	bc,0
 541    0224  C30000    		jp	c.rets
 542                    	L161:
 543                    	;  203      retptr = recbuf;
 544    0227  DD7E06    		ld	a,(ix+6)
 545    022A  DD77F4    		ld	(ix-12),a
 546    022D  DD7E07    		ld	a,(ix+7)
 547    0230  DD77F5    		ld	(ix-11),a
 548                    	;  204      *retptr++ = rbyte;
 549    0233  DD6EF4    		ld	l,(ix-12)
 550    0236  DD66F5    		ld	h,(ix-11)
 551    0239  DD34F4    		inc	(ix-12)
 552    023C  2003      		jr	nz,L21
 553    023E  DD34F5    		inc	(ix-11)
 554                    	L21:
 555    0241  DD7EF3    		ld	a,(ix-13)
 556    0244  77        		ld	(hl),a
 557                    	L171:
 558                    	;  205      for (; 1 < recbytes; recbytes--) /* recieve bytes */
 559    0245  3E01      		ld	a,1
 560    0247  DD9608    		sub	(ix+8)
 561    024A  3E00      		ld	a,0
 562    024C  DD9E09    		sbc	a,(ix+9)
 563    024F  F27802    		jp	p,L102
 564                    	;  206          *retptr++ = spiio(0xff);
 565    0252  DD6EF4    		ld	l,(ix-12)
 566    0255  DD66F5    		ld	h,(ix-11)
 567    0258  DD34F4    		inc	(ix-12)
 568    025B  2003      		jr	nz,L41
 569    025D  DD34F5    		inc	(ix-11)
 570                    	L41:
 571    0260  E5        		push	hl
 572    0261  21FF00    		ld	hl,255
 573    0264  CD0000    		call	_spiio
 574    0267  E1        		pop	hl
 575    0268  71        		ld	(hl),c
 576    0269  DD6E08    		ld	l,(ix+8)
 577    026C  DD6609    		ld	h,(ix+9)
 578    026F  2B        		dec	hl
 579    0270  DD7508    		ld	(ix+8),l
 580    0273  DD7409    		ld	(ix+9),h
 581    0276  18CD      		jr	L171
 582                    	L102:
 583                    	;  207      return (recbuf);
 584    0278  DD4E06    		ld	c,(ix+6)
 585    027B  DD4607    		ld	b,(ix+7)
 586    027E  C30000    		jp	c.rets
 587                    	L51:
 588    0281  0A        		.byte	10
 589    0282  53        		.byte	83
 590    0283  65        		.byte	101
 591    0284  6E        		.byte	110
 592    0285  74        		.byte	116
 593    0286  20        		.byte	32
 594    0287  38        		.byte	56
 595    0288  2A        		.byte	42
 596    0289  38        		.byte	56
 597    028A  20        		.byte	32
 598    028B  28        		.byte	40
 599    028C  37        		.byte	55
 600    028D  32        		.byte	50
 601    028E  29        		.byte	41
 602    028F  20        		.byte	32
 603    0290  63        		.byte	99
 604    0291  6C        		.byte	108
 605    0292  6F        		.byte	111
 606    0293  63        		.byte	99
 607    0294  6B        		.byte	107
 608    0295  20        		.byte	32
 609    0296  70        		.byte	112
 610    0297  75        		.byte	117
 611    0298  6C        		.byte	108
 612    0299  73        		.byte	115
 613    029A  65        		.byte	101
 614    029B  73        		.byte	115
 615    029C  2C        		.byte	44
 616    029D  20        		.byte	32
 617    029E  73        		.byte	115
 618    029F  65        		.byte	101
 619    02A0  6C        		.byte	108
 620    02A1  65        		.byte	101
 621    02A2  63        		.byte	99
 622    02A3  74        		.byte	116
 623    02A4  20        		.byte	32
 624    02A5  6E        		.byte	110
 625    02A6  6F        		.byte	111
 626    02A7  74        		.byte	116
 627    02A8  20        		.byte	32
 628    02A9  61        		.byte	97
 629    02AA  63        		.byte	99
 630    02AB  74        		.byte	116
 631    02AC  69        		.byte	105
 632    02AD  76        		.byte	118
 633    02AE  65        		.byte	101
 634    02AF  0A        		.byte	10
 635    02B0  00        		.byte	0
 636                    	L52:
 637    02B1  43        		.byte	67
 638    02B2  4D        		.byte	77
 639    02B3  44        		.byte	68
 640    02B4  30        		.byte	48
 641    02B5  3A        		.byte	58
 642    02B6  20        		.byte	32
 643    02B7  6E        		.byte	110
 644    02B8  6F        		.byte	111
 645    02B9  20        		.byte	32
 646    02BA  72        		.byte	114
 647    02BB  65        		.byte	101
 648    02BC  73        		.byte	115
 649    02BD  70        		.byte	112
 650    02BE  6F        		.byte	111
 651    02BF  6E        		.byte	110
 652    02C0  73        		.byte	115
 653    02C1  65        		.byte	101
 654    02C2  0A        		.byte	10
 655    02C3  00        		.byte	0
 656                    	L53:
 657    02C4  43        		.byte	67
 658    02C5  4D        		.byte	77
 659    02C6  44        		.byte	68
 660    02C7  30        		.byte	48
 661    02C8  3A        		.byte	58
 662    02C9  20        		.byte	32
 663    02CA  47        		.byte	71
 664    02CB  4F        		.byte	79
 665    02CC  5F        		.byte	95
 666    02CD  49        		.byte	73
 667    02CE  44        		.byte	68
 668    02CF  4C        		.byte	76
 669    02D0  45        		.byte	69
 670    02D1  5F        		.byte	95
 671    02D2  53        		.byte	83
 672    02D3  54        		.byte	84
 673    02D4  41        		.byte	65
 674    02D5  54        		.byte	84
 675    02D6  45        		.byte	69
 676    02D7  2C        		.byte	44
 677    02D8  20        		.byte	32
 678    02D9  52        		.byte	82
 679    02DA  31        		.byte	49
 680    02DB  20        		.byte	32
 681    02DC  72        		.byte	114
 682    02DD  65        		.byte	101
 683    02DE  73        		.byte	115
 684    02DF  70        		.byte	112
 685    02E0  6F        		.byte	111
 686    02E1  6E        		.byte	110
 687    02E2  73        		.byte	115
 688    02E3  65        		.byte	101
 689    02E4  20        		.byte	32
 690    02E5  5B        		.byte	91
 691    02E6  25        		.byte	37
 692    02E7  30        		.byte	48
 693    02E8  32        		.byte	50
 694    02E9  78        		.byte	120
 695    02EA  5D        		.byte	93
 696    02EB  0A        		.byte	10
 697    02EC  00        		.byte	0
 698                    	L54:
 699    02ED  43        		.byte	67
 700    02EE  4D        		.byte	77
 701    02EF  44        		.byte	68
 702    02F0  38        		.byte	56
 703    02F1  3A        		.byte	58
 704    02F2  20        		.byte	32
 705    02F3  6E        		.byte	110
 706    02F4  6F        		.byte	111
 707    02F5  20        		.byte	32
 708    02F6  72        		.byte	114
 709    02F7  65        		.byte	101
 710    02F8  73        		.byte	115
 711    02F9  70        		.byte	112
 712    02FA  6F        		.byte	111
 713    02FB  6E        		.byte	110
 714    02FC  73        		.byte	115
 715    02FD  65        		.byte	101
 716    02FE  0A        		.byte	10
 717    02FF  00        		.byte	0
 718                    	L55:
 719    0300  43        		.byte	67
 720    0301  4D        		.byte	77
 721    0302  44        		.byte	68
 722    0303  38        		.byte	56
 723    0304  3A        		.byte	58
 724    0305  20        		.byte	32
 725    0306  53        		.byte	83
 726    0307  45        		.byte	69
 727    0308  4E        		.byte	78
 728    0309  44        		.byte	68
 729    030A  5F        		.byte	95
 730    030B  49        		.byte	73
 731    030C  46        		.byte	70
 732    030D  5F        		.byte	95
 733    030E  43        		.byte	67
 734    030F  4F        		.byte	79
 735    0310  4E        		.byte	78
 736    0311  44        		.byte	68
 737    0312  2C        		.byte	44
 738    0313  20        		.byte	32
 739    0314  52        		.byte	82
 740    0315  37        		.byte	55
 741    0316  20        		.byte	32
 742    0317  72        		.byte	114
 743    0318  65        		.byte	101
 744    0319  73        		.byte	115
 745    031A  70        		.byte	112
 746    031B  6F        		.byte	111
 747    031C  6E        		.byte	110
 748    031D  73        		.byte	115
 749    031E  65        		.byte	101
 750    031F  20        		.byte	32
 751    0320  5B        		.byte	91
 752    0321  25        		.byte	37
 753    0322  30        		.byte	48
 754    0323  32        		.byte	50
 755    0324  78        		.byte	120
 756    0325  20        		.byte	32
 757    0326  25        		.byte	37
 758    0327  30        		.byte	48
 759    0328  32        		.byte	50
 760    0329  78        		.byte	120
 761    032A  20        		.byte	32
 762    032B  25        		.byte	37
 763    032C  30        		.byte	48
 764    032D  32        		.byte	50
 765    032E  78        		.byte	120
 766    032F  20        		.byte	32
 767    0330  25        		.byte	37
 768    0331  30        		.byte	48
 769    0332  32        		.byte	50
 770    0333  78        		.byte	120
 771    0334  20        		.byte	32
 772    0335  25        		.byte	37
 773    0336  30        		.byte	48
 774    0337  32        		.byte	50
 775    0338  78        		.byte	120
 776    0339  5D        		.byte	93
 777    033A  2C        		.byte	44
 778    033B  20        		.byte	32
 779    033C  00        		.byte	0
 780                    	L56:
 781    033D  65        		.byte	101
 782    033E  63        		.byte	99
 783    033F  68        		.byte	104
 784    0340  6F        		.byte	111
 785    0341  20        		.byte	32
 786    0342  62        		.byte	98
 787    0343  61        		.byte	97
 788    0344  63        		.byte	99
 789    0345  6B        		.byte	107
 790    0346  20        		.byte	32
 791    0347  6F        		.byte	111
 792    0348  6B        		.byte	107
 793    0349  2C        		.byte	44
 794    034A  20        		.byte	32
 795    034B  00        		.byte	0
 796                    	L57:
 797    034C  69        		.byte	105
 798    034D  6E        		.byte	110
 799    034E  76        		.byte	118
 800    034F  61        		.byte	97
 801    0350  6C        		.byte	108
 802    0351  69        		.byte	105
 803    0352  64        		.byte	100
 804    0353  20        		.byte	32
 805    0354  65        		.byte	101
 806    0355  63        		.byte	99
 807    0356  68        		.byte	104
 808    0357  6F        		.byte	111
 809    0358  20        		.byte	32
 810    0359  62        		.byte	98
 811    035A  61        		.byte	97
 812    035B  63        		.byte	99
 813    035C  6B        		.byte	107
 814    035D  0A        		.byte	10
 815    035E  00        		.byte	0
 816                    	L501:
 817    035F  70        		.byte	112
 818    0360  72        		.byte	114
 819    0361  6F        		.byte	111
 820    0362  62        		.byte	98
 821    0363  61        		.byte	97
 822    0364  62        		.byte	98
 823    0365  6C        		.byte	108
 824    0366  79        		.byte	121
 825    0367  20        		.byte	32
 826    0368  53        		.byte	83
 827    0369  44        		.byte	68
 828    036A  20        		.byte	32
 829    036B  76        		.byte	118
 830    036C  65        		.byte	101
 831    036D  72        		.byte	114
 832    036E  2E        		.byte	46
 833    036F  20        		.byte	32
 834    0370  31        		.byte	49
 835    0371  0A        		.byte	10
 836    0372  00        		.byte	0
 837                    	L511:
 838    0373  53        		.byte	83
 839    0374  44        		.byte	68
 840    0375  20        		.byte	32
 841    0376  76        		.byte	118
 842    0377  65        		.byte	101
 843    0378  72        		.byte	114
 844    0379  20        		.byte	32
 845    037A  32        		.byte	50
 846    037B  0A        		.byte	10
 847    037C  00        		.byte	0
 848                    	L521:
 849    037D  43        		.byte	67
 850    037E  4D        		.byte	77
 851    037F  44        		.byte	68
 852    0380  35        		.byte	53
 853    0381  35        		.byte	53
 854    0382  3A        		.byte	58
 855    0383  20        		.byte	32
 856    0384  6E        		.byte	110
 857    0385  6F        		.byte	111
 858    0386  20        		.byte	32
 859    0387  72        		.byte	114
 860    0388  65        		.byte	101
 861    0389  73        		.byte	115
 862    038A  70        		.byte	112
 863    038B  6F        		.byte	111
 864    038C  6E        		.byte	110
 865    038D  73        		.byte	115
 866    038E  65        		.byte	101
 867    038F  0A        		.byte	10
 868    0390  00        		.byte	0
 869                    	L531:
 870    0391  43        		.byte	67
 871    0392  4D        		.byte	77
 872    0393  44        		.byte	68
 873    0394  35        		.byte	53
 874    0395  35        		.byte	53
 875    0396  3A        		.byte	58
 876    0397  20        		.byte	32
 877    0398  41        		.byte	65
 878    0399  50        		.byte	80
 879    039A  50        		.byte	80
 880    039B  5F        		.byte	95
 881    039C  43        		.byte	67
 882    039D  4D        		.byte	77
 883    039E  44        		.byte	68
 884    039F  2C        		.byte	44
 885    03A0  20        		.byte	32
 886    03A1  52        		.byte	82
 887    03A2  31        		.byte	49
 888    03A3  20        		.byte	32
 889    03A4  72        		.byte	114
 890    03A5  65        		.byte	101
 891    03A6  73        		.byte	115
 892    03A7  70        		.byte	112
 893    03A8  6F        		.byte	111
 894    03A9  6E        		.byte	110
 895    03AA  73        		.byte	115
 896    03AB  65        		.byte	101
 897    03AC  20        		.byte	32
 898    03AD  5B        		.byte	91
 899    03AE  25        		.byte	37
 900    03AF  30        		.byte	48
 901    03B0  32        		.byte	50
 902    03B1  78        		.byte	120
 903    03B2  5D        		.byte	93
 904    03B3  0A        		.byte	10
 905    03B4  00        		.byte	0
 906                    	L541:
 907    03B5  41        		.byte	65
 908    03B6  43        		.byte	67
 909    03B7  4D        		.byte	77
 910    03B8  44        		.byte	68
 911    03B9  34        		.byte	52
 912    03BA  31        		.byte	49
 913    03BB  3A        		.byte	58
 914    03BC  20        		.byte	32
 915    03BD  6E        		.byte	110
 916    03BE  6F        		.byte	111
 917    03BF  20        		.byte	32
 918    03C0  72        		.byte	114
 919    03C1  65        		.byte	101
 920    03C2  73        		.byte	115
 921    03C3  70        		.byte	112
 922    03C4  6F        		.byte	111
 923    03C5  6E        		.byte	110
 924    03C6  73        		.byte	115
 925    03C7  65        		.byte	101
 926    03C8  0A        		.byte	10
 927    03C9  00        		.byte	0
 928                    	L571:
 929                    		.byte	[1]
 930                    	L561:
 931    03CB  20        		.byte	32
 932    03CC  2D        		.byte	45
 933    03CD  20        		.byte	32
 934    03CE  72        		.byte	114
 935    03CF  65        		.byte	101
 936    03D0  61        		.byte	97
 937    03D1  64        		.byte	100
 938    03D2  79        		.byte	121
 939    03D3  00        		.byte	0
 940                    	L551:
 941    03D4  41        		.byte	65
 942    03D5  43        		.byte	67
 943    03D6  4D        		.byte	77
 944    03D7  44        		.byte	68
 945    03D8  34        		.byte	52
 946    03D9  31        		.byte	49
 947    03DA  3A        		.byte	58
 948    03DB  20        		.byte	32
 949    03DC  53        		.byte	83
 950    03DD  45        		.byte	69
 951    03DE  4E        		.byte	78
 952    03DF  44        		.byte	68
 953    03E0  5F        		.byte	95
 954    03E1  4F        		.byte	79
 955    03E2  50        		.byte	80
 956    03E3  5F        		.byte	95
 957    03E4  43        		.byte	67
 958    03E5  4F        		.byte	79
 959    03E6  4E        		.byte	78
 960    03E7  44        		.byte	68
 961    03E8  2C        		.byte	44
 962    03E9  20        		.byte	32
 963    03EA  52        		.byte	82
 964    03EB  31        		.byte	49
 965    03EC  20        		.byte	32
 966    03ED  72        		.byte	114
 967    03EE  65        		.byte	101
 968    03EF  73        		.byte	115
 969    03F0  70        		.byte	112
 970    03F1  6F        		.byte	111
 971    03F2  6E        		.byte	110
 972    03F3  73        		.byte	115
 973    03F4  65        		.byte	101
 974    03F5  20        		.byte	32
 975    03F6  5B        		.byte	91
 976    03F7  25        		.byte	37
 977    03F8  30        		.byte	48
 978    03F9  32        		.byte	50
 979    03FA  78        		.byte	120
 980    03FB  5D        		.byte	93
 981    03FC  25        		.byte	37
 982    03FD  73        		.byte	115
 983    03FE  0A        		.byte	10
 984    03FF  00        		.byte	0
 985                    	L502:
 986    0400  43        		.byte	67
 987    0401  4D        		.byte	77
 988    0402  44        		.byte	68
 989    0403  35        		.byte	53
 990    0404  38        		.byte	56
 991    0405  3A        		.byte	58
 992    0406  20        		.byte	32
 993    0407  6E        		.byte	110
 994    0408  6F        		.byte	111
 995    0409  20        		.byte	32
 996    040A  72        		.byte	114
 997    040B  65        		.byte	101
 998    040C  73        		.byte	115
 999    040D  70        		.byte	112
1000    040E  6F        		.byte	111
1001    040F  6E        		.byte	110
1002    0410  73        		.byte	115
1003    0411  65        		.byte	101
1004    0412  0A        		.byte	10
1005    0413  00        		.byte	0
1006                    	L512:
1007    0414  43        		.byte	67
1008    0415  4D        		.byte	77
1009    0416  44        		.byte	68
1010    0417  35        		.byte	53
1011    0418  38        		.byte	56
1012    0419  3A        		.byte	58
1013    041A  20        		.byte	32
1014    041B  52        		.byte	82
1015    041C  45        		.byte	69
1016    041D  41        		.byte	65
1017    041E  44        		.byte	68
1018    041F  5F        		.byte	95
1019    0420  4F        		.byte	79
1020    0421  43        		.byte	67
1021    0422  52        		.byte	82
1022    0423  2C        		.byte	44
1023    0424  20        		.byte	32
1024    0425  52        		.byte	82
1025    0426  33        		.byte	51
1026    0427  20        		.byte	32
1027    0428  72        		.byte	114
1028    0429  65        		.byte	101
1029    042A  73        		.byte	115
1030    042B  70        		.byte	112
1031    042C  6F        		.byte	111
1032    042D  6E        		.byte	110
1033    042E  73        		.byte	115
1034    042F  65        		.byte	101
1035    0430  20        		.byte	32
1036    0431  5B        		.byte	91
1037    0432  25        		.byte	37
1038    0433  30        		.byte	48
1039    0434  32        		.byte	50
1040    0435  78        		.byte	120
1041    0436  20        		.byte	32
1042    0437  25        		.byte	37
1043    0438  30        		.byte	48
1044    0439  32        		.byte	50
1045    043A  78        		.byte	120
1046    043B  20        		.byte	32
1047    043C  25        		.byte	37
1048    043D  30        		.byte	48
1049    043E  32        		.byte	50
1050    043F  78        		.byte	120
1051    0440  20        		.byte	32
1052    0441  25        		.byte	37
1053    0442  30        		.byte	48
1054    0443  32        		.byte	50
1055    0444  78        		.byte	120
1056    0445  20        		.byte	32
1057    0446  25        		.byte	37
1058    0447  30        		.byte	48
1059    0448  32        		.byte	50
1060    0449  78        		.byte	120
1061    044A  5D        		.byte	93
1062    044B  0A        		.byte	10
1063    044C  00        		.byte	0
1064                    	L522:
1065    044D  43        		.byte	67
1066    044E  4D        		.byte	77
1067    044F  44        		.byte	68
1068    0450  31        		.byte	49
1069    0451  36        		.byte	54
1070    0452  3A        		.byte	58
1071    0453  20        		.byte	32
1072    0454  6E        		.byte	110
1073    0455  6F        		.byte	111
1074    0456  20        		.byte	32
1075    0457  72        		.byte	114
1076    0458  65        		.byte	101
1077    0459  73        		.byte	115
1078    045A  70        		.byte	112
1079    045B  6F        		.byte	111
1080    045C  6E        		.byte	110
1081    045D  73        		.byte	115
1082    045E  65        		.byte	101
1083    045F  0A        		.byte	10
1084    0460  00        		.byte	0
1085                    	L532:
1086    0461  43        		.byte	67
1087    0462  4D        		.byte	77
1088    0463  44        		.byte	68
1089    0464  31        		.byte	49
1090    0465  36        		.byte	54
1091    0466  3A        		.byte	58
1092    0467  20        		.byte	32
1093    0468  53        		.byte	83
1094    0469  45        		.byte	69
1095    046A  54        		.byte	84
1096    046B  5F        		.byte	95
1097    046C  42        		.byte	66
1098    046D  4C        		.byte	76
1099    046E  4F        		.byte	79
1100    046F  43        		.byte	67
1101    0470  4B        		.byte	75
1102    0471  4C        		.byte	76
1103    0472  45        		.byte	69
1104    0473  4E        		.byte	78
1105    0474  20        		.byte	32
1106    0475  28        		.byte	40
1107    0476  74        		.byte	116
1108    0477  6F        		.byte	111
1109    0478  20        		.byte	32
1110    0479  35        		.byte	53
1111    047A  31        		.byte	49
1112    047B  32        		.byte	50
1113    047C  20        		.byte	32
1114    047D  62        		.byte	98
1115    047E  79        		.byte	121
1116    047F  74        		.byte	116
1117    0480  65        		.byte	101
1118    0481  73        		.byte	115
1119    0482  29        		.byte	41
1120    0483  2C        		.byte	44
1121    0484  20        		.byte	32
1122    0485  52        		.byte	82
1123    0486  31        		.byte	49
1124    0487  20        		.byte	32
1125    0488  72        		.byte	114
1126    0489  65        		.byte	101
1127    048A  73        		.byte	115
1128    048B  70        		.byte	112
1129    048C  6F        		.byte	111
1130    048D  6E        		.byte	110
1131    048E  73        		.byte	115
1132    048F  65        		.byte	101
1133    0490  20        		.byte	32
1134    0491  5B        		.byte	91
1135    0492  25        		.byte	37
1136    0493  30        		.byte	48
1137    0494  32        		.byte	50
1138    0495  78        		.byte	120
1139    0496  5D        		.byte	93
1140    0497  0A        		.byte	10
1141    0498  00        		.byte	0
1142                    	L542:
1143    0499  43        		.byte	67
1144    049A  4D        		.byte	77
1145    049B  44        		.byte	68
1146    049C  31        		.byte	49
1147    049D  30        		.byte	48
1148    049E  3A        		.byte	58
1149    049F  20        		.byte	32
1150    04A0  6E        		.byte	110
1151    04A1  6F        		.byte	111
1152    04A2  20        		.byte	32
1153    04A3  72        		.byte	114
1154    04A4  65        		.byte	101
1155    04A5  73        		.byte	115
1156    04A6  70        		.byte	112
1157    04A7  6F        		.byte	111
1158    04A8  6E        		.byte	110
1159    04A9  73        		.byte	115
1160    04AA  65        		.byte	101
1161    04AB  0A        		.byte	10
1162    04AC  00        		.byte	0
1163                    	L552:
1164    04AD  43        		.byte	67
1165    04AE  4D        		.byte	77
1166    04AF  44        		.byte	68
1167    04B0  31        		.byte	49
1168    04B1  30        		.byte	48
1169    04B2  3A        		.byte	58
1170    04B3  20        		.byte	32
1171    04B4  53        		.byte	83
1172    04B5  45        		.byte	69
1173    04B6  4E        		.byte	78
1174    04B7  44        		.byte	68
1175    04B8  5F        		.byte	95
1176    04B9  43        		.byte	67
1177    04BA  49        		.byte	73
1178    04BB  44        		.byte	68
1179    04BC  2C        		.byte	44
1180    04BD  20        		.byte	32
1181    04BE  52        		.byte	82
1182    04BF  31        		.byte	49
1183    04C0  20        		.byte	32
1184    04C1  72        		.byte	114
1185    04C2  65        		.byte	101
1186    04C3  73        		.byte	115
1187    04C4  70        		.byte	112
1188    04C5  6F        		.byte	111
1189    04C6  6E        		.byte	110
1190    04C7  73        		.byte	115
1191    04C8  65        		.byte	101
1192    04C9  20        		.byte	32
1193    04CA  5B        		.byte	91
1194    04CB  25        		.byte	37
1195    04CC  30        		.byte	48
1196    04CD  32        		.byte	50
1197    04CE  78        		.byte	120
1198    04CF  5D        		.byte	93
1199    04D0  0A        		.byte	10
1200    04D1  00        		.byte	0
1201                    	L562:
1202    04D2  20        		.byte	32
1203    04D3  20        		.byte	32
1204    04D4  4E        		.byte	78
1205    04D5  6F        		.byte	111
1206    04D6  20        		.byte	32
1207    04D7  64        		.byte	100
1208    04D8  61        		.byte	97
1209    04D9  74        		.byte	116
1210    04DA  61        		.byte	97
1211    04DB  20        		.byte	32
1212    04DC  66        		.byte	102
1213    04DD  6F        		.byte	111
1214    04DE  75        		.byte	117
1215    04DF  6E        		.byte	110
1216    04E0  64        		.byte	100
1217    04E1  0A        		.byte	10
1218    04E2  00        		.byte	0
1219                    	L572:
1220    04E3  20        		.byte	32
1221    04E4  20        		.byte	32
1222    04E5  43        		.byte	67
1223    04E6  49        		.byte	73
1224    04E7  44        		.byte	68
1225    04E8  3A        		.byte	58
1226    04E9  20        		.byte	32
1227    04EA  5B        		.byte	91
1228    04EB  00        		.byte	0
1229                    	L503:
1230    04EC  25        		.byte	37
1231    04ED  30        		.byte	48
1232    04EE  32        		.byte	50
1233    04EF  78        		.byte	120
1234    04F0  20        		.byte	32
1235    04F1  00        		.byte	0
1236                    	L513:
1237    04F2  08        		.byte	8
1238    04F3  5D        		.byte	93
1239    04F4  20        		.byte	32
1240    04F5  7C        		.byte	124
1241    04F6  00        		.byte	0
1242                    	L523:
1243    04F7  7C        		.byte	124
1244    04F8  0A        		.byte	10
1245    04F9  00        		.byte	0
1246                    	L533:
1247    04FA  43        		.byte	67
1248    04FB  52        		.byte	82
1249    04FC  43        		.byte	67
1250    04FD  37        		.byte	55
1251    04FE  20        		.byte	32
1252    04FF  6F        		.byte	111
1253    0500  6B        		.byte	107
1254    0501  3A        		.byte	58
1255    0502  20        		.byte	32
1256    0503  5B        		.byte	91
1257    0504  25        		.byte	37
1258    0505  30        		.byte	48
1259    0506  32        		.byte	50
1260    0507  78        		.byte	120
1261    0508  5D        		.byte	93
1262    0509  0A        		.byte	10
1263    050A  00        		.byte	0
1264                    	L543:
1265    050B  43        		.byte	67
1266    050C  52        		.byte	82
1267    050D  43        		.byte	67
1268    050E  37        		.byte	55
1269    050F  20        		.byte	32
1270    0510  65        		.byte	101
1271    0511  72        		.byte	114
1272    0512  72        		.byte	114
1273    0513  6F        		.byte	111
1274    0514  72        		.byte	114
1275    0515  2C        		.byte	44
1276    0516  20        		.byte	32
1277    0517  63        		.byte	99
1278    0518  61        		.byte	97
1279    0519  6C        		.byte	108
1280    051A  63        		.byte	99
1281    051B  75        		.byte	117
1282    051C  6C        		.byte	108
1283    051D  61        		.byte	97
1284    051E  74        		.byte	116
1285    051F  65        		.byte	101
1286    0520  64        		.byte	100
1287    0521  3A        		.byte	58
1288    0522  20        		.byte	32
1289    0523  5B        		.byte	91
1290    0524  25        		.byte	37
1291    0525  30        		.byte	48
1292    0526  32        		.byte	50
1293    0527  78        		.byte	120
1294    0528  5D        		.byte	93
1295    0529  2C        		.byte	44
1296    052A  20        		.byte	32
1297    052B  72        		.byte	114
1298    052C  65        		.byte	101
1299    052D  63        		.byte	99
1300    052E  69        		.byte	105
1301    052F  65        		.byte	101
1302    0530  76        		.byte	118
1303    0531  65        		.byte	101
1304    0532  64        		.byte	100
1305    0533  3A        		.byte	58
1306    0534  20        		.byte	32
1307    0535  5B        		.byte	91
1308    0536  25        		.byte	37
1309    0537  30        		.byte	48
1310    0538  32        		.byte	50
1311    0539  78        		.byte	120
1312    053A  5D        		.byte	93
1313    053B  0A        		.byte	10
1314    053C  00        		.byte	0
1315                    	L553:
1316    053D  43        		.byte	67
1317    053E  4D        		.byte	77
1318    053F  44        		.byte	68
1319    0540  39        		.byte	57
1320    0541  3A        		.byte	58
1321    0542  20        		.byte	32
1322    0543  6E        		.byte	110
1323    0544  6F        		.byte	111
1324    0545  20        		.byte	32
1325    0546  72        		.byte	114
1326    0547  65        		.byte	101
1327    0548  73        		.byte	115
1328    0549  70        		.byte	112
1329    054A  6F        		.byte	111
1330    054B  6E        		.byte	110
1331    054C  73        		.byte	115
1332    054D  65        		.byte	101
1333    054E  0A        		.byte	10
1334    054F  00        		.byte	0
1335                    	L563:
1336    0550  43        		.byte	67
1337    0551  4D        		.byte	77
1338    0552  44        		.byte	68
1339    0553  39        		.byte	57
1340    0554  3A        		.byte	58
1341    0555  20        		.byte	32
1342    0556  53        		.byte	83
1343    0557  45        		.byte	69
1344    0558  4E        		.byte	78
1345    0559  44        		.byte	68
1346    055A  5F        		.byte	95
1347    055B  43        		.byte	67
1348    055C  53        		.byte	83
1349    055D  44        		.byte	68
1350    055E  2C        		.byte	44
1351    055F  20        		.byte	32
1352    0560  52        		.byte	82
1353    0561  31        		.byte	49
1354    0562  20        		.byte	32
1355    0563  72        		.byte	114
1356    0564  65        		.byte	101
1357    0565  73        		.byte	115
1358    0566  70        		.byte	112
1359    0567  6F        		.byte	111
1360    0568  6E        		.byte	110
1361    0569  73        		.byte	115
1362    056A  65        		.byte	101
1363    056B  20        		.byte	32
1364    056C  5B        		.byte	91
1365    056D  25        		.byte	37
1366    056E  30        		.byte	48
1367    056F  32        		.byte	50
1368    0570  78        		.byte	120
1369    0571  5D        		.byte	93
1370    0572  0A        		.byte	10
1371    0573  00        		.byte	0
1372                    	L573:
1373    0574  20        		.byte	32
1374    0575  20        		.byte	32
1375    0576  4E        		.byte	78
1376    0577  6F        		.byte	111
1377    0578  20        		.byte	32
1378    0579  64        		.byte	100
1379    057A  61        		.byte	97
1380    057B  74        		.byte	116
1381    057C  61        		.byte	97
1382    057D  20        		.byte	32
1383    057E  66        		.byte	102
1384    057F  6F        		.byte	111
1385    0580  75        		.byte	117
1386    0581  6E        		.byte	110
1387    0582  64        		.byte	100
1388    0583  0A        		.byte	10
1389    0584  00        		.byte	0
1390                    	L504:
1391    0585  20        		.byte	32
1392    0586  20        		.byte	32
1393    0587  43        		.byte	67
1394    0588  53        		.byte	83
1395    0589  44        		.byte	68
1396    058A  3A        		.byte	58
1397    058B  20        		.byte	32
1398    058C  5B        		.byte	91
1399    058D  00        		.byte	0
1400                    	L514:
1401    058E  25        		.byte	37
1402    058F  30        		.byte	48
1403    0590  32        		.byte	50
1404    0591  78        		.byte	120
1405    0592  20        		.byte	32
1406    0593  00        		.byte	0
1407                    	L524:
1408    0594  08        		.byte	8
1409    0595  5D        		.byte	93
1410    0596  20        		.byte	32
1411    0597  7C        		.byte	124
1412    0598  00        		.byte	0
1413                    	L534:
1414    0599  7C        		.byte	124
1415    059A  0A        		.byte	10
1416    059B  00        		.byte	0
1417                    	L544:
1418    059C  43        		.byte	67
1419    059D  52        		.byte	82
1420    059E  43        		.byte	67
1421    059F  37        		.byte	55
1422    05A0  20        		.byte	32
1423    05A1  6F        		.byte	111
1424    05A2  6B        		.byte	107
1425    05A3  3A        		.byte	58
1426    05A4  20        		.byte	32
1427    05A5  5B        		.byte	91
1428    05A6  25        		.byte	37
1429    05A7  30        		.byte	48
1430    05A8  32        		.byte	50
1431    05A9  78        		.byte	120
1432    05AA  5D        		.byte	93
1433    05AB  0A        		.byte	10
1434    05AC  00        		.byte	0
1435                    	L554:
1436    05AD  43        		.byte	67
1437    05AE  52        		.byte	82
1438    05AF  43        		.byte	67
1439    05B0  37        		.byte	55
1440    05B1  20        		.byte	32
1441    05B2  65        		.byte	101
1442    05B3  72        		.byte	114
1443    05B4  72        		.byte	114
1444    05B5  6F        		.byte	111
1445    05B6  72        		.byte	114
1446    05B7  2C        		.byte	44
1447    05B8  20        		.byte	32
1448    05B9  63        		.byte	99
1449    05BA  61        		.byte	97
1450    05BB  6C        		.byte	108
1451    05BC  63        		.byte	99
1452    05BD  75        		.byte	117
1453    05BE  6C        		.byte	108
1454    05BF  61        		.byte	97
1455    05C0  74        		.byte	116
1456    05C1  65        		.byte	101
1457    05C2  64        		.byte	100
1458    05C3  3A        		.byte	58
1459    05C4  20        		.byte	32
1460    05C5  5B        		.byte	91
1461    05C6  25        		.byte	37
1462    05C7  30        		.byte	48
1463    05C8  32        		.byte	50
1464    05C9  78        		.byte	120
1465    05CA  5D        		.byte	93
1466    05CB  2C        		.byte	44
1467    05CC  20        		.byte	32
1468    05CD  72        		.byte	114
1469    05CE  65        		.byte	101
1470    05CF  63        		.byte	99
1471    05D0  69        		.byte	105
1472    05D1  65        		.byte	101
1473    05D2  76        		.byte	118
1474    05D3  65        		.byte	101
1475    05D4  64        		.byte	100
1476    05D5  3A        		.byte	58
1477    05D6  20        		.byte	32
1478    05D7  5B        		.byte	91
1479    05D8  25        		.byte	37
1480    05D9  30        		.byte	48
1481    05DA  32        		.byte	50
1482    05DB  78        		.byte	120
1483    05DC  5D        		.byte	93
1484    05DD  0A        		.byte	10
1485    05DE  00        		.byte	0
1486                    	L564:
1487    05DF  53        		.byte	83
1488    05E0  65        		.byte	101
1489    05E1  6E        		.byte	110
1490    05E2  74        		.byte	116
1491    05E3  20        		.byte	32
1492    05E4  39        		.byte	57
1493    05E5  2A        		.byte	42
1494    05E6  38        		.byte	56
1495    05E7  20        		.byte	32
1496    05E8  28        		.byte	40
1497    05E9  37        		.byte	55
1498    05EA  32        		.byte	50
1499    05EB  29        		.byte	41
1500    05EC  20        		.byte	32
1501    05ED  63        		.byte	99
1502    05EE  6C        		.byte	108
1503    05EF  6F        		.byte	111
1504    05F0  63        		.byte	99
1505    05F1  6B        		.byte	107
1506    05F2  20        		.byte	32
1507    05F3  70        		.byte	112
1508    05F4  75        		.byte	117
1509    05F5  6C        		.byte	108
1510    05F6  73        		.byte	115
1511    05F7  65        		.byte	101
1512    05F8  73        		.byte	115
1513    05F9  2C        		.byte	44
1514    05FA  20        		.byte	32
1515    05FB  73        		.byte	115
1516    05FC  65        		.byte	101
1517    05FD  6C        		.byte	108
1518    05FE  65        		.byte	101
1519    05FF  63        		.byte	99
1520    0600  74        		.byte	116
1521    0601  20        		.byte	32
1522    0602  61        		.byte	97
1523    0603  63        		.byte	99
1524    0604  74        		.byte	116
1525    0605  69        		.byte	105
1526    0606  76        		.byte	118
1527    0607  65        		.byte	101
1528    0608  0A        		.byte	10
1529    0609  00        		.byte	0
1530                    	;  208      }
1531                    	;  209  
1532                    	;  210  /* Initialise SD card interface
1533                    	;  211   *
1534                    	;  212   * returns YES if ok and NO if not ok
1535                    	;  213   *
1536                    	;  214   * References:
1537                    	;  215   *   https://www.sdcard.org/downloads/pls/
1538                    	;  216   *      Physical Layer Simplified Specification version 8.0
1539                    	;  217   *
1540                    	;  218   * A nice flowchart how to initialize:
1541                    	;  219   *   https://www.totalphase.com/blog/2018/08/set-sdc-mmc-cards-spi-mode-verify-files-successfully-programmed/
1542                    	;  220   *
1543                    	;  221   */
1544                    	;  222  int sdinit()
1545                    	;  223      {
1546                    	_sdinit:
1547    060A  CD0000    		call	c.savs0
1548    060D  21E4FF    		ld	hl,65508
1549    0610  39        		add	hl,sp
1550    0611  F9        		ld	sp,hl
1551                    	;  224      int nbytes;  /* byte counter */
1552                    	;  225      int tries;   /* tries to get to active state or searching for data  */
1553                    	;  226      int wtloop;  /* timer loop when trying to enter active state */
1554                    	;  227      unsigned char cmdbuf[5];   /* buffer to build command in */
1555                    	;  228      unsigned char rstatbuf[5]; /* buffer to recieve status in */
1556                    	;  229      unsigned char *statptr;    /* pointer to returned status from SD command */
1557                    	;  230      unsigned char crc;         /* crc register for CID and CSD */
1558                    	;  231      unsigned char rbyte;       /* recieved byte */
1559                    	;  232      unsigned char *prtptr;     /* for debug printing */
1560                    	;  233  
1561                    	;  234      ledon();
1562    0612  CD0000    		call	_ledon
1563                    	;  235      spideselect();
1564    0615  CD0000    		call	_spideselect
1565                    	;  236      sdinitok = NO;
1566    0618  210000    		ld	hl,0
1567    061B  220C00    		ld	(_sdinitok),hl
1568                    	;  237  
1569                    	;  238      /* start to generate 9*8 clock pulses with not selected SD card */
1570                    	;  239      for (nbytes = 9; 0 < nbytes; nbytes--)
1571    061E  DD36F809  		ld	(ix-8),9
1572    0622  DD36F900  		ld	(ix-7),0
1573                    	L132:
1574    0626  97        		sub	a
1575    0627  DD96F8    		sub	(ix-8)
1576    062A  3E00      		ld	a,0
1577    062C  DD9EF9    		sbc	a,(ix-7)
1578    062F  F24706    		jp	p,L142
1579                    	;  240          spiio(0xff);
1580    0632  21FF00    		ld	hl,255
1581    0635  CD0000    		call	_spiio
1582    0638  DD6EF8    		ld	l,(ix-8)
1583    063B  DD66F9    		ld	h,(ix-7)
1584    063E  2B        		dec	hl
1585    063F  DD75F8    		ld	(ix-8),l
1586    0642  DD74F9    		ld	(ix-7),h
1587    0645  18DF      		jr	L132
1588                    	L142:
1589                    	;  241      if (sdtestflg)
1590    0647  2A0000    		ld	hl,(_sdtestflg)
1591    064A  7C        		ld	a,h
1592    064B  B5        		or	l
1593    064C  2806      		jr	z,L172
1594                    	;  242          {
1595                    	;  243          printf("\nSent 8*8 (72) clock pulses, select not active\n");
1596    064E  218102    		ld	hl,L51
1597    0651  CD0000    		call	_printf
1598                    	L172:
1599                    	;  244          } /* sdtestflg */
1600                    	;  245      spiselect();
1601    0654  CD0000    		call	_spiselect
1602                    	;  246  
1603                    	;  247      /* CMD0: GO_IDLE_STATE */
1604                    	;  248      for (tries = 0; tries < 10; tries++)
1605    0657  DD36F600  		ld	(ix-10),0
1606    065B  DD36F700  		ld	(ix-9),0
1607                    	L103:
1608    065F  DD7EF6    		ld	a,(ix-10)
1609    0662  D60A      		sub	10
1610    0664  DD7EF7    		ld	a,(ix-9)
1611    0667  DE00      		sbc	a,0
1612    0669  F21F07    		jp	p,L113
1613                    	;  249          {
1614                    	;  250          memcpy(cmdbuf, cmd0, 5);
1615    066C  210500    		ld	hl,5
1616    066F  E5        		push	hl
1617    0670  211900    		ld	hl,_cmd0
1618    0673  E5        		push	hl
1619    0674  DDE5      		push	ix
1620    0676  C1        		pop	bc
1621    0677  21EFFF    		ld	hl,65519
1622    067A  09        		add	hl,bc
1623    067B  CD0000    		call	_memcpy
1624    067E  F1        		pop	af
1625    067F  F1        		pop	af
1626                    	;  251          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1627    0680  210100    		ld	hl,1
1628    0683  E5        		push	hl
1629    0684  DDE5      		push	ix
1630    0686  C1        		pop	bc
1631    0687  21EAFF    		ld	hl,65514
1632    068A  09        		add	hl,bc
1633    068B  E5        		push	hl
1634    068C  DDE5      		push	ix
1635    068E  C1        		pop	bc
1636    068F  21EFFF    		ld	hl,65519
1637    0692  09        		add	hl,bc
1638    0693  CD7701    		call	_sdcommand
1639    0696  F1        		pop	af
1640    0697  F1        		pop	af
1641    0698  DD71E8    		ld	(ix-24),c
1642    069B  DD70E9    		ld	(ix-23),b
1643                    	;  252          if (sdtestflg)
1644    069E  2A0000    		ld	hl,(_sdtestflg)
1645    06A1  7C        		ld	a,h
1646    06A2  B5        		or	l
1647    06A3  282C      		jr	z,L143
1648                    	;  253              {
1649                    	;  254              if (!statptr)
1650    06A5  DD7EE8    		ld	a,(ix-24)
1651    06A8  DDB6E9    		or	(ix-23)
1652    06AB  2013      		jr	nz,L153
1653                    	;  255                  printf("CMD0: no response\n");
1654    06AD  21B102    		ld	hl,L52
1655    06B0  CD0000    		call	_printf
1656                    	;  256              else
1657    06B3  181C      		jr	L143
1658                    	L123:
1659    06B5  DD34F6    		inc	(ix-10)
1660    06B8  2003      		jr	nz,L02
1661    06BA  DD34F7    		inc	(ix-9)
1662                    	L02:
1663    06BD  C35F06    		jp	L103
1664                    	L153:
1665                    	;  257                  printf("CMD0: GO_IDLE_STATE, R1 response [%02x]\n", statptr[0]);
1666    06C0  DD6EE8    		ld	l,(ix-24)
1667    06C3  DD66E9    		ld	h,(ix-23)
1668    06C6  4E        		ld	c,(hl)
1669    06C7  97        		sub	a
1670    06C8  47        		ld	b,a
1671    06C9  C5        		push	bc
1672    06CA  21C402    		ld	hl,L53
1673    06CD  CD0000    		call	_printf
1674    06D0  F1        		pop	af
1675                    	L143:
1676                    	;  258              } /* sdtestflg */
1677                    	;  259          if (!statptr)
1678    06D1  DD7EE8    		ld	a,(ix-24)
1679    06D4  DDB6E9    		or	(ix-23)
1680    06D7  200C      		jr	nz,L173
1681                    	;  260              {
1682                    	;  261              spideselect();
1683    06D9  CD0000    		call	_spideselect
1684                    	;  262              ledoff();
1685    06DC  CD0000    		call	_ledoff
1686                    	;  263              return (NO);
1687    06DF  010000    		ld	bc,0
1688    06E2  C30000    		jp	c.rets0
1689                    	L173:
1690                    	;  264              }
1691                    	;  265          if (statptr[0] == 0x01)
1692    06E5  DD6EE8    		ld	l,(ix-24)
1693    06E8  DD66E9    		ld	h,(ix-23)
1694    06EB  7E        		ld	a,(hl)
1695    06EC  FE01      		cp	1
1696    06EE  282F      		jr	z,L113
1697                    	;  266              break;
1698                    	;  267          for (wtloop = 0; wtloop < tries * 10; wtloop++)
1699    06F0  DD36F400  		ld	(ix-12),0
1700    06F4  DD36F500  		ld	(ix-11),0
1701                    	L114:
1702    06F8  DD6EF6    		ld	l,(ix-10)
1703    06FB  DD66F7    		ld	h,(ix-9)
1704    06FE  4D        		ld	c,l
1705    06FF  44        		ld	b,h
1706    0700  29        		add	hl,hl
1707    0701  29        		add	hl,hl
1708    0702  09        		add	hl,bc
1709    0703  29        		add	hl,hl
1710    0704  DD7EF4    		ld	a,(ix-12)
1711    0707  95        		sub	l
1712    0708  DD7EF5    		ld	a,(ix-11)
1713    070B  9C        		sbc	a,h
1714    070C  F2B506    		jp	p,L123
1715                    	;  268              {
1716                    	;  269              /* wait loop, time increasing for each try */
1717                    	;  270              spiio(0xff);
1718    070F  21FF00    		ld	hl,255
1719    0712  CD0000    		call	_spiio
1720                    	;  271              }
1721    0715  DD34F4    		inc	(ix-12)
1722    0718  2003      		jr	nz,L22
1723    071A  DD34F5    		inc	(ix-11)
1724                    	L22:
1725    071D  18D9      		jr	L114
1726                    	L113:
1727                    	;  272          }
1728                    	;  273  
1729                    	;  274      /* CMD8: SEND_IF_COND */
1730                    	;  275      memcpy(cmdbuf, cmd8, 5);
1731    071F  210500    		ld	hl,5
1732    0722  E5        		push	hl
1733    0723  211F00    		ld	hl,_cmd8
1734    0726  E5        		push	hl
1735    0727  DDE5      		push	ix
1736    0729  C1        		pop	bc
1737    072A  21EFFF    		ld	hl,65519
1738    072D  09        		add	hl,bc
1739    072E  CD0000    		call	_memcpy
1740    0731  F1        		pop	af
1741    0732  F1        		pop	af
1742                    	;  276      statptr = sdcommand(cmdbuf, rstatbuf, R7_LEN);
1743    0733  210500    		ld	hl,5
1744    0736  E5        		push	hl
1745    0737  DDE5      		push	ix
1746    0739  C1        		pop	bc
1747    073A  21EAFF    		ld	hl,65514
1748    073D  09        		add	hl,bc
1749    073E  E5        		push	hl
1750    073F  DDE5      		push	ix
1751    0741  C1        		pop	bc
1752    0742  21EFFF    		ld	hl,65519
1753    0745  09        		add	hl,bc
1754    0746  CD7701    		call	_sdcommand
1755    0749  F1        		pop	af
1756    074A  F1        		pop	af
1757    074B  DD71E8    		ld	(ix-24),c
1758    074E  DD70E9    		ld	(ix-23),b
1759                    	;  277      if (sdtestflg)
1760    0751  2A0000    		ld	hl,(_sdtestflg)
1761    0754  7C        		ld	a,h
1762    0755  B5        		or	l
1763    0756  CADD07    		jp	z,L154
1764                    	;  278          {
1765                    	;  279          if (!statptr)
1766    0759  DD7EE8    		ld	a,(ix-24)
1767    075C  DDB6E9    		or	(ix-23)
1768    075F  2009      		jr	nz,L164
1769                    	;  280              printf("CMD8: no response\n");
1770    0761  21ED02    		ld	hl,L54
1771    0764  CD0000    		call	_printf
1772                    	;  281          else
1773    0767  C3DD07    		jp	L154
1774                    	L164:
1775                    	;  282              {
1776                    	;  283              printf("CMD8: SEND_IF_COND, R7 response [%02x %02x %02x %02x %02x], ",
1777                    	;  284                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
1778    076A  DD6EE8    		ld	l,(ix-24)
1779    076D  DD66E9    		ld	h,(ix-23)
1780    0770  23        		inc	hl
1781    0771  23        		inc	hl
1782    0772  23        		inc	hl
1783    0773  23        		inc	hl
1784    0774  4E        		ld	c,(hl)
1785    0775  97        		sub	a
1786    0776  47        		ld	b,a
1787    0777  C5        		push	bc
1788    0778  DD6EE8    		ld	l,(ix-24)
1789    077B  DD66E9    		ld	h,(ix-23)
1790    077E  23        		inc	hl
1791    077F  23        		inc	hl
1792    0780  23        		inc	hl
1793    0781  4E        		ld	c,(hl)
1794    0782  97        		sub	a
1795    0783  47        		ld	b,a
1796    0784  C5        		push	bc
1797    0785  DD6EE8    		ld	l,(ix-24)
1798    0788  DD66E9    		ld	h,(ix-23)
1799    078B  23        		inc	hl
1800    078C  23        		inc	hl
1801    078D  4E        		ld	c,(hl)
1802    078E  97        		sub	a
1803    078F  47        		ld	b,a
1804    0790  C5        		push	bc
1805    0791  DD6EE8    		ld	l,(ix-24)
1806    0794  DD66E9    		ld	h,(ix-23)
1807    0797  23        		inc	hl
1808    0798  4E        		ld	c,(hl)
1809    0799  97        		sub	a
1810    079A  47        		ld	b,a
1811    079B  C5        		push	bc
1812    079C  DD6EE8    		ld	l,(ix-24)
1813    079F  DD66E9    		ld	h,(ix-23)
1814    07A2  4E        		ld	c,(hl)
1815    07A3  97        		sub	a
1816    07A4  47        		ld	b,a
1817    07A5  C5        		push	bc
1818    07A6  210003    		ld	hl,L55
1819    07A9  CD0000    		call	_printf
1820    07AC  210A00    		ld	hl,10
1821    07AF  39        		add	hl,sp
1822    07B0  F9        		ld	sp,hl
1823                    	;  285              if (!(statptr[0] & 0xfe)) /* no error */
1824    07B1  DD6EE8    		ld	l,(ix-24)
1825    07B4  DD66E9    		ld	h,(ix-23)
1826    07B7  6E        		ld	l,(hl)
1827    07B8  97        		sub	a
1828    07B9  67        		ld	h,a
1829    07BA  CB85      		res	0,l
1830    07BC  7D        		ld	a,l
1831    07BD  B4        		or	h
1832    07BE  201D      		jr	nz,L154
1833                    	;  286                  {
1834                    	;  287                  if (statptr[4] == 0xaa)
1835    07C0  DD6EE8    		ld	l,(ix-24)
1836    07C3  DD66E9    		ld	h,(ix-23)
1837    07C6  23        		inc	hl
1838    07C7  23        		inc	hl
1839    07C8  23        		inc	hl
1840    07C9  23        		inc	hl
1841    07CA  7E        		ld	a,(hl)
1842    07CB  FEAA      		cp	170
1843    07CD  2008      		jr	nz,L115
1844                    	;  288                      printf("echo back ok, ");
1845    07CF  213D03    		ld	hl,L56
1846    07D2  CD0000    		call	_printf
1847                    	;  289                  else
1848    07D5  1806      		jr	L154
1849                    	L115:
1850                    	;  290                      printf("invalid echo back\n");
1851    07D7  214C03    		ld	hl,L57
1852    07DA  CD0000    		call	_printf
1853                    	L154:
1854                    	;  291                  }
1855                    	;  292              }
1856                    	;  293          } /* sdtestflg */
1857                    	;  294      if (!statptr || (statptr[0] & 0xfe)) /* if no answer or error */
1858    07DD  DD7EE8    		ld	a,(ix-24)
1859    07E0  DDB6E9    		or	(ix-23)
1860    07E3  280F      		jr	z,L145
1861    07E5  DD6EE8    		ld	l,(ix-24)
1862    07E8  DD66E9    		ld	h,(ix-23)
1863    07EB  6E        		ld	l,(hl)
1864    07EC  97        		sub	a
1865    07ED  67        		ld	h,a
1866    07EE  CB85      		res	0,l
1867    07F0  7D        		ld	a,l
1868    07F1  B4        		or	h
1869    07F2  2815      		jr	z,L135
1870                    	L145:
1871                    	;  295          {
1872                    	;  296          sdver2 = NO;
1873    07F4  210000    		ld	hl,0
1874    07F7  220A00    		ld	(_sdver2),hl
1875                    	;  297          if (sdtestflg)
1876    07FA  2A0000    		ld	hl,(_sdtestflg)
1877    07FD  7C        		ld	a,h
1878    07FE  B5        		or	l
1879    07FF  2836      		jr	z,L165
1880                    	;  298              {
1881                    	;  299              printf("probably SD ver. 1\n");
1882    0801  215F03    		ld	hl,L501
1883    0804  CD0000    		call	_printf
1884    0807  182E      		jr	L165
1885                    	L135:
1886                    	;  300              } /* sdtestflg */
1887                    	;  301          }
1888                    	;  302      else
1889                    	;  303          {
1890                    	;  304          sdver2 = YES;
1891    0809  210100    		ld	hl,1
1892    080C  220A00    		ld	(_sdver2),hl
1893                    	;  305          if (statptr[4] != 0xaa) /* but invalid echo back */
1894    080F  DD6EE8    		ld	l,(ix-24)
1895    0812  DD66E9    		ld	h,(ix-23)
1896    0815  23        		inc	hl
1897    0816  23        		inc	hl
1898    0817  23        		inc	hl
1899    0818  23        		inc	hl
1900    0819  7E        		ld	a,(hl)
1901    081A  FEAA      		cp	170
1902    081C  280C      		jr	z,L175
1903                    	;  306              {
1904                    	;  307              spideselect();
1905    081E  CD0000    		call	_spideselect
1906                    	;  308              ledoff();
1907    0821  CD0000    		call	_ledoff
1908                    	;  309              return (NO);
1909    0824  010000    		ld	bc,0
1910    0827  C30000    		jp	c.rets0
1911                    	L175:
1912                    	;  310              }
1913                    	;  311          if (sdtestflg)
1914    082A  2A0000    		ld	hl,(_sdtestflg)
1915    082D  7C        		ld	a,h
1916    082E  B5        		or	l
1917    082F  2806      		jr	z,L165
1918                    	;  312              {
1919                    	;  313              printf("SD ver 2\n");
1920    0831  217303    		ld	hl,L511
1921    0834  CD0000    		call	_printf
1922                    	L165:
1923                    	;  314              } /* sdtestflg */
1924                    	;  315          }
1925                    	;  316  
1926                    	;  317      /* CMD55: APP_CMD followed by ACMD41: SEND_OP_COND until status is 0x00 */
1927                    	;  318      for (tries = 0; tries < 20; tries++)
1928    0837  DD36F600  		ld	(ix-10),0
1929    083B  DD36F700  		ld	(ix-9),0
1930                    	L116:
1931    083F  DD7EF6    		ld	a,(ix-10)
1932    0842  D614      		sub	20
1933    0844  DD7EF7    		ld	a,(ix-9)
1934    0847  DE00      		sbc	a,0
1935    0849  F29109    		jp	p,L126
1936                    	;  319          {
1937                    	;  320          memcpy(cmdbuf, cmd55, 5);
1938    084C  210500    		ld	hl,5
1939    084F  E5        		push	hl
1940    0850  214300    		ld	hl,_cmd55
1941    0853  E5        		push	hl
1942    0854  DDE5      		push	ix
1943    0856  C1        		pop	bc
1944    0857  21EFFF    		ld	hl,65519
1945    085A  09        		add	hl,bc
1946    085B  CD0000    		call	_memcpy
1947    085E  F1        		pop	af
1948    085F  F1        		pop	af
1949                    	;  321          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1950    0860  210100    		ld	hl,1
1951    0863  E5        		push	hl
1952    0864  DDE5      		push	ix
1953    0866  C1        		pop	bc
1954    0867  21EAFF    		ld	hl,65514
1955    086A  09        		add	hl,bc
1956    086B  E5        		push	hl
1957    086C  DDE5      		push	ix
1958    086E  C1        		pop	bc
1959    086F  21EFFF    		ld	hl,65519
1960    0872  09        		add	hl,bc
1961    0873  CD7701    		call	_sdcommand
1962    0876  F1        		pop	af
1963    0877  F1        		pop	af
1964    0878  DD71E8    		ld	(ix-24),c
1965    087B  DD70E9    		ld	(ix-23),b
1966                    	;  322          if (sdtestflg)
1967    087E  2A0000    		ld	hl,(_sdtestflg)
1968    0881  7C        		ld	a,h
1969    0882  B5        		or	l
1970    0883  282C      		jr	z,L156
1971                    	;  323              {
1972                    	;  324              if (!statptr)
1973    0885  DD7EE8    		ld	a,(ix-24)
1974    0888  DDB6E9    		or	(ix-23)
1975    088B  2013      		jr	nz,L166
1976                    	;  325                  printf("CMD55: no response\n");
1977    088D  217D03    		ld	hl,L521
1978    0890  CD0000    		call	_printf
1979                    	;  326              else
1980    0893  181C      		jr	L156
1981                    	L136:
1982    0895  DD34F6    		inc	(ix-10)
1983    0898  2003      		jr	nz,L42
1984    089A  DD34F7    		inc	(ix-9)
1985                    	L42:
1986    089D  C33F08    		jp	L116
1987                    	L166:
1988                    	;  327                  printf("CMD55: APP_CMD, R1 response [%02x]\n", statptr[0]);
1989    08A0  DD6EE8    		ld	l,(ix-24)
1990    08A3  DD66E9    		ld	h,(ix-23)
1991    08A6  4E        		ld	c,(hl)
1992    08A7  97        		sub	a
1993    08A8  47        		ld	b,a
1994    08A9  C5        		push	bc
1995    08AA  219103    		ld	hl,L531
1996    08AD  CD0000    		call	_printf
1997    08B0  F1        		pop	af
1998                    	L156:
1999                    	;  328              } /* sdtestflg */
2000                    	;  329          if (!statptr)
2001    08B1  DD7EE8    		ld	a,(ix-24)
2002    08B4  DDB6E9    		or	(ix-23)
2003    08B7  200C      		jr	nz,L107
2004                    	;  330              {
2005                    	;  331              spideselect();
2006    08B9  CD0000    		call	_spideselect
2007                    	;  332              ledoff();
2008    08BC  CD0000    		call	_ledoff
2009                    	;  333              return (NO);
2010    08BF  010000    		ld	bc,0
2011    08C2  C30000    		jp	c.rets0
2012                    	L107:
2013                    	;  334              }
2014                    	;  335          memcpy(cmdbuf, acmd41, 5);
2015    08C5  210500    		ld	hl,5
2016    08C8  E5        		push	hl
2017    08C9  214F00    		ld	hl,_acmd41
2018    08CC  E5        		push	hl
2019    08CD  DDE5      		push	ix
2020    08CF  C1        		pop	bc
2021    08D0  21EFFF    		ld	hl,65519
2022    08D3  09        		add	hl,bc
2023    08D4  CD0000    		call	_memcpy
2024    08D7  F1        		pop	af
2025    08D8  F1        		pop	af
2026                    	;  336          if (sdver2)
2027    08D9  2A0A00    		ld	hl,(_sdver2)
2028    08DC  7C        		ld	a,h
2029    08DD  B5        		or	l
2030    08DE  2806      		jr	z,L117
2031                    	;  337              cmdbuf[1] = 0x40;
2032    08E0  DD36F040  		ld	(ix-16),64
2033                    	;  338          else
2034    08E4  1804      		jr	L127
2035                    	L117:
2036                    	;  339              cmdbuf[1] = 0x00;
2037    08E6  DD36F000  		ld	(ix-16),0
2038                    	L127:
2039                    	;  340          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2040    08EA  210100    		ld	hl,1
2041    08ED  E5        		push	hl
2042    08EE  DDE5      		push	ix
2043    08F0  C1        		pop	bc
2044    08F1  21EAFF    		ld	hl,65514
2045    08F4  09        		add	hl,bc
2046    08F5  E5        		push	hl
2047    08F6  DDE5      		push	ix
2048    08F8  C1        		pop	bc
2049    08F9  21EFFF    		ld	hl,65519
2050    08FC  09        		add	hl,bc
2051    08FD  CD7701    		call	_sdcommand
2052    0900  F1        		pop	af
2053    0901  F1        		pop	af
2054    0902  DD71E8    		ld	(ix-24),c
2055    0905  DD70E9    		ld	(ix-23),b
2056                    	;  341          if (sdtestflg)
2057    0908  2A0000    		ld	hl,(_sdtestflg)
2058    090B  7C        		ld	a,h
2059    090C  B5        		or	l
2060    090D  2835      		jr	z,L137
2061                    	;  342              {
2062                    	;  343              if (!statptr)
2063    090F  DD7EE8    		ld	a,(ix-24)
2064    0912  DDB6E9    		or	(ix-23)
2065    0915  2008      		jr	nz,L147
2066                    	;  344                  printf("ACMD41: no response\n");
2067    0917  21B503    		ld	hl,L541
2068    091A  CD0000    		call	_printf
2069                    	;  345              else
2070    091D  1825      		jr	L137
2071                    	L147:
2072                    	;  346                  printf("ACMD41: SEND_OP_COND, R1 response [%02x]%s\n",
2073                    	;  347                         statptr[0], (statptr[0] == 0x00) ? " - ready" : "");
2074    091F  DD6EE8    		ld	l,(ix-24)
2075    0922  DD66E9    		ld	h,(ix-23)
2076    0925  7E        		ld	a,(hl)
2077    0926  B7        		or	a
2078    0927  2005      		jr	nz,L62
2079    0929  01CB03    		ld	bc,L561
2080    092C  1803      		jr	L03
2081                    	L62:
2082    092E  01CA03    		ld	bc,L571
2083                    	L03:
2084    0931  C5        		push	bc
2085    0932  DD6EE8    		ld	l,(ix-24)
2086    0935  DD66E9    		ld	h,(ix-23)
2087    0938  4E        		ld	c,(hl)
2088    0939  97        		sub	a
2089    093A  47        		ld	b,a
2090    093B  C5        		push	bc
2091    093C  21D403    		ld	hl,L551
2092    093F  CD0000    		call	_printf
2093    0942  F1        		pop	af
2094    0943  F1        		pop	af
2095                    	L137:
2096                    	;  348              } /* sdtestflg */
2097                    	;  349          if (!statptr)
2098    0944  DD7EE8    		ld	a,(ix-24)
2099    0947  DDB6E9    		or	(ix-23)
2100    094A  200C      		jr	nz,L167
2101                    	;  350              {
2102                    	;  351              spideselect();
2103    094C  CD0000    		call	_spideselect
2104                    	;  352              ledoff();
2105    094F  CD0000    		call	_ledoff
2106                    	;  353              return (NO);
2107    0952  010000    		ld	bc,0
2108    0955  C30000    		jp	c.rets0
2109                    	L167:
2110                    	;  354              }
2111                    	;  355          if (statptr[0] == 0x00) /* now the SD card is ready */
2112    0958  DD6EE8    		ld	l,(ix-24)
2113    095B  DD66E9    		ld	h,(ix-23)
2114    095E  7E        		ld	a,(hl)
2115    095F  B7        		or	a
2116    0960  282F      		jr	z,L126
2117                    	;  356              {
2118                    	;  357              break;
2119                    	;  358              }
2120                    	;  359          for (wtloop = 0; wtloop < tries * 10; wtloop++)
2121    0962  DD36F400  		ld	(ix-12),0
2122    0966  DD36F500  		ld	(ix-11),0
2123                    	L1001:
2124    096A  DD6EF6    		ld	l,(ix-10)
2125    096D  DD66F7    		ld	h,(ix-9)
2126    0970  4D        		ld	c,l
2127    0971  44        		ld	b,h
2128    0972  29        		add	hl,hl
2129    0973  29        		add	hl,hl
2130    0974  09        		add	hl,bc
2131    0975  29        		add	hl,hl
2132    0976  DD7EF4    		ld	a,(ix-12)
2133    0979  95        		sub	l
2134    097A  DD7EF5    		ld	a,(ix-11)
2135    097D  9C        		sbc	a,h
2136    097E  F29508    		jp	p,L136
2137                    	;  360              {
2138                    	;  361              /* wait loop, time increasing for each try */
2139                    	;  362              spiio(0xff);
2140    0981  21FF00    		ld	hl,255
2141    0984  CD0000    		call	_spiio
2142                    	;  363              }
2143    0987  DD34F4    		inc	(ix-12)
2144    098A  2003      		jr	nz,L23
2145    098C  DD34F5    		inc	(ix-11)
2146                    	L23:
2147    098F  18D9      		jr	L1001
2148                    	L126:
2149                    	;  364          }
2150                    	;  365  
2151                    	;  366      /* CMD58: READ_OCR */
2152                    	;  367      /* According to the flow chart this should not work
2153                    	;  368         for SD ver. 1 but the response is ok anyway
2154                    	;  369         all tested SD cards  */
2155                    	;  370      memcpy(cmdbuf, cmd58, 5);
2156    0991  210500    		ld	hl,5
2157    0994  E5        		push	hl
2158    0995  214900    		ld	hl,_cmd58
2159    0998  E5        		push	hl
2160    0999  DDE5      		push	ix
2161    099B  C1        		pop	bc
2162    099C  21EFFF    		ld	hl,65519
2163    099F  09        		add	hl,bc
2164    09A0  CD0000    		call	_memcpy
2165    09A3  F1        		pop	af
2166    09A4  F1        		pop	af
2167                    	;  371      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
2168    09A5  210500    		ld	hl,5
2169    09A8  E5        		push	hl
2170    09A9  DDE5      		push	ix
2171    09AB  C1        		pop	bc
2172    09AC  21EAFF    		ld	hl,65514
2173    09AF  09        		add	hl,bc
2174    09B0  E5        		push	hl
2175    09B1  DDE5      		push	ix
2176    09B3  C1        		pop	bc
2177    09B4  21EFFF    		ld	hl,65519
2178    09B7  09        		add	hl,bc
2179    09B8  CD7701    		call	_sdcommand
2180    09BB  F1        		pop	af
2181    09BC  F1        		pop	af
2182    09BD  DD71E8    		ld	(ix-24),c
2183    09C0  DD70E9    		ld	(ix-23),b
2184                    	;  372      if (sdtestflg)
2185    09C3  2A0000    		ld	hl,(_sdtestflg)
2186    09C6  7C        		ld	a,h
2187    09C7  B5        		or	l
2188    09C8  CA230A    		jp	z,L1401
2189                    	;  373          {
2190                    	;  374          if (!statptr)
2191    09CB  DD7EE8    		ld	a,(ix-24)
2192    09CE  DDB6E9    		or	(ix-23)
2193    09D1  2009      		jr	nz,L1501
2194                    	;  375              printf("CMD58: no response\n");
2195    09D3  210004    		ld	hl,L502
2196    09D6  CD0000    		call	_printf
2197                    	;  376          else
2198    09D9  C3230A    		jp	L1401
2199                    	L1501:
2200                    	;  377              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
2201                    	;  378                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
2202    09DC  DD6EE8    		ld	l,(ix-24)
2203    09DF  DD66E9    		ld	h,(ix-23)
2204    09E2  23        		inc	hl
2205    09E3  23        		inc	hl
2206    09E4  23        		inc	hl
2207    09E5  23        		inc	hl
2208    09E6  4E        		ld	c,(hl)
2209    09E7  97        		sub	a
2210    09E8  47        		ld	b,a
2211    09E9  C5        		push	bc
2212    09EA  DD6EE8    		ld	l,(ix-24)
2213    09ED  DD66E9    		ld	h,(ix-23)
2214    09F0  23        		inc	hl
2215    09F1  23        		inc	hl
2216    09F2  23        		inc	hl
2217    09F3  4E        		ld	c,(hl)
2218    09F4  97        		sub	a
2219    09F5  47        		ld	b,a
2220    09F6  C5        		push	bc
2221    09F7  DD6EE8    		ld	l,(ix-24)
2222    09FA  DD66E9    		ld	h,(ix-23)
2223    09FD  23        		inc	hl
2224    09FE  23        		inc	hl
2225    09FF  4E        		ld	c,(hl)
2226    0A00  97        		sub	a
2227    0A01  47        		ld	b,a
2228    0A02  C5        		push	bc
2229    0A03  DD6EE8    		ld	l,(ix-24)
2230    0A06  DD66E9    		ld	h,(ix-23)
2231    0A09  23        		inc	hl
2232    0A0A  4E        		ld	c,(hl)
2233    0A0B  97        		sub	a
2234    0A0C  47        		ld	b,a
2235    0A0D  C5        		push	bc
2236    0A0E  DD6EE8    		ld	l,(ix-24)
2237    0A11  DD66E9    		ld	h,(ix-23)
2238    0A14  4E        		ld	c,(hl)
2239    0A15  97        		sub	a
2240    0A16  47        		ld	b,a
2241    0A17  C5        		push	bc
2242    0A18  211404    		ld	hl,L512
2243    0A1B  CD0000    		call	_printf
2244    0A1E  210A00    		ld	hl,10
2245    0A21  39        		add	hl,sp
2246    0A22  F9        		ld	sp,hl
2247                    	L1401:
2248                    	;  379          } /* sdtestflg */
2249                    	;  380      if (!statptr)
2250    0A23  DD7EE8    		ld	a,(ix-24)
2251    0A26  DDB6E9    		or	(ix-23)
2252    0A29  200C      		jr	nz,L1701
2253                    	;  381          {
2254                    	;  382          spideselect();
2255    0A2B  CD0000    		call	_spideselect
2256                    	;  383          ledoff();
2257    0A2E  CD0000    		call	_ledoff
2258                    	;  384          return (NO);
2259    0A31  010000    		ld	bc,0
2260    0A34  C30000    		jp	c.rets0
2261                    	L1701:
2262                    	;  385          }
2263                    	;  386      memcpy(&ocrreg[0], &statptr[1], sizeof (ocrreg));
2264    0A37  210400    		ld	hl,4
2265    0A3A  E5        		push	hl
2266    0A3B  DD6EE8    		ld	l,(ix-24)
2267    0A3E  DD66E9    		ld	h,(ix-23)
2268    0A41  23        		inc	hl
2269    0A42  E5        		push	hl
2270    0A43  214800    		ld	hl,_ocrreg
2271    0A46  CD0000    		call	_memcpy
2272    0A49  F1        		pop	af
2273    0A4A  F1        		pop	af
2274                    	;  387      blkmult = 1; /* assume block address */
2275    0A4B  3E01      		ld	a,1
2276    0A4D  320800    		ld	(_blkmult+2),a
2277    0A50  87        		add	a,a
2278    0A51  9F        		sbc	a,a
2279    0A52  320900    		ld	(_blkmult+3),a
2280    0A55  320700    		ld	(_blkmult+1),a
2281    0A58  320600    		ld	(_blkmult),a
2282                    	;  388      if (ocrreg[0] & 0x80)
2283    0A5B  3A4800    		ld	a,(_ocrreg)
2284    0A5E  CB7F      		bit	7,a
2285    0A60  6F        		ld	l,a
2286    0A61  2817      		jr	z,L1011
2287                    	;  389          {
2288                    	;  390          /* SD Ver.2+ */
2289                    	;  391          if (!(ocrreg[0] & 0x40))
2290    0A63  3A4800    		ld	a,(_ocrreg)
2291    0A66  CB77      		bit	6,a
2292    0A68  6F        		ld	l,a
2293    0A69  200F      		jr	nz,L1011
2294                    	;  392              {
2295                    	;  393              /* SD Ver.2+, Byte address */
2296                    	;  394              blkmult = 512;
2297    0A6B  97        		sub	a
2298    0A6C  320600    		ld	(_blkmult),a
2299    0A6F  320700    		ld	(_blkmult+1),a
2300    0A72  320800    		ld	(_blkmult+2),a
2301    0A75  3E02      		ld	a,2
2302    0A77  320900    		ld	(_blkmult+3),a
2303                    	L1011:
2304                    	;  395              }
2305                    	;  396          }
2306                    	;  397  
2307                    	;  398      /* CMD 16: SET_BLOCKLEN, only if Byte addressing */
2308                    	;  399      if (blkmult == 512)
2309    0A7A  210600    		ld	hl,_blkmult
2310    0A7D  E5        		push	hl
2311    0A7E  97        		sub	a
2312    0A7F  320000    		ld	(c.r0),a
2313    0A82  320100    		ld	(c.r0+1),a
2314    0A85  320200    		ld	(c.r0+2),a
2315    0A88  3E02      		ld	a,2
2316    0A8A  320300    		ld	(c.r0+3),a
2317    0A8D  210000    		ld	hl,c.r0
2318    0A90  E5        		push	hl
2319    0A91  CD0000    		call	c.lcmp
2320    0A94  C2050B    		jp	nz,L1211
2321                    	;  400          {
2322                    	;  401          memcpy(cmdbuf, cmd16, 5);
2323    0A97  210500    		ld	hl,5
2324    0A9A  E5        		push	hl
2325    0A9B  213100    		ld	hl,_cmd16
2326    0A9E  E5        		push	hl
2327    0A9F  DDE5      		push	ix
2328    0AA1  C1        		pop	bc
2329    0AA2  21EFFF    		ld	hl,65519
2330    0AA5  09        		add	hl,bc
2331    0AA6  CD0000    		call	_memcpy
2332    0AA9  F1        		pop	af
2333    0AAA  F1        		pop	af
2334                    	;  402          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2335    0AAB  210100    		ld	hl,1
2336    0AAE  E5        		push	hl
2337    0AAF  DDE5      		push	ix
2338    0AB1  C1        		pop	bc
2339    0AB2  21EAFF    		ld	hl,65514
2340    0AB5  09        		add	hl,bc
2341    0AB6  E5        		push	hl
2342    0AB7  DDE5      		push	ix
2343    0AB9  C1        		pop	bc
2344    0ABA  21EFFF    		ld	hl,65519
2345    0ABD  09        		add	hl,bc
2346    0ABE  CD7701    		call	_sdcommand
2347    0AC1  F1        		pop	af
2348    0AC2  F1        		pop	af
2349    0AC3  DD71E8    		ld	(ix-24),c
2350    0AC6  DD70E9    		ld	(ix-23),b
2351                    	;  403          if (sdtestflg)
2352    0AC9  2A0000    		ld	hl,(_sdtestflg)
2353    0ACC  7C        		ld	a,h
2354    0ACD  B5        		or	l
2355    0ACE  2821      		jr	z,L1311
2356                    	;  404              {
2357                    	;  405              if (!statptr)
2358    0AD0  DD7EE8    		ld	a,(ix-24)
2359    0AD3  DDB6E9    		or	(ix-23)
2360    0AD6  2008      		jr	nz,L1411
2361                    	;  406                  printf("CMD16: no response\n");
2362    0AD8  214D04    		ld	hl,L522
2363    0ADB  CD0000    		call	_printf
2364                    	;  407              else
2365    0ADE  1811      		jr	L1311
2366                    	L1411:
2367                    	;  408                  printf("CMD16: SET_BLOCKLEN (to 512 bytes), R1 response [%02x]\n",
2368                    	;  409                         statptr[0]);
2369    0AE0  DD6EE8    		ld	l,(ix-24)
2370    0AE3  DD66E9    		ld	h,(ix-23)
2371    0AE6  4E        		ld	c,(hl)
2372    0AE7  97        		sub	a
2373    0AE8  47        		ld	b,a
2374    0AE9  C5        		push	bc
2375    0AEA  216104    		ld	hl,L532
2376    0AED  CD0000    		call	_printf
2377    0AF0  F1        		pop	af
2378                    	L1311:
2379                    	;  410              } /* sdtestflg */
2380                    	;  411          if (!statptr)
2381    0AF1  DD7EE8    		ld	a,(ix-24)
2382    0AF4  DDB6E9    		or	(ix-23)
2383    0AF7  200C      		jr	nz,L1211
2384                    	;  412              {
2385                    	;  413              spideselect();
2386    0AF9  CD0000    		call	_spideselect
2387                    	;  414              ledoff();
2388    0AFC  CD0000    		call	_ledoff
2389                    	;  415              return (NO);
2390    0AFF  010000    		ld	bc,0
2391    0B02  C30000    		jp	c.rets0
2392                    	L1211:
2393                    	;  416              }
2394                    	;  417          }
2395                    	;  418      /* Register information:
2396                    	;  419       *   https://www.cameramemoryspeed.com/sd-memory-card-faq/reading-sd-card-cid-serial-psn-internal-numbers/
2397                    	;  420       */
2398                    	;  421  
2399                    	;  422      /* CMD10: SEND_CID */
2400                    	;  423      memcpy(cmdbuf, cmd10, 5);
2401    0B05  210500    		ld	hl,5
2402    0B08  E5        		push	hl
2403    0B09  212B00    		ld	hl,_cmd10
2404    0B0C  E5        		push	hl
2405    0B0D  DDE5      		push	ix
2406    0B0F  C1        		pop	bc
2407    0B10  21EFFF    		ld	hl,65519
2408    0B13  09        		add	hl,bc
2409    0B14  CD0000    		call	_memcpy
2410    0B17  F1        		pop	af
2411    0B18  F1        		pop	af
2412                    	;  424      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2413    0B19  210100    		ld	hl,1
2414    0B1C  E5        		push	hl
2415    0B1D  DDE5      		push	ix
2416    0B1F  C1        		pop	bc
2417    0B20  21EAFF    		ld	hl,65514
2418    0B23  09        		add	hl,bc
2419    0B24  E5        		push	hl
2420    0B25  DDE5      		push	ix
2421    0B27  C1        		pop	bc
2422    0B28  21EFFF    		ld	hl,65519
2423    0B2B  09        		add	hl,bc
2424    0B2C  CD7701    		call	_sdcommand
2425    0B2F  F1        		pop	af
2426    0B30  F1        		pop	af
2427    0B31  DD71E8    		ld	(ix-24),c
2428    0B34  DD70E9    		ld	(ix-23),b
2429                    	;  425      if (sdtestflg)
2430    0B37  2A0000    		ld	hl,(_sdtestflg)
2431    0B3A  7C        		ld	a,h
2432    0B3B  B5        		or	l
2433    0B3C  2821      		jr	z,L1711
2434                    	;  426          {
2435                    	;  427          if (!statptr)
2436    0B3E  DD7EE8    		ld	a,(ix-24)
2437    0B41  DDB6E9    		or	(ix-23)
2438    0B44  2008      		jr	nz,L1021
2439                    	;  428              printf("CMD10: no response\n");
2440    0B46  219904    		ld	hl,L542
2441    0B49  CD0000    		call	_printf
2442                    	;  429          else
2443    0B4C  1811      		jr	L1711
2444                    	L1021:
2445                    	;  430              printf("CMD10: SEND_CID, R1 response [%02x]\n", statptr[0]);
2446    0B4E  DD6EE8    		ld	l,(ix-24)
2447    0B51  DD66E9    		ld	h,(ix-23)
2448    0B54  4E        		ld	c,(hl)
2449    0B55  97        		sub	a
2450    0B56  47        		ld	b,a
2451    0B57  C5        		push	bc
2452    0B58  21AD04    		ld	hl,L552
2453    0B5B  CD0000    		call	_printf
2454    0B5E  F1        		pop	af
2455                    	L1711:
2456                    	;  431          } /* sdtestflg */
2457                    	;  432      if (!statptr)
2458    0B5F  DD7EE8    		ld	a,(ix-24)
2459    0B62  DDB6E9    		or	(ix-23)
2460    0B65  200C      		jr	nz,L1221
2461                    	;  433          {
2462                    	;  434          spideselect();
2463    0B67  CD0000    		call	_spideselect
2464                    	;  435          ledoff();
2465    0B6A  CD0000    		call	_ledoff
2466                    	;  436          return (NO);
2467    0B6D  010000    		ld	bc,0
2468    0B70  C30000    		jp	c.rets0
2469                    	L1221:
2470                    	;  437          }
2471                    	;  438      /* looking for 0xfe that is the byte before data */
2472                    	;  439      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
2473    0B73  DD36F614  		ld	(ix-10),20
2474    0B77  DD36F700  		ld	(ix-9),0
2475                    	L1321:
2476    0B7B  97        		sub	a
2477    0B7C  DD96F6    		sub	(ix-10)
2478    0B7F  3E00      		ld	a,0
2479    0B81  DD9EF7    		sbc	a,(ix-9)
2480    0B84  F2A60B    		jp	p,L1421
2481    0B87  21FF00    		ld	hl,255
2482    0B8A  CD0000    		call	_spiio
2483    0B8D  79        		ld	a,c
2484    0B8E  FEFE      		cp	254
2485    0B90  2003      		jr	nz,L43
2486    0B92  78        		ld	a,b
2487    0B93  FE00      		cp	0
2488                    	L43:
2489    0B95  280F      		jr	z,L1421
2490                    	L1521:
2491    0B97  DD6EF6    		ld	l,(ix-10)
2492    0B9A  DD66F7    		ld	h,(ix-9)
2493    0B9D  2B        		dec	hl
2494    0B9E  DD75F6    		ld	(ix-10),l
2495    0BA1  DD74F7    		ld	(ix-9),h
2496    0BA4  18D5      		jr	L1321
2497                    	L1421:
2498                    	;  440          ;
2499                    	;  441      if (tries == 0) /* tried too many times */
2500    0BA6  DD7EF6    		ld	a,(ix-10)
2501    0BA9  DDB6F7    		or	(ix-9)
2502    0BAC  2019      		jr	nz,L1721
2503                    	;  442          {
2504                    	;  443          if (sdtestflg)
2505    0BAE  2A0000    		ld	hl,(_sdtestflg)
2506    0BB1  7C        		ld	a,h
2507    0BB2  B5        		or	l
2508    0BB3  2806      		jr	z,L1031
2509                    	;  444              {
2510                    	;  445              printf("  No data found\n");
2511    0BB5  21D204    		ld	hl,L562
2512    0BB8  CD0000    		call	_printf
2513                    	L1031:
2514                    	;  446              } /* sdtestflg */
2515                    	;  447          spideselect();
2516    0BBB  CD0000    		call	_spideselect
2517                    	;  448          ledoff();
2518    0BBE  CD0000    		call	_ledoff
2519                    	;  449          return (NO);
2520    0BC1  010000    		ld	bc,0
2521    0BC4  C30000    		jp	c.rets0
2522                    	L1721:
2523                    	;  450          }
2524                    	;  451      else
2525                    	;  452          {
2526                    	;  453          crc = 0;
2527    0BC7  DD36E700  		ld	(ix-25),0
2528                    	;  454          for (nbytes = 0; nbytes < 15; nbytes++)
2529    0BCB  DD36F800  		ld	(ix-8),0
2530    0BCF  DD36F900  		ld	(ix-7),0
2531                    	L1231:
2532    0BD3  DD7EF8    		ld	a,(ix-8)
2533    0BD6  D60F      		sub	15
2534    0BD8  DD7EF9    		ld	a,(ix-7)
2535    0BDB  DE00      		sbc	a,0
2536    0BDD  F2130C    		jp	p,L1331
2537                    	;  455              {
2538                    	;  456              rbyte = spiio(0xff);
2539    0BE0  21FF00    		ld	hl,255
2540    0BE3  CD0000    		call	_spiio
2541    0BE6  DD71E6    		ld	(ix-26),c
2542                    	;  457              cidreg[nbytes] = rbyte;
2543    0BE9  213800    		ld	hl,_cidreg
2544    0BEC  DD4EF8    		ld	c,(ix-8)
2545    0BEF  DD46F9    		ld	b,(ix-7)
2546    0BF2  09        		add	hl,bc
2547    0BF3  DD7EE6    		ld	a,(ix-26)
2548    0BF6  77        		ld	(hl),a
2549                    	;  458              crc = CRC7_one(crc, rbyte);
2550    0BF7  DD6EE6    		ld	l,(ix-26)
2551    0BFA  97        		sub	a
2552    0BFB  67        		ld	h,a
2553    0BFC  E5        		push	hl
2554    0BFD  DD6EE7    		ld	l,(ix-25)
2555    0C00  97        		sub	a
2556    0C01  67        		ld	h,a
2557    0C02  CD6700    		call	_CRC7_one
2558    0C05  F1        		pop	af
2559    0C06  DD71E7    		ld	(ix-25),c
2560                    	;  459              }
2561    0C09  DD34F8    		inc	(ix-8)
2562    0C0C  2003      		jr	nz,L63
2563    0C0E  DD34F9    		inc	(ix-7)
2564                    	L63:
2565    0C11  18C0      		jr	L1231
2566                    	L1331:
2567                    	;  460          cidreg[15] = spiio(0xff);
2568    0C13  21FF00    		ld	hl,255
2569    0C16  CD0000    		call	_spiio
2570    0C19  79        		ld	a,c
2571    0C1A  324700    		ld	(_cidreg+15),a
2572                    	;  461          crc |= 0x01;
2573    0C1D  DDCBE7C6  		set	0,(ix-25)
2574                    	;  462          /* some SD cards need additional clock pulses */
2575                    	;  463          for (nbytes = 9; 0 < nbytes; nbytes--)
2576    0C21  DD36F809  		ld	(ix-8),9
2577    0C25  DD36F900  		ld	(ix-7),0
2578                    	L1631:
2579    0C29  97        		sub	a
2580    0C2A  DD96F8    		sub	(ix-8)
2581    0C2D  3E00      		ld	a,0
2582    0C2F  DD9EF9    		sbc	a,(ix-7)
2583    0C32  F24A0C    		jp	p,L1731
2584                    	;  464              spiio(0xff);
2585    0C35  21FF00    		ld	hl,255
2586    0C38  CD0000    		call	_spiio
2587    0C3B  DD6EF8    		ld	l,(ix-8)
2588    0C3E  DD66F9    		ld	h,(ix-7)
2589    0C41  2B        		dec	hl
2590    0C42  DD75F8    		ld	(ix-8),l
2591    0C45  DD74F9    		ld	(ix-7),h
2592    0C48  18DF      		jr	L1631
2593                    	L1731:
2594                    	;  465          if (sdtestflg)
2595    0C4A  2A0000    		ld	hl,(_sdtestflg)
2596    0C4D  7C        		ld	a,h
2597    0C4E  B5        		or	l
2598    0C4F  CA2C0D    		jp	z,L1131
2599                    	;  466              {
2600                    	;  467              prtptr = &cidreg[0];
2601    0C52  213800    		ld	hl,_cidreg
2602    0C55  DD75E4    		ld	(ix-28),l
2603    0C58  DD74E5    		ld	(ix-27),h
2604                    	;  468              printf("  CID: [");
2605    0C5B  21E304    		ld	hl,L572
2606    0C5E  CD0000    		call	_printf
2607                    	;  469              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
2608    0C61  DD36F800  		ld	(ix-8),0
2609    0C65  DD36F900  		ld	(ix-7),0
2610                    	L1341:
2611    0C69  DD7EF8    		ld	a,(ix-8)
2612    0C6C  D610      		sub	16
2613    0C6E  DD7EF9    		ld	a,(ix-7)
2614    0C71  DE00      		sbc	a,0
2615    0C73  F2990C    		jp	p,L1441
2616                    	;  470                  printf("%02x ", *prtptr);
2617    0C76  DD6EE4    		ld	l,(ix-28)
2618    0C79  DD66E5    		ld	h,(ix-27)
2619    0C7C  4E        		ld	c,(hl)
2620    0C7D  97        		sub	a
2621    0C7E  47        		ld	b,a
2622    0C7F  C5        		push	bc
2623    0C80  21EC04    		ld	hl,L503
2624    0C83  CD0000    		call	_printf
2625    0C86  F1        		pop	af
2626    0C87  DD34F8    		inc	(ix-8)
2627    0C8A  2003      		jr	nz,L04
2628    0C8C  DD34F9    		inc	(ix-7)
2629                    	L04:
2630    0C8F  DD34E4    		inc	(ix-28)
2631    0C92  2003      		jr	nz,L24
2632    0C94  DD34E5    		inc	(ix-27)
2633                    	L24:
2634    0C97  18D0      		jr	L1341
2635                    	L1441:
2636                    	;  471              prtptr = &cidreg[0];
2637    0C99  213800    		ld	hl,_cidreg
2638    0C9C  DD75E4    		ld	(ix-28),l
2639    0C9F  DD74E5    		ld	(ix-27),h
2640                    	;  472              printf("\b] |");
2641    0CA2  21F204    		ld	hl,L513
2642    0CA5  CD0000    		call	_printf
2643                    	;  473              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
2644    0CA8  DD36F800  		ld	(ix-8),0
2645    0CAC  DD36F900  		ld	(ix-7),0
2646                    	L1741:
2647    0CB0  DD7EF8    		ld	a,(ix-8)
2648    0CB3  D610      		sub	16
2649    0CB5  DD7EF9    		ld	a,(ix-7)
2650    0CB8  DE00      		sbc	a,0
2651    0CBA  F2F90C    		jp	p,L1051
2652                    	;  474                  {
2653                    	;  475                  if ((' ' <= *prtptr) && (*prtptr < 127))
2654    0CBD  DD6EE4    		ld	l,(ix-28)
2655    0CC0  DD66E5    		ld	h,(ix-27)
2656    0CC3  7E        		ld	a,(hl)
2657    0CC4  FE20      		cp	32
2658    0CC6  3819      		jr	c,L1351
2659    0CC8  DD6EE4    		ld	l,(ix-28)
2660    0CCB  DD66E5    		ld	h,(ix-27)
2661    0CCE  7E        		ld	a,(hl)
2662    0CCF  FE7F      		cp	127
2663    0CD1  300E      		jr	nc,L1351
2664                    	;  476                      putchar(*prtptr);
2665    0CD3  DD6EE4    		ld	l,(ix-28)
2666    0CD6  DD66E5    		ld	h,(ix-27)
2667    0CD9  6E        		ld	l,(hl)
2668    0CDA  97        		sub	a
2669    0CDB  67        		ld	h,a
2670    0CDC  CD0000    		call	_putchar
2671                    	;  477                  else
2672    0CDF  1806      		jr	L1151
2673                    	L1351:
2674                    	;  478                      putchar('.');
2675    0CE1  212E00    		ld	hl,46
2676    0CE4  CD0000    		call	_putchar
2677                    	L1151:
2678    0CE7  DD34F8    		inc	(ix-8)
2679    0CEA  2003      		jr	nz,L44
2680    0CEC  DD34F9    		inc	(ix-7)
2681                    	L44:
2682    0CEF  DD34E4    		inc	(ix-28)
2683    0CF2  2003      		jr	nz,L64
2684    0CF4  DD34E5    		inc	(ix-27)
2685                    	L64:
2686    0CF7  18B7      		jr	L1741
2687                    	L1051:
2688                    	;  479                  }
2689                    	;  480              printf("|\n");
2690    0CF9  21F704    		ld	hl,L523
2691    0CFC  CD0000    		call	_printf
2692                    	;  481              if (crc == cidreg[15])
2693    0CFF  214700    		ld	hl,_cidreg+15
2694    0D02  DD7EE7    		ld	a,(ix-25)
2695    0D05  BE        		cp	(hl)
2696    0D06  200F      		jr	nz,L1551
2697                    	;  482                  {
2698                    	;  483                  printf("CRC7 ok: [%02x]\n", crc);
2699    0D08  DD4EE7    		ld	c,(ix-25)
2700    0D0B  97        		sub	a
2701    0D0C  47        		ld	b,a
2702    0D0D  C5        		push	bc
2703    0D0E  21FA04    		ld	hl,L533
2704    0D11  CD0000    		call	_printf
2705    0D14  F1        		pop	af
2706                    	;  484                  }
2707                    	;  485              else
2708    0D15  1815      		jr	L1131
2709                    	L1551:
2710                    	;  486                  {
2711                    	;  487                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
2712                    	;  488                         crc, cidreg[15]);
2713    0D17  3A4700    		ld	a,(_cidreg+15)
2714    0D1A  4F        		ld	c,a
2715    0D1B  97        		sub	a
2716    0D1C  47        		ld	b,a
2717    0D1D  C5        		push	bc
2718    0D1E  DD4EE7    		ld	c,(ix-25)
2719    0D21  97        		sub	a
2720    0D22  47        		ld	b,a
2721    0D23  C5        		push	bc
2722    0D24  210B05    		ld	hl,L543
2723    0D27  CD0000    		call	_printf
2724    0D2A  F1        		pop	af
2725    0D2B  F1        		pop	af
2726                    	L1131:
2727                    	;  489                  /* could maybe return failure here */
2728                    	;  490                  }
2729                    	;  491              } /* sdtestflg */
2730                    	;  492          }
2731                    	;  493  
2732                    	;  494      /* CMD9: SEND_CSD */
2733                    	;  495      memcpy(cmdbuf, cmd9, 5);
2734    0D2C  210500    		ld	hl,5
2735    0D2F  E5        		push	hl
2736    0D30  212500    		ld	hl,_cmd9
2737    0D33  E5        		push	hl
2738    0D34  DDE5      		push	ix
2739    0D36  C1        		pop	bc
2740    0D37  21EFFF    		ld	hl,65519
2741    0D3A  09        		add	hl,bc
2742    0D3B  CD0000    		call	_memcpy
2743    0D3E  F1        		pop	af
2744    0D3F  F1        		pop	af
2745                    	;  496      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2746    0D40  210100    		ld	hl,1
2747    0D43  E5        		push	hl
2748    0D44  DDE5      		push	ix
2749    0D46  C1        		pop	bc
2750    0D47  21EAFF    		ld	hl,65514
2751    0D4A  09        		add	hl,bc
2752    0D4B  E5        		push	hl
2753    0D4C  DDE5      		push	ix
2754    0D4E  C1        		pop	bc
2755    0D4F  21EFFF    		ld	hl,65519
2756    0D52  09        		add	hl,bc
2757    0D53  CD7701    		call	_sdcommand
2758    0D56  F1        		pop	af
2759    0D57  F1        		pop	af
2760    0D58  DD71E8    		ld	(ix-24),c
2761    0D5B  DD70E9    		ld	(ix-23),b
2762                    	;  497      if (sdtestflg)
2763    0D5E  2A0000    		ld	hl,(_sdtestflg)
2764    0D61  7C        		ld	a,h
2765    0D62  B5        		or	l
2766    0D63  2821      		jr	z,L1751
2767                    	;  498          {
2768                    	;  499          if (!statptr)
2769    0D65  DD7EE8    		ld	a,(ix-24)
2770    0D68  DDB6E9    		or	(ix-23)
2771    0D6B  2008      		jr	nz,L1061
2772                    	;  500              printf("CMD9: no response\n");
2773    0D6D  213D05    		ld	hl,L553
2774    0D70  CD0000    		call	_printf
2775                    	;  501          else
2776    0D73  1811      		jr	L1751
2777                    	L1061:
2778                    	;  502              printf("CMD9: SEND_CSD, R1 response [%02x]\n", statptr[0]);
2779    0D75  DD6EE8    		ld	l,(ix-24)
2780    0D78  DD66E9    		ld	h,(ix-23)
2781    0D7B  4E        		ld	c,(hl)
2782    0D7C  97        		sub	a
2783    0D7D  47        		ld	b,a
2784    0D7E  C5        		push	bc
2785    0D7F  215005    		ld	hl,L563
2786    0D82  CD0000    		call	_printf
2787    0D85  F1        		pop	af
2788                    	L1751:
2789                    	;  503          } /* sdtestflg */
2790                    	;  504      if (!statptr)
2791    0D86  DD7EE8    		ld	a,(ix-24)
2792    0D89  DDB6E9    		or	(ix-23)
2793    0D8C  200C      		jr	nz,L1261
2794                    	;  505          {
2795                    	;  506          spideselect();
2796    0D8E  CD0000    		call	_spideselect
2797                    	;  507          ledoff();
2798    0D91  CD0000    		call	_ledoff
2799                    	;  508          return (NO);
2800    0D94  010000    		ld	bc,0
2801    0D97  C30000    		jp	c.rets0
2802                    	L1261:
2803                    	;  509          }
2804                    	;  510      /* looking for 0xfe that is the byte before data */
2805                    	;  511      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
2806    0D9A  DD36F614  		ld	(ix-10),20
2807    0D9E  DD36F700  		ld	(ix-9),0
2808                    	L1361:
2809    0DA2  97        		sub	a
2810    0DA3  DD96F6    		sub	(ix-10)
2811    0DA6  3E00      		ld	a,0
2812    0DA8  DD9EF7    		sbc	a,(ix-9)
2813    0DAB  F2CD0D    		jp	p,L1461
2814    0DAE  21FF00    		ld	hl,255
2815    0DB1  CD0000    		call	_spiio
2816    0DB4  79        		ld	a,c
2817    0DB5  FEFE      		cp	254
2818    0DB7  2003      		jr	nz,L05
2819    0DB9  78        		ld	a,b
2820    0DBA  FE00      		cp	0
2821                    	L05:
2822    0DBC  280F      		jr	z,L1461
2823                    	L1561:
2824    0DBE  DD6EF6    		ld	l,(ix-10)
2825    0DC1  DD66F7    		ld	h,(ix-9)
2826    0DC4  2B        		dec	hl
2827    0DC5  DD75F6    		ld	(ix-10),l
2828    0DC8  DD74F7    		ld	(ix-9),h
2829    0DCB  18D5      		jr	L1361
2830                    	L1461:
2831                    	;  512          ;
2832                    	;  513      if (tries == 0) /* tried too many times */
2833    0DCD  DD7EF6    		ld	a,(ix-10)
2834    0DD0  DDB6F7    		or	(ix-9)
2835    0DD3  2013      		jr	nz,L1761
2836                    	;  514          {
2837                    	;  515          if (sdtestflg)
2838    0DD5  2A0000    		ld	hl,(_sdtestflg)
2839    0DD8  7C        		ld	a,h
2840    0DD9  B5        		or	l
2841    0DDA  2806      		jr	z,L1071
2842                    	;  516              {
2843                    	;  517              printf("  No data found\n");
2844    0DDC  217405    		ld	hl,L573
2845    0DDF  CD0000    		call	_printf
2846                    	L1071:
2847                    	;  518              } /* sdtestflg */
2848                    	;  519          return (NO);
2849    0DE2  010000    		ld	bc,0
2850    0DE5  C30000    		jp	c.rets0
2851                    	L1761:
2852                    	;  520          }
2853                    	;  521      else
2854                    	;  522          {
2855                    	;  523          crc = 0;
2856    0DE8  DD36E700  		ld	(ix-25),0
2857                    	;  524          for (nbytes = 0; nbytes < 15; nbytes++)
2858    0DEC  DD36F800  		ld	(ix-8),0
2859    0DF0  DD36F900  		ld	(ix-7),0
2860                    	L1271:
2861    0DF4  DD7EF8    		ld	a,(ix-8)
2862    0DF7  D60F      		sub	15
2863    0DF9  DD7EF9    		ld	a,(ix-7)
2864    0DFC  DE00      		sbc	a,0
2865    0DFE  F2340E    		jp	p,L1371
2866                    	;  525              {
2867                    	;  526              rbyte = spiio(0xff);
2868    0E01  21FF00    		ld	hl,255
2869    0E04  CD0000    		call	_spiio
2870    0E07  DD71E6    		ld	(ix-26),c
2871                    	;  527              csdreg[nbytes] = rbyte;
2872    0E0A  212800    		ld	hl,_csdreg
2873    0E0D  DD4EF8    		ld	c,(ix-8)
2874    0E10  DD46F9    		ld	b,(ix-7)
2875    0E13  09        		add	hl,bc
2876    0E14  DD7EE6    		ld	a,(ix-26)
2877    0E17  77        		ld	(hl),a
2878                    	;  528              crc = CRC7_one(crc, rbyte);
2879    0E18  DD6EE6    		ld	l,(ix-26)
2880    0E1B  97        		sub	a
2881    0E1C  67        		ld	h,a
2882    0E1D  E5        		push	hl
2883    0E1E  DD6EE7    		ld	l,(ix-25)
2884    0E21  97        		sub	a
2885    0E22  67        		ld	h,a
2886    0E23  CD6700    		call	_CRC7_one
2887    0E26  F1        		pop	af
2888    0E27  DD71E7    		ld	(ix-25),c
2889                    	;  529              }
2890    0E2A  DD34F8    		inc	(ix-8)
2891    0E2D  2003      		jr	nz,L25
2892    0E2F  DD34F9    		inc	(ix-7)
2893                    	L25:
2894    0E32  18C0      		jr	L1271
2895                    	L1371:
2896                    	;  530          csdreg[15] = spiio(0xff);
2897    0E34  21FF00    		ld	hl,255
2898    0E37  CD0000    		call	_spiio
2899    0E3A  79        		ld	a,c
2900    0E3B  323700    		ld	(_csdreg+15),a
2901                    	;  531          crc |= 0x01;
2902    0E3E  DDCBE7C6  		set	0,(ix-25)
2903                    	;  532          /* some SD cards need additional clock pulses */
2904                    	;  533          for (nbytes = 9; 0 < nbytes; nbytes--)
2905    0E42  DD36F809  		ld	(ix-8),9
2906    0E46  DD36F900  		ld	(ix-7),0
2907                    	L1671:
2908    0E4A  97        		sub	a
2909    0E4B  DD96F8    		sub	(ix-8)
2910    0E4E  3E00      		ld	a,0
2911    0E50  DD9EF9    		sbc	a,(ix-7)
2912    0E53  F26B0E    		jp	p,L1771
2913                    	;  534              spiio(0xff);
2914    0E56  21FF00    		ld	hl,255
2915    0E59  CD0000    		call	_spiio
2916    0E5C  DD6EF8    		ld	l,(ix-8)
2917    0E5F  DD66F9    		ld	h,(ix-7)
2918    0E62  2B        		dec	hl
2919    0E63  DD75F8    		ld	(ix-8),l
2920    0E66  DD74F9    		ld	(ix-7),h
2921    0E69  18DF      		jr	L1671
2922                    	L1771:
2923                    	;  535          if (sdtestflg)
2924    0E6B  2A0000    		ld	hl,(_sdtestflg)
2925    0E6E  7C        		ld	a,h
2926    0E6F  B5        		or	l
2927    0E70  CA4D0F    		jp	z,L1171
2928                    	;  536              {
2929                    	;  537              prtptr = &csdreg[0];
2930    0E73  212800    		ld	hl,_csdreg
2931    0E76  DD75E4    		ld	(ix-28),l
2932    0E79  DD74E5    		ld	(ix-27),h
2933                    	;  538              printf("  CSD: [");
2934    0E7C  218505    		ld	hl,L504
2935    0E7F  CD0000    		call	_printf
2936                    	;  539              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
2937    0E82  DD36F800  		ld	(ix-8),0
2938    0E86  DD36F900  		ld	(ix-7),0
2939                    	L1302:
2940    0E8A  DD7EF8    		ld	a,(ix-8)
2941    0E8D  D610      		sub	16
2942    0E8F  DD7EF9    		ld	a,(ix-7)
2943    0E92  DE00      		sbc	a,0
2944    0E94  F2BA0E    		jp	p,L1402
2945                    	;  540                  printf("%02x ", *prtptr);
2946    0E97  DD6EE4    		ld	l,(ix-28)
2947    0E9A  DD66E5    		ld	h,(ix-27)
2948    0E9D  4E        		ld	c,(hl)
2949    0E9E  97        		sub	a
2950    0E9F  47        		ld	b,a
2951    0EA0  C5        		push	bc
2952    0EA1  218E05    		ld	hl,L514
2953    0EA4  CD0000    		call	_printf
2954    0EA7  F1        		pop	af
2955    0EA8  DD34F8    		inc	(ix-8)
2956    0EAB  2003      		jr	nz,L45
2957    0EAD  DD34F9    		inc	(ix-7)
2958                    	L45:
2959    0EB0  DD34E4    		inc	(ix-28)
2960    0EB3  2003      		jr	nz,L65
2961    0EB5  DD34E5    		inc	(ix-27)
2962                    	L65:
2963    0EB8  18D0      		jr	L1302
2964                    	L1402:
2965                    	;  541              prtptr = &csdreg[0];
2966    0EBA  212800    		ld	hl,_csdreg
2967    0EBD  DD75E4    		ld	(ix-28),l
2968    0EC0  DD74E5    		ld	(ix-27),h
2969                    	;  542              printf("\b] |");
2970    0EC3  219405    		ld	hl,L524
2971    0EC6  CD0000    		call	_printf
2972                    	;  543              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
2973    0EC9  DD36F800  		ld	(ix-8),0
2974    0ECD  DD36F900  		ld	(ix-7),0
2975                    	L1702:
2976    0ED1  DD7EF8    		ld	a,(ix-8)
2977    0ED4  D610      		sub	16
2978    0ED6  DD7EF9    		ld	a,(ix-7)
2979    0ED9  DE00      		sbc	a,0
2980    0EDB  F21A0F    		jp	p,L1012
2981                    	;  544                  {
2982                    	;  545                  if ((' ' <= *prtptr) && (*prtptr < 127))
2983    0EDE  DD6EE4    		ld	l,(ix-28)
2984    0EE1  DD66E5    		ld	h,(ix-27)
2985    0EE4  7E        		ld	a,(hl)
2986    0EE5  FE20      		cp	32
2987    0EE7  3819      		jr	c,L1312
2988    0EE9  DD6EE4    		ld	l,(ix-28)
2989    0EEC  DD66E5    		ld	h,(ix-27)
2990    0EEF  7E        		ld	a,(hl)
2991    0EF0  FE7F      		cp	127
2992    0EF2  300E      		jr	nc,L1312
2993                    	;  546                      putchar(*prtptr);
2994    0EF4  DD6EE4    		ld	l,(ix-28)
2995    0EF7  DD66E5    		ld	h,(ix-27)
2996    0EFA  6E        		ld	l,(hl)
2997    0EFB  97        		sub	a
2998    0EFC  67        		ld	h,a
2999    0EFD  CD0000    		call	_putchar
3000                    	;  547                  else
3001    0F00  1806      		jr	L1112
3002                    	L1312:
3003                    	;  548                      putchar('.');
3004    0F02  212E00    		ld	hl,46
3005    0F05  CD0000    		call	_putchar
3006                    	L1112:
3007    0F08  DD34F8    		inc	(ix-8)
3008    0F0B  2003      		jr	nz,L06
3009    0F0D  DD34F9    		inc	(ix-7)
3010                    	L06:
3011    0F10  DD34E4    		inc	(ix-28)
3012    0F13  2003      		jr	nz,L26
3013    0F15  DD34E5    		inc	(ix-27)
3014                    	L26:
3015    0F18  18B7      		jr	L1702
3016                    	L1012:
3017                    	;  549                  }
3018                    	;  550              printf("|\n");
3019    0F1A  219905    		ld	hl,L534
3020    0F1D  CD0000    		call	_printf
3021                    	;  551              if (crc == csdreg[15])
3022    0F20  213700    		ld	hl,_csdreg+15
3023    0F23  DD7EE7    		ld	a,(ix-25)
3024    0F26  BE        		cp	(hl)
3025    0F27  200F      		jr	nz,L1512
3026                    	;  552                  {
3027                    	;  553                  printf("CRC7 ok: [%02x]\n", crc);
3028    0F29  DD4EE7    		ld	c,(ix-25)
3029    0F2C  97        		sub	a
3030    0F2D  47        		ld	b,a
3031    0F2E  C5        		push	bc
3032    0F2F  219C05    		ld	hl,L544
3033    0F32  CD0000    		call	_printf
3034    0F35  F1        		pop	af
3035                    	;  554                  }
3036                    	;  555              else
3037    0F36  1815      		jr	L1171
3038                    	L1512:
3039                    	;  556                  {
3040                    	;  557                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
3041                    	;  558                         crc, csdreg[15]);
3042    0F38  3A3700    		ld	a,(_csdreg+15)
3043    0F3B  4F        		ld	c,a
3044    0F3C  97        		sub	a
3045    0F3D  47        		ld	b,a
3046    0F3E  C5        		push	bc
3047    0F3F  DD4EE7    		ld	c,(ix-25)
3048    0F42  97        		sub	a
3049    0F43  47        		ld	b,a
3050    0F44  C5        		push	bc
3051    0F45  21AD05    		ld	hl,L554
3052    0F48  CD0000    		call	_printf
3053    0F4B  F1        		pop	af
3054    0F4C  F1        		pop	af
3055                    	L1171:
3056                    	;  559                  /* could maybe return failure here */
3057                    	;  560                  }
3058                    	;  561              } /* sdtestflg */
3059                    	;  562          }
3060                    	;  563  
3061                    	;  564      for (nbytes = 9; 0 < nbytes; nbytes--)
3062    0F4D  DD36F809  		ld	(ix-8),9
3063    0F51  DD36F900  		ld	(ix-7),0
3064                    	L1712:
3065    0F55  97        		sub	a
3066    0F56  DD96F8    		sub	(ix-8)
3067    0F59  3E00      		ld	a,0
3068    0F5B  DD9EF9    		sbc	a,(ix-7)
3069    0F5E  F2760F    		jp	p,L1022
3070                    	;  565          spiio(0xff);
3071    0F61  21FF00    		ld	hl,255
3072    0F64  CD0000    		call	_spiio
3073    0F67  DD6EF8    		ld	l,(ix-8)
3074    0F6A  DD66F9    		ld	h,(ix-7)
3075    0F6D  2B        		dec	hl
3076    0F6E  DD75F8    		ld	(ix-8),l
3077    0F71  DD74F9    		ld	(ix-7),h
3078    0F74  18DF      		jr	L1712
3079                    	L1022:
3080                    	;  566      if (sdtestflg)
3081    0F76  2A0000    		ld	hl,(_sdtestflg)
3082    0F79  7C        		ld	a,h
3083    0F7A  B5        		or	l
3084    0F7B  2806      		jr	z,L1322
3085                    	;  567          {
3086                    	;  568          printf("Sent 9*8 (72) clock pulses, select active\n");
3087    0F7D  21DF05    		ld	hl,L564
3088    0F80  CD0000    		call	_printf
3089                    	L1322:
3090                    	;  569          } /* sdtestflg */
3091                    	;  570  
3092                    	;  571      sdinitok = YES;
3093    0F83  210100    		ld	hl,1
3094    0F86  220C00    		ld	(_sdinitok),hl
3095                    	;  572  
3096                    	;  573      spideselect();
3097    0F89  CD0000    		call	_spideselect
3098                    	;  574      ledoff();
3099    0F8C  CD0000    		call	_ledoff
3100                    	;  575  
3101                    	;  576      return (YES);
3102    0F8F  010100    		ld	bc,1
3103    0F92  C30000    		jp	c.rets0
3104                    	L574:
3105    0F95  43        		.byte	67
3106    0F96  4D        		.byte	77
3107    0F97  44        		.byte	68
3108    0F98  35        		.byte	53
3109    0F99  38        		.byte	56
3110    0F9A  3A        		.byte	58
3111    0F9B  20        		.byte	32
3112    0F9C  6E        		.byte	110
3113    0F9D  6F        		.byte	111
3114    0F9E  20        		.byte	32
3115    0F9F  72        		.byte	114
3116    0FA0  65        		.byte	101
3117    0FA1  73        		.byte	115
3118    0FA2  70        		.byte	112
3119    0FA3  6F        		.byte	111
3120    0FA4  6E        		.byte	110
3121    0FA5  73        		.byte	115
3122    0FA6  65        		.byte	101
3123    0FA7  0A        		.byte	10
3124    0FA8  00        		.byte	0
3125                    	L505:
3126    0FA9  43        		.byte	67
3127    0FAA  4D        		.byte	77
3128    0FAB  44        		.byte	68
3129    0FAC  35        		.byte	53
3130    0FAD  38        		.byte	56
3131    0FAE  3A        		.byte	58
3132    0FAF  20        		.byte	32
3133    0FB0  52        		.byte	82
3134    0FB1  45        		.byte	69
3135    0FB2  41        		.byte	65
3136    0FB3  44        		.byte	68
3137    0FB4  5F        		.byte	95
3138    0FB5  4F        		.byte	79
3139    0FB6  43        		.byte	67
3140    0FB7  52        		.byte	82
3141    0FB8  2C        		.byte	44
3142    0FB9  20        		.byte	32
3143    0FBA  52        		.byte	82
3144    0FBB  33        		.byte	51
3145    0FBC  20        		.byte	32
3146    0FBD  72        		.byte	114
3147    0FBE  65        		.byte	101
3148    0FBF  73        		.byte	115
3149    0FC0  70        		.byte	112
3150    0FC1  6F        		.byte	111
3151    0FC2  6E        		.byte	110
3152    0FC3  73        		.byte	115
3153    0FC4  65        		.byte	101
3154    0FC5  20        		.byte	32
3155    0FC6  5B        		.byte	91
3156    0FC7  25        		.byte	37
3157    0FC8  30        		.byte	48
3158    0FC9  32        		.byte	50
3159    0FCA  78        		.byte	120
3160    0FCB  20        		.byte	32
3161    0FCC  25        		.byte	37
3162    0FCD  30        		.byte	48
3163    0FCE  32        		.byte	50
3164    0FCF  78        		.byte	120
3165    0FD0  20        		.byte	32
3166    0FD1  25        		.byte	37
3167    0FD2  30        		.byte	48
3168    0FD3  32        		.byte	50
3169    0FD4  78        		.byte	120
3170    0FD5  20        		.byte	32
3171    0FD6  25        		.byte	37
3172    0FD7  30        		.byte	48
3173    0FD8  32        		.byte	50
3174    0FD9  78        		.byte	120
3175    0FDA  20        		.byte	32
3176    0FDB  25        		.byte	37
3177    0FDC  30        		.byte	48
3178    0FDD  32        		.byte	50
3179    0FDE  78        		.byte	120
3180    0FDF  5D        		.byte	93
3181    0FE0  0A        		.byte	10
3182    0FE1  00        		.byte	0
3183                    	L515:
3184    0FE2  53        		.byte	83
3185    0FE3  44        		.byte	68
3186    0FE4  20        		.byte	32
3187    0FE5  63        		.byte	99
3188    0FE6  61        		.byte	97
3189    0FE7  72        		.byte	114
3190    0FE8  64        		.byte	100
3191    0FE9  20        		.byte	32
3192    0FEA  6E        		.byte	110
3193    0FEB  6F        		.byte	111
3194    0FEC  74        		.byte	116
3195    0FED  20        		.byte	32
3196    0FEE  69        		.byte	105
3197    0FEF  6E        		.byte	110
3198    0FF0  73        		.byte	115
3199    0FF1  65        		.byte	101
3200    0FF2  72        		.byte	114
3201    0FF3  74        		.byte	116
3202    0FF4  65        		.byte	101
3203    0FF5  64        		.byte	100
3204    0FF6  20        		.byte	32
3205    0FF7  6F        		.byte	111
3206    0FF8  72        		.byte	114
3207    0FF9  20        		.byte	32
3208    0FFA  6E        		.byte	110
3209    0FFB  6F        		.byte	111
3210    0FFC  74        		.byte	116
3211    0FFD  20        		.byte	32
3212    0FFE  69        		.byte	105
3213    0FFF  6E        		.byte	110
3214    1000  69        		.byte	105
3215    1001  74        		.byte	116
3216    1002  69        		.byte	105
3217    1003  61        		.byte	97
3218    1004  6C        		.byte	108
3219    1005  69        		.byte	105
3220    1006  7A        		.byte	122
3221    1007  65        		.byte	101
3222    1008  64        		.byte	100
3223    1009  0A        		.byte	10
3224    100A  00        		.byte	0
3225                    	;  577      }
3226                    	;  578  
3227                    	;  579  int sdprobe()
3228                    	;  580      {
3229                    	_sdprobe:
3230    100B  CD0000    		call	c.savs0
3231    100E  21EAFF    		ld	hl,65514
3232    1011  39        		add	hl,sp
3233    1012  F9        		ld	sp,hl
3234                    	;  581      unsigned char cmdbuf[5];   /* buffer to build command in */
3235                    	;  582      unsigned char rstatbuf[5]; /* buffer to recieve status in */
3236                    	;  583      unsigned char *statptr;    /* pointer to returned status from SD command */
3237                    	;  584      int nbytes;  /* byte counter */
3238                    	;  585      int allzero = YES;
3239    1013  DD36EA01  		ld	(ix-22),1
3240    1017  DD36EB00  		ld	(ix-21),0
3241                    	;  586  
3242                    	;  587      ledon();
3243    101B  CD0000    		call	_ledon
3244                    	;  588      spiselect();
3245    101E  CD0000    		call	_spiselect
3246                    	;  589  
3247                    	;  590      /* CMD58: READ_OCR */
3248                    	;  591      memcpy(cmdbuf, cmd58, 5);
3249    1021  210500    		ld	hl,5
3250    1024  E5        		push	hl
3251    1025  214900    		ld	hl,_cmd58
3252    1028  E5        		push	hl
3253    1029  DDE5      		push	ix
3254    102B  C1        		pop	bc
3255    102C  21F5FF    		ld	hl,65525
3256    102F  09        		add	hl,bc
3257    1030  CD0000    		call	_memcpy
3258    1033  F1        		pop	af
3259    1034  F1        		pop	af
3260                    	;  592      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
3261    1035  210500    		ld	hl,5
3262    1038  E5        		push	hl
3263    1039  DDE5      		push	ix
3264    103B  C1        		pop	bc
3265    103C  21F0FF    		ld	hl,65520
3266    103F  09        		add	hl,bc
3267    1040  E5        		push	hl
3268    1041  DDE5      		push	ix
3269    1043  C1        		pop	bc
3270    1044  21F5FF    		ld	hl,65525
3271    1047  09        		add	hl,bc
3272    1048  CD7701    		call	_sdcommand
3273    104B  F1        		pop	af
3274    104C  F1        		pop	af
3275    104D  DD71EE    		ld	(ix-18),c
3276    1050  DD70EF    		ld	(ix-17),b
3277                    	;  593      for (nbytes = 0; nbytes < 5; nbytes++)
3278    1053  DD36EC00  		ld	(ix-20),0
3279    1057  DD36ED00  		ld	(ix-19),0
3280                    	L1422:
3281    105B  DD7EEC    		ld	a,(ix-20)
3282    105E  D605      		sub	5
3283    1060  DD7EED    		ld	a,(ix-19)
3284    1063  DE00      		sbc	a,0
3285    1065  F28B10    		jp	p,L1522
3286                    	;  594          {
3287                    	;  595          if (statptr[nbytes] != 0)
3288    1068  DD6EEE    		ld	l,(ix-18)
3289    106B  DD66EF    		ld	h,(ix-17)
3290    106E  DD4EEC    		ld	c,(ix-20)
3291    1071  DD46ED    		ld	b,(ix-19)
3292    1074  09        		add	hl,bc
3293    1075  7E        		ld	a,(hl)
3294    1076  B7        		or	a
3295    1077  2808      		jr	z,L1622
3296                    	;  596              allzero = NO;
3297    1079  DD36EA00  		ld	(ix-22),0
3298    107D  DD36EB00  		ld	(ix-21),0
3299                    	L1622:
3300    1081  DD34EC    		inc	(ix-20)
3301    1084  2003      		jr	nz,L66
3302    1086  DD34ED    		inc	(ix-19)
3303                    	L66:
3304    1089  18D0      		jr	L1422
3305                    	L1522:
3306                    	;  597          }
3307                    	;  598      if (sdtestflg)
3308    108B  2A0000    		ld	hl,(_sdtestflg)
3309    108E  7C        		ld	a,h
3310    108F  B5        		or	l
3311    1090  CAF910    		jp	z,L1132
3312                    	;  599          {
3313                    	;  600          if (!statptr)
3314    1093  DD7EEE    		ld	a,(ix-18)
3315    1096  DDB6EF    		or	(ix-17)
3316    1099  2009      		jr	nz,L1232
3317                    	;  601              printf("CMD58: no response\n");
3318    109B  21950F    		ld	hl,L574
3319    109E  CD0000    		call	_printf
3320                    	;  602          else
3321    10A1  C3F910    		jp	L1132
3322                    	L1232:
3323                    	;  603              {
3324                    	;  604              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
3325                    	;  605                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
3326    10A4  DD6EEE    		ld	l,(ix-18)
3327    10A7  DD66EF    		ld	h,(ix-17)
3328    10AA  23        		inc	hl
3329    10AB  23        		inc	hl
3330    10AC  23        		inc	hl
3331    10AD  23        		inc	hl
3332    10AE  4E        		ld	c,(hl)
3333    10AF  97        		sub	a
3334    10B0  47        		ld	b,a
3335    10B1  C5        		push	bc
3336    10B2  DD6EEE    		ld	l,(ix-18)
3337    10B5  DD66EF    		ld	h,(ix-17)
3338    10B8  23        		inc	hl
3339    10B9  23        		inc	hl
3340    10BA  23        		inc	hl
3341    10BB  4E        		ld	c,(hl)
3342    10BC  97        		sub	a
3343    10BD  47        		ld	b,a
3344    10BE  C5        		push	bc
3345    10BF  DD6EEE    		ld	l,(ix-18)
3346    10C2  DD66EF    		ld	h,(ix-17)
3347    10C5  23        		inc	hl
3348    10C6  23        		inc	hl
3349    10C7  4E        		ld	c,(hl)
3350    10C8  97        		sub	a
3351    10C9  47        		ld	b,a
3352    10CA  C5        		push	bc
3353    10CB  DD6EEE    		ld	l,(ix-18)
3354    10CE  DD66EF    		ld	h,(ix-17)
3355    10D1  23        		inc	hl
3356    10D2  4E        		ld	c,(hl)
3357    10D3  97        		sub	a
3358    10D4  47        		ld	b,a
3359    10D5  C5        		push	bc
3360    10D6  DD6EEE    		ld	l,(ix-18)
3361    10D9  DD66EF    		ld	h,(ix-17)
3362    10DC  4E        		ld	c,(hl)
3363    10DD  97        		sub	a
3364    10DE  47        		ld	b,a
3365    10DF  C5        		push	bc
3366    10E0  21A90F    		ld	hl,L505
3367    10E3  CD0000    		call	_printf
3368    10E6  210A00    		ld	hl,10
3369    10E9  39        		add	hl,sp
3370    10EA  F9        		ld	sp,hl
3371                    	;  606              if (allzero)
3372    10EB  DD7EEA    		ld	a,(ix-22)
3373    10EE  DDB6EB    		or	(ix-21)
3374    10F1  2806      		jr	z,L1132
3375                    	;  607                  printf("SD card not inserted or not initialized\n");
3376    10F3  21E20F    		ld	hl,L515
3377    10F6  CD0000    		call	_printf
3378                    	L1132:
3379                    	;  608              }
3380                    	;  609          } /* sdtestflg */
3381                    	;  610      if (!statptr || allzero)
3382    10F9  DD7EEE    		ld	a,(ix-18)
3383    10FC  DDB6EF    		or	(ix-17)
3384    10FF  2808      		jr	z,L1632
3385    1101  DD7EEA    		ld	a,(ix-22)
3386    1104  DDB6EB    		or	(ix-21)
3387    1107  2812      		jr	z,L1532
3388                    	L1632:
3389                    	;  611          {
3390                    	;  612          sdinitok = NO;
3391    1109  210000    		ld	hl,0
3392    110C  220C00    		ld	(_sdinitok),hl
3393                    	;  613          spideselect();
3394    110F  CD0000    		call	_spideselect
3395                    	;  614          ledoff();
3396    1112  CD0000    		call	_ledoff
3397                    	;  615          return (NO);
3398    1115  010000    		ld	bc,0
3399    1118  C30000    		jp	c.rets0
3400                    	L1532:
3401                    	;  616          }
3402                    	;  617  
3403                    	;  618      spideselect();
3404    111B  CD0000    		call	_spideselect
3405                    	;  619      ledoff();
3406    111E  CD0000    		call	_ledoff
3407                    	;  620  
3408                    	;  621      return (YES);
3409    1121  010100    		ld	bc,1
3410    1124  C30000    		jp	c.rets0
3411                    	L525:
3412    1127  53        		.byte	83
3413    1128  44        		.byte	68
3414    1129  20        		.byte	32
3415    112A  63        		.byte	99
3416    112B  61        		.byte	97
3417    112C  72        		.byte	114
3418    112D  64        		.byte	100
3419    112E  20        		.byte	32
3420    112F  6E        		.byte	110
3421    1130  6F        		.byte	111
3422    1131  74        		.byte	116
3423    1132  20        		.byte	32
3424    1133  69        		.byte	105
3425    1134  6E        		.byte	110
3426    1135  69        		.byte	105
3427    1136  74        		.byte	116
3428    1137  69        		.byte	105
3429    1138  61        		.byte	97
3430    1139  6C        		.byte	108
3431    113A  69        		.byte	105
3432    113B  7A        		.byte	122
3433    113C  65        		.byte	101
3434    113D  64        		.byte	100
3435    113E  0A        		.byte	10
3436    113F  00        		.byte	0
3437                    	L535:
3438    1140  53        		.byte	83
3439    1141  44        		.byte	68
3440    1142  20        		.byte	32
3441    1143  63        		.byte	99
3442    1144  61        		.byte	97
3443    1145  72        		.byte	114
3444    1146  64        		.byte	100
3445    1147  20        		.byte	32
3446    1148  69        		.byte	105
3447    1149  6E        		.byte	110
3448    114A  66        		.byte	102
3449    114B  6F        		.byte	111
3450    114C  72        		.byte	114
3451    114D  6D        		.byte	109
3452    114E  61        		.byte	97
3453    114F  74        		.byte	116
3454    1150  69        		.byte	105
3455    1151  6F        		.byte	111
3456    1152  6E        		.byte	110
3457    1153  3A        		.byte	58
3458    1154  00        		.byte	0
3459                    	L545:
3460    1155  20        		.byte	32
3461    1156  20        		.byte	32
3462    1157  53        		.byte	83
3463    1158  44        		.byte	68
3464    1159  20        		.byte	32
3465    115A  63        		.byte	99
3466    115B  61        		.byte	97
3467    115C  72        		.byte	114
3468    115D  64        		.byte	100
3469    115E  20        		.byte	32
3470    115F  76        		.byte	118
3471    1160  65        		.byte	101
3472    1161  72        		.byte	114
3473    1162  2E        		.byte	46
3474    1163  20        		.byte	32
3475    1164  32        		.byte	50
3476    1165  2B        		.byte	43
3477    1166  2C        		.byte	44
3478    1167  20        		.byte	32
3479    1168  42        		.byte	66
3480    1169  6C        		.byte	108
3481    116A  6F        		.byte	111
3482    116B  63        		.byte	99
3483    116C  6B        		.byte	107
3484    116D  20        		.byte	32
3485    116E  61        		.byte	97
3486    116F  64        		.byte	100
3487    1170  64        		.byte	100
3488    1171  72        		.byte	114
3489    1172  65        		.byte	101
3490    1173  73        		.byte	115
3491    1174  73        		.byte	115
3492    1175  0A        		.byte	10
3493    1176  00        		.byte	0
3494                    	L555:
3495    1177  20        		.byte	32
3496    1178  20        		.byte	32
3497    1179  53        		.byte	83
3498    117A  44        		.byte	68
3499    117B  20        		.byte	32
3500    117C  63        		.byte	99
3501    117D  61        		.byte	97
3502    117E  72        		.byte	114
3503    117F  64        		.byte	100
3504    1180  20        		.byte	32
3505    1181  76        		.byte	118
3506    1182  65        		.byte	101
3507    1183  72        		.byte	114
3508    1184  2E        		.byte	46
3509    1185  20        		.byte	32
3510    1186  32        		.byte	50
3511    1187  2B        		.byte	43
3512    1188  2C        		.byte	44
3513    1189  20        		.byte	32
3514    118A  42        		.byte	66
3515    118B  79        		.byte	121
3516    118C  74        		.byte	116
3517    118D  65        		.byte	101
3518    118E  20        		.byte	32
3519    118F  61        		.byte	97
3520    1190  64        		.byte	100
3521    1191  64        		.byte	100
3522    1192  72        		.byte	114
3523    1193  65        		.byte	101
3524    1194  73        		.byte	115
3525    1195  73        		.byte	115
3526    1196  0A        		.byte	10
3527    1197  00        		.byte	0
3528                    	L565:
3529    1198  20        		.byte	32
3530    1199  20        		.byte	32
3531    119A  53        		.byte	83
3532    119B  44        		.byte	68
3533    119C  20        		.byte	32
3534    119D  63        		.byte	99
3535    119E  61        		.byte	97
3536    119F  72        		.byte	114
3537    11A0  64        		.byte	100
3538    11A1  20        		.byte	32
3539    11A2  76        		.byte	118
3540    11A3  65        		.byte	101
3541    11A4  72        		.byte	114
3542    11A5  2E        		.byte	46
3543    11A6  20        		.byte	32
3544    11A7  31        		.byte	49
3545    11A8  2C        		.byte	44
3546    11A9  20        		.byte	32
3547    11AA  42        		.byte	66
3548    11AB  79        		.byte	121
3549    11AC  74        		.byte	116
3550    11AD  65        		.byte	101
3551    11AE  20        		.byte	32
3552    11AF  61        		.byte	97
3553    11B0  64        		.byte	100
3554    11B1  64        		.byte	100
3555    11B2  72        		.byte	114
3556    11B3  65        		.byte	101
3557    11B4  73        		.byte	115
3558    11B5  73        		.byte	115
3559    11B6  0A        		.byte	10
3560    11B7  00        		.byte	0
3561                    	L575:
3562    11B8  20        		.byte	32
3563    11B9  20        		.byte	32
3564    11BA  4D        		.byte	77
3565    11BB  61        		.byte	97
3566    11BC  6E        		.byte	110
3567    11BD  75        		.byte	117
3568    11BE  66        		.byte	102
3569    11BF  61        		.byte	97
3570    11C0  63        		.byte	99
3571    11C1  74        		.byte	116
3572    11C2  75        		.byte	117
3573    11C3  72        		.byte	114
3574    11C4  65        		.byte	101
3575    11C5  72        		.byte	114
3576    11C6  20        		.byte	32
3577    11C7  49        		.byte	73
3578    11C8  44        		.byte	68
3579    11C9  3A        		.byte	58
3580    11CA  20        		.byte	32
3581    11CB  30        		.byte	48
3582    11CC  78        		.byte	120
3583    11CD  25        		.byte	37
3584    11CE  30        		.byte	48
3585    11CF  32        		.byte	50
3586    11D0  78        		.byte	120
3587    11D1  2C        		.byte	44
3588    11D2  20        		.byte	32
3589    11D3  00        		.byte	0
3590                    	L506:
3591    11D4  4F        		.byte	79
3592    11D5  45        		.byte	69
3593    11D6  4D        		.byte	77
3594    11D7  20        		.byte	32
3595    11D8  49        		.byte	73
3596    11D9  44        		.byte	68
3597    11DA  3A        		.byte	58
3598    11DB  20        		.byte	32
3599    11DC  25        		.byte	37
3600    11DD  2E        		.byte	46
3601    11DE  32        		.byte	50
3602    11DF  73        		.byte	115
3603    11E0  2C        		.byte	44
3604    11E1  20        		.byte	32
3605    11E2  00        		.byte	0
3606                    	L516:
3607    11E3  50        		.byte	80
3608    11E4  72        		.byte	114
3609    11E5  6F        		.byte	111
3610    11E6  64        		.byte	100
3611    11E7  75        		.byte	117
3612    11E8  63        		.byte	99
3613    11E9  74        		.byte	116
3614    11EA  20        		.byte	32
3615    11EB  6E        		.byte	110
3616    11EC  61        		.byte	97
3617    11ED  6D        		.byte	109
3618    11EE  65        		.byte	101
3619    11EF  3A        		.byte	58
3620    11F0  20        		.byte	32
3621    11F1  25        		.byte	37
3622    11F2  2E        		.byte	46
3623    11F3  35        		.byte	53
3624    11F4  73        		.byte	115
3625    11F5  0A        		.byte	10
3626    11F6  00        		.byte	0
3627                    	L526:
3628    11F7  20        		.byte	32
3629    11F8  20        		.byte	32
3630    11F9  50        		.byte	80
3631    11FA  72        		.byte	114
3632    11FB  6F        		.byte	111
3633    11FC  64        		.byte	100
3634    11FD  75        		.byte	117
3635    11FE  63        		.byte	99
3636    11FF  74        		.byte	116
3637    1200  20        		.byte	32
3638    1201  72        		.byte	114
3639    1202  65        		.byte	101
3640    1203  76        		.byte	118
3641    1204  69        		.byte	105
3642    1205  73        		.byte	115
3643    1206  69        		.byte	105
3644    1207  6F        		.byte	111
3645    1208  6E        		.byte	110
3646    1209  3A        		.byte	58
3647    120A  20        		.byte	32
3648    120B  25        		.byte	37
3649    120C  64        		.byte	100
3650    120D  2E        		.byte	46
3651    120E  25        		.byte	37
3652    120F  64        		.byte	100
3653    1210  2C        		.byte	44
3654    1211  20        		.byte	32
3655    1212  00        		.byte	0
3656                    	L536:
3657    1213  53        		.byte	83
3658    1214  65        		.byte	101
3659    1215  72        		.byte	114
3660    1216  69        		.byte	105
3661    1217  61        		.byte	97
3662    1218  6C        		.byte	108
3663    1219  20        		.byte	32
3664    121A  6E        		.byte	110
3665    121B  75        		.byte	117
3666    121C  6D        		.byte	109
3667    121D  62        		.byte	98
3668    121E  65        		.byte	101
3669    121F  72        		.byte	114
3670    1220  3A        		.byte	58
3671    1221  20        		.byte	32
3672    1222  25        		.byte	37
3673    1223  6C        		.byte	108
3674    1224  75        		.byte	117
3675    1225  0A        		.byte	10
3676    1226  00        		.byte	0
3677                    	L546:
3678    1227  20        		.byte	32
3679    1228  20        		.byte	32
3680    1229  4D        		.byte	77
3681    122A  61        		.byte	97
3682    122B  6E        		.byte	110
3683    122C  75        		.byte	117
3684    122D  66        		.byte	102
3685    122E  61        		.byte	97
3686    122F  63        		.byte	99
3687    1230  74        		.byte	116
3688    1231  75        		.byte	117
3689    1232  72        		.byte	114
3690    1233  69        		.byte	105
3691    1234  6E        		.byte	110
3692    1235  67        		.byte	103
3693    1236  20        		.byte	32
3694    1237  64        		.byte	100
3695    1238  61        		.byte	97
3696    1239  74        		.byte	116
3697    123A  65        		.byte	101
3698    123B  3A        		.byte	58
3699    123C  20        		.byte	32
3700    123D  25        		.byte	37
3701    123E  64        		.byte	100
3702    123F  2D        		.byte	45
3703    1240  25        		.byte	37
3704    1241  64        		.byte	100
3705    1242  2C        		.byte	44
3706    1243  20        		.byte	32
3707    1244  00        		.byte	0
3708                    	L556:
3709    1245  44        		.byte	68
3710    1246  65        		.byte	101
3711    1247  76        		.byte	118
3712    1248  69        		.byte	105
3713    1249  63        		.byte	99
3714    124A  65        		.byte	101
3715    124B  20        		.byte	32
3716    124C  63        		.byte	99
3717    124D  61        		.byte	97
3718    124E  70        		.byte	112
3719    124F  61        		.byte	97
3720    1250  63        		.byte	99
3721    1251  69        		.byte	105
3722    1252  74        		.byte	116
3723    1253  79        		.byte	121
3724    1254  3A        		.byte	58
3725    1255  20        		.byte	32
3726    1256  25        		.byte	37
3727    1257  6C        		.byte	108
3728    1258  75        		.byte	117
3729    1259  20        		.byte	32
3730    125A  4D        		.byte	77
3731    125B  42        		.byte	66
3732    125C  79        		.byte	121
3733    125D  74        		.byte	116
3734    125E  65        		.byte	101
3735    125F  0A        		.byte	10
3736    1260  00        		.byte	0
3737                    	L566:
3738    1261  44        		.byte	68
3739    1262  65        		.byte	101
3740    1263  76        		.byte	118
3741    1264  69        		.byte	105
3742    1265  63        		.byte	99
3743    1266  65        		.byte	101
3744    1267  20        		.byte	32
3745    1268  63        		.byte	99
3746    1269  61        		.byte	97
3747    126A  70        		.byte	112
3748    126B  61        		.byte	97
3749    126C  63        		.byte	99
3750    126D  69        		.byte	105
3751    126E  74        		.byte	116
3752    126F  79        		.byte	121
3753    1270  3A        		.byte	58
3754    1271  20        		.byte	32
3755    1272  25        		.byte	37
3756    1273  6C        		.byte	108
3757    1274  75        		.byte	117
3758    1275  20        		.byte	32
3759    1276  4D        		.byte	77
3760    1277  42        		.byte	66
3761    1278  79        		.byte	121
3762    1279  74        		.byte	116
3763    127A  65        		.byte	101
3764    127B  0A        		.byte	10
3765    127C  00        		.byte	0
3766                    	L576:
3767    127D  44        		.byte	68
3768    127E  65        		.byte	101
3769    127F  76        		.byte	118
3770    1280  69        		.byte	105
3771    1281  63        		.byte	99
3772    1282  65        		.byte	101
3773    1283  20        		.byte	32
3774    1284  75        		.byte	117
3775    1285  6C        		.byte	108
3776    1286  74        		.byte	116
3777    1287  72        		.byte	114
3778    1288  61        		.byte	97
3779    1289  20        		.byte	32
3780    128A  63        		.byte	99
3781    128B  61        		.byte	97
3782    128C  70        		.byte	112
3783    128D  61        		.byte	97
3784    128E  63        		.byte	99
3785    128F  69        		.byte	105
3786    1290  74        		.byte	116
3787    1291  79        		.byte	121
3788    1292  3A        		.byte	58
3789    1293  20        		.byte	32
3790    1294  25        		.byte	37
3791    1295  6C        		.byte	108
3792    1296  75        		.byte	117
3793    1297  20        		.byte	32
3794    1298  4D        		.byte	77
3795    1299  42        		.byte	66
3796    129A  79        		.byte	121
3797    129B  74        		.byte	116
3798    129C  65        		.byte	101
3799    129D  0A        		.byte	10
3800    129E  00        		.byte	0
3801                    	L507:
3802    129F  2D        		.byte	45
3803    12A0  2D        		.byte	45
3804    12A1  2D        		.byte	45
3805    12A2  2D        		.byte	45
3806    12A3  2D        		.byte	45
3807    12A4  2D        		.byte	45
3808    12A5  2D        		.byte	45
3809    12A6  2D        		.byte	45
3810    12A7  2D        		.byte	45
3811    12A8  2D        		.byte	45
3812    12A9  2D        		.byte	45
3813    12AA  2D        		.byte	45
3814    12AB  2D        		.byte	45
3815    12AC  2D        		.byte	45
3816    12AD  2D        		.byte	45
3817    12AE  2D        		.byte	45
3818    12AF  2D        		.byte	45
3819    12B0  2D        		.byte	45
3820    12B1  2D        		.byte	45
3821    12B2  2D        		.byte	45
3822    12B3  2D        		.byte	45
3823    12B4  2D        		.byte	45
3824    12B5  2D        		.byte	45
3825    12B6  2D        		.byte	45
3826    12B7  2D        		.byte	45
3827    12B8  2D        		.byte	45
3828    12B9  2D        		.byte	45
3829    12BA  2D        		.byte	45
3830    12BB  2D        		.byte	45
3831    12BC  2D        		.byte	45
3832    12BD  2D        		.byte	45
3833    12BE  2D        		.byte	45
3834    12BF  2D        		.byte	45
3835    12C0  2D        		.byte	45
3836    12C1  2D        		.byte	45
3837    12C2  2D        		.byte	45
3838    12C3  2D        		.byte	45
3839    12C4  2D        		.byte	45
3840    12C5  0A        		.byte	10
3841    12C6  00        		.byte	0
3842                    	L517:
3843    12C7  4F        		.byte	79
3844    12C8  43        		.byte	67
3845    12C9  52        		.byte	82
3846    12CA  20        		.byte	32
3847    12CB  72        		.byte	114
3848    12CC  65        		.byte	101
3849    12CD  67        		.byte	103
3850    12CE  69        		.byte	105
3851    12CF  73        		.byte	115
3852    12D0  74        		.byte	116
3853    12D1  65        		.byte	101
3854    12D2  72        		.byte	114
3855    12D3  3A        		.byte	58
3856    12D4  0A        		.byte	10
3857    12D5  00        		.byte	0
3858                    	L527:
3859    12D6  32        		.byte	50
3860    12D7  2E        		.byte	46
3861    12D8  37        		.byte	55
3862    12D9  2D        		.byte	45
3863    12DA  32        		.byte	50
3864    12DB  2E        		.byte	46
3865    12DC  38        		.byte	56
3866    12DD  56        		.byte	86
3867    12DE  20        		.byte	32
3868    12DF  28        		.byte	40
3869    12E0  62        		.byte	98
3870    12E1  69        		.byte	105
3871    12E2  74        		.byte	116
3872    12E3  20        		.byte	32
3873    12E4  31        		.byte	49
3874    12E5  35        		.byte	53
3875    12E6  29        		.byte	41
3876    12E7  20        		.byte	32
3877    12E8  00        		.byte	0
3878                    	L537:
3879    12E9  32        		.byte	50
3880    12EA  2E        		.byte	46
3881    12EB  38        		.byte	56
3882    12EC  2D        		.byte	45
3883    12ED  32        		.byte	50
3884    12EE  2E        		.byte	46
3885    12EF  39        		.byte	57
3886    12F0  56        		.byte	86
3887    12F1  20        		.byte	32
3888    12F2  28        		.byte	40
3889    12F3  62        		.byte	98
3890    12F4  69        		.byte	105
3891    12F5  74        		.byte	116
3892    12F6  20        		.byte	32
3893    12F7  31        		.byte	49
3894    12F8  36        		.byte	54
3895    12F9  29        		.byte	41
3896    12FA  20        		.byte	32
3897    12FB  00        		.byte	0
3898                    	L547:
3899    12FC  32        		.byte	50
3900    12FD  2E        		.byte	46
3901    12FE  39        		.byte	57
3902    12FF  2D        		.byte	45
3903    1300  33        		.byte	51
3904    1301  2E        		.byte	46
3905    1302  30        		.byte	48
3906    1303  56        		.byte	86
3907    1304  20        		.byte	32
3908    1305  28        		.byte	40
3909    1306  62        		.byte	98
3910    1307  69        		.byte	105
3911    1308  74        		.byte	116
3912    1309  20        		.byte	32
3913    130A  31        		.byte	49
3914    130B  37        		.byte	55
3915    130C  29        		.byte	41
3916    130D  20        		.byte	32
3917    130E  00        		.byte	0
3918                    	L557:
3919    130F  33        		.byte	51
3920    1310  2E        		.byte	46
3921    1311  30        		.byte	48
3922    1312  2D        		.byte	45
3923    1313  33        		.byte	51
3924    1314  2E        		.byte	46
3925    1315  31        		.byte	49
3926    1316  56        		.byte	86
3927    1317  20        		.byte	32
3928    1318  28        		.byte	40
3929    1319  62        		.byte	98
3930    131A  69        		.byte	105
3931    131B  74        		.byte	116
3932    131C  20        		.byte	32
3933    131D  31        		.byte	49
3934    131E  38        		.byte	56
3935    131F  29        		.byte	41
3936    1320  20        		.byte	32
3937    1321  0A        		.byte	10
3938    1322  00        		.byte	0
3939                    	L567:
3940    1323  33        		.byte	51
3941    1324  2E        		.byte	46
3942    1325  31        		.byte	49
3943    1326  2D        		.byte	45
3944    1327  33        		.byte	51
3945    1328  2E        		.byte	46
3946    1329  32        		.byte	50
3947    132A  56        		.byte	86
3948    132B  20        		.byte	32
3949    132C  28        		.byte	40
3950    132D  62        		.byte	98
3951    132E  69        		.byte	105
3952    132F  74        		.byte	116
3953    1330  20        		.byte	32
3954    1331  31        		.byte	49
3955    1332  39        		.byte	57
3956    1333  29        		.byte	41
3957    1334  20        		.byte	32
3958    1335  00        		.byte	0
3959                    	L577:
3960    1336  33        		.byte	51
3961    1337  2E        		.byte	46
3962    1338  32        		.byte	50
3963    1339  2D        		.byte	45
3964    133A  33        		.byte	51
3965    133B  2E        		.byte	46
3966    133C  33        		.byte	51
3967    133D  56        		.byte	86
3968    133E  20        		.byte	32
3969    133F  28        		.byte	40
3970    1340  62        		.byte	98
3971    1341  69        		.byte	105
3972    1342  74        		.byte	116
3973    1343  20        		.byte	32
3974    1344  32        		.byte	50
3975    1345  30        		.byte	48
3976    1346  29        		.byte	41
3977    1347  20        		.byte	32
3978    1348  00        		.byte	0
3979                    	L5001:
3980    1349  33        		.byte	51
3981    134A  2E        		.byte	46
3982    134B  33        		.byte	51
3983    134C  2D        		.byte	45
3984    134D  33        		.byte	51
3985    134E  2E        		.byte	46
3986    134F  34        		.byte	52
3987    1350  56        		.byte	86
3988    1351  20        		.byte	32
3989    1352  28        		.byte	40
3990    1353  62        		.byte	98
3991    1354  69        		.byte	105
3992    1355  74        		.byte	116
3993    1356  20        		.byte	32
3994    1357  32        		.byte	50
3995    1358  31        		.byte	49
3996    1359  29        		.byte	41
3997    135A  20        		.byte	32
3998    135B  00        		.byte	0
3999                    	L5101:
4000    135C  33        		.byte	51
4001    135D  2E        		.byte	46
4002    135E  34        		.byte	52
4003    135F  2D        		.byte	45
4004    1360  33        		.byte	51
4005    1361  2E        		.byte	46
4006    1362  35        		.byte	53
4007    1363  56        		.byte	86
4008    1364  20        		.byte	32
4009    1365  28        		.byte	40
4010    1366  62        		.byte	98
4011    1367  69        		.byte	105
4012    1368  74        		.byte	116
4013    1369  20        		.byte	32
4014    136A  32        		.byte	50
4015    136B  32        		.byte	50
4016    136C  29        		.byte	41
4017    136D  20        		.byte	32
4018    136E  0A        		.byte	10
4019    136F  00        		.byte	0
4020                    	L5201:
4021    1370  33        		.byte	51
4022    1371  2E        		.byte	46
4023    1372  35        		.byte	53
4024    1373  2D        		.byte	45
4025    1374  33        		.byte	51
4026    1375  2E        		.byte	46
4027    1376  36        		.byte	54
4028    1377  56        		.byte	86
4029    1378  20        		.byte	32
4030    1379  28        		.byte	40
4031    137A  62        		.byte	98
4032    137B  69        		.byte	105
4033    137C  74        		.byte	116
4034    137D  20        		.byte	32
4035    137E  32        		.byte	50
4036    137F  33        		.byte	51
4037    1380  29        		.byte	41
4038    1381  20        		.byte	32
4039    1382  0A        		.byte	10
4040    1383  00        		.byte	0
4041                    	L5301:
4042    1384  53        		.byte	83
4043    1385  77        		.byte	119
4044    1386  69        		.byte	105
4045    1387  74        		.byte	116
4046    1388  63        		.byte	99
4047    1389  68        		.byte	104
4048    138A  69        		.byte	105
4049    138B  6E        		.byte	110
4050    138C  67        		.byte	103
4051    138D  20        		.byte	32
4052    138E  74        		.byte	116
4053    138F  6F        		.byte	111
4054    1390  20        		.byte	32
4055    1391  31        		.byte	49
4056    1392  2E        		.byte	46
4057    1393  38        		.byte	56
4058    1394  56        		.byte	86
4059    1395  20        		.byte	32
4060    1396  41        		.byte	65
4061    1397  63        		.byte	99
4062    1398  63        		.byte	99
4063    1399  65        		.byte	101
4064    139A  70        		.byte	112
4065    139B  74        		.byte	116
4066    139C  65        		.byte	101
4067    139D  64        		.byte	100
4068    139E  20        		.byte	32
4069    139F  28        		.byte	40
4070    13A0  53        		.byte	83
4071    13A1  31        		.byte	49
4072    13A2  38        		.byte	56
4073    13A3  41        		.byte	65
4074    13A4  29        		.byte	41
4075    13A5  20        		.byte	32
4076    13A6  28        		.byte	40
4077    13A7  62        		.byte	98
4078    13A8  69        		.byte	105
4079    13A9  74        		.byte	116
4080    13AA  20        		.byte	32
4081    13AB  32        		.byte	50
4082    13AC  34        		.byte	52
4083    13AD  29        		.byte	41
4084    13AE  20        		.byte	32
4085    13AF  73        		.byte	115
4086    13B0  65        		.byte	101
4087    13B1  74        		.byte	116
4088    13B2  20        		.byte	32
4089    13B3  00        		.byte	0
4090                    	L5401:
4091    13B4  4F        		.byte	79
4092    13B5  76        		.byte	118
4093    13B6  65        		.byte	101
4094    13B7  72        		.byte	114
4095    13B8  20        		.byte	32
   0    13B9  32        		.byte	50
   1    13BA  54        		.byte	84
   2    13BB  42        		.byte	66
   3    13BC  20        		.byte	32
   4    13BD  73        		.byte	115
   5    13BE  75        		.byte	117
   6    13BF  70        		.byte	112
   7    13C0  70        		.byte	112
   8    13C1  6F        		.byte	111
   9    13C2  72        		.byte	114
  10    13C3  74        		.byte	116
  11    13C4  20        		.byte	32
  12    13C5  53        		.byte	83
  13    13C6  74        		.byte	116
  14    13C7  61        		.byte	97
  15    13C8  74        		.byte	116
  16    13C9  75        		.byte	117
  17    13CA  73        		.byte	115
  18    13CB  20        		.byte	32
  19    13CC  28        		.byte	40
  20    13CD  43        		.byte	67
  21    13CE  4F        		.byte	79
  22    13CF  32        		.byte	50
  23    13D0  54        		.byte	84
  24    13D1  29        		.byte	41
  25    13D2  20        		.byte	32
  26    13D3  28        		.byte	40
  27    13D4  62        		.byte	98
  28    13D5  69        		.byte	105
  29    13D6  74        		.byte	116
  30    13D7  20        		.byte	32
  31    13D8  32        		.byte	50
  32    13D9  37        		.byte	55
  33    13DA  29        		.byte	41
  34    13DB  20        		.byte	32
  35    13DC  73        		.byte	115
  36    13DD  65        		.byte	101
  37    13DE  74        		.byte	116
  38    13DF  0A        		.byte	10
  39    13E0  00        		.byte	0
  40                    	L5501:
  41    13E1  55        		.byte	85
  42    13E2  48        		.byte	72
  43    13E3  53        		.byte	83
  44    13E4  2D        		.byte	45
  45    13E5  49        		.byte	73
  46    13E6  49        		.byte	73
  47    13E7  20        		.byte	32
  48    13E8  43        		.byte	67
  49    13E9  61        		.byte	97
  50    13EA  72        		.byte	114
  51    13EB  64        		.byte	100
  52    13EC  20        		.byte	32
  53    13ED  53        		.byte	83
  54    13EE  74        		.byte	116
  55    13EF  61        		.byte	97
  56    13F0  74        		.byte	116
  57    13F1  75        		.byte	117
  58    13F2  73        		.byte	115
  59    13F3  20        		.byte	32
  60    13F4  28        		.byte	40
  61    13F5  62        		.byte	98
  62    13F6  69        		.byte	105
  63    13F7  74        		.byte	116
  64    13F8  20        		.byte	32
  65    13F9  32        		.byte	50
  66    13FA  39        		.byte	57
  67    13FB  29        		.byte	41
  68    13FC  20        		.byte	32
  69    13FD  73        		.byte	115
  70    13FE  65        		.byte	101
  71    13FF  74        		.byte	116
  72    1400  20        		.byte	32
  73    1401  00        		.byte	0
  74                    	L5601:
  75    1402  43        		.byte	67
  76    1403  61        		.byte	97
  77    1404  72        		.byte	114
  78    1405  64        		.byte	100
  79    1406  20        		.byte	32
  80    1407  43        		.byte	67
  81    1408  61        		.byte	97
  82    1409  70        		.byte	112
  83    140A  61        		.byte	97
  84    140B  63        		.byte	99
  85    140C  69        		.byte	105
  86    140D  74        		.byte	116
  87    140E  79        		.byte	121
  88    140F  20        		.byte	32
  89    1410  53        		.byte	83
  90    1411  74        		.byte	116
  91    1412  61        		.byte	97
  92    1413  74        		.byte	116
  93    1414  75        		.byte	117
  94    1415  73        		.byte	115
  95    1416  20        		.byte	32
  96    1417  28        		.byte	40
  97    1418  43        		.byte	67
  98    1419  43        		.byte	67
  99    141A  53        		.byte	83
 100    141B  29        		.byte	41
 101    141C  20        		.byte	32
 102    141D  28        		.byte	40
 103    141E  62        		.byte	98
 104    141F  69        		.byte	105
 105    1420  74        		.byte	116
 106    1421  20        		.byte	32
 107    1422  33        		.byte	51
 108    1423  30        		.byte	48
 109    1424  29        		.byte	41
 110    1425  20        		.byte	32
 111    1426  73        		.byte	115
 112    1427  65        		.byte	101
 113    1428  74        		.byte	116
 114    1429  0A        		.byte	10
 115    142A  00        		.byte	0
 116                    	L5701:
 117    142B  20        		.byte	32
 118    142C  20        		.byte	32
 119    142D  53        		.byte	83
 120    142E  44        		.byte	68
 121    142F  20        		.byte	32
 122    1430  56        		.byte	86
 123    1431  65        		.byte	101
 124    1432  72        		.byte	114
 125    1433  2E        		.byte	46
 126    1434  32        		.byte	50
 127    1435  2B        		.byte	43
 128    1436  2C        		.byte	44
 129    1437  20        		.byte	32
 130    1438  42        		.byte	66
 131    1439  6C        		.byte	108
 132    143A  6F        		.byte	111
 133    143B  63        		.byte	99
 134    143C  6B        		.byte	107
 135    143D  20        		.byte	32
 136    143E  61        		.byte	97
 137    143F  64        		.byte	100
 138    1440  64        		.byte	100
 139    1441  72        		.byte	114
 140    1442  65        		.byte	101
 141    1443  73        		.byte	115
 142    1444  73        		.byte	115
 143    1445  00        		.byte	0
 144                    	L5011:
 145    1446  43        		.byte	67
 146    1447  61        		.byte	97
 147    1448  72        		.byte	114
 148    1449  64        		.byte	100
 149    144A  20        		.byte	32
 150    144B  43        		.byte	67
 151    144C  61        		.byte	97
 152    144D  70        		.byte	112
 153    144E  61        		.byte	97
 154    144F  63        		.byte	99
 155    1450  69        		.byte	105
 156    1451  74        		.byte	116
 157    1452  79        		.byte	121
 158    1453  20        		.byte	32
 159    1454  53        		.byte	83
 160    1455  74        		.byte	116
 161    1456  61        		.byte	97
 162    1457  74        		.byte	116
 163    1458  75        		.byte	117
 164    1459  73        		.byte	115
 165    145A  20        		.byte	32
 166    145B  28        		.byte	40
 167    145C  43        		.byte	67
 168    145D  43        		.byte	67
 169    145E  53        		.byte	83
 170    145F  29        		.byte	41
 171    1460  20        		.byte	32
 172    1461  28        		.byte	40
 173    1462  62        		.byte	98
 174    1463  69        		.byte	105
 175    1464  74        		.byte	116
 176    1465  20        		.byte	32
 177    1466  33        		.byte	51
 178    1467  30        		.byte	48
 179    1468  29        		.byte	41
 180    1469  20        		.byte	32
 181    146A  6E        		.byte	110
 182    146B  6F        		.byte	111
 183    146C  74        		.byte	116
 184    146D  20        		.byte	32
 185    146E  73        		.byte	115
 186    146F  65        		.byte	101
 187    1470  74        		.byte	116
 188    1471  0A        		.byte	10
 189    1472  00        		.byte	0
 190                    	L5111:
 191    1473  20        		.byte	32
 192    1474  20        		.byte	32
 193    1475  53        		.byte	83
 194    1476  44        		.byte	68
 195    1477  20        		.byte	32
 196    1478  56        		.byte	86
 197    1479  65        		.byte	101
 198    147A  72        		.byte	114
 199    147B  2E        		.byte	46
 200    147C  32        		.byte	50
 201    147D  2B        		.byte	43
 202    147E  2C        		.byte	44
 203    147F  20        		.byte	32
 204    1480  42        		.byte	66
 205    1481  79        		.byte	121
 206    1482  74        		.byte	116
 207    1483  65        		.byte	101
 208    1484  20        		.byte	32
 209    1485  61        		.byte	97
 210    1486  64        		.byte	100
 211    1487  64        		.byte	100
 212    1488  72        		.byte	114
 213    1489  65        		.byte	101
 214    148A  73        		.byte	115
 215    148B  73        		.byte	115
 216    148C  00        		.byte	0
 217                    	L5211:
 218    148D  20        		.byte	32
 219    148E  20        		.byte	32
 220    148F  53        		.byte	83
 221    1490  44        		.byte	68
 222    1491  20        		.byte	32
 223    1492  56        		.byte	86
 224    1493  65        		.byte	101
 225    1494  72        		.byte	114
 226    1495  2E        		.byte	46
 227    1496  31        		.byte	49
 228    1497  2C        		.byte	44
 229    1498  20        		.byte	32
 230    1499  42        		.byte	66
 231    149A  79        		.byte	121
 232    149B  74        		.byte	116
 233    149C  65        		.byte	101
 234    149D  20        		.byte	32
 235    149E  61        		.byte	97
 236    149F  64        		.byte	100
 237    14A0  64        		.byte	100
 238    14A1  72        		.byte	114
 239    14A2  65        		.byte	101
 240    14A3  73        		.byte	115
 241    14A4  73        		.byte	115
 242    14A5  00        		.byte	0
 243                    	L5311:
 244    14A6  0A        		.byte	10
 245    14A7  43        		.byte	67
 246    14A8  61        		.byte	97
 247    14A9  72        		.byte	114
 248    14AA  64        		.byte	100
 249    14AB  20        		.byte	32
 250    14AC  70        		.byte	112
 251    14AD  6F        		.byte	111
 252    14AE  77        		.byte	119
 253    14AF  65        		.byte	101
 254    14B0  72        		.byte	114
 255    14B1  20        		.byte	32
 256    14B2  75        		.byte	117
 257    14B3  70        		.byte	112
 258    14B4  20        		.byte	32
 259    14B5  73        		.byte	115
 260    14B6  74        		.byte	116
 261    14B7  61        		.byte	97
 262    14B8  74        		.byte	116
 263    14B9  75        		.byte	117
 264    14BA  73        		.byte	115
 265    14BB  20        		.byte	32
 266    14BC  62        		.byte	98
 267    14BD  69        		.byte	105
 268    14BE  74        		.byte	116
 269    14BF  20        		.byte	32
 270    14C0  28        		.byte	40
 271    14C1  62        		.byte	98
 272    14C2  75        		.byte	117
 273    14C3  73        		.byte	115
 274    14C4  79        		.byte	121
 275    14C5  29        		.byte	41
 276    14C6  20        		.byte	32
 277    14C7  28        		.byte	40
 278    14C8  62        		.byte	98
 279    14C9  69        		.byte	105
 280    14CA  74        		.byte	116
 281    14CB  20        		.byte	32
 282    14CC  33        		.byte	51
 283    14CD  31        		.byte	49
 284    14CE  29        		.byte	41
 285    14CF  20        		.byte	32
 286    14D0  73        		.byte	115
 287    14D1  65        		.byte	101
 288    14D2  74        		.byte	116
 289    14D3  0A        		.byte	10
 290    14D4  00        		.byte	0
 291                    	L5411:
 292    14D5  0A        		.byte	10
 293    14D6  43        		.byte	67
 294    14D7  61        		.byte	97
 295    14D8  72        		.byte	114
 296    14D9  64        		.byte	100
 297    14DA  20        		.byte	32
 298    14DB  70        		.byte	112
 299    14DC  6F        		.byte	111
 300    14DD  77        		.byte	119
 301    14DE  65        		.byte	101
 302    14DF  72        		.byte	114
 303    14E0  20        		.byte	32
 304    14E1  75        		.byte	117
 305    14E2  70        		.byte	112
 306    14E3  20        		.byte	32
 307    14E4  73        		.byte	115
 308    14E5  74        		.byte	116
 309    14E6  61        		.byte	97
 310    14E7  74        		.byte	116
 311    14E8  75        		.byte	117
 312    14E9  73        		.byte	115
 313    14EA  20        		.byte	32
 314    14EB  62        		.byte	98
 315    14EC  69        		.byte	105
 316    14ED  74        		.byte	116
 317    14EE  20        		.byte	32
 318    14EF  28        		.byte	40
 319    14F0  62        		.byte	98
 320    14F1  75        		.byte	117
 321    14F2  73        		.byte	115
 322    14F3  79        		.byte	121
 323    14F4  29        		.byte	41
 324    14F5  20        		.byte	32
 325    14F6  28        		.byte	40
 326    14F7  62        		.byte	98
 327    14F8  69        		.byte	105
 328    14F9  74        		.byte	116
 329    14FA  20        		.byte	32
 330    14FB  33        		.byte	51
 331    14FC  31        		.byte	49
 332    14FD  29        		.byte	41
 333    14FE  20        		.byte	32
 334    14FF  6E        		.byte	110
 335    1500  6F        		.byte	111
 336    1501  74        		.byte	116
 337    1502  20        		.byte	32
 338    1503  73        		.byte	115
 339    1504  65        		.byte	101
 340    1505  74        		.byte	116
 341    1506  2E        		.byte	46
 342    1507  0A        		.byte	10
 343    1508  00        		.byte	0
 344                    	L5511:
 345    1509  20        		.byte	32
 346    150A  20        		.byte	32
 347    150B  54        		.byte	84
 348    150C  68        		.byte	104
 349    150D  69        		.byte	105
 350    150E  73        		.byte	115
 351    150F  20        		.byte	32
 352    1510  62        		.byte	98
 353    1511  69        		.byte	105
 354    1512  74        		.byte	116
 355    1513  20        		.byte	32
 356    1514  69        		.byte	105
 357    1515  73        		.byte	115
 358    1516  20        		.byte	32
 359    1517  6E        		.byte	110
 360    1518  6F        		.byte	111
 361    1519  74        		.byte	116
 362    151A  20        		.byte	32
 363    151B  73        		.byte	115
 364    151C  65        		.byte	101
 365    151D  74        		.byte	116
 366    151E  20        		.byte	32
 367    151F  69        		.byte	105
 368    1520  66        		.byte	102
 369    1521  20        		.byte	32
 370    1522  74        		.byte	116
 371    1523  68        		.byte	104
 372    1524  65        		.byte	101
 373    1525  20        		.byte	32
 374    1526  63        		.byte	99
 375    1527  61        		.byte	97
 376    1528  72        		.byte	114
 377    1529  64        		.byte	100
 378    152A  20        		.byte	32
 379    152B  68        		.byte	104
 380    152C  61        		.byte	97
 381    152D  73        		.byte	115
 382    152E  20        		.byte	32
 383    152F  6E        		.byte	110
 384    1530  6F        		.byte	111
 385    1531  74        		.byte	116
 386    1532  20        		.byte	32
 387    1533  66        		.byte	102
 388    1534  69        		.byte	105
 389    1535  6E        		.byte	110
 390    1536  69        		.byte	105
 391    1537  73        		.byte	115
 392    1538  68        		.byte	104
 393    1539  65        		.byte	101
 394    153A  64        		.byte	100
 395    153B  20        		.byte	32
 396    153C  74        		.byte	116
 397    153D  68        		.byte	104
 398    153E  65        		.byte	101
 399    153F  20        		.byte	32
 400    1540  70        		.byte	112
 401    1541  6F        		.byte	111
 402    1542  77        		.byte	119
 403    1543  65        		.byte	101
 404    1544  72        		.byte	114
 405    1545  20        		.byte	32
 406    1546  75        		.byte	117
 407    1547  70        		.byte	112
 408    1548  20        		.byte	32
 409    1549  72        		.byte	114
 410    154A  6F        		.byte	111
 411    154B  75        		.byte	117
 412    154C  74        		.byte	116
 413    154D  69        		.byte	105
 414    154E  6E        		.byte	110
 415    154F  65        		.byte	101
 416    1550  2E        		.byte	46
 417    1551  0A        		.byte	10
 418    1552  00        		.byte	0
 419                    	L5611:
 420    1553  2D        		.byte	45
 421    1554  2D        		.byte	45
 422    1555  2D        		.byte	45
 423    1556  2D        		.byte	45
 424    1557  2D        		.byte	45
 425    1558  2D        		.byte	45
 426    1559  2D        		.byte	45
 427    155A  2D        		.byte	45
 428    155B  2D        		.byte	45
 429    155C  2D        		.byte	45
 430    155D  2D        		.byte	45
 431    155E  2D        		.byte	45
 432    155F  2D        		.byte	45
 433    1560  2D        		.byte	45
 434    1561  2D        		.byte	45
 435    1562  2D        		.byte	45
 436    1563  2D        		.byte	45
 437    1564  2D        		.byte	45
 438    1565  2D        		.byte	45
 439    1566  2D        		.byte	45
 440    1567  2D        		.byte	45
 441    1568  2D        		.byte	45
 442    1569  2D        		.byte	45
 443    156A  2D        		.byte	45
 444    156B  2D        		.byte	45
 445    156C  2D        		.byte	45
 446    156D  2D        		.byte	45
 447    156E  2D        		.byte	45
 448    156F  2D        		.byte	45
 449    1570  2D        		.byte	45
 450    1571  2D        		.byte	45
 451    1572  2D        		.byte	45
 452    1573  2D        		.byte	45
 453    1574  2D        		.byte	45
 454    1575  2D        		.byte	45
 455    1576  2D        		.byte	45
 456    1577  2D        		.byte	45
 457    1578  2D        		.byte	45
 458    1579  0A        		.byte	10
 459    157A  00        		.byte	0
 460                    	L5711:
 461    157B  43        		.byte	67
 462    157C  49        		.byte	73
 463    157D  44        		.byte	68
 464    157E  20        		.byte	32
 465    157F  72        		.byte	114
 466    1580  65        		.byte	101
 467    1581  67        		.byte	103
 468    1582  69        		.byte	105
 469    1583  73        		.byte	115
 470    1584  74        		.byte	116
 471    1585  65        		.byte	101
 472    1586  72        		.byte	114
 473    1587  3A        		.byte	58
 474    1588  0A        		.byte	10
 475    1589  00        		.byte	0
 476                    	L5021:
 477    158A  4D        		.byte	77
 478    158B  49        		.byte	73
 479    158C  44        		.byte	68
 480    158D  3A        		.byte	58
 481    158E  20        		.byte	32
 482    158F  30        		.byte	48
 483    1590  78        		.byte	120
 484    1591  25        		.byte	37
 485    1592  30        		.byte	48
 486    1593  32        		.byte	50
 487    1594  78        		.byte	120
 488    1595  2C        		.byte	44
 489    1596  20        		.byte	32
 490    1597  00        		.byte	0
 491                    	L5121:
 492    1598  4F        		.byte	79
 493    1599  49        		.byte	73
 494    159A  44        		.byte	68
 495    159B  3A        		.byte	58
 496    159C  20        		.byte	32
 497    159D  25        		.byte	37
 498    159E  2E        		.byte	46
 499    159F  32        		.byte	50
 500    15A0  73        		.byte	115
 501    15A1  2C        		.byte	44
 502    15A2  20        		.byte	32
 503    15A3  00        		.byte	0
 504                    	L5221:
 505    15A4  50        		.byte	80
 506    15A5  4E        		.byte	78
 507    15A6  4D        		.byte	77
 508    15A7  3A        		.byte	58
 509    15A8  20        		.byte	32
 510    15A9  25        		.byte	37
 511    15AA  2E        		.byte	46
 512    15AB  35        		.byte	53
 513    15AC  73        		.byte	115
 514    15AD  2C        		.byte	44
 515    15AE  20        		.byte	32
 516    15AF  00        		.byte	0
 517                    	L5321:
 518    15B0  50        		.byte	80
 519    15B1  52        		.byte	82
 520    15B2  56        		.byte	86
 521    15B3  3A        		.byte	58
 522    15B4  20        		.byte	32
 523    15B5  25        		.byte	37
 524    15B6  64        		.byte	100
 525    15B7  2E        		.byte	46
 526    15B8  25        		.byte	37
 527    15B9  64        		.byte	100
 528    15BA  2C        		.byte	44
 529    15BB  20        		.byte	32
 530    15BC  00        		.byte	0
 531                    	L5421:
 532    15BD  50        		.byte	80
 533    15BE  53        		.byte	83
 534    15BF  4E        		.byte	78
 535    15C0  3A        		.byte	58
 536    15C1  20        		.byte	32
 537    15C2  25        		.byte	37
 538    15C3  6C        		.byte	108
 539    15C4  75        		.byte	117
 540    15C5  2C        		.byte	44
 541    15C6  20        		.byte	32
 542    15C7  00        		.byte	0
 543                    	L5521:
 544    15C8  4D        		.byte	77
 545    15C9  44        		.byte	68
 546    15CA  54        		.byte	84
 547    15CB  3A        		.byte	58
 548    15CC  20        		.byte	32
 549    15CD  25        		.byte	37
 550    15CE  64        		.byte	100
 551    15CF  2D        		.byte	45
 552    15D0  25        		.byte	37
 553    15D1  64        		.byte	100
 554    15D2  0A        		.byte	10
 555    15D3  00        		.byte	0
 556                    	L5621:
 557    15D4  2D        		.byte	45
 558    15D5  2D        		.byte	45
 559    15D6  2D        		.byte	45
 560    15D7  2D        		.byte	45
 561    15D8  2D        		.byte	45
 562    15D9  2D        		.byte	45
 563    15DA  2D        		.byte	45
 564    15DB  2D        		.byte	45
 565    15DC  2D        		.byte	45
 566    15DD  2D        		.byte	45
 567    15DE  2D        		.byte	45
 568    15DF  2D        		.byte	45
 569    15E0  2D        		.byte	45
 570    15E1  2D        		.byte	45
 571    15E2  2D        		.byte	45
 572    15E3  2D        		.byte	45
 573    15E4  2D        		.byte	45
 574    15E5  2D        		.byte	45
 575    15E6  2D        		.byte	45
 576    15E7  2D        		.byte	45
 577    15E8  2D        		.byte	45
 578    15E9  2D        		.byte	45
 579    15EA  2D        		.byte	45
 580    15EB  2D        		.byte	45
 581    15EC  2D        		.byte	45
 582    15ED  2D        		.byte	45
 583    15EE  2D        		.byte	45
 584    15EF  2D        		.byte	45
 585    15F0  2D        		.byte	45
 586    15F1  2D        		.byte	45
 587    15F2  2D        		.byte	45
 588    15F3  2D        		.byte	45
 589    15F4  2D        		.byte	45
 590    15F5  2D        		.byte	45
 591    15F6  2D        		.byte	45
 592    15F7  2D        		.byte	45
 593    15F8  2D        		.byte	45
 594    15F9  2D        		.byte	45
 595    15FA  0A        		.byte	10
 596    15FB  00        		.byte	0
 597                    	L5721:
 598    15FC  43        		.byte	67
 599    15FD  53        		.byte	83
 600    15FE  44        		.byte	68
 601    15FF  20        		.byte	32
 602    1600  72        		.byte	114
 603    1601  65        		.byte	101
 604    1602  67        		.byte	103
 605    1603  69        		.byte	105
 606    1604  73        		.byte	115
 607    1605  74        		.byte	116
 608    1606  65        		.byte	101
 609    1607  72        		.byte	114
 610    1608  3A        		.byte	58
 611    1609  0A        		.byte	10
 612    160A  00        		.byte	0
 613                    	L5031:
 614    160B  43        		.byte	67
 615    160C  53        		.byte	83
 616    160D  44        		.byte	68
 617    160E  20        		.byte	32
 618    160F  56        		.byte	86
 619    1610  65        		.byte	101
 620    1611  72        		.byte	114
 621    1612  73        		.byte	115
 622    1613  69        		.byte	105
 623    1614  6F        		.byte	111
 624    1615  6E        		.byte	110
 625    1616  20        		.byte	32
 626    1617  31        		.byte	49
 627    1618  2E        		.byte	46
 628    1619  30        		.byte	48
 629    161A  2C        		.byte	44
 630    161B  20        		.byte	32
 631    161C  53        		.byte	83
 632    161D  74        		.byte	116
 633    161E  61        		.byte	97
 634    161F  6E        		.byte	110
 635    1620  64        		.byte	100
 636    1621  61        		.byte	97
 637    1622  72        		.byte	114
 638    1623  64        		.byte	100
 639    1624  20        		.byte	32
 640    1625  43        		.byte	67
 641    1626  61        		.byte	97
 642    1627  70        		.byte	112
 643    1628  61        		.byte	97
 644    1629  63        		.byte	99
 645    162A  69        		.byte	105
 646    162B  74        		.byte	116
 647    162C  79        		.byte	121
 648    162D  0A        		.byte	10
 649    162E  00        		.byte	0
 650                    	L5131:
 651    162F  20        		.byte	32
 652    1630  44        		.byte	68
 653    1631  65        		.byte	101
 654    1632  76        		.byte	118
 655    1633  69        		.byte	105
 656    1634  63        		.byte	99
 657    1635  65        		.byte	101
 658    1636  20        		.byte	32
 659    1637  63        		.byte	99
 660    1638  61        		.byte	97
 661    1639  70        		.byte	112
 662    163A  61        		.byte	97
 663    163B  63        		.byte	99
 664    163C  69        		.byte	105
 665    163D  74        		.byte	116
 666    163E  79        		.byte	121
 667    163F  3A        		.byte	58
 668    1640  20        		.byte	32
 669    1641  25        		.byte	37
 670    1642  6C        		.byte	108
 671    1643  75        		.byte	117
 672    1644  20        		.byte	32
 673    1645  4B        		.byte	75
 674    1646  42        		.byte	66
 675    1647  79        		.byte	121
 676    1648  74        		.byte	116
 677    1649  65        		.byte	101
 678    164A  2C        		.byte	44
 679    164B  20        		.byte	32
 680    164C  25        		.byte	37
 681    164D  6C        		.byte	108
 682    164E  75        		.byte	117
 683    164F  20        		.byte	32
 684    1650  4D        		.byte	77
 685    1651  42        		.byte	66
 686    1652  79        		.byte	121
 687    1653  74        		.byte	116
 688    1654  65        		.byte	101
 689    1655  0A        		.byte	10
 690    1656  00        		.byte	0
 691                    	L5231:
 692    1657  43        		.byte	67
 693    1658  53        		.byte	83
 694    1659  44        		.byte	68
 695    165A  20        		.byte	32
 696    165B  56        		.byte	86
 697    165C  65        		.byte	101
 698    165D  72        		.byte	114
 699    165E  73        		.byte	115
 700    165F  69        		.byte	105
 701    1660  6F        		.byte	111
 702    1661  6E        		.byte	110
 703    1662  20        		.byte	32
 704    1663  32        		.byte	50
 705    1664  2E        		.byte	46
 706    1665  30        		.byte	48
 707    1666  2C        		.byte	44
 708    1667  20        		.byte	32
 709    1668  48        		.byte	72
 710    1669  69        		.byte	105
 711    166A  67        		.byte	103
 712    166B  68        		.byte	104
 713    166C  20        		.byte	32
 714    166D  43        		.byte	67
 715    166E  61        		.byte	97
 716    166F  70        		.byte	112
 717    1670  61        		.byte	97
 718    1671  63        		.byte	99
 719    1672  69        		.byte	105
 720    1673  74        		.byte	116
 721    1674  79        		.byte	121
 722    1675  20        		.byte	32
 723    1676  61        		.byte	97
 724    1677  6E        		.byte	110
 725    1678  64        		.byte	100
 726    1679  20        		.byte	32
 727    167A  45        		.byte	69
 728    167B  78        		.byte	120
 729    167C  74        		.byte	116
 730    167D  65        		.byte	101
 731    167E  6E        		.byte	110
 732    167F  64        		.byte	100
 733    1680  65        		.byte	101
 734    1681  64        		.byte	100
 735    1682  20        		.byte	32
 736    1683  43        		.byte	67
 737    1684  61        		.byte	97
 738    1685  70        		.byte	112
 739    1686  61        		.byte	97
 740    1687  63        		.byte	99
 741    1688  69        		.byte	105
 742    1689  74        		.byte	116
 743    168A  79        		.byte	121
 744    168B  0A        		.byte	10
 745    168C  00        		.byte	0
 746                    	L5331:
 747    168D  20        		.byte	32
 748    168E  44        		.byte	68
 749    168F  65        		.byte	101
 750    1690  76        		.byte	118
 751    1691  69        		.byte	105
 752    1692  63        		.byte	99
 753    1693  65        		.byte	101
 754    1694  20        		.byte	32
 755    1695  63        		.byte	99
 756    1696  61        		.byte	97
 757    1697  70        		.byte	112
 758    1698  61        		.byte	97
 759    1699  63        		.byte	99
 760    169A  69        		.byte	105
 761    169B  74        		.byte	116
 762    169C  79        		.byte	121
 763    169D  3A        		.byte	58
 764    169E  20        		.byte	32
 765    169F  25        		.byte	37
 766    16A0  6C        		.byte	108
 767    16A1  75        		.byte	117
 768    16A2  20        		.byte	32
 769    16A3  4B        		.byte	75
 770    16A4  42        		.byte	66
 771    16A5  79        		.byte	121
 772    16A6  74        		.byte	116
 773    16A7  65        		.byte	101
 774    16A8  2C        		.byte	44
 775    16A9  20        		.byte	32
 776    16AA  25        		.byte	37
 777    16AB  6C        		.byte	108
 778    16AC  75        		.byte	117
 779    16AD  20        		.byte	32
 780    16AE  4D        		.byte	77
 781    16AF  42        		.byte	66
 782    16B0  79        		.byte	121
 783    16B1  74        		.byte	116
 784    16B2  65        		.byte	101
 785    16B3  0A        		.byte	10
 786    16B4  00        		.byte	0
 787                    	L5431:
 788    16B5  43        		.byte	67
 789    16B6  53        		.byte	83
 790    16B7  44        		.byte	68
 791    16B8  20        		.byte	32
 792    16B9  56        		.byte	86
 793    16BA  65        		.byte	101
 794    16BB  72        		.byte	114
 795    16BC  73        		.byte	115
 796    16BD  69        		.byte	105
 797    16BE  6F        		.byte	111
 798    16BF  6E        		.byte	110
 799    16C0  20        		.byte	32
 800    16C1  33        		.byte	51
 801    16C2  2E        		.byte	46
 802    16C3  30        		.byte	48
 803    16C4  2C        		.byte	44
 804    16C5  20        		.byte	32
 805    16C6  55        		.byte	85
 806    16C7  6C        		.byte	108
 807    16C8  74        		.byte	116
 808    16C9  72        		.byte	114
 809    16CA  61        		.byte	97
 810    16CB  20        		.byte	32
 811    16CC  43        		.byte	67
 812    16CD  61        		.byte	97
 813    16CE  70        		.byte	112
 814    16CF  61        		.byte	97
 815    16D0  63        		.byte	99
 816    16D1  69        		.byte	105
 817    16D2  74        		.byte	116
 818    16D3  79        		.byte	121
 819    16D4  20        		.byte	32
 820    16D5  28        		.byte	40
 821    16D6  53        		.byte	83
 822    16D7  44        		.byte	68
 823    16D8  55        		.byte	85
 824    16D9  43        		.byte	67
 825    16DA  29        		.byte	41
 826    16DB  0A        		.byte	10
 827    16DC  00        		.byte	0
 828                    	L5531:
 829    16DD  20        		.byte	32
 830    16DE  44        		.byte	68
 831    16DF  65        		.byte	101
 832    16E0  76        		.byte	118
 833    16E1  69        		.byte	105
 834    16E2  63        		.byte	99
 835    16E3  65        		.byte	101
 836    16E4  20        		.byte	32
 837    16E5  63        		.byte	99
 838    16E6  61        		.byte	97
 839    16E7  70        		.byte	112
 840    16E8  61        		.byte	97
 841    16E9  63        		.byte	99
 842    16EA  69        		.byte	105
 843    16EB  74        		.byte	116
 844    16EC  79        		.byte	121
 845    16ED  3A        		.byte	58
 846    16EE  20        		.byte	32
 847    16EF  25        		.byte	37
 848    16F0  6C        		.byte	108
 849    16F1  75        		.byte	117
 850    16F2  20        		.byte	32
 851    16F3  4B        		.byte	75
 852    16F4  42        		.byte	66
 853    16F5  79        		.byte	121
 854    16F6  74        		.byte	116
 855    16F7  65        		.byte	101
 856    16F8  2C        		.byte	44
 857    16F9  20        		.byte	32
 858    16FA  25        		.byte	37
 859    16FB  6C        		.byte	108
 860    16FC  75        		.byte	117
 861    16FD  20        		.byte	32
 862    16FE  4D        		.byte	77
 863    16FF  42        		.byte	66
 864    1700  79        		.byte	121
 865    1701  74        		.byte	116
 866    1702  65        		.byte	101
 867    1703  0A        		.byte	10
 868    1704  00        		.byte	0
 869                    	L5631:
 870    1705  2D        		.byte	45
 871    1706  2D        		.byte	45
 872    1707  2D        		.byte	45
 873    1708  2D        		.byte	45
 874    1709  2D        		.byte	45
 875    170A  2D        		.byte	45
 876    170B  2D        		.byte	45
 877    170C  2D        		.byte	45
 878    170D  2D        		.byte	45
 879    170E  2D        		.byte	45
 880    170F  2D        		.byte	45
 881    1710  2D        		.byte	45
 882    1711  2D        		.byte	45
 883    1712  2D        		.byte	45
 884    1713  2D        		.byte	45
 885    1714  2D        		.byte	45
 886    1715  2D        		.byte	45
 887    1716  2D        		.byte	45
 888    1717  2D        		.byte	45
 889    1718  2D        		.byte	45
 890    1719  2D        		.byte	45
 891    171A  2D        		.byte	45
 892    171B  2D        		.byte	45
 893    171C  2D        		.byte	45
 894    171D  2D        		.byte	45
 895    171E  2D        		.byte	45
 896    171F  2D        		.byte	45
 897    1720  2D        		.byte	45
 898    1721  2D        		.byte	45
 899    1722  2D        		.byte	45
 900    1723  2D        		.byte	45
 901    1724  2D        		.byte	45
 902    1725  2D        		.byte	45
 903    1726  2D        		.byte	45
 904    1727  2D        		.byte	45
 905    1728  2D        		.byte	45
 906    1729  2D        		.byte	45
 907    172A  2D        		.byte	45
 908    172B  0A        		.byte	10
 909    172C  00        		.byte	0
 910                    	;  622      }
 911                    	;  623  
 912                    	;  624  /* print OCR, CID and CSD registers*/
 913                    	;  625  void sdprtreg()
 914                    	;  626      {
 915                    	_sdprtreg:
 916    172D  CD0000    		call	c.savs0
 917    1730  21EEFF    		ld	hl,65518
 918    1733  39        		add	hl,sp
 919    1734  F9        		ld	sp,hl
 920                    	;  627      unsigned int n;
 921                    	;  628      unsigned int csize;
 922                    	;  629      unsigned long devsize;
 923                    	;  630      unsigned long capacity;
 924                    	;  631  
 925                    	;  632      if (!sdinitok)
 926    1735  2A0C00    		ld	hl,(_sdinitok)
 927    1738  7C        		ld	a,h
 928    1739  B5        		or	l
 929    173A  2009      		jr	nz,L1732
 930                    	;  633          {
 931                    	;  634          printf("SD card not initialized\n");
 932    173C  212711    		ld	hl,L525
 933    173F  CD0000    		call	_printf
 934                    	;  635          return;
 935    1742  C30000    		jp	c.rets0
 936                    	L1732:
 937                    	;  636          }
 938                    	;  637      printf("SD card information:");
 939    1745  214011    		ld	hl,L535
 940    1748  CD0000    		call	_printf
 941                    	;  638      if (ocrreg[0] & 0x80)
 942    174B  3A4800    		ld	a,(_ocrreg)
 943    174E  CB7F      		bit	7,a
 944    1750  6F        		ld	l,a
 945    1751  2825      		jr	z,L1042
 946                    	;  639          {
 947                    	;  640          if (ocrreg[0] & 0x40)
 948    1753  3A4800    		ld	a,(_ocrreg)
 949    1756  CB77      		bit	6,a
 950    1758  6F        		ld	l,a
 951    1759  2808      		jr	z,L1142
 952                    	;  641              printf("  SD card ver. 2+, Block address\n");
 953    175B  215511    		ld	hl,L545
 954    175E  CD0000    		call	_printf
 955                    	;  642          else
 956    1761  1815      		jr	L1042
 957                    	L1142:
 958                    	;  643              {
 959                    	;  644              if (sdver2)
 960    1763  2A0A00    		ld	hl,(_sdver2)
 961    1766  7C        		ld	a,h
 962    1767  B5        		or	l
 963    1768  2808      		jr	z,L1342
 964                    	;  645                  printf("  SD card ver. 2+, Byte address\n");
 965    176A  217711    		ld	hl,L555
 966    176D  CD0000    		call	_printf
 967                    	;  646              else
 968    1770  1806      		jr	L1042
 969                    	L1342:
 970                    	;  647                  printf("  SD card ver. 1, Byte address\n");
 971    1772  219811    		ld	hl,L565
 972    1775  CD0000    		call	_printf
 973                    	L1042:
 974                    	;  648              }
 975                    	;  649          }
 976                    	;  650      printf("  Manufacturer ID: 0x%02x, ", cidreg[0]);
 977    1778  3A3800    		ld	a,(_cidreg)
 978    177B  4F        		ld	c,a
 979    177C  97        		sub	a
 980    177D  47        		ld	b,a
 981    177E  C5        		push	bc
 982    177F  21B811    		ld	hl,L575
 983    1782  CD0000    		call	_printf
 984    1785  F1        		pop	af
 985                    	;  651      printf("OEM ID: %.2s, ", &cidreg[1]);
 986    1786  213900    		ld	hl,_cidreg+1
 987    1789  E5        		push	hl
 988    178A  21D411    		ld	hl,L506
 989    178D  CD0000    		call	_printf
 990    1790  F1        		pop	af
 991                    	;  652      printf("Product name: %.5s\n", &cidreg[3]);
 992    1791  213B00    		ld	hl,_cidreg+3
 993    1794  E5        		push	hl
 994    1795  21E311    		ld	hl,L516
 995    1798  CD0000    		call	_printf
 996    179B  F1        		pop	af
 997                    	;  653      printf("  Product revision: %d.%d, ",
 998                    	;  654             (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
 999    179C  3A4000    		ld	a,(_cidreg+8)
1000    179F  6F        		ld	l,a
1001    17A0  97        		sub	a
1002    17A1  67        		ld	h,a
1003    17A2  7D        		ld	a,l
1004    17A3  E60F      		and	15
1005    17A5  6F        		ld	l,a
1006    17A6  97        		sub	a
1007    17A7  67        		ld	h,a
1008    17A8  E5        		push	hl
1009    17A9  3A4000    		ld	a,(_cidreg+8)
1010    17AC  4F        		ld	c,a
1011    17AD  97        		sub	a
1012    17AE  47        		ld	b,a
1013    17AF  C5        		push	bc
1014    17B0  210400    		ld	hl,4
1015    17B3  E5        		push	hl
1016    17B4  CD0000    		call	c.irsh
1017    17B7  E1        		pop	hl
1018    17B8  7D        		ld	a,l
1019    17B9  E60F      		and	15
1020    17BB  6F        		ld	l,a
1021    17BC  97        		sub	a
1022    17BD  67        		ld	h,a
1023    17BE  E5        		push	hl
1024    17BF  21F711    		ld	hl,L526
1025    17C2  CD0000    		call	_printf
1026    17C5  F1        		pop	af
1027    17C6  F1        		pop	af
1028                    	;  655      printf("Serial number: %lu\n",
1029                    	;  656             (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
1030    17C7  3A4100    		ld	a,(_cidreg+9)
1031    17CA  4F        		ld	c,a
1032    17CB  97        		sub	a
1033    17CC  47        		ld	b,a
1034    17CD  C5        		push	bc
1035    17CE  211800    		ld	hl,24
1036    17D1  E5        		push	hl
1037    17D2  CD0000    		call	c.ilsh
1038    17D5  E1        		pop	hl
1039    17D6  E5        		push	hl
1040    17D7  3A4200    		ld	a,(_cidreg+10)
1041    17DA  4F        		ld	c,a
1042    17DB  97        		sub	a
1043    17DC  47        		ld	b,a
1044    17DD  C5        		push	bc
1045    17DE  211000    		ld	hl,16
1046    17E1  E5        		push	hl
1047    17E2  CD0000    		call	c.ilsh
1048    17E5  E1        		pop	hl
1049    17E6  E3        		ex	(sp),hl
1050    17E7  C1        		pop	bc
1051    17E8  09        		add	hl,bc
1052    17E9  E5        		push	hl
1053    17EA  3A4300    		ld	a,(_cidreg+11)
1054    17ED  6F        		ld	l,a
1055    17EE  97        		sub	a
1056    17EF  67        		ld	h,a
1057    17F0  29        		add	hl,hl
1058    17F1  29        		add	hl,hl
1059    17F2  29        		add	hl,hl
1060    17F3  29        		add	hl,hl
1061    17F4  29        		add	hl,hl
1062    17F5  29        		add	hl,hl
1063    17F6  29        		add	hl,hl
1064    17F7  29        		add	hl,hl
1065    17F8  E3        		ex	(sp),hl
1066    17F9  C1        		pop	bc
1067    17FA  09        		add	hl,bc
1068    17FB  E5        		push	hl
1069    17FC  3A4400    		ld	a,(_cidreg+12)
1070    17FF  6F        		ld	l,a
1071    1800  97        		sub	a
1072    1801  67        		ld	h,a
1073    1802  E3        		ex	(sp),hl
1074    1803  C1        		pop	bc
1075    1804  09        		add	hl,bc
1076    1805  E5        		push	hl
1077    1806  211312    		ld	hl,L536
1078    1809  CD0000    		call	_printf
1079    180C  F1        		pop	af
1080                    	;  657      printf("  Manufacturing date: %d-%d, ",
1081                    	;  658             2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
1082    180D  3A4600    		ld	a,(_cidreg+14)
1083    1810  6F        		ld	l,a
1084    1811  97        		sub	a
1085    1812  67        		ld	h,a
1086    1813  7D        		ld	a,l
1087    1814  E60F      		and	15
1088    1816  6F        		ld	l,a
1089    1817  97        		sub	a
1090    1818  67        		ld	h,a
1091    1819  E5        		push	hl
1092    181A  3A4500    		ld	a,(_cidreg+13)
1093    181D  6F        		ld	l,a
1094    181E  97        		sub	a
1095    181F  67        		ld	h,a
1096    1820  7D        		ld	a,l
1097    1821  E60F      		and	15
1098    1823  6F        		ld	l,a
1099    1824  97        		sub	a
1100    1825  67        		ld	h,a
1101    1826  29        		add	hl,hl
1102    1827  29        		add	hl,hl
1103    1828  29        		add	hl,hl
1104    1829  29        		add	hl,hl
1105    182A  01D007    		ld	bc,2000
1106    182D  09        		add	hl,bc
1107    182E  E5        		push	hl
1108    182F  3A4600    		ld	a,(_cidreg+14)
1109    1832  4F        		ld	c,a
1110    1833  97        		sub	a
1111    1834  47        		ld	b,a
1112    1835  C5        		push	bc
1113    1836  210400    		ld	hl,4
1114    1839  E5        		push	hl
1115    183A  CD0000    		call	c.irsh
1116    183D  E1        		pop	hl
1117    183E  E3        		ex	(sp),hl
1118    183F  C1        		pop	bc
1119    1840  09        		add	hl,bc
1120    1841  E5        		push	hl
1121    1842  212712    		ld	hl,L546
1122    1845  CD0000    		call	_printf
1123    1848  F1        		pop	af
1124    1849  F1        		pop	af
1125                    	;  659      if ((csdreg[0] & 0xc0) == 0x00) /* CSD version 1 */
1126    184A  3A2800    		ld	a,(_csdreg)
1127    184D  E6C0      		and	192
1128    184F  C22D19    		jp	nz,L1542
1129                    	;  660          {
1130                    	;  661          n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
1131    1852  3A2D00    		ld	a,(_csdreg+5)
1132    1855  6F        		ld	l,a
1133    1856  97        		sub	a
1134    1857  67        		ld	h,a
1135    1858  7D        		ld	a,l
1136    1859  E60F      		and	15
1137    185B  6F        		ld	l,a
1138    185C  97        		sub	a
1139    185D  67        		ld	h,a
1140    185E  E5        		push	hl
1141    185F  3A3200    		ld	a,(_csdreg+10)
1142    1862  6F        		ld	l,a
1143    1863  97        		sub	a
1144    1864  67        		ld	h,a
1145    1865  7D        		ld	a,l
1146    1866  E680      		and	128
1147    1868  6F        		ld	l,a
1148    1869  97        		sub	a
1149    186A  67        		ld	h,a
1150    186B  E5        		push	hl
1151    186C  210700    		ld	hl,7
1152    186F  E5        		push	hl
1153    1870  CD0000    		call	c.irsh
1154    1873  E1        		pop	hl
1155    1874  E3        		ex	(sp),hl
1156    1875  C1        		pop	bc
1157    1876  09        		add	hl,bc
1158    1877  E5        		push	hl
1159    1878  3A3100    		ld	a,(_csdreg+9)
1160    187B  6F        		ld	l,a
1161    187C  97        		sub	a
1162    187D  67        		ld	h,a
1163    187E  7D        		ld	a,l
1164    187F  E603      		and	3
1165    1881  6F        		ld	l,a
1166    1882  97        		sub	a
1167    1883  67        		ld	h,a
1168    1884  29        		add	hl,hl
1169    1885  E3        		ex	(sp),hl
1170    1886  C1        		pop	bc
1171    1887  09        		add	hl,bc
1172    1888  23        		inc	hl
1173    1889  23        		inc	hl
1174    188A  DD75F8    		ld	(ix-8),l
1175    188D  DD74F9    		ld	(ix-7),h
1176                    	;  662          csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
1177                    	;  663                  ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
1178    1890  3A3000    		ld	a,(_csdreg+8)
1179    1893  4F        		ld	c,a
1180    1894  97        		sub	a
1181    1895  47        		ld	b,a
1182    1896  C5        		push	bc
1183    1897  210600    		ld	hl,6
1184    189A  E5        		push	hl
1185    189B  CD0000    		call	c.irsh
1186    189E  E1        		pop	hl
1187    189F  E5        		push	hl
1188    18A0  3A2F00    		ld	a,(_csdreg+7)
1189    18A3  6F        		ld	l,a
1190    18A4  97        		sub	a
1191    18A5  67        		ld	h,a
1192    18A6  29        		add	hl,hl
1193    18A7  29        		add	hl,hl
1194    18A8  E3        		ex	(sp),hl
1195    18A9  C1        		pop	bc
1196    18AA  09        		add	hl,bc
1197    18AB  E5        		push	hl
1198    18AC  3A2E00    		ld	a,(_csdreg+6)
1199    18AF  6F        		ld	l,a
1200    18B0  97        		sub	a
1201    18B1  67        		ld	h,a
1202    18B2  7D        		ld	a,l
1203    18B3  E603      		and	3
1204    18B5  6F        		ld	l,a
1205    18B6  97        		sub	a
1206    18B7  67        		ld	h,a
1207    18B8  E5        		push	hl
1208    18B9  210A00    		ld	hl,10
1209    18BC  E5        		push	hl
1210    18BD  CD0000    		call	c.ilsh
1211    18C0  E1        		pop	hl
1212    18C1  E3        		ex	(sp),hl
1213    18C2  C1        		pop	bc
1214    18C3  09        		add	hl,bc
1215    18C4  23        		inc	hl
1216    18C5  DD75F6    		ld	(ix-10),l
1217    18C8  DD74F7    		ld	(ix-9),h
1218                    	;  664          capacity = (unsigned long) csize << (n-10);
1219    18CB  DDE5      		push	ix
1220    18CD  C1        		pop	bc
1221    18CE  21EEFF    		ld	hl,65518
1222    18D1  09        		add	hl,bc
1223    18D2  E5        		push	hl
1224    18D3  DDE5      		push	ix
1225    18D5  C1        		pop	bc
1226    18D6  21F6FF    		ld	hl,65526
1227    18D9  09        		add	hl,bc
1228    18DA  4D        		ld	c,l
1229    18DB  44        		ld	b,h
1230    18DC  97        		sub	a
1231    18DD  320000    		ld	(c.r0),a
1232    18E0  320100    		ld	(c.r0+1),a
1233    18E3  0A        		ld	a,(bc)
1234    18E4  320200    		ld	(c.r0+2),a
1235    18E7  03        		inc	bc
1236    18E8  0A        		ld	a,(bc)
1237    18E9  320300    		ld	(c.r0+3),a
1238    18EC  210000    		ld	hl,c.r0
1239    18EF  E5        		push	hl
1240    18F0  DD6EF8    		ld	l,(ix-8)
1241    18F3  DD66F9    		ld	h,(ix-7)
1242    18F6  01F6FF    		ld	bc,65526
1243    18F9  09        		add	hl,bc
1244    18FA  E5        		push	hl
1245    18FB  CD0000    		call	c.llsh
1246    18FE  CD0000    		call	c.mvl
1247    1901  F1        		pop	af
1248                    	;  665          printf("Device capacity: %lu MByte\n", capacity >> 10);
1249    1902  DDE5      		push	ix
1250    1904  C1        		pop	bc
1251    1905  21EEFF    		ld	hl,65518
1252    1908  09        		add	hl,bc
1253    1909  CD0000    		call	c.0mvf
1254    190C  210000    		ld	hl,c.r0
1255    190F  E5        		push	hl
1256    1910  210A00    		ld	hl,10
1257    1913  E5        		push	hl
1258    1914  CD0000    		call	c.ulrsh
1259    1917  E1        		pop	hl
1260    1918  23        		inc	hl
1261    1919  23        		inc	hl
1262    191A  4E        		ld	c,(hl)
1263    191B  23        		inc	hl
1264    191C  46        		ld	b,(hl)
1265    191D  C5        		push	bc
1266    191E  2B        		dec	hl
1267    191F  2B        		dec	hl
1268    1920  2B        		dec	hl
1269    1921  4E        		ld	c,(hl)
1270    1922  23        		inc	hl
1271    1923  46        		ld	b,(hl)
1272    1924  C5        		push	bc
1273    1925  214512    		ld	hl,L556
1274    1928  CD0000    		call	_printf
1275    192B  F1        		pop	af
1276    192C  F1        		pop	af
1277                    	L1542:
1278                    	;  666          }
1279                    	;  667      if ((csdreg[0] & 0xc0) == 0x40) /* CSD version 2 */
1280    192D  3A2800    		ld	a,(_csdreg)
1281    1930  6F        		ld	l,a
1282    1931  97        		sub	a
1283    1932  67        		ld	h,a
1284    1933  7D        		ld	a,l
1285    1934  E6C0      		and	192
1286    1936  6F        		ld	l,a
1287    1937  97        		sub	a
1288    1938  67        		ld	h,a
1289    1939  7D        		ld	a,l
1290    193A  FE40      		cp	64
1291    193C  2003      		jr	nz,L27
1292    193E  7C        		ld	a,h
1293    193F  FE00      		cp	0
1294                    	L27:
1295    1941  C2141A    		jp	nz,L1642
1296                    	;  668          {
1297                    	;  669          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
1298                    	;  670                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
1299    1944  DDE5      		push	ix
1300    1946  C1        		pop	bc
1301    1947  21F2FF    		ld	hl,65522
1302    194A  09        		add	hl,bc
1303    194B  E5        		push	hl
1304    194C  97        		sub	a
1305    194D  320000    		ld	(c.r0),a
1306    1950  320100    		ld	(c.r0+1),a
1307    1953  3A3000    		ld	a,(_csdreg+8)
1308    1956  320200    		ld	(c.r0+2),a
1309    1959  97        		sub	a
1310    195A  320300    		ld	(c.r0+3),a
1311    195D  210000    		ld	hl,c.r0
1312    1960  E5        		push	hl
1313    1961  210800    		ld	hl,8
1314    1964  E5        		push	hl
1315    1965  CD0000    		call	c.llsh
1316    1968  97        		sub	a
1317    1969  320000    		ld	(c.r1),a
1318    196C  320100    		ld	(c.r1+1),a
1319    196F  3A3100    		ld	a,(_csdreg+9)
1320    1972  320200    		ld	(c.r1+2),a
1321    1975  97        		sub	a
1322    1976  320300    		ld	(c.r1+3),a
1323    1979  210000    		ld	hl,c.r1
1324    197C  E5        		push	hl
1325    197D  CD0000    		call	c.ladd
1326    1980  3A2F00    		ld	a,(_csdreg+7)
1327    1983  6F        		ld	l,a
1328    1984  97        		sub	a
1329    1985  67        		ld	h,a
1330    1986  7D        		ld	a,l
1331    1987  E63F      		and	63
1332    1989  6F        		ld	l,a
1333    198A  97        		sub	a
1334    198B  67        		ld	h,a
1335    198C  4D        		ld	c,l
1336    198D  44        		ld	b,h
1337    198E  78        		ld	a,b
1338    198F  87        		add	a,a
1339    1990  9F        		sbc	a,a
1340    1991  320000    		ld	(c.r1),a
1341    1994  320100    		ld	(c.r1+1),a
1342    1997  78        		ld	a,b
1343    1998  320300    		ld	(c.r1+3),a
1344    199B  79        		ld	a,c
1345    199C  320200    		ld	(c.r1+2),a
1346    199F  210000    		ld	hl,c.r1
1347    19A2  E5        		push	hl
1348    19A3  211000    		ld	hl,16
1349    19A6  E5        		push	hl
1350    19A7  CD0000    		call	c.llsh
1351    19AA  CD0000    		call	c.ladd
1352    19AD  3E01      		ld	a,1
1353    19AF  320200    		ld	(c.r1+2),a
1354    19B2  87        		add	a,a
1355    19B3  9F        		sbc	a,a
1356    19B4  320300    		ld	(c.r1+3),a
1357    19B7  320100    		ld	(c.r1+1),a
1358    19BA  320000    		ld	(c.r1),a
1359    19BD  210000    		ld	hl,c.r1
1360    19C0  E5        		push	hl
1361    19C1  CD0000    		call	c.ladd
1362    19C4  CD0000    		call	c.mvl
1363    19C7  F1        		pop	af
1364                    	;  671          capacity = devsize << 9;
1365    19C8  DDE5      		push	ix
1366    19CA  C1        		pop	bc
1367    19CB  21EEFF    		ld	hl,65518
1368    19CE  09        		add	hl,bc
1369    19CF  E5        		push	hl
1370    19D0  DDE5      		push	ix
1371    19D2  C1        		pop	bc
1372    19D3  21F2FF    		ld	hl,65522
1373    19D6  09        		add	hl,bc
1374    19D7  CD0000    		call	c.0mvf
1375    19DA  210000    		ld	hl,c.r0
1376    19DD  E5        		push	hl
1377    19DE  210900    		ld	hl,9
1378    19E1  E5        		push	hl
1379    19E2  CD0000    		call	c.llsh
1380    19E5  CD0000    		call	c.mvl
1381    19E8  F1        		pop	af
1382                    	;  672          printf("Device capacity: %lu MByte\n", capacity >> 10);
1383    19E9  DDE5      		push	ix
1384    19EB  C1        		pop	bc
1385    19EC  21EEFF    		ld	hl,65518
1386    19EF  09        		add	hl,bc
1387    19F0  CD0000    		call	c.0mvf
1388    19F3  210000    		ld	hl,c.r0
1389    19F6  E5        		push	hl
1390    19F7  210A00    		ld	hl,10
1391    19FA  E5        		push	hl
1392    19FB  CD0000    		call	c.ulrsh
1393    19FE  E1        		pop	hl
1394    19FF  23        		inc	hl
1395    1A00  23        		inc	hl
1396    1A01  4E        		ld	c,(hl)
1397    1A02  23        		inc	hl
1398    1A03  46        		ld	b,(hl)
1399    1A04  C5        		push	bc
1400    1A05  2B        		dec	hl
1401    1A06  2B        		dec	hl
1402    1A07  2B        		dec	hl
1403    1A08  4E        		ld	c,(hl)
1404    1A09  23        		inc	hl
1405    1A0A  46        		ld	b,(hl)
1406    1A0B  C5        		push	bc
1407    1A0C  216112    		ld	hl,L566
1408    1A0F  CD0000    		call	_printf
1409    1A12  F1        		pop	af
1410    1A13  F1        		pop	af
1411                    	L1642:
1412                    	;  673          }
1413                    	;  674      if ((csdreg[0] & 0xc0) == 0x80) /* CSD version 3 */
1414    1A14  3A2800    		ld	a,(_csdreg)
1415    1A17  6F        		ld	l,a
1416    1A18  97        		sub	a
1417    1A19  67        		ld	h,a
1418    1A1A  7D        		ld	a,l
1419    1A1B  E6C0      		and	192
1420    1A1D  6F        		ld	l,a
1421    1A1E  97        		sub	a
1422    1A1F  67        		ld	h,a
1423    1A20  7D        		ld	a,l
1424    1A21  FE80      		cp	128
1425    1A23  2003      		jr	nz,L47
1426    1A25  7C        		ld	a,h
1427    1A26  FE00      		cp	0
1428                    	L47:
1429    1A28  C2FB1A    		jp	nz,L1742
1430                    	;  675          {
1431                    	;  676          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
1432                    	;  677                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
1433    1A2B  DDE5      		push	ix
1434    1A2D  C1        		pop	bc
1435    1A2E  21F2FF    		ld	hl,65522
1436    1A31  09        		add	hl,bc
1437    1A32  E5        		push	hl
1438    1A33  97        		sub	a
1439    1A34  320000    		ld	(c.r0),a
1440    1A37  320100    		ld	(c.r0+1),a
1441    1A3A  3A3000    		ld	a,(_csdreg+8)
1442    1A3D  320200    		ld	(c.r0+2),a
1443    1A40  97        		sub	a
1444    1A41  320300    		ld	(c.r0+3),a
1445    1A44  210000    		ld	hl,c.r0
1446    1A47  E5        		push	hl
1447    1A48  210800    		ld	hl,8
1448    1A4B  E5        		push	hl
1449    1A4C  CD0000    		call	c.llsh
1450    1A4F  97        		sub	a
1451    1A50  320000    		ld	(c.r1),a
1452    1A53  320100    		ld	(c.r1+1),a
1453    1A56  3A3100    		ld	a,(_csdreg+9)
1454    1A59  320200    		ld	(c.r1+2),a
1455    1A5C  97        		sub	a
1456    1A5D  320300    		ld	(c.r1+3),a
1457    1A60  210000    		ld	hl,c.r1
1458    1A63  E5        		push	hl
1459    1A64  CD0000    		call	c.ladd
1460    1A67  3A2F00    		ld	a,(_csdreg+7)
1461    1A6A  6F        		ld	l,a
1462    1A6B  97        		sub	a
1463    1A6C  67        		ld	h,a
1464    1A6D  7D        		ld	a,l
1465    1A6E  E63F      		and	63
1466    1A70  6F        		ld	l,a
1467    1A71  97        		sub	a
1468    1A72  67        		ld	h,a
1469    1A73  4D        		ld	c,l
1470    1A74  44        		ld	b,h
1471    1A75  78        		ld	a,b
1472    1A76  87        		add	a,a
1473    1A77  9F        		sbc	a,a
1474    1A78  320000    		ld	(c.r1),a
1475    1A7B  320100    		ld	(c.r1+1),a
1476    1A7E  78        		ld	a,b
1477    1A7F  320300    		ld	(c.r1+3),a
1478    1A82  79        		ld	a,c
1479    1A83  320200    		ld	(c.r1+2),a
1480    1A86  210000    		ld	hl,c.r1
1481    1A89  E5        		push	hl
1482    1A8A  211000    		ld	hl,16
1483    1A8D  E5        		push	hl
1484    1A8E  CD0000    		call	c.llsh
1485    1A91  CD0000    		call	c.ladd
1486    1A94  3E01      		ld	a,1
1487    1A96  320200    		ld	(c.r1+2),a
1488    1A99  87        		add	a,a
1489    1A9A  9F        		sbc	a,a
1490    1A9B  320300    		ld	(c.r1+3),a
1491    1A9E  320100    		ld	(c.r1+1),a
1492    1AA1  320000    		ld	(c.r1),a
1493    1AA4  210000    		ld	hl,c.r1
1494    1AA7  E5        		push	hl
1495    1AA8  CD0000    		call	c.ladd
1496    1AAB  CD0000    		call	c.mvl
1497    1AAE  F1        		pop	af
1498                    	;  678          capacity = devsize << 9;
1499    1AAF  DDE5      		push	ix
1500    1AB1  C1        		pop	bc
1501    1AB2  21EEFF    		ld	hl,65518
1502    1AB5  09        		add	hl,bc
1503    1AB6  E5        		push	hl
1504    1AB7  DDE5      		push	ix
1505    1AB9  C1        		pop	bc
1506    1ABA  21F2FF    		ld	hl,65522
1507    1ABD  09        		add	hl,bc
1508    1ABE  CD0000    		call	c.0mvf
1509    1AC1  210000    		ld	hl,c.r0
1510    1AC4  E5        		push	hl
1511    1AC5  210900    		ld	hl,9
1512    1AC8  E5        		push	hl
1513    1AC9  CD0000    		call	c.llsh
1514    1ACC  CD0000    		call	c.mvl
1515    1ACF  F1        		pop	af
1516                    	;  679          printf("Device ultra capacity: %lu MByte\n", capacity >> 10);
1517    1AD0  DDE5      		push	ix
1518    1AD2  C1        		pop	bc
1519    1AD3  21EEFF    		ld	hl,65518
1520    1AD6  09        		add	hl,bc
1521    1AD7  CD0000    		call	c.0mvf
1522    1ADA  210000    		ld	hl,c.r0
1523    1ADD  E5        		push	hl
1524    1ADE  210A00    		ld	hl,10
1525    1AE1  E5        		push	hl
1526    1AE2  CD0000    		call	c.ulrsh
1527    1AE5  E1        		pop	hl
1528    1AE6  23        		inc	hl
1529    1AE7  23        		inc	hl
1530    1AE8  4E        		ld	c,(hl)
1531    1AE9  23        		inc	hl
1532    1AEA  46        		ld	b,(hl)
1533    1AEB  C5        		push	bc
1534    1AEC  2B        		dec	hl
1535    1AED  2B        		dec	hl
1536    1AEE  2B        		dec	hl
1537    1AEF  4E        		ld	c,(hl)
1538    1AF0  23        		inc	hl
1539    1AF1  46        		ld	b,(hl)
1540    1AF2  C5        		push	bc
1541    1AF3  217D12    		ld	hl,L576
1542    1AF6  CD0000    		call	_printf
1543    1AF9  F1        		pop	af
1544    1AFA  F1        		pop	af
1545                    	L1742:
1546                    	;  680          }
1547                    	;  681  
1548                    	;  682      if (sdtestflg)
1549    1AFB  2A0000    		ld	hl,(_sdtestflg)
1550    1AFE  7C        		ld	a,h
1551    1AFF  B5        		or	l
1552    1B00  CAE71F    		jp	z,L1052
1553                    	;  683          {
1554                    	;  684  
1555                    	;  685          printf("--------------------------------------\n");
1556    1B03  219F12    		ld	hl,L507
1557    1B06  CD0000    		call	_printf
1558                    	;  686          printf("OCR register:\n");
1559    1B09  21C712    		ld	hl,L517
1560    1B0C  CD0000    		call	_printf
1561                    	;  687          if (ocrreg[2] & 0x80)
1562    1B0F  3A4A00    		ld	a,(_ocrreg+2)
1563    1B12  CB7F      		bit	7,a
1564    1B14  6F        		ld	l,a
1565    1B15  2806      		jr	z,L1152
1566                    	;  688              printf("2.7-2.8V (bit 15) ");
1567    1B17  21D612    		ld	hl,L527
1568    1B1A  CD0000    		call	_printf
1569                    	L1152:
1570                    	;  689          if (ocrreg[1] & 0x01)
1571    1B1D  3A4900    		ld	a,(_ocrreg+1)
1572    1B20  CB47      		bit	0,a
1573    1B22  6F        		ld	l,a
1574    1B23  2806      		jr	z,L1252
1575                    	;  690              printf("2.8-2.9V (bit 16) ");
1576    1B25  21E912    		ld	hl,L537
1577    1B28  CD0000    		call	_printf
1578                    	L1252:
1579                    	;  691          if (ocrreg[1] & 0x02)
1580    1B2B  3A4900    		ld	a,(_ocrreg+1)
1581    1B2E  CB4F      		bit	1,a
1582    1B30  6F        		ld	l,a
1583    1B31  2806      		jr	z,L1352
1584                    	;  692              printf("2.9-3.0V (bit 17) ");
1585    1B33  21FC12    		ld	hl,L547
1586    1B36  CD0000    		call	_printf
1587                    	L1352:
1588                    	;  693          if (ocrreg[1] & 0x04)
1589    1B39  3A4900    		ld	a,(_ocrreg+1)
1590    1B3C  CB57      		bit	2,a
1591    1B3E  6F        		ld	l,a
1592    1B3F  2806      		jr	z,L1452
1593                    	;  694              printf("3.0-3.1V (bit 18) \n");
1594    1B41  210F13    		ld	hl,L557
1595    1B44  CD0000    		call	_printf
1596                    	L1452:
1597                    	;  695          if (ocrreg[1] & 0x08)
1598    1B47  3A4900    		ld	a,(_ocrreg+1)
1599    1B4A  CB5F      		bit	3,a
1600    1B4C  6F        		ld	l,a
1601    1B4D  2806      		jr	z,L1552
1602                    	;  696              printf("3.1-3.2V (bit 19) ");
1603    1B4F  212313    		ld	hl,L567
1604    1B52  CD0000    		call	_printf
1605                    	L1552:
1606                    	;  697          if (ocrreg[1] & 0x10)
1607    1B55  3A4900    		ld	a,(_ocrreg+1)
1608    1B58  CB67      		bit	4,a
1609    1B5A  6F        		ld	l,a
1610    1B5B  2806      		jr	z,L1652
1611                    	;  698              printf("3.2-3.3V (bit 20) ");
1612    1B5D  213613    		ld	hl,L577
1613    1B60  CD0000    		call	_printf
1614                    	L1652:
1615                    	;  699          if (ocrreg[1] & 0x20)
1616    1B63  3A4900    		ld	a,(_ocrreg+1)
1617    1B66  CB6F      		bit	5,a
1618    1B68  6F        		ld	l,a
1619    1B69  2806      		jr	z,L1752
1620                    	;  700              printf("3.3-3.4V (bit 21) ");
1621    1B6B  214913    		ld	hl,L5001
1622    1B6E  CD0000    		call	_printf
1623                    	L1752:
1624                    	;  701          if (ocrreg[1] & 0x40)
1625    1B71  3A4900    		ld	a,(_ocrreg+1)
1626    1B74  CB77      		bit	6,a
1627    1B76  6F        		ld	l,a
1628    1B77  2806      		jr	z,L1062
1629                    	;  702              printf("3.4-3.5V (bit 22) \n");
1630    1B79  215C13    		ld	hl,L5101
1631    1B7C  CD0000    		call	_printf
1632                    	L1062:
1633                    	;  703          if (ocrreg[1] & 0x80)
1634    1B7F  3A4900    		ld	a,(_ocrreg+1)
1635    1B82  CB7F      		bit	7,a
1636    1B84  6F        		ld	l,a
1637    1B85  2806      		jr	z,L1162
1638                    	;  704              printf("3.5-3.6V (bit 23) \n");
1639    1B87  217013    		ld	hl,L5201
1640    1B8A  CD0000    		call	_printf
1641                    	L1162:
1642                    	;  705          if (ocrreg[0] & 0x01)
1643    1B8D  3A4800    		ld	a,(_ocrreg)
1644    1B90  CB47      		bit	0,a
1645    1B92  6F        		ld	l,a
1646    1B93  2806      		jr	z,L1262
1647                    	;  706              printf("Switching to 1.8V Accepted (S18A) (bit 24) set ");
1648    1B95  218413    		ld	hl,L5301
1649    1B98  CD0000    		call	_printf
1650                    	L1262:
1651                    	;  707          if (ocrreg[0] & 0x08)
1652    1B9B  3A4800    		ld	a,(_ocrreg)
1653    1B9E  CB5F      		bit	3,a
1654    1BA0  6F        		ld	l,a
1655    1BA1  2806      		jr	z,L1362
1656                    	;  708              printf("Over 2TB support Status (CO2T) (bit 27) set\n");
1657    1BA3  21B413    		ld	hl,L5401
1658    1BA6  CD0000    		call	_printf
1659                    	L1362:
1660                    	;  709          if (ocrreg[0] & 0x20)
1661    1BA9  3A4800    		ld	a,(_ocrreg)
1662    1BAC  CB6F      		bit	5,a
1663    1BAE  6F        		ld	l,a
1664    1BAF  2806      		jr	z,L1462
1665                    	;  710              printf("UHS-II Card Status (bit 29) set ");
1666    1BB1  21E113    		ld	hl,L5501
1667    1BB4  CD0000    		call	_printf
1668                    	L1462:
1669                    	;  711          if (ocrreg[0] & 0x80)
1670    1BB7  3A4800    		ld	a,(_ocrreg)
1671    1BBA  CB7F      		bit	7,a
1672    1BBC  6F        		ld	l,a
1673    1BBD  2839      		jr	z,L1562
1674                    	;  712              {
1675                    	;  713              if (ocrreg[0] & 0x40)
1676    1BBF  3A4800    		ld	a,(_ocrreg)
1677    1BC2  CB77      		bit	6,a
1678    1BC4  6F        		ld	l,a
1679    1BC5  280E      		jr	z,L1662
1680                    	;  714                  {
1681                    	;  715                  printf("Card Capacity Status (CCS) (bit 30) set\n");
1682    1BC7  210214    		ld	hl,L5601
1683    1BCA  CD0000    		call	_printf
1684                    	;  716                  printf("  SD Ver.2+, Block address");
1685    1BCD  212B14    		ld	hl,L5701
1686    1BD0  CD0000    		call	_printf
1687                    	;  717                  }
1688                    	;  718              else
1689    1BD3  181B      		jr	L1762
1690                    	L1662:
1691                    	;  719                  {
1692                    	;  720                  printf("Card Capacity Status (CCS) (bit 30) not set\n");
1693    1BD5  214614    		ld	hl,L5011
1694    1BD8  CD0000    		call	_printf
1695                    	;  721                  if (sdver2)
1696    1BDB  2A0A00    		ld	hl,(_sdver2)
1697    1BDE  7C        		ld	a,h
1698    1BDF  B5        		or	l
1699    1BE0  2808      		jr	z,L1072
1700                    	;  722                      printf("  SD Ver.2+, Byte address");
1701    1BE2  217314    		ld	hl,L5111
1702    1BE5  CD0000    		call	_printf
1703                    	;  723                  else
1704    1BE8  1806      		jr	L1762
1705                    	L1072:
1706                    	;  724                      printf("  SD Ver.1, Byte address");
1707    1BEA  218D14    		ld	hl,L5211
1708    1BED  CD0000    		call	_printf
1709                    	L1762:
1710                    	;  725                  }
1711                    	;  726              printf("\nCard power up status bit (busy) (bit 31) set\n");
1712    1BF0  21A614    		ld	hl,L5311
1713    1BF3  CD0000    		call	_printf
1714                    	;  727              }
1715                    	;  728          else
1716    1BF6  180C      		jr	L1272
1717                    	L1562:
1718                    	;  729              {
1719                    	;  730              printf("\nCard power up status bit (busy) (bit 31) not set.\n");
1720    1BF8  21D514    		ld	hl,L5411
1721    1BFB  CD0000    		call	_printf
1722                    	;  731              printf("  This bit is not set if the card has not finished the power up routine.\n");
1723    1BFE  210915    		ld	hl,L5511
1724    1C01  CD0000    		call	_printf
1725                    	L1272:
1726                    	;  732              }
1727                    	;  733          printf("--------------------------------------\n");
1728    1C04  215315    		ld	hl,L5611
1729    1C07  CD0000    		call	_printf
1730                    	;  734          printf("CID register:\n");
1731    1C0A  217B15    		ld	hl,L5711
1732    1C0D  CD0000    		call	_printf
1733                    	;  735          printf("MID: 0x%02x, ", cidreg[0]);
1734    1C10  3A3800    		ld	a,(_cidreg)
1735    1C13  4F        		ld	c,a
1736    1C14  97        		sub	a
1737    1C15  47        		ld	b,a
1738    1C16  C5        		push	bc
1739    1C17  218A15    		ld	hl,L5021
1740    1C1A  CD0000    		call	_printf
1741    1C1D  F1        		pop	af
1742                    	;  736          printf("OID: %.2s, ", &cidreg[1]);
1743    1C1E  213900    		ld	hl,_cidreg+1
1744    1C21  E5        		push	hl
1745    1C22  219815    		ld	hl,L5121
1746    1C25  CD0000    		call	_printf
1747    1C28  F1        		pop	af
1748                    	;  737          printf("PNM: %.5s, ", &cidreg[3]);
1749    1C29  213B00    		ld	hl,_cidreg+3
1750    1C2C  E5        		push	hl
1751    1C2D  21A415    		ld	hl,L5221
1752    1C30  CD0000    		call	_printf
1753    1C33  F1        		pop	af
1754                    	;  738          printf("PRV: %d.%d, ",
1755                    	;  739                 (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
1756    1C34  3A4000    		ld	a,(_cidreg+8)
1757    1C37  6F        		ld	l,a
1758    1C38  97        		sub	a
1759    1C39  67        		ld	h,a
1760    1C3A  7D        		ld	a,l
1761    1C3B  E60F      		and	15
1762    1C3D  6F        		ld	l,a
1763    1C3E  97        		sub	a
1764    1C3F  67        		ld	h,a
1765    1C40  E5        		push	hl
1766    1C41  3A4000    		ld	a,(_cidreg+8)
1767    1C44  4F        		ld	c,a
1768    1C45  97        		sub	a
1769    1C46  47        		ld	b,a
1770    1C47  C5        		push	bc
1771    1C48  210400    		ld	hl,4
1772    1C4B  E5        		push	hl
1773    1C4C  CD0000    		call	c.irsh
1774    1C4F  E1        		pop	hl
1775    1C50  7D        		ld	a,l
1776    1C51  E60F      		and	15
1777    1C53  6F        		ld	l,a
1778    1C54  97        		sub	a
1779    1C55  67        		ld	h,a
1780    1C56  E5        		push	hl
1781    1C57  21B015    		ld	hl,L5321
1782    1C5A  CD0000    		call	_printf
1783    1C5D  F1        		pop	af
1784    1C5E  F1        		pop	af
1785                    	;  740          printf("PSN: %lu, ",
1786                    	;  741                 (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
1787    1C5F  3A4100    		ld	a,(_cidreg+9)
1788    1C62  4F        		ld	c,a
1789    1C63  97        		sub	a
1790    1C64  47        		ld	b,a
1791    1C65  C5        		push	bc
1792    1C66  211800    		ld	hl,24
1793    1C69  E5        		push	hl
1794    1C6A  CD0000    		call	c.ilsh
1795    1C6D  E1        		pop	hl
1796    1C6E  E5        		push	hl
1797    1C6F  3A4200    		ld	a,(_cidreg+10)
1798    1C72  4F        		ld	c,a
1799    1C73  97        		sub	a
1800    1C74  47        		ld	b,a
1801    1C75  C5        		push	bc
1802    1C76  211000    		ld	hl,16
1803    1C79  E5        		push	hl
1804    1C7A  CD0000    		call	c.ilsh
1805    1C7D  E1        		pop	hl
1806    1C7E  E3        		ex	(sp),hl
1807    1C7F  C1        		pop	bc
1808    1C80  09        		add	hl,bc
1809    1C81  E5        		push	hl
1810    1C82  3A4300    		ld	a,(_cidreg+11)
1811    1C85  6F        		ld	l,a
1812    1C86  97        		sub	a
1813    1C87  67        		ld	h,a
1814    1C88  29        		add	hl,hl
1815    1C89  29        		add	hl,hl
1816    1C8A  29        		add	hl,hl
1817    1C8B  29        		add	hl,hl
1818    1C8C  29        		add	hl,hl
1819    1C8D  29        		add	hl,hl
1820    1C8E  29        		add	hl,hl
1821    1C8F  29        		add	hl,hl
1822    1C90  E3        		ex	(sp),hl
1823    1C91  C1        		pop	bc
1824    1C92  09        		add	hl,bc
1825    1C93  E5        		push	hl
1826    1C94  3A4400    		ld	a,(_cidreg+12)
1827    1C97  6F        		ld	l,a
1828    1C98  97        		sub	a
1829    1C99  67        		ld	h,a
1830    1C9A  E3        		ex	(sp),hl
1831    1C9B  C1        		pop	bc
1832    1C9C  09        		add	hl,bc
1833    1C9D  E5        		push	hl
1834    1C9E  21BD15    		ld	hl,L5421
1835    1CA1  CD0000    		call	_printf
1836    1CA4  F1        		pop	af
1837                    	;  742          printf("MDT: %d-%d\n",
1838                    	;  743                 2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
1839    1CA5  3A4600    		ld	a,(_cidreg+14)
1840    1CA8  6F        		ld	l,a
1841    1CA9  97        		sub	a
1842    1CAA  67        		ld	h,a
1843    1CAB  7D        		ld	a,l
1844    1CAC  E60F      		and	15
1845    1CAE  6F        		ld	l,a
1846    1CAF  97        		sub	a
1847    1CB0  67        		ld	h,a
1848    1CB1  E5        		push	hl
1849    1CB2  3A4500    		ld	a,(_cidreg+13)
1850    1CB5  6F        		ld	l,a
1851    1CB6  97        		sub	a
1852    1CB7  67        		ld	h,a
1853    1CB8  7D        		ld	a,l
1854    1CB9  E60F      		and	15
1855    1CBB  6F        		ld	l,a
1856    1CBC  97        		sub	a
1857    1CBD  67        		ld	h,a
1858    1CBE  29        		add	hl,hl
1859    1CBF  29        		add	hl,hl
1860    1CC0  29        		add	hl,hl
1861    1CC1  29        		add	hl,hl
1862    1CC2  01D007    		ld	bc,2000
1863    1CC5  09        		add	hl,bc
1864    1CC6  E5        		push	hl
1865    1CC7  3A4600    		ld	a,(_cidreg+14)
1866    1CCA  4F        		ld	c,a
1867    1CCB  97        		sub	a
1868    1CCC  47        		ld	b,a
1869    1CCD  C5        		push	bc
1870    1CCE  210400    		ld	hl,4
1871    1CD1  E5        		push	hl
1872    1CD2  CD0000    		call	c.irsh
1873    1CD5  E1        		pop	hl
1874    1CD6  E3        		ex	(sp),hl
1875    1CD7  C1        		pop	bc
1876    1CD8  09        		add	hl,bc
1877    1CD9  E5        		push	hl
1878    1CDA  21C815    		ld	hl,L5521
1879    1CDD  CD0000    		call	_printf
1880    1CE0  F1        		pop	af
1881    1CE1  F1        		pop	af
1882                    	;  744          printf("--------------------------------------\n");
1883    1CE2  21D415    		ld	hl,L5621
1884    1CE5  CD0000    		call	_printf
1885                    	;  745          printf("CSD register:\n");
1886    1CE8  21FC15    		ld	hl,L5721
1887    1CEB  CD0000    		call	_printf
1888                    	;  746          if ((csdreg[0] & 0xc0) == 0x00)
1889    1CEE  3A2800    		ld	a,(_csdreg)
1890    1CF1  E6C0      		and	192
1891    1CF3  C2E71D    		jp	nz,L1372
1892                    	;  747              {
1893                    	;  748              printf("CSD Version 1.0, Standard Capacity\n");
1894    1CF6  210B16    		ld	hl,L5031
1895    1CF9  CD0000    		call	_printf
1896                    	;  749              n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
1897    1CFC  3A2D00    		ld	a,(_csdreg+5)
1898    1CFF  6F        		ld	l,a
1899    1D00  97        		sub	a
1900    1D01  67        		ld	h,a
1901    1D02  7D        		ld	a,l
1902    1D03  E60F      		and	15
1903    1D05  6F        		ld	l,a
1904    1D06  97        		sub	a
1905    1D07  67        		ld	h,a
1906    1D08  E5        		push	hl
1907    1D09  3A3200    		ld	a,(_csdreg+10)
1908    1D0C  6F        		ld	l,a
1909    1D0D  97        		sub	a
1910    1D0E  67        		ld	h,a
1911    1D0F  7D        		ld	a,l
1912    1D10  E680      		and	128
1913    1D12  6F        		ld	l,a
1914    1D13  97        		sub	a
1915    1D14  67        		ld	h,a
1916    1D15  E5        		push	hl
1917    1D16  210700    		ld	hl,7
1918    1D19  E5        		push	hl
1919    1D1A  CD0000    		call	c.irsh
1920    1D1D  E1        		pop	hl
1921    1D1E  E3        		ex	(sp),hl
1922    1D1F  C1        		pop	bc
1923    1D20  09        		add	hl,bc
1924    1D21  E5        		push	hl
1925    1D22  3A3100    		ld	a,(_csdreg+9)
1926    1D25  6F        		ld	l,a
1927    1D26  97        		sub	a
1928    1D27  67        		ld	h,a
1929    1D28  7D        		ld	a,l
1930    1D29  E603      		and	3
1931    1D2B  6F        		ld	l,a
1932    1D2C  97        		sub	a
1933    1D2D  67        		ld	h,a
1934    1D2E  29        		add	hl,hl
1935    1D2F  E3        		ex	(sp),hl
1936    1D30  C1        		pop	bc
1937    1D31  09        		add	hl,bc
1938    1D32  23        		inc	hl
1939    1D33  23        		inc	hl
1940    1D34  DD75F8    		ld	(ix-8),l
1941    1D37  DD74F9    		ld	(ix-7),h
1942                    	;  750              csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
1943                    	;  751                      ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
1944    1D3A  3A3000    		ld	a,(_csdreg+8)
1945    1D3D  4F        		ld	c,a
1946    1D3E  97        		sub	a
1947    1D3F  47        		ld	b,a
1948    1D40  C5        		push	bc
1949    1D41  210600    		ld	hl,6
1950    1D44  E5        		push	hl
1951    1D45  CD0000    		call	c.irsh
1952    1D48  E1        		pop	hl
1953    1D49  E5        		push	hl
1954    1D4A  3A2F00    		ld	a,(_csdreg+7)
1955    1D4D  6F        		ld	l,a
1956    1D4E  97        		sub	a
1957    1D4F  67        		ld	h,a
1958    1D50  29        		add	hl,hl
1959    1D51  29        		add	hl,hl
1960    1D52  E3        		ex	(sp),hl
1961    1D53  C1        		pop	bc
1962    1D54  09        		add	hl,bc
1963    1D55  E5        		push	hl
1964    1D56  3A2E00    		ld	a,(_csdreg+6)
1965    1D59  6F        		ld	l,a
1966    1D5A  97        		sub	a
1967    1D5B  67        		ld	h,a
1968    1D5C  7D        		ld	a,l
1969    1D5D  E603      		and	3
1970    1D5F  6F        		ld	l,a
1971    1D60  97        		sub	a
1972    1D61  67        		ld	h,a
1973    1D62  E5        		push	hl
1974    1D63  210A00    		ld	hl,10
1975    1D66  E5        		push	hl
1976    1D67  CD0000    		call	c.ilsh
1977    1D6A  E1        		pop	hl
1978    1D6B  E3        		ex	(sp),hl
1979    1D6C  C1        		pop	bc
1980    1D6D  09        		add	hl,bc
1981    1D6E  23        		inc	hl
1982    1D6F  DD75F6    		ld	(ix-10),l
1983    1D72  DD74F7    		ld	(ix-9),h
1984                    	;  752              capacity = (unsigned long) csize << (n-10);
1985    1D75  DDE5      		push	ix
1986    1D77  C1        		pop	bc
1987    1D78  21EEFF    		ld	hl,65518
1988    1D7B  09        		add	hl,bc
1989    1D7C  E5        		push	hl
1990    1D7D  DDE5      		push	ix
1991    1D7F  C1        		pop	bc
1992    1D80  21F6FF    		ld	hl,65526
1993    1D83  09        		add	hl,bc
1994    1D84  4D        		ld	c,l
1995    1D85  44        		ld	b,h
1996    1D86  97        		sub	a
1997    1D87  320000    		ld	(c.r0),a
1998    1D8A  320100    		ld	(c.r0+1),a
1999    1D8D  0A        		ld	a,(bc)
2000    1D8E  320200    		ld	(c.r0+2),a
2001    1D91  03        		inc	bc
2002    1D92  0A        		ld	a,(bc)
2003    1D93  320300    		ld	(c.r0+3),a
2004    1D96  210000    		ld	hl,c.r0
2005    1D99  E5        		push	hl
2006    1D9A  DD6EF8    		ld	l,(ix-8)
2007    1D9D  DD66F9    		ld	h,(ix-7)
2008    1DA0  01F6FF    		ld	bc,65526
2009    1DA3  09        		add	hl,bc
2010    1DA4  E5        		push	hl
2011    1DA5  CD0000    		call	c.llsh
2012    1DA8  CD0000    		call	c.mvl
2013    1DAB  F1        		pop	af
2014                    	;  753              printf(" Device capacity: %lu KByte, %lu MByte\n",
2015                    	;  754                     capacity, capacity >> 10);
2016    1DAC  DDE5      		push	ix
2017    1DAE  C1        		pop	bc
2018    1DAF  21EEFF    		ld	hl,65518
2019    1DB2  09        		add	hl,bc
2020    1DB3  CD0000    		call	c.0mvf
2021    1DB6  210000    		ld	hl,c.r0
2022    1DB9  E5        		push	hl
2023    1DBA  210A00    		ld	hl,10
2024    1DBD  E5        		push	hl
2025    1DBE  CD0000    		call	c.ulrsh
2026    1DC1  E1        		pop	hl
2027    1DC2  23        		inc	hl
2028    1DC3  23        		inc	hl
2029    1DC4  4E        		ld	c,(hl)
2030    1DC5  23        		inc	hl
2031    1DC6  46        		ld	b,(hl)
2032    1DC7  C5        		push	bc
2033    1DC8  2B        		dec	hl
2034    1DC9  2B        		dec	hl
2035    1DCA  2B        		dec	hl
2036    1DCB  4E        		ld	c,(hl)
2037    1DCC  23        		inc	hl
2038    1DCD  46        		ld	b,(hl)
2039    1DCE  C5        		push	bc
2040    1DCF  DD66F1    		ld	h,(ix-15)
2041    1DD2  DD6EF0    		ld	l,(ix-16)
2042    1DD5  E5        		push	hl
2043    1DD6  DD66EF    		ld	h,(ix-17)
2044    1DD9  DD6EEE    		ld	l,(ix-18)
2045    1DDC  E5        		push	hl
2046    1DDD  212F16    		ld	hl,L5131
2047    1DE0  CD0000    		call	_printf
2048    1DE3  F1        		pop	af
2049    1DE4  F1        		pop	af
2050    1DE5  F1        		pop	af
2051    1DE6  F1        		pop	af
2052                    	L1372:
2053                    	;  755              }
2054                    	;  756          if ((csdreg[0] & 0xc0) == 0x40)
2055    1DE7  3A2800    		ld	a,(_csdreg)
2056    1DEA  6F        		ld	l,a
2057    1DEB  97        		sub	a
2058    1DEC  67        		ld	h,a
2059    1DED  7D        		ld	a,l
2060    1DEE  E6C0      		and	192
2061    1DF0  6F        		ld	l,a
2062    1DF1  97        		sub	a
2063    1DF2  67        		ld	h,a
2064    1DF3  7D        		ld	a,l
2065    1DF4  FE40      		cp	64
2066    1DF6  2003      		jr	nz,L67
2067    1DF8  7C        		ld	a,h
2068    1DF9  FE00      		cp	0
2069                    	L67:
2070    1DFB  C2E41E    		jp	nz,L1472
2071                    	;  757              {
2072                    	;  758              printf("CSD Version 2.0, High Capacity and Extended Capacity\n");
2073    1DFE  215716    		ld	hl,L5231
2074    1E01  CD0000    		call	_printf
2075                    	;  759              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
2076                    	;  760                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
2077    1E04  DDE5      		push	ix
2078    1E06  C1        		pop	bc
2079    1E07  21F2FF    		ld	hl,65522
2080    1E0A  09        		add	hl,bc
2081    1E0B  E5        		push	hl
2082    1E0C  97        		sub	a
2083    1E0D  320000    		ld	(c.r0),a
2084    1E10  320100    		ld	(c.r0+1),a
2085    1E13  3A3000    		ld	a,(_csdreg+8)
2086    1E16  320200    		ld	(c.r0+2),a
2087    1E19  97        		sub	a
2088    1E1A  320300    		ld	(c.r0+3),a
2089    1E1D  210000    		ld	hl,c.r0
2090    1E20  E5        		push	hl
2091    1E21  210800    		ld	hl,8
2092    1E24  E5        		push	hl
2093    1E25  CD0000    		call	c.llsh
2094    1E28  97        		sub	a
2095    1E29  320000    		ld	(c.r1),a
2096    1E2C  320100    		ld	(c.r1+1),a
2097    1E2F  3A3100    		ld	a,(_csdreg+9)
2098    1E32  320200    		ld	(c.r1+2),a
2099    1E35  97        		sub	a
2100    1E36  320300    		ld	(c.r1+3),a
2101    1E39  210000    		ld	hl,c.r1
2102    1E3C  E5        		push	hl
2103    1E3D  CD0000    		call	c.ladd
2104    1E40  3A2F00    		ld	a,(_csdreg+7)
2105    1E43  6F        		ld	l,a
2106    1E44  97        		sub	a
2107    1E45  67        		ld	h,a
2108    1E46  7D        		ld	a,l
2109    1E47  E63F      		and	63
2110    1E49  6F        		ld	l,a
2111    1E4A  97        		sub	a
2112    1E4B  67        		ld	h,a
2113    1E4C  4D        		ld	c,l
2114    1E4D  44        		ld	b,h
2115    1E4E  78        		ld	a,b
2116    1E4F  87        		add	a,a
2117    1E50  9F        		sbc	a,a
2118    1E51  320000    		ld	(c.r1),a
2119    1E54  320100    		ld	(c.r1+1),a
2120    1E57  78        		ld	a,b
2121    1E58  320300    		ld	(c.r1+3),a
2122    1E5B  79        		ld	a,c
2123    1E5C  320200    		ld	(c.r1+2),a
2124    1E5F  210000    		ld	hl,c.r1
2125    1E62  E5        		push	hl
2126    1E63  211000    		ld	hl,16
2127    1E66  E5        		push	hl
2128    1E67  CD0000    		call	c.llsh
2129    1E6A  CD0000    		call	c.ladd
2130    1E6D  3E01      		ld	a,1
2131    1E6F  320200    		ld	(c.r1+2),a
2132    1E72  87        		add	a,a
2133    1E73  9F        		sbc	a,a
2134    1E74  320300    		ld	(c.r1+3),a
2135    1E77  320100    		ld	(c.r1+1),a
2136    1E7A  320000    		ld	(c.r1),a
2137    1E7D  210000    		ld	hl,c.r1
2138    1E80  E5        		push	hl
2139    1E81  CD0000    		call	c.ladd
2140    1E84  CD0000    		call	c.mvl
2141    1E87  F1        		pop	af
2142                    	;  761              capacity = devsize << 9;
2143    1E88  DDE5      		push	ix
2144    1E8A  C1        		pop	bc
2145    1E8B  21EEFF    		ld	hl,65518
2146    1E8E  09        		add	hl,bc
2147    1E8F  E5        		push	hl
2148    1E90  DDE5      		push	ix
2149    1E92  C1        		pop	bc
2150    1E93  21F2FF    		ld	hl,65522
2151    1E96  09        		add	hl,bc
2152    1E97  CD0000    		call	c.0mvf
2153    1E9A  210000    		ld	hl,c.r0
2154    1E9D  E5        		push	hl
2155    1E9E  210900    		ld	hl,9
2156    1EA1  E5        		push	hl
2157    1EA2  CD0000    		call	c.llsh
2158    1EA5  CD0000    		call	c.mvl
2159    1EA8  F1        		pop	af
2160                    	;  762              printf(" Device capacity: %lu KByte, %lu MByte\n",
2161                    	;  763                     capacity, capacity >> 10);
2162    1EA9  DDE5      		push	ix
2163    1EAB  C1        		pop	bc
2164    1EAC  21EEFF    		ld	hl,65518
2165    1EAF  09        		add	hl,bc
2166    1EB0  CD0000    		call	c.0mvf
2167    1EB3  210000    		ld	hl,c.r0
2168    1EB6  E5        		push	hl
2169    1EB7  210A00    		ld	hl,10
2170    1EBA  E5        		push	hl
2171    1EBB  CD0000    		call	c.ulrsh
2172    1EBE  E1        		pop	hl
2173    1EBF  23        		inc	hl
2174    1EC0  23        		inc	hl
2175    1EC1  4E        		ld	c,(hl)
2176    1EC2  23        		inc	hl
2177    1EC3  46        		ld	b,(hl)
2178    1EC4  C5        		push	bc
2179    1EC5  2B        		dec	hl
2180    1EC6  2B        		dec	hl
2181    1EC7  2B        		dec	hl
2182    1EC8  4E        		ld	c,(hl)
2183    1EC9  23        		inc	hl
2184    1ECA  46        		ld	b,(hl)
2185    1ECB  C5        		push	bc
2186    1ECC  DD66F1    		ld	h,(ix-15)
2187    1ECF  DD6EF0    		ld	l,(ix-16)
2188    1ED2  E5        		push	hl
2189    1ED3  DD66EF    		ld	h,(ix-17)
2190    1ED6  DD6EEE    		ld	l,(ix-18)
2191    1ED9  E5        		push	hl
2192    1EDA  218D16    		ld	hl,L5331
2193    1EDD  CD0000    		call	_printf
2194    1EE0  F1        		pop	af
2195    1EE1  F1        		pop	af
2196    1EE2  F1        		pop	af
2197    1EE3  F1        		pop	af
2198                    	L1472:
2199                    	;  764              }
2200                    	;  765          if ((csdreg[0] & 0xc0) == 0x80)
2201    1EE4  3A2800    		ld	a,(_csdreg)
2202    1EE7  6F        		ld	l,a
2203    1EE8  97        		sub	a
2204    1EE9  67        		ld	h,a
2205    1EEA  7D        		ld	a,l
2206    1EEB  E6C0      		and	192
2207    1EED  6F        		ld	l,a
2208    1EEE  97        		sub	a
2209    1EEF  67        		ld	h,a
2210    1EF0  7D        		ld	a,l
2211    1EF1  FE80      		cp	128
2212    1EF3  2003      		jr	nz,L001
2213    1EF5  7C        		ld	a,h
2214    1EF6  FE00      		cp	0
2215                    	L001:
2216    1EF8  C2E11F    		jp	nz,L1572
2217                    	;  766              {
2218                    	;  767              printf("CSD Version 3.0, Ultra Capacity (SDUC)\n");
2219    1EFB  21B516    		ld	hl,L5431
2220    1EFE  CD0000    		call	_printf
2221                    	;  768              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
2222                    	;  769                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
2223    1F01  DDE5      		push	ix
2224    1F03  C1        		pop	bc
2225    1F04  21F2FF    		ld	hl,65522
2226    1F07  09        		add	hl,bc
2227    1F08  E5        		push	hl
2228    1F09  97        		sub	a
2229    1F0A  320000    		ld	(c.r0),a
2230    1F0D  320100    		ld	(c.r0+1),a
2231    1F10  3A3000    		ld	a,(_csdreg+8)
2232    1F13  320200    		ld	(c.r0+2),a
2233    1F16  97        		sub	a
2234    1F17  320300    		ld	(c.r0+3),a
2235    1F1A  210000    		ld	hl,c.r0
2236    1F1D  E5        		push	hl
2237    1F1E  210800    		ld	hl,8
2238    1F21  E5        		push	hl
2239    1F22  CD0000    		call	c.llsh
2240    1F25  97        		sub	a
2241    1F26  320000    		ld	(c.r1),a
2242    1F29  320100    		ld	(c.r1+1),a
2243    1F2C  3A3100    		ld	a,(_csdreg+9)
2244    1F2F  320200    		ld	(c.r1+2),a
2245    1F32  97        		sub	a
2246    1F33  320300    		ld	(c.r1+3),a
2247    1F36  210000    		ld	hl,c.r1
2248    1F39  E5        		push	hl
2249    1F3A  CD0000    		call	c.ladd
2250    1F3D  3A2F00    		ld	a,(_csdreg+7)
2251    1F40  6F        		ld	l,a
2252    1F41  97        		sub	a
2253    1F42  67        		ld	h,a
2254    1F43  7D        		ld	a,l
2255    1F44  E63F      		and	63
2256    1F46  6F        		ld	l,a
2257    1F47  97        		sub	a
2258    1F48  67        		ld	h,a
2259    1F49  4D        		ld	c,l
2260    1F4A  44        		ld	b,h
2261    1F4B  78        		ld	a,b
2262    1F4C  87        		add	a,a
2263    1F4D  9F        		sbc	a,a
2264    1F4E  320000    		ld	(c.r1),a
2265    1F51  320100    		ld	(c.r1+1),a
2266    1F54  78        		ld	a,b
2267    1F55  320300    		ld	(c.r1+3),a
2268    1F58  79        		ld	a,c
2269    1F59  320200    		ld	(c.r1+2),a
2270    1F5C  210000    		ld	hl,c.r1
2271    1F5F  E5        		push	hl
2272    1F60  211000    		ld	hl,16
2273    1F63  E5        		push	hl
2274    1F64  CD0000    		call	c.llsh
2275    1F67  CD0000    		call	c.ladd
2276    1F6A  3E01      		ld	a,1
2277    1F6C  320200    		ld	(c.r1+2),a
2278    1F6F  87        		add	a,a
2279    1F70  9F        		sbc	a,a
2280    1F71  320300    		ld	(c.r1+3),a
2281    1F74  320100    		ld	(c.r1+1),a
2282    1F77  320000    		ld	(c.r1),a
2283    1F7A  210000    		ld	hl,c.r1
2284    1F7D  E5        		push	hl
2285    1F7E  CD0000    		call	c.ladd
2286    1F81  CD0000    		call	c.mvl
2287    1F84  F1        		pop	af
2288                    	;  770              capacity = devsize << 9;
2289    1F85  DDE5      		push	ix
2290    1F87  C1        		pop	bc
2291    1F88  21EEFF    		ld	hl,65518
2292    1F8B  09        		add	hl,bc
2293    1F8C  E5        		push	hl
2294    1F8D  DDE5      		push	ix
2295    1F8F  C1        		pop	bc
2296    1F90  21F2FF    		ld	hl,65522
2297    1F93  09        		add	hl,bc
2298    1F94  CD0000    		call	c.0mvf
2299    1F97  210000    		ld	hl,c.r0
2300    1F9A  E5        		push	hl
2301    1F9B  210900    		ld	hl,9
2302    1F9E  E5        		push	hl
2303    1F9F  CD0000    		call	c.llsh
2304    1FA2  CD0000    		call	c.mvl
2305    1FA5  F1        		pop	af
2306                    	;  771              printf(" Device capacity: %lu KByte, %lu MByte\n",
2307                    	;  772                     capacity, capacity >> 10);
2308    1FA6  DDE5      		push	ix
2309    1FA8  C1        		pop	bc
2310    1FA9  21EEFF    		ld	hl,65518
2311    1FAC  09        		add	hl,bc
2312    1FAD  CD0000    		call	c.0mvf
2313    1FB0  210000    		ld	hl,c.r0
2314    1FB3  E5        		push	hl
2315    1FB4  210A00    		ld	hl,10
2316    1FB7  E5        		push	hl
2317    1FB8  CD0000    		call	c.ulrsh
2318    1FBB  E1        		pop	hl
2319    1FBC  23        		inc	hl
2320    1FBD  23        		inc	hl
2321    1FBE  4E        		ld	c,(hl)
2322    1FBF  23        		inc	hl
2323    1FC0  46        		ld	b,(hl)
2324    1FC1  C5        		push	bc
2325    1FC2  2B        		dec	hl
2326    1FC3  2B        		dec	hl
2327    1FC4  2B        		dec	hl
2328    1FC5  4E        		ld	c,(hl)
2329    1FC6  23        		inc	hl
2330    1FC7  46        		ld	b,(hl)
2331    1FC8  C5        		push	bc
2332    1FC9  DD66F1    		ld	h,(ix-15)
2333    1FCC  DD6EF0    		ld	l,(ix-16)
2334    1FCF  E5        		push	hl
2335    1FD0  DD66EF    		ld	h,(ix-17)
2336    1FD3  DD6EEE    		ld	l,(ix-18)
2337    1FD6  E5        		push	hl
2338    1FD7  21DD16    		ld	hl,L5531
2339    1FDA  CD0000    		call	_printf
2340    1FDD  F1        		pop	af
2341    1FDE  F1        		pop	af
2342    1FDF  F1        		pop	af
2343    1FE0  F1        		pop	af
2344                    	L1572:
2345                    	;  773              }
2346                    	;  774          printf("--------------------------------------\n");
2347    1FE1  210517    		ld	hl,L5631
2348    1FE4  CD0000    		call	_printf
2349                    	L1052:
2350                    	;  775  
2351                    	;  776          } /* sdtestflg */ /* SDTEST */
2352                    	;  777  
2353                    	;  778      }
2354    1FE7  C30000    		jp	c.rets0
2355                    	L5731:
2356    1FEA  53        		.byte	83
2357    1FEB  44        		.byte	68
2358    1FEC  20        		.byte	32
2359    1FED  63        		.byte	99
2360    1FEE  61        		.byte	97
2361    1FEF  72        		.byte	114
2362    1FF0  64        		.byte	100
2363    1FF1  20        		.byte	32
2364    1FF2  6E        		.byte	110
2365    1FF3  6F        		.byte	111
2366    1FF4  74        		.byte	116
2367    1FF5  20        		.byte	32
2368    1FF6  69        		.byte	105
2369    1FF7  6E        		.byte	110
2370    1FF8  69        		.byte	105
2371    1FF9  74        		.byte	116
2372    1FFA  69        		.byte	105
2373    1FFB  61        		.byte	97
2374    1FFC  6C        		.byte	108
2375    1FFD  69        		.byte	105
2376    1FFE  7A        		.byte	122
2377    1FFF  65        		.byte	101
2378    2000  64        		.byte	100
2379    2001  0A        		.byte	10
2380    2002  00        		.byte	0
2381                    	L5041:
2382    2003  0A        		.byte	10
2383    2004  43        		.byte	67
2384    2005  4D        		.byte	77
2385    2006  44        		.byte	68
2386    2007  31        		.byte	49
2387    2008  37        		.byte	55
2388    2009  3A        		.byte	58
2389    200A  20        		.byte	32
2390    200B  52        		.byte	82
2391    200C  45        		.byte	69
2392    200D  41        		.byte	65
2393    200E  44        		.byte	68
2394    200F  5F        		.byte	95
2395    2010  53        		.byte	83
2396    2011  49        		.byte	73
2397    2012  4E        		.byte	78
2398    2013  47        		.byte	71
2399    2014  4C        		.byte	76
2400    2015  45        		.byte	69
2401    2016  5F        		.byte	95
2402    2017  42        		.byte	66
2403    2018  4C        		.byte	76
2404    2019  4F        		.byte	79
2405    201A  43        		.byte	67
2406    201B  4B        		.byte	75
2407    201C  2C        		.byte	44
2408    201D  20        		.byte	32
2409    201E  63        		.byte	99
2410    201F  6F        		.byte	111
2411    2020  6D        		.byte	109
2412    2021  6D        		.byte	109
2413    2022  61        		.byte	97
2414    2023  6E        		.byte	110
2415    2024  64        		.byte	100
2416    2025  20        		.byte	32
2417    2026  5B        		.byte	91
2418    2027  25        		.byte	37
2419    2028  30        		.byte	48
2420    2029  32        		.byte	50
2421    202A  78        		.byte	120
2422    202B  20        		.byte	32
2423    202C  25        		.byte	37
2424    202D  30        		.byte	48
2425    202E  32        		.byte	50
2426    202F  78        		.byte	120
2427    2030  20        		.byte	32
2428    2031  25        		.byte	37
2429    2032  30        		.byte	48
2430    2033  32        		.byte	50
2431    2034  78        		.byte	120
2432    2035  20        		.byte	32
2433    2036  25        		.byte	37
2434    2037  30        		.byte	48
2435    2038  32        		.byte	50
2436    2039  78        		.byte	120
2437    203A  20        		.byte	32
2438    203B  25        		.byte	37
2439    203C  30        		.byte	48
2440    203D  32        		.byte	50
2441    203E  78        		.byte	120
2442    203F  5D        		.byte	93
2443    2040  0A        		.byte	10
2444    2041  00        		.byte	0
2445                    	L5141:
2446    2042  43        		.byte	67
2447    2043  4D        		.byte	77
2448    2044  44        		.byte	68
2449    2045  31        		.byte	49
2450    2046  37        		.byte	55
2451    2047  20        		.byte	32
2452    2048  52        		.byte	82
2453    2049  31        		.byte	49
2454    204A  20        		.byte	32
2455    204B  72        		.byte	114
2456    204C  65        		.byte	101
2457    204D  73        		.byte	115
2458    204E  70        		.byte	112
2459    204F  6F        		.byte	111
2460    2050  6E        		.byte	110
2461    2051  73        		.byte	115
2462    2052  65        		.byte	101
2463    2053  20        		.byte	32
2464    2054  5B        		.byte	91
2465    2055  25        		.byte	37
2466    2056  30        		.byte	48
2467    2057  32        		.byte	50
2468    2058  78        		.byte	120
2469    2059  5D        		.byte	93
2470    205A  0A        		.byte	10
2471    205B  00        		.byte	0
2472                    	L5241:
2473    205C  20        		.byte	32
2474    205D  20        		.byte	32
2475    205E  63        		.byte	99
2476    205F  6F        		.byte	111
2477    2060  75        		.byte	117
2478    2061  6C        		.byte	108
2479    2062  64        		.byte	100
2480    2063  20        		.byte	32
2481    2064  6E        		.byte	110
2482    2065  6F        		.byte	111
2483    2066  74        		.byte	116
2484    2067  20        		.byte	32
2485    2068  72        		.byte	114
2486    2069  65        		.byte	101
2487    206A  61        		.byte	97
2488    206B  64        		.byte	100
2489    206C  20        		.byte	32
2490    206D  62        		.byte	98
2491    206E  6C        		.byte	108
2492    206F  6F        		.byte	111
2493    2070  63        		.byte	99
2494    2071  6B        		.byte	107
2495    2072  0A        		.byte	10
2496    2073  00        		.byte	0
2497                    	L5341:
2498    2074  20        		.byte	32
2499    2075  20        		.byte	32
2500    2076  72        		.byte	114
2501    2077  65        		.byte	101
2502    2078  61        		.byte	97
2503    2079  64        		.byte	100
2504    207A  20        		.byte	32
2505    207B  65        		.byte	101
2506    207C  72        		.byte	114
2507    207D  72        		.byte	114
2508    207E  6F        		.byte	111
2509    207F  72        		.byte	114
2510    2080  3A        		.byte	58
2511    2081  20        		.byte	32
2512    2082  5B        		.byte	91
2513    2083  25        		.byte	37
2514    2084  30        		.byte	48
2515    2085  32        		.byte	50
2516    2086  78        		.byte	120
2517    2087  5D        		.byte	93
2518    2088  0A        		.byte	10
2519    2089  00        		.byte	0
2520                    	L5441:
2521    208A  20        		.byte	32
2522    208B  20        		.byte	32
2523    208C  6E        		.byte	110
2524    208D  6F        		.byte	111
2525    208E  20        		.byte	32
2526    208F  64        		.byte	100
2527    2090  61        		.byte	97
2528    2091  74        		.byte	116
2529    2092  61        		.byte	97
2530    2093  20        		.byte	32
2531    2094  66        		.byte	102
2532    2095  6F        		.byte	111
2533    2096  75        		.byte	117
2534    2097  6E        		.byte	110
2535    2098  64        		.byte	100
2536    2099  0A        		.byte	10
2537    209A  00        		.byte	0
2538                    	L5541:
2539    209B  20        		.byte	32
2540    209C  20        		.byte	32
2541    209D  72        		.byte	114
2542    209E  65        		.byte	101
2543    209F  61        		.byte	97
2544    20A0  64        		.byte	100
2545    20A1  20        		.byte	32
2546    20A2  64        		.byte	100
2547    20A3  61        		.byte	97
2548    20A4  74        		.byte	116
2549    20A5  61        		.byte	97
2550    20A6  20        		.byte	32
2551    20A7  62        		.byte	98
2552    20A8  6C        		.byte	108
2553    20A9  6F        		.byte	111
2554    20AA  63        		.byte	99
2555    20AB  6B        		.byte	107
2556    20AC  20        		.byte	32
2557    20AD  25        		.byte	37
2558    20AE  6C        		.byte	108
2559    20AF  64        		.byte	100
2560    20B0  3A        		.byte	58
2561    20B1  0A        		.byte	10
2562    20B2  00        		.byte	0
2563                    	L5641:
2564    20B3  20        		.byte	32
2565    20B4  20        		.byte	32
2566    20B5  43        		.byte	67
2567    20B6  52        		.byte	82
2568    20B7  43        		.byte	67
2569    20B8  31        		.byte	49
2570    20B9  36        		.byte	54
2571    20BA  20        		.byte	32
2572    20BB  65        		.byte	101
2573    20BC  72        		.byte	114
2574    20BD  72        		.byte	114
2575    20BE  6F        		.byte	111
2576    20BF  72        		.byte	114
2577    20C0  2C        		.byte	44
2578    20C1  20        		.byte	32
2579    20C2  72        		.byte	114
2580    20C3  65        		.byte	101
2581    20C4  63        		.byte	99
2582    20C5  69        		.byte	105
2583    20C6  65        		.byte	101
2584    20C7  76        		.byte	118
2585    20C8  65        		.byte	101
2586    20C9  64        		.byte	100
2587    20CA  3A        		.byte	58
2588    20CB  20        		.byte	32
2589    20CC  30        		.byte	48
2590    20CD  78        		.byte	120
2591    20CE  25        		.byte	37
2592    20CF  30        		.byte	48
2593    20D0  34        		.byte	52
2594    20D1  78        		.byte	120
2595    20D2  2C        		.byte	44
2596    20D3  20        		.byte	32
2597    20D4  63        		.byte	99
2598    20D5  61        		.byte	97
2599    20D6  6C        		.byte	108
2600    20D7  63        		.byte	99
2601    20D8  3A        		.byte	58
2602    20D9  20        		.byte	32
2603    20DA  30        		.byte	48
2604    20DB  78        		.byte	120
2605    20DC  25        		.byte	37
2606    20DD  30        		.byte	48
2607    20DE  34        		.byte	52
2608    20DF  68        		.byte	104
2609    20E0  69        		.byte	105
2610    20E1  0A        		.byte	10
2611    20E2  00        		.byte	0
2612                    	;  779  
2613                    	;  780  /* Read data block of 512 bytes to buffer
2614                    	;  781   * Returns YES if ok or NO if error
2615                    	;  782   */
2616                    	;  783  int sdread(unsigned char *rdbuf, unsigned long rdblkno)
2617                    	;  784      {
2618                    	_sdread:
2619    20E3  CD0000    		call	c.savs
2620    20E6  21E0FF    		ld	hl,65504
2621    20E9  39        		add	hl,sp
2622    20EA  F9        		ld	sp,hl
2623                    	;  785      unsigned char *statptr;
2624                    	;  786      unsigned char rbyte;
2625                    	;  787      unsigned char cmdbuf[5];   /* buffer to build command in */
2626                    	;  788      unsigned char rstatbuf[5]; /* buffer to recieve status in */
2627                    	;  789      int nbytes;
2628                    	;  790      int tries;
2629                    	;  791      unsigned long blktoread;
2630                    	;  792      unsigned int rxcrc16;
2631                    	;  793      unsigned int calcrc16;
2632                    	;  794  
2633                    	;  795      ledon();
2634    20EB  CD0000    		call	_ledon
2635                    	;  796      spiselect();
2636    20EE  CD0000    		call	_spiselect
2637                    	;  797  
2638                    	;  798      if (!sdinitok)
2639    20F1  2A0C00    		ld	hl,(_sdinitok)
2640    20F4  7C        		ld	a,h
2641    20F5  B5        		or	l
2642    20F6  2019      		jr	nz,L1672
2643                    	;  799          {
2644                    	;  800          if (sdtestflg)
2645    20F8  2A0000    		ld	hl,(_sdtestflg)
2646    20FB  7C        		ld	a,h
2647    20FC  B5        		or	l
2648    20FD  2806      		jr	z,L1772
2649                    	;  801              {
2650                    	;  802              printf("SD card not initialized\n");
2651    20FF  21EA1F    		ld	hl,L5731
2652    2102  CD0000    		call	_printf
2653                    	L1772:
2654                    	;  803              } /* sdtestflg */
2655                    	;  804          spideselect();
2656    2105  CD0000    		call	_spideselect
2657                    	;  805          ledoff();
2658    2108  CD0000    		call	_ledoff
2659                    	;  806          return (NO);
2660    210B  010000    		ld	bc,0
2661    210E  C30000    		jp	c.rets
2662                    	L1672:
2663                    	;  807          }
2664                    	;  808  
2665                    	;  809      /* CMD17: READ_SINGLE_BLOCK */
2666                    	;  810      /* Insert block # into command */
2667                    	;  811      memcpy(cmdbuf, cmd17, 5);
2668    2111  210500    		ld	hl,5
2669    2114  E5        		push	hl
2670    2115  213700    		ld	hl,_cmd17
2671    2118  E5        		push	hl
2672    2119  DDE5      		push	ix
2673    211B  C1        		pop	bc
2674    211C  21F2FF    		ld	hl,65522
2675    211F  09        		add	hl,bc
2676    2120  CD0000    		call	_memcpy
2677    2123  F1        		pop	af
2678    2124  F1        		pop	af
2679                    	;  812      blktoread = blkmult * rdblkno;
2680    2125  DDE5      		push	ix
2681    2127  C1        		pop	bc
2682    2128  21E4FF    		ld	hl,65508
2683    212B  09        		add	hl,bc
2684    212C  E5        		push	hl
2685    212D  210600    		ld	hl,_blkmult
2686    2130  CD0000    		call	c.0mvf
2687    2133  210000    		ld	hl,c.r0
2688    2136  E5        		push	hl
2689    2137  DDE5      		push	ix
2690    2139  C1        		pop	bc
2691    213A  210600    		ld	hl,6
2692    213D  09        		add	hl,bc
2693    213E  E5        		push	hl
2694    213F  CD0000    		call	c.lmul
2695    2142  CD0000    		call	c.mvl
2696    2145  F1        		pop	af
2697                    	;  813      cmdbuf[4] = blktoread & 0xff;
2698    2146  DD6EE6    		ld	l,(ix-26)
2699    2149  7D        		ld	a,l
2700    214A  E6FF      		and	255
2701    214C  DD77F6    		ld	(ix-10),a
2702                    	;  814      blktoread = blktoread >> 8;
2703    214F  DDE5      		push	ix
2704    2151  C1        		pop	bc
2705    2152  21E4FF    		ld	hl,65508
2706    2155  09        		add	hl,bc
2707    2156  E5        		push	hl
2708    2157  210800    		ld	hl,8
2709    215A  E5        		push	hl
2710    215B  CD0000    		call	c.ulrsh
2711    215E  F1        		pop	af
2712                    	;  815      cmdbuf[3] = blktoread & 0xff;
2713    215F  DD6EE6    		ld	l,(ix-26)
2714    2162  7D        		ld	a,l
2715    2163  E6FF      		and	255
2716    2165  DD77F5    		ld	(ix-11),a
2717                    	;  816      blktoread = blktoread >> 8;
2718    2168  DDE5      		push	ix
2719    216A  C1        		pop	bc
2720    216B  21E4FF    		ld	hl,65508
2721    216E  09        		add	hl,bc
2722    216F  E5        		push	hl
2723    2170  210800    		ld	hl,8
2724    2173  E5        		push	hl
2725    2174  CD0000    		call	c.ulrsh
2726    2177  F1        		pop	af
2727                    	;  817      cmdbuf[2] = blktoread & 0xff;
2728    2178  DD6EE6    		ld	l,(ix-26)
2729    217B  7D        		ld	a,l
2730    217C  E6FF      		and	255
2731    217E  DD77F4    		ld	(ix-12),a
2732                    	;  818      blktoread = blktoread >> 8;
2733    2181  DDE5      		push	ix
2734    2183  C1        		pop	bc
2735    2184  21E4FF    		ld	hl,65508
2736    2187  09        		add	hl,bc
2737    2188  E5        		push	hl
2738    2189  210800    		ld	hl,8
2739    218C  E5        		push	hl
2740    218D  CD0000    		call	c.ulrsh
2741    2190  F1        		pop	af
2742                    	;  819      cmdbuf[1] = blktoread & 0xff;
2743    2191  DD6EE6    		ld	l,(ix-26)
2744    2194  7D        		ld	a,l
2745    2195  E6FF      		and	255
2746    2197  DD77F3    		ld	(ix-13),a
2747                    	;  820  
2748                    	;  821      if (sdtestflg)
2749    219A  2A0000    		ld	hl,(_sdtestflg)
2750    219D  7C        		ld	a,h
2751    219E  B5        		or	l
2752    219F  2829      		jr	z,L1003
2753                    	;  822          {
2754                    	;  823          printf("\nCMD17: READ_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
2755                    	;  824                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
2756    21A1  DD4EF6    		ld	c,(ix-10)
2757    21A4  97        		sub	a
2758    21A5  47        		ld	b,a
2759    21A6  C5        		push	bc
2760    21A7  DD4EF5    		ld	c,(ix-11)
2761    21AA  97        		sub	a
2762    21AB  47        		ld	b,a
2763    21AC  C5        		push	bc
2764    21AD  DD4EF4    		ld	c,(ix-12)
2765    21B0  97        		sub	a
2766    21B1  47        		ld	b,a
2767    21B2  C5        		push	bc
2768    21B3  DD4EF3    		ld	c,(ix-13)
2769    21B6  97        		sub	a
2770    21B7  47        		ld	b,a
2771    21B8  C5        		push	bc
2772    21B9  DD4EF2    		ld	c,(ix-14)
2773    21BC  97        		sub	a
2774    21BD  47        		ld	b,a
2775    21BE  C5        		push	bc
2776    21BF  210320    		ld	hl,L5041
2777    21C2  CD0000    		call	_printf
2778    21C5  210A00    		ld	hl,10
2779    21C8  39        		add	hl,sp
2780    21C9  F9        		ld	sp,hl
2781                    	L1003:
2782                    	;  825          } /* sdtestflg */
2783                    	;  826      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2784    21CA  210100    		ld	hl,1
2785    21CD  E5        		push	hl
2786    21CE  DDE5      		push	ix
2787    21D0  C1        		pop	bc
2788    21D1  21EDFF    		ld	hl,65517
2789    21D4  09        		add	hl,bc
2790    21D5  E5        		push	hl
2791    21D6  DDE5      		push	ix
2792    21D8  C1        		pop	bc
2793    21D9  21F2FF    		ld	hl,65522
2794    21DC  09        		add	hl,bc
2795    21DD  CD7701    		call	_sdcommand
2796    21E0  F1        		pop	af
2797    21E1  F1        		pop	af
2798    21E2  DD71F8    		ld	(ix-8),c
2799    21E5  DD70F9    		ld	(ix-7),b
2800                    	;  827      if (sdtestflg)
2801    21E8  2A0000    		ld	hl,(_sdtestflg)
2802    21EB  7C        		ld	a,h
2803    21EC  B5        		or	l
2804    21ED  2811      		jr	z,L1103
2805                    	;  828          {
2806                    	;  829          printf("CMD17 R1 response [%02x]\n", statptr[0]);
2807    21EF  DD6EF8    		ld	l,(ix-8)
2808    21F2  DD66F9    		ld	h,(ix-7)
2809    21F5  4E        		ld	c,(hl)
2810    21F6  97        		sub	a
2811    21F7  47        		ld	b,a
2812    21F8  C5        		push	bc
2813    21F9  214220    		ld	hl,L5141
2814    21FC  CD0000    		call	_printf
2815    21FF  F1        		pop	af
2816                    	L1103:
2817                    	;  830          } /* sdtestflg */
2818                    	;  831      if (statptr[0])
2819    2200  DD6EF8    		ld	l,(ix-8)
2820    2203  DD66F9    		ld	h,(ix-7)
2821    2206  7E        		ld	a,(hl)
2822    2207  B7        		or	a
2823    2208  2819      		jr	z,L1203
2824                    	;  832          {
2825                    	;  833          if (sdtestflg)
2826    220A  2A0000    		ld	hl,(_sdtestflg)
2827    220D  7C        		ld	a,h
2828    220E  B5        		or	l
2829    220F  2806      		jr	z,L1303
2830                    	;  834              {
2831                    	;  835              printf("  could not read block\n");
2832    2211  215C20    		ld	hl,L5241
2833    2214  CD0000    		call	_printf
2834                    	L1303:
2835                    	;  836              } /* sdtestflg */
2836                    	;  837          spideselect();
2837    2217  CD0000    		call	_spideselect
2838                    	;  838          ledoff();
2839    221A  CD0000    		call	_ledoff
2840                    	;  839          return (NO);
2841    221D  010000    		ld	bc,0
2842    2220  C30000    		jp	c.rets
2843                    	L1203:
2844                    	;  840          }
2845                    	;  841      /* looking for 0xfe that is the byte before data */
2846                    	;  842      for (tries = 80; (0 < tries) && ((rbyte = spiio(0xff)) != 0xfe); tries--)
2847    2223  DD36E850  		ld	(ix-24),80
2848    2227  DD36E900  		ld	(ix-23),0
2849                    	L1403:
2850    222B  97        		sub	a
2851    222C  DD96E8    		sub	(ix-24)
2852    222F  3E00      		ld	a,0
2853    2231  DD9EE9    		sbc	a,(ix-23)
2854    2234  F28022    		jp	p,L1503
2855    2237  21FF00    		ld	hl,255
2856    223A  CD0000    		call	_spiio
2857    223D  DD71F7    		ld	(ix-9),c
2858    2240  DD7EF7    		ld	a,(ix-9)
2859    2243  FEFE      		cp	254
2860    2245  2839      		jr	z,L1503
2861                    	;  843          {
2862                    	;  844          if ((rbyte & 0xe0) == 0x00)
2863    2247  DD6EF7    		ld	l,(ix-9)
2864    224A  7D        		ld	a,l
2865    224B  E6E0      		and	224
2866    224D  2016      		jr	nz,L1603
2867                    	;  845              {
2868                    	;  846              /* If a read operation fails and the card cannot provide
2869                    	;  847                 the required data, it will send a data error token instead
2870                    	;  848               */
2871                    	;  849              if (sdtestflg)
2872    224F  2A0000    		ld	hl,(_sdtestflg)
2873    2252  7C        		ld	a,h
2874    2253  B5        		or	l
2875    2254  281E      		jr	z,L1113
2876                    	;  850                  {
2877                    	;  851                  printf("  read error: [%02x]\n", rbyte);
2878    2256  DD4EF7    		ld	c,(ix-9)
2879    2259  97        		sub	a
2880    225A  47        		ld	b,a
2881    225B  C5        		push	bc
2882    225C  217420    		ld	hl,L5341
2883    225F  CD0000    		call	_printf
2884    2262  F1        		pop	af
2885    2263  180F      		jr	L1113
2886                    	L1603:
2887    2265  DD6EE8    		ld	l,(ix-24)
2888    2268  DD66E9    		ld	h,(ix-23)
2889    226B  2B        		dec	hl
2890    226C  DD75E8    		ld	(ix-24),l
2891    226F  DD74E9    		ld	(ix-23),h
2892    2272  18B7      		jr	L1403
2893                    	L1113:
2894                    	;  852                  } /* sdtestflg */
2895                    	;  853              spideselect();
2896    2274  CD0000    		call	_spideselect
2897                    	;  854              ledoff();
2898    2277  CD0000    		call	_ledoff
2899                    	;  855              return (NO);
2900    227A  010000    		ld	bc,0
2901    227D  C30000    		jp	c.rets
2902                    	L1503:
2903                    	;  856              }
2904                    	;  857          }
2905                    	;  858      if (tries == 0) /* tried too many times */
2906    2280  DD7EE8    		ld	a,(ix-24)
2907    2283  DDB6E9    		or	(ix-23)
2908    2286  2019      		jr	nz,L1213
2909                    	;  859          {
2910                    	;  860          if (sdtestflg)
2911    2288  2A0000    		ld	hl,(_sdtestflg)
2912    228B  7C        		ld	a,h
2913    228C  B5        		or	l
2914    228D  2806      		jr	z,L1313
2915                    	;  861              {
2916                    	;  862              printf("  no data found\n");
2917    228F  218A20    		ld	hl,L5441
2918    2292  CD0000    		call	_printf
2919                    	L1313:
2920                    	;  863              } /* sdtestflg */
2921                    	;  864          spideselect();
2922    2295  CD0000    		call	_spideselect
2923                    	;  865          ledoff();
2924    2298  CD0000    		call	_ledoff
2925                    	;  866          return (NO);
2926    229B  010000    		ld	bc,0
2927    229E  C30000    		jp	c.rets
2928                    	L1213:
2929                    	;  867          }
2930                    	;  868      else
2931                    	;  869          {
2932                    	;  870          calcrc16 = 0;
2933    22A1  DD36E000  		ld	(ix-32),0
2934    22A5  DD36E100  		ld	(ix-31),0
2935                    	;  871          for (nbytes = 0; nbytes < 512; nbytes++)
2936    22A9  DD36EA00  		ld	(ix-22),0
2937    22AD  DD36EB00  		ld	(ix-21),0
2938                    	L1513:
2939    22B1  DD7EEA    		ld	a,(ix-22)
2940    22B4  D600      		sub	0
2941    22B6  DD7EEB    		ld	a,(ix-21)
2942    22B9  DE02      		sbc	a,2
2943    22BB  F2F822    		jp	p,L1613
2944                    	;  872              {
2945                    	;  873              rbyte = spiio(0xff);
2946    22BE  21FF00    		ld	hl,255
2947    22C1  CD0000    		call	_spiio
2948    22C4  DD71F7    		ld	(ix-9),c
2949                    	;  874              calcrc16 = CRC16_one(calcrc16, rbyte);
2950    22C7  DD6EF7    		ld	l,(ix-9)
2951    22CA  97        		sub	a
2952    22CB  67        		ld	h,a
2953    22CC  E5        		push	hl
2954    22CD  DD6EE0    		ld	l,(ix-32)
2955    22D0  DD66E1    		ld	h,(ix-31)
2956    22D3  CDC900    		call	_CRC16_one
2957    22D6  F1        		pop	af
2958    22D7  DD71E0    		ld	(ix-32),c
2959    22DA  DD70E1    		ld	(ix-31),b
2960                    	;  875              rdbuf[nbytes] = rbyte;
2961    22DD  DD6E04    		ld	l,(ix+4)
2962    22E0  DD6605    		ld	h,(ix+5)
2963    22E3  DD4EEA    		ld	c,(ix-22)
2964    22E6  DD46EB    		ld	b,(ix-21)
2965    22E9  09        		add	hl,bc
2966    22EA  DD7EF7    		ld	a,(ix-9)
2967    22ED  77        		ld	(hl),a
2968                    	;  876              }
2969    22EE  DD34EA    		inc	(ix-22)
2970    22F1  2003      		jr	nz,L401
2971    22F3  DD34EB    		inc	(ix-21)
2972                    	L401:
2973    22F6  18B9      		jr	L1513
2974                    	L1613:
2975                    	;  877          rxcrc16 = spiio(0xff) << 8;
2976    22F8  21FF00    		ld	hl,255
2977    22FB  CD0000    		call	_spiio
2978    22FE  69        		ld	l,c
2979    22FF  60        		ld	h,b
2980    2300  29        		add	hl,hl
2981    2301  29        		add	hl,hl
2982    2302  29        		add	hl,hl
2983    2303  29        		add	hl,hl
2984    2304  29        		add	hl,hl
2985    2305  29        		add	hl,hl
2986    2306  29        		add	hl,hl
2987    2307  29        		add	hl,hl
2988    2308  DD75E2    		ld	(ix-30),l
2989    230B  DD74E3    		ld	(ix-29),h
2990                    	;  878          rxcrc16 += spiio(0xff);
2991    230E  21FF00    		ld	hl,255
2992    2311  CD0000    		call	_spiio
2993    2314  DD6EE2    		ld	l,(ix-30)
2994    2317  DD66E3    		ld	h,(ix-29)
2995    231A  09        		add	hl,bc
2996    231B  DD75E2    		ld	(ix-30),l
2997    231E  DD74E3    		ld	(ix-29),h
2998                    	;  879  
2999                    	;  880          if (sdtestflg)
3000    2321  2A0000    		ld	hl,(_sdtestflg)
3001    2324  7C        		ld	a,h
3002    2325  B5        		or	l
3003    2326  2816      		jr	z,L1123
3004                    	;  881              {
3005                    	;  882              printf("  read data block %ld:\n", rdblkno);
3006    2328  DD6609    		ld	h,(ix+9)
3007    232B  DD6E08    		ld	l,(ix+8)
3008    232E  E5        		push	hl
3009    232F  DD6607    		ld	h,(ix+7)
3010    2332  DD6E06    		ld	l,(ix+6)
3011    2335  E5        		push	hl
3012    2336  219B20    		ld	hl,L5541
3013    2339  CD0000    		call	_printf
3014    233C  F1        		pop	af
3015    233D  F1        		pop	af
3016                    	L1123:
3017                    	;  883              } /* sdtestflg */
3018                    	;  884          if (rxcrc16 != calcrc16)
3019    233E  DD7EE2    		ld	a,(ix-30)
3020    2341  DDBEE0    		cp	(ix-32)
3021    2344  2006      		jr	nz,L601
3022    2346  DD7EE3    		ld	a,(ix-29)
3023    2349  DDBEE1    		cp	(ix-31)
3024                    	L601:
3025    234C  2829      		jr	z,L1413
3026                    	;  885              {
3027                    	;  886              if (sdtestflg)
3028    234E  2A0000    		ld	hl,(_sdtestflg)
3029    2351  7C        		ld	a,h
3030    2352  B5        		or	l
3031    2353  2816      		jr	z,L1323
3032                    	;  887                  {
3033                    	;  888                  printf("  CRC16 error, recieved: 0x%04x, calc: 0x%04hi\n",
3034                    	;  889                         rxcrc16, calcrc16);
3035    2355  DD6EE0    		ld	l,(ix-32)
3036    2358  DD66E1    		ld	h,(ix-31)
3037    235B  E5        		push	hl
3038    235C  DD6EE2    		ld	l,(ix-30)
3039    235F  DD66E3    		ld	h,(ix-29)
3040    2362  E5        		push	hl
3041    2363  21B320    		ld	hl,L5641
3042    2366  CD0000    		call	_printf
3043    2369  F1        		pop	af
3044    236A  F1        		pop	af
3045                    	L1323:
3046                    	;  890                  } /* sdtestflg */
3047                    	;  891              spideselect();
3048    236B  CD0000    		call	_spideselect
3049                    	;  892              ledoff();
3050    236E  CD0000    		call	_ledoff
3051                    	;  893              return (NO);
3052    2371  010000    		ld	bc,0
3053    2374  C30000    		jp	c.rets
3054                    	L1413:
3055                    	;  894              }
3056                    	;  895          }
3057                    	;  896      spideselect();
3058    2377  CD0000    		call	_spideselect
3059                    	;  897      ledoff();
3060    237A  CD0000    		call	_ledoff
3061                    	;  898      return (YES);
3062    237D  010100    		ld	bc,1
3063    2380  C30000    		jp	c.rets
3064                    	L5741:
3065    2383  53        		.byte	83
3066    2384  44        		.byte	68
3067    2385  20        		.byte	32
3068    2386  63        		.byte	99
3069    2387  61        		.byte	97
3070    2388  72        		.byte	114
3071    2389  64        		.byte	100
3072    238A  20        		.byte	32
3073    238B  6E        		.byte	110
3074    238C  6F        		.byte	111
3075    238D  74        		.byte	116
3076    238E  20        		.byte	32
3077    238F  69        		.byte	105
3078    2390  6E        		.byte	110
3079    2391  69        		.byte	105
3080    2392  74        		.byte	116
3081    2393  69        		.byte	105
3082    2394  61        		.byte	97
3083    2395  6C        		.byte	108
3084    2396  69        		.byte	105
3085    2397  7A        		.byte	122
3086    2398  65        		.byte	101
3087    2399  64        		.byte	100
3088    239A  0A        		.byte	10
3089    239B  00        		.byte	0
3090                    	L5051:
3091    239C  20        		.byte	32
3092    239D  20        		.byte	32
3093    239E  77        		.byte	119
3094    239F  72        		.byte	114
3095    23A0  69        		.byte	105
3096    23A1  74        		.byte	116
3097    23A2  65        		.byte	101
3098    23A3  20        		.byte	32
3099    23A4  64        		.byte	100
3100    23A5  61        		.byte	97
3101    23A6  74        		.byte	116
3102    23A7  61        		.byte	97
3103    23A8  20        		.byte	32
3104    23A9  62        		.byte	98
3105    23AA  6C        		.byte	108
3106    23AB  6F        		.byte	111
3107    23AC  63        		.byte	99
3108    23AD  6B        		.byte	107
3109    23AE  20        		.byte	32
3110    23AF  25        		.byte	37
3111    23B0  6C        		.byte	108
3112    23B1  64        		.byte	100
3113    23B2  3A        		.byte	58
3114    23B3  0A        		.byte	10
3115    23B4  00        		.byte	0
3116                    	L5151:
3117    23B5  0A        		.byte	10
3118    23B6  43        		.byte	67
3119    23B7  4D        		.byte	77
3120    23B8  44        		.byte	68
3121    23B9  32        		.byte	50
3122    23BA  34        		.byte	52
3123    23BB  3A        		.byte	58
3124    23BC  20        		.byte	32
3125    23BD  57        		.byte	87
3126    23BE  52        		.byte	82
3127    23BF  49        		.byte	73
3128    23C0  54        		.byte	84
3129    23C1  45        		.byte	69
3130    23C2  5F        		.byte	95
3131    23C3  53        		.byte	83
3132    23C4  49        		.byte	73
3133    23C5  4E        		.byte	78
3134    23C6  47        		.byte	71
3135    23C7  4C        		.byte	76
3136    23C8  45        		.byte	69
3137    23C9  5F        		.byte	95
3138    23CA  42        		.byte	66
3139    23CB  4C        		.byte	76
3140    23CC  4F        		.byte	79
3141    23CD  43        		.byte	67
3142    23CE  4B        		.byte	75
3143    23CF  2C        		.byte	44
3144    23D0  20        		.byte	32
3145    23D1  63        		.byte	99
3146    23D2  6F        		.byte	111
3147    23D3  6D        		.byte	109
3148    23D4  6D        		.byte	109
3149    23D5  61        		.byte	97
3150    23D6  6E        		.byte	110
3151    23D7  64        		.byte	100
3152    23D8  20        		.byte	32
3153    23D9  5B        		.byte	91
3154    23DA  25        		.byte	37
3155    23DB  30        		.byte	48
3156    23DC  32        		.byte	50
3157    23DD  78        		.byte	120
3158    23DE  20        		.byte	32
3159    23DF  25        		.byte	37
3160    23E0  30        		.byte	48
3161    23E1  32        		.byte	50
3162    23E2  78        		.byte	120
3163    23E3  20        		.byte	32
3164    23E4  25        		.byte	37
3165    23E5  30        		.byte	48
3166    23E6  32        		.byte	50
3167    23E7  78        		.byte	120
3168    23E8  20        		.byte	32
3169    23E9  25        		.byte	37
3170    23EA  30        		.byte	48
3171    23EB  32        		.byte	50
3172    23EC  78        		.byte	120
3173    23ED  20        		.byte	32
3174    23EE  25        		.byte	37
3175    23EF  30        		.byte	48
3176    23F0  32        		.byte	50
3177    23F1  78        		.byte	120
3178    23F2  5D        		.byte	93
3179    23F3  0A        		.byte	10
3180    23F4  00        		.byte	0
3181                    	L5251:
3182    23F5  43        		.byte	67
3183    23F6  4D        		.byte	77
3184    23F7  44        		.byte	68
3185    23F8  32        		.byte	50
3186    23F9  34        		.byte	52
3187    23FA  20        		.byte	32
3188    23FB  52        		.byte	82
3189    23FC  31        		.byte	49
3190    23FD  20        		.byte	32
3191    23FE  72        		.byte	114
3192    23FF  65        		.byte	101
3193    2400  73        		.byte	115
3194    2401  70        		.byte	112
3195    2402  6F        		.byte	111
3196    2403  6E        		.byte	110
3197    2404  73        		.byte	115
3198    2405  65        		.byte	101
3199    2406  20        		.byte	32
3200    2407  5B        		.byte	91
3201    2408  25        		.byte	37
3202    2409  30        		.byte	48
3203    240A  32        		.byte	50
3204    240B  78        		.byte	120
3205    240C  5D        		.byte	93
3206    240D  0A        		.byte	10
3207    240E  00        		.byte	0
3208                    	L5351:
3209    240F  20        		.byte	32
3210    2410  20        		.byte	32
3211    2411  63        		.byte	99
3212    2412  6F        		.byte	111
3213    2413  75        		.byte	117
3214    2414  6C        		.byte	108
3215    2415  64        		.byte	100
3216    2416  20        		.byte	32
3217    2417  6E        		.byte	110
3218    2418  6F        		.byte	111
3219    2419  74        		.byte	116
3220    241A  20        		.byte	32
3221    241B  77        		.byte	119
3222    241C  72        		.byte	114
3223    241D  69        		.byte	105
3224    241E  74        		.byte	116
3225    241F  65        		.byte	101
3226    2420  20        		.byte	32
3227    2421  62        		.byte	98
3228    2422  6C        		.byte	108
3229    2423  6F        		.byte	111
3230    2424  63        		.byte	99
3231    2425  6B        		.byte	107
3232    2426  0A        		.byte	10
3233    2427  00        		.byte	0
3234                    	L5451:
3235    2428  4E        		.byte	78
3236    2429  6F        		.byte	111
3237    242A  20        		.byte	32
3238    242B  64        		.byte	100
3239    242C  61        		.byte	97
3240    242D  74        		.byte	116
3241    242E  61        		.byte	97
3242    242F  20        		.byte	32
3243    2430  72        		.byte	114
3244    2431  65        		.byte	101
3245    2432  73        		.byte	115
3246    2433  70        		.byte	112
3247    2434  6F        		.byte	111
3248    2435  6E        		.byte	110
3249    2436  73        		.byte	115
3250    2437  65        		.byte	101
3251    2438  0A        		.byte	10
3252    2439  00        		.byte	0
3253                    	L5551:
3254    243A  44        		.byte	68
3255    243B  61        		.byte	97
3256    243C  74        		.byte	116
3257    243D  61        		.byte	97
3258    243E  20        		.byte	32
3259    243F  72        		.byte	114
3260    2440  65        		.byte	101
3261    2441  73        		.byte	115
3262    2442  70        		.byte	112
3263    2443  6F        		.byte	111
3264    2444  6E        		.byte	110
3265    2445  73        		.byte	115
3266    2446  65        		.byte	101
3267    2447  20        		.byte	32
3268    2448  5B        		.byte	91
3269    2449  25        		.byte	37
3270    244A  30        		.byte	48
3271    244B  32        		.byte	50
3272    244C  78        		.byte	120
3273    244D  5D        		.byte	93
3274    244E  00        		.byte	0
3275                    	L5651:
3276    244F  2C        		.byte	44
3277    2450  20        		.byte	32
3278    2451  64        		.byte	100
3279    2452  61        		.byte	97
3280    2453  74        		.byte	116
3281    2454  61        		.byte	97
3282    2455  20        		.byte	32
3283    2456  61        		.byte	97
3284    2457  63        		.byte	99
3285    2458  63        		.byte	99
3286    2459  65        		.byte	101
3287    245A  70        		.byte	112
3288    245B  74        		.byte	116
3289    245C  65        		.byte	101
3290    245D  64        		.byte	100
3291    245E  0A        		.byte	10
3292    245F  00        		.byte	0
3293                    	L5751:
3294    2460  53        		.byte	83
3295    2461  65        		.byte	101
3296    2462  6E        		.byte	110
3297    2463  74        		.byte	116
3298    2464  20        		.byte	32
3299    2465  39        		.byte	57
3300    2466  2A        		.byte	42
3301    2467  38        		.byte	56
3302    2468  20        		.byte	32
3303    2469  28        		.byte	40
3304    246A  37        		.byte	55
3305    246B  32        		.byte	50
3306    246C  29        		.byte	41
3307    246D  20        		.byte	32
3308    246E  63        		.byte	99
3309    246F  6C        		.byte	108
3310    2470  6F        		.byte	111
3311    2471  63        		.byte	99
3312    2472  6B        		.byte	107
3313    2473  20        		.byte	32
3314    2474  70        		.byte	112
3315    2475  75        		.byte	117
3316    2476  6C        		.byte	108
3317    2477  73        		.byte	115
3318    2478  65        		.byte	101
3319    2479  73        		.byte	115
3320    247A  2C        		.byte	44
3321    247B  20        		.byte	32
3322    247C  73        		.byte	115
3323    247D  65        		.byte	101
3324    247E  6C        		.byte	108
3325    247F  65        		.byte	101
3326    2480  63        		.byte	99
3327    2481  74        		.byte	116
3328    2482  20        		.byte	32
3329    2483  61        		.byte	97
3330    2484  63        		.byte	99
3331    2485  74        		.byte	116
3332    2486  69        		.byte	105
3333    2487  76        		.byte	118
3334    2488  65        		.byte	101
3335    2489  0A        		.byte	10
3336    248A  00        		.byte	0
3337                    	L5061:
3338    248B  2C        		.byte	44
3339    248C  20        		.byte	32
3340    248D  64        		.byte	100
3341    248E  61        		.byte	97
3342    248F  74        		.byte	116
3343    2490  61        		.byte	97
3344    2491  20        		.byte	32
3345    2492  6E        		.byte	110
3346    2493  6F        		.byte	111
3347    2494  74        		.byte	116
3348    2495  20        		.byte	32
3349    2496  61        		.byte	97
3350    2497  63        		.byte	99
3351    2498  63        		.byte	99
3352    2499  65        		.byte	101
3353    249A  70        		.byte	112
3354    249B  74        		.byte	116
3355    249C  65        		.byte	101
3356    249D  64        		.byte	100
3357    249E  0A        		.byte	10
3358    249F  00        		.byte	0
3359                    	;  899      }
3360                    	;  900  
3361                    	;  901  /* Write data block of 512 bytes from buffer
3362                    	;  902   * Returns YES if ok or NO if error
3363                    	;  903   */
3364                    	;  904  int sdwrite(unsigned char *wrbuf, unsigned long wrblkno)
3365                    	;  905      {
3366                    	_sdwrite:
3367    24A0  CD0000    		call	c.savs
3368    24A3  21E2FF    		ld	hl,65506
3369    24A6  39        		add	hl,sp
3370    24A7  F9        		ld	sp,hl
3371                    	;  906      unsigned char *statptr;
3372                    	;  907      unsigned char rbyte;
3373                    	;  908      unsigned char tbyte;
3374                    	;  909      unsigned char cmdbuf[5];   /* buffer to build command in */
3375                    	;  910      unsigned char rstatbuf[5]; /* buffer to recieve status in */
3376                    	;  911      int nbytes;
3377                    	;  912      int tries;
3378                    	;  913      unsigned long blktowrite;
3379                    	;  914      unsigned int calcrc16;
3380                    	;  915  
3381                    	;  916      ledon();
3382    24A8  CD0000    		call	_ledon
3383                    	;  917      spiselect();
3384    24AB  CD0000    		call	_spiselect
3385                    	;  918  
3386                    	;  919      if (!sdinitok)
3387    24AE  2A0C00    		ld	hl,(_sdinitok)
3388    24B1  7C        		ld	a,h
3389    24B2  B5        		or	l
3390    24B3  2019      		jr	nz,L1423
3391                    	;  920          {
3392                    	;  921          if (sdtestflg)
3393    24B5  2A0000    		ld	hl,(_sdtestflg)
3394    24B8  7C        		ld	a,h
3395    24B9  B5        		or	l
3396    24BA  2806      		jr	z,L1523
3397                    	;  922              {
3398                    	;  923              printf("SD card not initialized\n");
3399    24BC  218323    		ld	hl,L5741
3400    24BF  CD0000    		call	_printf
3401                    	L1523:
3402                    	;  924              } /* sdtestflg */
3403                    	;  925          spideselect();
3404    24C2  CD0000    		call	_spideselect
3405                    	;  926          ledoff();
3406    24C5  CD0000    		call	_ledoff
3407                    	;  927          return (NO);
3408    24C8  010000    		ld	bc,0
3409    24CB  C30000    		jp	c.rets
3410                    	L1423:
3411                    	;  928          }
3412                    	;  929  
3413                    	;  930      if (sdtestflg)
3414    24CE  2A0000    		ld	hl,(_sdtestflg)
3415    24D1  7C        		ld	a,h
3416    24D2  B5        		or	l
3417    24D3  2816      		jr	z,L1623
3418                    	;  931          {
3419                    	;  932          printf("  write data block %ld:\n", wrblkno);
3420    24D5  DD6609    		ld	h,(ix+9)
3421    24D8  DD6E08    		ld	l,(ix+8)
3422    24DB  E5        		push	hl
3423    24DC  DD6607    		ld	h,(ix+7)
3424    24DF  DD6E06    		ld	l,(ix+6)
3425    24E2  E5        		push	hl
3426    24E3  219C23    		ld	hl,L5051
3427    24E6  CD0000    		call	_printf
3428    24E9  F1        		pop	af
3429    24EA  F1        		pop	af
3430                    	L1623:
3431                    	;  933          } /* sdtestflg */
3432                    	;  934      /* CMD24: WRITE_SINGLE_BLOCK */
3433                    	;  935      /* Insert block # into command */
3434                    	;  936      memcpy(cmdbuf, cmd24, 5);
3435    24EB  210500    		ld	hl,5
3436    24EE  E5        		push	hl
3437    24EF  213D00    		ld	hl,_cmd24
3438    24F2  E5        		push	hl
3439    24F3  DDE5      		push	ix
3440    24F5  C1        		pop	bc
3441    24F6  21F1FF    		ld	hl,65521
3442    24F9  09        		add	hl,bc
3443    24FA  CD0000    		call	_memcpy
3444    24FD  F1        		pop	af
3445    24FE  F1        		pop	af
3446                    	;  937      blktowrite = blkmult * wrblkno;
3447    24FF  DDE5      		push	ix
3448    2501  C1        		pop	bc
3449    2502  21E4FF    		ld	hl,65508
3450    2505  09        		add	hl,bc
3451    2506  E5        		push	hl
3452    2507  210600    		ld	hl,_blkmult
3453    250A  CD0000    		call	c.0mvf
3454    250D  210000    		ld	hl,c.r0
3455    2510  E5        		push	hl
3456    2511  DDE5      		push	ix
3457    2513  C1        		pop	bc
3458    2514  210600    		ld	hl,6
3459    2517  09        		add	hl,bc
3460    2518  E5        		push	hl
3461    2519  CD0000    		call	c.lmul
3462    251C  CD0000    		call	c.mvl
3463    251F  F1        		pop	af
3464                    	;  938      cmdbuf[4] = blktowrite & 0xff;
3465    2520  DD6EE6    		ld	l,(ix-26)
3466    2523  7D        		ld	a,l
3467    2524  E6FF      		and	255
3468    2526  DD77F5    		ld	(ix-11),a
3469                    	;  939      blktowrite = blktowrite >> 8;
3470    2529  DDE5      		push	ix
3471    252B  C1        		pop	bc
3472    252C  21E4FF    		ld	hl,65508
3473    252F  09        		add	hl,bc
3474    2530  E5        		push	hl
3475    2531  210800    		ld	hl,8
3476    2534  E5        		push	hl
3477    2535  CD0000    		call	c.ulrsh
3478    2538  F1        		pop	af
3479                    	;  940      cmdbuf[3] = blktowrite & 0xff;
3480    2539  DD6EE6    		ld	l,(ix-26)
3481    253C  7D        		ld	a,l
3482    253D  E6FF      		and	255
3483    253F  DD77F4    		ld	(ix-12),a
3484                    	;  941      blktowrite = blktowrite >> 8;
3485    2542  DDE5      		push	ix
3486    2544  C1        		pop	bc
3487    2545  21E4FF    		ld	hl,65508
3488    2548  09        		add	hl,bc
3489    2549  E5        		push	hl
3490    254A  210800    		ld	hl,8
3491    254D  E5        		push	hl
3492    254E  CD0000    		call	c.ulrsh
3493    2551  F1        		pop	af
3494                    	;  942      cmdbuf[2] = blktowrite & 0xff;
3495    2552  DD6EE6    		ld	l,(ix-26)
3496    2555  7D        		ld	a,l
3497    2556  E6FF      		and	255
3498    2558  DD77F3    		ld	(ix-13),a
3499                    	;  943      blktowrite = blktowrite >> 8;
3500    255B  DDE5      		push	ix
3501    255D  C1        		pop	bc
3502    255E  21E4FF    		ld	hl,65508
3503    2561  09        		add	hl,bc
3504    2562  E5        		push	hl
3505    2563  210800    		ld	hl,8
3506    2566  E5        		push	hl
3507    2567  CD0000    		call	c.ulrsh
3508    256A  F1        		pop	af
3509                    	;  944      cmdbuf[1] = blktowrite & 0xff;
3510    256B  DD6EE6    		ld	l,(ix-26)
3511    256E  7D        		ld	a,l
3512    256F  E6FF      		and	255
3513    2571  DD77F2    		ld	(ix-14),a
3514                    	;  945  
3515                    	;  946      if (sdtestflg)
3516    2574  2A0000    		ld	hl,(_sdtestflg)
3517    2577  7C        		ld	a,h
3518    2578  B5        		or	l
3519    2579  2829      		jr	z,L1723
3520                    	;  947          {
3521                    	;  948          printf("\nCMD24: WRITE_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
3522                    	;  949                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
3523    257B  DD4EF5    		ld	c,(ix-11)
3524    257E  97        		sub	a
3525    257F  47        		ld	b,a
3526    2580  C5        		push	bc
3527    2581  DD4EF4    		ld	c,(ix-12)
3528    2584  97        		sub	a
3529    2585  47        		ld	b,a
3530    2586  C5        		push	bc
3531    2587  DD4EF3    		ld	c,(ix-13)
3532    258A  97        		sub	a
3533    258B  47        		ld	b,a
3534    258C  C5        		push	bc
3535    258D  DD4EF2    		ld	c,(ix-14)
3536    2590  97        		sub	a
3537    2591  47        		ld	b,a
3538    2592  C5        		push	bc
3539    2593  DD4EF1    		ld	c,(ix-15)
3540    2596  97        		sub	a
3541    2597  47        		ld	b,a
3542    2598  C5        		push	bc
3543    2599  21B523    		ld	hl,L5151
3544    259C  CD0000    		call	_printf
3545    259F  210A00    		ld	hl,10
3546    25A2  39        		add	hl,sp
3547    25A3  F9        		ld	sp,hl
3548                    	L1723:
3549                    	;  950          } /* sdtestflg */
3550                    	;  951      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3551    25A4  210100    		ld	hl,1
3552    25A7  E5        		push	hl
3553    25A8  DDE5      		push	ix
3554    25AA  C1        		pop	bc
3555    25AB  21ECFF    		ld	hl,65516
3556    25AE  09        		add	hl,bc
3557    25AF  E5        		push	hl
3558    25B0  DDE5      		push	ix
3559    25B2  C1        		pop	bc
3560    25B3  21F1FF    		ld	hl,65521
3561    25B6  09        		add	hl,bc
3562    25B7  CD7701    		call	_sdcommand
3563    25BA  F1        		pop	af
3564    25BB  F1        		pop	af
3565    25BC  DD71F8    		ld	(ix-8),c
3566    25BF  DD70F9    		ld	(ix-7),b
3567                    	;  952      if (sdtestflg)
3568    25C2  2A0000    		ld	hl,(_sdtestflg)
3569    25C5  7C        		ld	a,h
3570    25C6  B5        		or	l
3571    25C7  2811      		jr	z,L1033
3572                    	;  953          {
3573                    	;  954          printf("CMD24 R1 response [%02x]\n", statptr[0]);
3574    25C9  DD6EF8    		ld	l,(ix-8)
3575    25CC  DD66F9    		ld	h,(ix-7)
3576    25CF  4E        		ld	c,(hl)
3577    25D0  97        		sub	a
3578    25D1  47        		ld	b,a
3579    25D2  C5        		push	bc
3580    25D3  21F523    		ld	hl,L5251
3581    25D6  CD0000    		call	_printf
3582    25D9  F1        		pop	af
3583                    	L1033:
3584                    	;  955          } /* sdtestflg */
3585                    	;  956      if (statptr[0])
3586    25DA  DD6EF8    		ld	l,(ix-8)
3587    25DD  DD66F9    		ld	h,(ix-7)
3588    25E0  7E        		ld	a,(hl)
3589    25E1  B7        		or	a
3590    25E2  2819      		jr	z,L1133
3591                    	;  957          {
3592                    	;  958          if (sdtestflg)
3593    25E4  2A0000    		ld	hl,(_sdtestflg)
3594    25E7  7C        		ld	a,h
3595    25E8  B5        		or	l
3596    25E9  2806      		jr	z,L1233
3597                    	;  959              {
3598                    	;  960              printf("  could not write block\n");
3599    25EB  210F24    		ld	hl,L5351
3600    25EE  CD0000    		call	_printf
3601                    	L1233:
3602                    	;  961              } /* sdtestflg */
3603                    	;  962          spideselect();
3604    25F1  CD0000    		call	_spideselect
3605                    	;  963          ledoff();
3606    25F4  CD0000    		call	_ledoff
3607                    	;  964          return (NO);
3608    25F7  010000    		ld	bc,0
3609    25FA  C30000    		jp	c.rets
3610                    	L1133:
3611                    	;  965          }
3612                    	;  966      /* send 0xfe, the byte before data */
3613                    	;  967      spiio(0xfe);
3614    25FD  21FE00    		ld	hl,254
3615    2600  CD0000    		call	_spiio
3616                    	;  968      /* initialize crc and send block */
3617                    	;  969      calcrc16 = 0;
3618    2603  DD36E200  		ld	(ix-30),0
3619    2607  DD36E300  		ld	(ix-29),0
3620                    	;  970      for (nbytes = 0; nbytes < 512; nbytes++)
3621    260B  DD36EA00  		ld	(ix-22),0
3622    260F  DD36EB00  		ld	(ix-21),0
3623                    	L1333:
3624    2613  DD7EEA    		ld	a,(ix-22)
3625    2616  D600      		sub	0
3626    2618  DD7EEB    		ld	a,(ix-21)
3627    261B  DE02      		sbc	a,2
3628    261D  F25926    		jp	p,L1433
3629                    	;  971          {
3630                    	;  972          tbyte = wrbuf[nbytes];
3631    2620  DD6E04    		ld	l,(ix+4)
3632    2623  DD6605    		ld	h,(ix+5)
3633    2626  DD4EEA    		ld	c,(ix-22)
3634    2629  DD46EB    		ld	b,(ix-21)
3635    262C  09        		add	hl,bc
3636    262D  7E        		ld	a,(hl)
3637    262E  DD77F6    		ld	(ix-10),a
3638                    	;  973          spiio(tbyte);
3639    2631  DD6EF6    		ld	l,(ix-10)
3640    2634  97        		sub	a
3641    2635  67        		ld	h,a
3642    2636  CD0000    		call	_spiio
3643                    	;  974          calcrc16 = CRC16_one(calcrc16, tbyte);
3644    2639  DD6EF6    		ld	l,(ix-10)
3645    263C  97        		sub	a
3646    263D  67        		ld	h,a
3647    263E  E5        		push	hl
3648    263F  DD6EE2    		ld	l,(ix-30)
3649    2642  DD66E3    		ld	h,(ix-29)
3650    2645  CDC900    		call	_CRC16_one
3651    2648  F1        		pop	af
3652    2649  DD71E2    		ld	(ix-30),c
3653    264C  DD70E3    		ld	(ix-29),b
3654                    	;  975          }
3655    264F  DD34EA    		inc	(ix-22)
3656    2652  2003      		jr	nz,L211
3657    2654  DD34EB    		inc	(ix-21)
3658                    	L211:
3659    2657  18BA      		jr	L1333
3660                    	L1433:
3661                    	;  976      spiio((calcrc16 >> 8) & 0xff);
3662    2659  DD6EE2    		ld	l,(ix-30)
3663    265C  DD66E3    		ld	h,(ix-29)
3664    265F  E5        		push	hl
3665    2660  210800    		ld	hl,8
3666    2663  E5        		push	hl
3667    2664  CD0000    		call	c.ursh
3668    2667  E1        		pop	hl
3669    2668  7D        		ld	a,l
3670    2669  E6FF      		and	255
3671    266B  6F        		ld	l,a
3672    266C  97        		sub	a
3673    266D  67        		ld	h,a
3674    266E  CD0000    		call	_spiio
3675                    	;  977      spiio(calcrc16 & 0xff);
3676    2671  DD6EE2    		ld	l,(ix-30)
3677    2674  DD66E3    		ld	h,(ix-29)
3678    2677  7D        		ld	a,l
3679    2678  E6FF      		and	255
3680    267A  6F        		ld	l,a
3681    267B  97        		sub	a
3682    267C  67        		ld	h,a
3683    267D  CD0000    		call	_spiio
3684                    	;  978  
3685                    	;  979      /* check data resposnse */
3686                    	;  980      for (tries = 20;
3687    2680  DD36E814  		ld	(ix-24),20
3688    2684  DD36E900  		ld	(ix-23),0
3689                    	L1733:
3690                    	;  981              0 < tries && (((rbyte = spiio(0xff)) & 0x11) != 0x01);
3691    2688  97        		sub	a
3692    2689  DD96E8    		sub	(ix-24)
3693    268C  3E00      		ld	a,0
3694    268E  DD9EE9    		sbc	a,(ix-23)
3695    2691  F2C126    		jp	p,L1043
3696    2694  21FF00    		ld	hl,255
3697    2697  CD0000    		call	_spiio
3698    269A  DD71F7    		ld	(ix-9),c
3699    269D  DD6EF7    		ld	l,(ix-9)
3700    26A0  97        		sub	a
3701    26A1  67        		ld	h,a
3702    26A2  7D        		ld	a,l
3703    26A3  E611      		and	17
3704    26A5  6F        		ld	l,a
3705    26A6  97        		sub	a
3706    26A7  67        		ld	h,a
3707    26A8  7D        		ld	a,l
3708    26A9  FE01      		cp	1
3709    26AB  2003      		jr	nz,L411
3710    26AD  7C        		ld	a,h
3711    26AE  FE00      		cp	0
3712                    	L411:
3713    26B0  280F      		jr	z,L1043
3714                    	;  982              tries--)
3715                    	L1143:
3716    26B2  DD6EE8    		ld	l,(ix-24)
3717    26B5  DD66E9    		ld	h,(ix-23)
3718    26B8  2B        		dec	hl
3719    26B9  DD75E8    		ld	(ix-24),l
3720    26BC  DD74E9    		ld	(ix-23),h
3721    26BF  18C7      		jr	L1733
3722                    	L1043:
3723                    	;  983          ;
3724                    	;  984      if (tries == 0)
3725    26C1  DD7EE8    		ld	a,(ix-24)
3726    26C4  DDB6E9    		or	(ix-23)
3727    26C7  2019      		jr	nz,L1343
3728                    	;  985          {
3729                    	;  986          if (sdtestflg)
3730    26C9  2A0000    		ld	hl,(_sdtestflg)
3731    26CC  7C        		ld	a,h
3732    26CD  B5        		or	l
3733    26CE  2806      		jr	z,L1443
3734                    	;  987              {
3735                    	;  988              printf("No data response\n");
3736    26D0  212824    		ld	hl,L5451
3737    26D3  CD0000    		call	_printf
3738                    	L1443:
3739                    	;  989              } /* sdtestflg */
3740                    	;  990          spideselect();
3741    26D6  CD0000    		call	_spideselect
3742                    	;  991          ledoff();
3743    26D9  CD0000    		call	_ledoff
3744                    	;  992          return (NO);
3745    26DC  010000    		ld	bc,0
3746    26DF  C30000    		jp	c.rets
3747                    	L1343:
3748                    	;  993          }
3749                    	;  994      else
3750                    	;  995          {
3751                    	;  996          if (sdtestflg)
3752    26E2  2A0000    		ld	hl,(_sdtestflg)
3753    26E5  7C        		ld	a,h
3754    26E6  B5        		or	l
3755    26E7  2813      		jr	z,L1643
3756                    	;  997              {
3757                    	;  998              printf("Data response [%02x]", 0x1f & rbyte);
3758    26E9  DD6EF7    		ld	l,(ix-9)
3759    26EC  97        		sub	a
3760    26ED  67        		ld	h,a
3761    26EE  7D        		ld	a,l
3762    26EF  E61F      		and	31
3763    26F1  6F        		ld	l,a
3764    26F2  97        		sub	a
3765    26F3  67        		ld	h,a
3766    26F4  E5        		push	hl
3767    26F5  213A24    		ld	hl,L5551
3768    26F8  CD0000    		call	_printf
3769    26FB  F1        		pop	af
3770                    	L1643:
3771                    	;  999              } /* sdtestflg */
3772                    	; 1000          if ((0x1f & rbyte) == 0x05)
3773    26FC  DD6EF7    		ld	l,(ix-9)
3774    26FF  97        		sub	a
3775    2700  67        		ld	h,a
3776    2701  7D        		ld	a,l
3777    2702  E61F      		and	31
3778    2704  6F        		ld	l,a
3779    2705  97        		sub	a
3780    2706  67        		ld	h,a
3781    2707  7D        		ld	a,l
3782    2708  FE05      		cp	5
3783    270A  2003      		jr	nz,L611
3784    270C  7C        		ld	a,h
3785    270D  FE00      		cp	0
3786                    	L611:
3787    270F  C26127    		jp	nz,L1743
3788                    	; 1001              {
3789                    	; 1002              if (sdtestflg)
3790    2712  2A0000    		ld	hl,(_sdtestflg)
3791    2715  7C        		ld	a,h
3792    2716  B5        		or	l
3793    2717  2806      		jr	z,L1053
3794                    	; 1003                  {
3795                    	; 1004                  printf(", data accepted\n");
3796    2719  214F24    		ld	hl,L5651
3797    271C  CD0000    		call	_printf
3798                    	L1053:
3799                    	; 1005                  } /* sdtestflg */
3800                    	; 1006              for (nbytes = 9; 0 < nbytes; nbytes--)
3801    271F  DD36EA09  		ld	(ix-22),9
3802    2723  DD36EB00  		ld	(ix-21),0
3803                    	L1153:
3804    2727  97        		sub	a
3805    2728  DD96EA    		sub	(ix-22)
3806    272B  3E00      		ld	a,0
3807    272D  DD9EEB    		sbc	a,(ix-21)
3808    2730  F24827    		jp	p,L1253
3809                    	; 1007                  spiio(0xff);
3810    2733  21FF00    		ld	hl,255
3811    2736  CD0000    		call	_spiio
3812    2739  DD6EEA    		ld	l,(ix-22)
3813    273C  DD66EB    		ld	h,(ix-21)
3814    273F  2B        		dec	hl
3815    2740  DD75EA    		ld	(ix-22),l
3816    2743  DD74EB    		ld	(ix-21),h
3817    2746  18DF      		jr	L1153
3818                    	L1253:
3819                    	; 1008              if (sdtestflg)
3820    2748  2A0000    		ld	hl,(_sdtestflg)
3821    274B  7C        		ld	a,h
3822    274C  B5        		or	l
3823    274D  2806      		jr	z,L1553
3824                    	; 1009                  {
3825                    	; 1010                  printf("Sent 9*8 (72) clock pulses, select active\n");
3826    274F  216024    		ld	hl,L5751
3827    2752  CD0000    		call	_printf
3828                    	L1553:
3829                    	; 1011                  } /* sdtestflg */
3830                    	; 1012              spideselect();
3831    2755  CD0000    		call	_spideselect
3832                    	; 1013              ledoff();
3833    2758  CD0000    		call	_ledoff
3834                    	; 1014              return (YES);
3835    275B  010100    		ld	bc,1
3836    275E  C30000    		jp	c.rets
3837                    	L1743:
3838                    	; 1015              }
3839                    	; 1016          else
3840                    	; 1017              {
3841                    	; 1018              if (sdtestflg)
3842    2761  2A0000    		ld	hl,(_sdtestflg)
3843    2764  7C        		ld	a,h
3844    2765  B5        		or	l
3845    2766  2806      		jr	z,L1753
3846                    	; 1019                  {
3847                    	; 1020                  printf(", data not accepted\n");
3848    2768  218B24    		ld	hl,L5061
3849    276B  CD0000    		call	_printf
3850                    	L1753:
3851                    	; 1021                  } /* sdtestflg */
3852                    	; 1022              spideselect();
3853    276E  CD0000    		call	_spideselect
3854                    	; 1023              ledoff();
3855    2771  CD0000    		call	_ledoff
3856                    	; 1024              return (NO);
3857    2774  010000    		ld	bc,0
3858    2777  C30000    		jp	c.rets
3859                    	L5161:
3860    277A  2A        		.byte	42
3861    277B  0A        		.byte	10
3862    277C  00        		.byte	0
3863                    	L5261:
3864    277D  25        		.byte	37
3865    277E  30        		.byte	48
3866    277F  34        		.byte	52
3867    2780  78        		.byte	120
3868    2781  20        		.byte	32
3869    2782  00        		.byte	0
3870                    	L5361:
3871    2783  25        		.byte	37
3872    2784  30        		.byte	48
3873    2785  32        		.byte	50
3874    2786  78        		.byte	120
3875    2787  20        		.byte	32
3876    2788  00        		.byte	0
3877                    	L5461:
3878    2789  20        		.byte	32
3879    278A  7C        		.byte	124
3880    278B  00        		.byte	0
3881                    	L5561:
3882    278C  7C        		.byte	124
3883    278D  0A        		.byte	10
3884    278E  00        		.byte	0
3885                    	; 1025              }
3886                    	; 1026          }
3887                    	; 1027      }
3888                    	; 1028  
3889                    	; 1029  /* Print data in 512 byte buffer */
3890                    	; 1030  void sddatprt(unsigned char *prtbuf)
3891                    	; 1031      {
3892                    	_sddatprt:
3893    278F  CD0000    		call	c.savs
3894    2792  21EEFF    		ld	hl,65518
3895    2795  39        		add	hl,sp
3896    2796  F9        		ld	sp,hl
3897                    	; 1032      /* Variables used for "pretty-print" */
3898                    	; 1033      int allzero, dmpline, dotprted, lastallz, nbytes;
3899                    	; 1034      unsigned char *prtptr;
3900                    	; 1035  
3901                    	; 1036      prtptr = prtbuf;
3902    2797  DD7E04    		ld	a,(ix+4)
3903    279A  DD77EE    		ld	(ix-18),a
3904    279D  DD7E05    		ld	a,(ix+5)
3905    27A0  DD77EF    		ld	(ix-17),a
3906                    	; 1037      dotprted = NO;
3907    27A3  DD36F400  		ld	(ix-12),0
3908    27A7  DD36F500  		ld	(ix-11),0
3909                    	; 1038      lastallz = NO;
3910    27AB  DD36F200  		ld	(ix-14),0
3911    27AF  DD36F300  		ld	(ix-13),0
3912                    	; 1039      for (dmpline = 0; dmpline < 32; dmpline++)
3913    27B3  DD36F600  		ld	(ix-10),0
3914    27B7  DD36F700  		ld	(ix-9),0
3915                    	L1063:
3916    27BB  DD7EF6    		ld	a,(ix-10)
3917    27BE  D620      		sub	32
3918    27C0  DD7EF7    		ld	a,(ix-9)
3919    27C3  DE00      		sbc	a,0
3920    27C5  F21C29    		jp	p,L1163
3921                    	; 1040          {
3922                    	; 1041          /* test if all 16 bytes are 0x00 */
3923                    	; 1042          allzero = YES;
3924    27C8  DD36F801  		ld	(ix-8),1
3925    27CC  DD36F900  		ld	(ix-7),0
3926                    	; 1043          for (nbytes = 0; nbytes < 16; nbytes++)
3927    27D0  DD36F000  		ld	(ix-16),0
3928    27D4  DD36F100  		ld	(ix-15),0
3929                    	L1463:
3930    27D8  DD7EF0    		ld	a,(ix-16)
3931    27DB  D610      		sub	16
3932    27DD  DD7EF1    		ld	a,(ix-15)
3933    27E0  DE00      		sbc	a,0
3934    27E2  F20828    		jp	p,L1563
3935                    	; 1044              {
3936                    	; 1045              if (prtptr[nbytes] != 0)
3937    27E5  DD6EEE    		ld	l,(ix-18)
3938    27E8  DD66EF    		ld	h,(ix-17)
3939    27EB  DD4EF0    		ld	c,(ix-16)
3940    27EE  DD46F1    		ld	b,(ix-15)
3941    27F1  09        		add	hl,bc
3942    27F2  7E        		ld	a,(hl)
3943    27F3  B7        		or	a
3944    27F4  2808      		jr	z,L1663
3945                    	; 1046                  allzero = NO;
3946    27F6  DD36F800  		ld	(ix-8),0
3947    27FA  DD36F900  		ld	(ix-7),0
3948                    	L1663:
3949    27FE  DD34F0    		inc	(ix-16)
3950    2801  2003      		jr	nz,L421
3951    2803  DD34F1    		inc	(ix-15)
3952                    	L421:
3953    2806  18D0      		jr	L1463
3954                    	L1563:
3955                    	; 1047              }
3956                    	; 1048          if (lastallz && allzero)
3957    2808  DD7EF2    		ld	a,(ix-14)
3958    280B  DDB6F3    		or	(ix-13)
3959    280E  2822      		jr	z,L1173
3960    2810  DD7EF8    		ld	a,(ix-8)
3961    2813  DDB6F9    		or	(ix-7)
3962    2816  281A      		jr	z,L1173
3963                    	; 1049              {
3964                    	; 1050              if (!dotprted)
3965    2818  DD7EF4    		ld	a,(ix-12)
3966    281B  DDB6F5    		or	(ix-11)
3967    281E  C2F128    		jp	nz,L1373
3968                    	; 1051                  {
3969                    	; 1052                  printf("*\n");
3970    2821  217A27    		ld	hl,L5161
3971    2824  CD0000    		call	_printf
3972                    	; 1053                  dotprted = YES;
3973    2827  DD36F401  		ld	(ix-12),1
3974    282B  DD36F500  		ld	(ix-11),0
3975    282F  C3F128    		jp	L1373
3976                    	L1173:
3977                    	; 1054                  }
3978                    	; 1055              }
3979                    	; 1056          else
3980                    	; 1057              {
3981                    	; 1058              dotprted = NO;
3982    2832  DD36F400  		ld	(ix-12),0
3983    2836  DD36F500  		ld	(ix-11),0
3984                    	; 1059              /* print offset */
3985                    	; 1060              printf("%04x ", dmpline * 16);
3986    283A  DD6EF6    		ld	l,(ix-10)
3987    283D  DD66F7    		ld	h,(ix-9)
3988    2840  E5        		push	hl
3989    2841  211000    		ld	hl,16
3990    2844  E5        		push	hl
3991    2845  CD0000    		call	c.imul
3992    2848  217D27    		ld	hl,L5261
3993    284B  CD0000    		call	_printf
3994    284E  F1        		pop	af
3995                    	; 1061              /* print 16 bytes in hex */
3996                    	; 1062              for (nbytes = 0; nbytes < 16; nbytes++)
3997    284F  DD36F000  		ld	(ix-16),0
3998    2853  DD36F100  		ld	(ix-15),0
3999                    	L1473:
4000    2857  DD7EF0    		ld	a,(ix-16)
4001    285A  D610      		sub	16
4002    285C  DD7EF1    		ld	a,(ix-15)
4003    285F  DE00      		sbc	a,0
4004    2861  F28628    		jp	p,L1573
4005                    	; 1063                  printf("%02x ", prtptr[nbytes]);
4006    2864  DD6EEE    		ld	l,(ix-18)
4007    2867  DD66EF    		ld	h,(ix-17)
4008    286A  DD4EF0    		ld	c,(ix-16)
4009    286D  DD46F1    		ld	b,(ix-15)
4010    2870  09        		add	hl,bc
4011    2871  4E        		ld	c,(hl)
4012    2872  97        		sub	a
4013    2873  47        		ld	b,a
4014    2874  C5        		push	bc
4015    2875  218327    		ld	hl,L5361
4016    2878  CD0000    		call	_printf
4017    287B  F1        		pop	af
4018    287C  DD34F0    		inc	(ix-16)
4019    287F  2003      		jr	nz,L621
4020    2881  DD34F1    		inc	(ix-15)
4021                    	L621:
4022    2884  18D1      		jr	L1473
4023                    	L1573:
4024                    	; 1064              /* print these bytes in ASCII if printable */
4025                    	; 1065              printf(" |");
4026    2886  218927    		ld	hl,L5461
4027    2889  CD0000    		call	_printf
4028                    	; 1066              for (nbytes = 0; nbytes < 16; nbytes++)
4029    288C  DD36F000  		ld	(ix-16),0
4030    2890  DD36F100  		ld	(ix-15),0
4031                    	L1004:
4032    2894  DD7EF0    		ld	a,(ix-16)
4033    2897  D610      		sub	16
4034    2899  DD7EF1    		ld	a,(ix-15)
4035    289C  DE00      		sbc	a,0
4036    289E  F2EB28    		jp	p,L1104
4037                    	; 1067                  {
4038                    	; 1068                  if ((' ' <= prtptr[nbytes]) && (prtptr[nbytes] < 127))
4039    28A1  DD6EEE    		ld	l,(ix-18)
4040    28A4  DD66EF    		ld	h,(ix-17)
4041    28A7  DD4EF0    		ld	c,(ix-16)
4042    28AA  DD46F1    		ld	b,(ix-15)
4043    28AD  09        		add	hl,bc
4044    28AE  7E        		ld	a,(hl)
4045    28AF  FE20      		cp	32
4046    28B1  3827      		jr	c,L1404
4047    28B3  DD6EEE    		ld	l,(ix-18)
4048    28B6  DD66EF    		ld	h,(ix-17)
4049    28B9  DD4EF0    		ld	c,(ix-16)
4050    28BC  DD46F1    		ld	b,(ix-15)
4051    28BF  09        		add	hl,bc
4052    28C0  7E        		ld	a,(hl)
4053    28C1  FE7F      		cp	127
4054    28C3  3015      		jr	nc,L1404
4055                    	; 1069                      putchar(prtptr[nbytes]);
4056    28C5  DD6EEE    		ld	l,(ix-18)
4057    28C8  DD66EF    		ld	h,(ix-17)
4058    28CB  DD4EF0    		ld	c,(ix-16)
4059    28CE  DD46F1    		ld	b,(ix-15)
4060    28D1  09        		add	hl,bc
4061    28D2  6E        		ld	l,(hl)
4062    28D3  97        		sub	a
4063    28D4  67        		ld	h,a
4064    28D5  CD0000    		call	_putchar
4065                    	; 1070                  else
4066    28D8  1806      		jr	L1204
4067                    	L1404:
4068                    	; 1071                      putchar('.');
4069    28DA  212E00    		ld	hl,46
4070    28DD  CD0000    		call	_putchar
4071                    	L1204:
4072    28E0  DD34F0    		inc	(ix-16)
4073    28E3  2003      		jr	nz,L031
4074    28E5  DD34F1    		inc	(ix-15)
4075                    	L031:
4076    28E8  C39428    		jp	L1004
4077                    	L1104:
4078                    	; 1072                  }
4079                    	; 1073              printf("|\n");
4080    28EB  218C27    		ld	hl,L5561
4081    28EE  CD0000    		call	_printf
4082                    	L1373:
4083                    	; 1074              }
4084                    	; 1075          prtptr += 16;
4085    28F1  DD6EEE    		ld	l,(ix-18)
4086    28F4  DD66EF    		ld	h,(ix-17)
4087    28F7  7D        		ld	a,l
4088    28F8  C610      		add	a,16
4089    28FA  6F        		ld	l,a
4090    28FB  7C        		ld	a,h
4091    28FC  CE00      		adc	a,0
4092    28FE  67        		ld	h,a
4093    28FF  DD75EE    		ld	(ix-18),l
4094    2902  DD74EF    		ld	(ix-17),h
4095                    	; 1076          lastallz = allzero;
   0    2905  DD7EF8    		ld	a,(ix-8)
   1    2908  DD77F2    		ld	(ix-14),a
   2    290B  DD7EF9    		ld	a,(ix-7)
   3    290E  DD77F3    		ld	(ix-13),a
   4                    	; 1077          }
   5    2911  DD34F6    		inc	(ix-10)
   6    2914  2003      		jr	nz,L221
   7    2916  DD34F7    		inc	(ix-9)
   8                    	L221:
   9    2919  C3BB27    		jp	L1063
  10                    	L1163:
  11                    	; 1078      }
  12    291C  C30000    		jp	c.rets
  13                    	L5661:
  14    291F  25        		.byte	37
  15    2920  30        		.byte	48
  16    2921  32        		.byte	50
  17    2922  78        		.byte	120
  18    2923  25        		.byte	37
  19    2924  30        		.byte	48
  20    2925  32        		.byte	50
  21    2926  78        		.byte	120
  22    2927  25        		.byte	37
  23    2928  30        		.byte	48
  24    2929  32        		.byte	50
  25    292A  78        		.byte	120
  26    292B  25        		.byte	37
  27    292C  30        		.byte	48
  28    292D  32        		.byte	50
  29    292E  78        		.byte	120
  30    292F  2D        		.byte	45
  31    2930  00        		.byte	0
  32                    	L5761:
  33    2931  25        		.byte	37
  34    2932  30        		.byte	48
  35    2933  32        		.byte	50
  36    2934  78        		.byte	120
  37    2935  25        		.byte	37
  38    2936  30        		.byte	48
  39    2937  32        		.byte	50
  40    2938  78        		.byte	120
  41    2939  2D        		.byte	45
  42    293A  00        		.byte	0
  43                    	L5071:
  44    293B  25        		.byte	37
  45    293C  30        		.byte	48
  46    293D  32        		.byte	50
  47    293E  78        		.byte	120
  48    293F  25        		.byte	37
  49    2940  30        		.byte	48
  50    2941  32        		.byte	50
  51    2942  78        		.byte	120
  52    2943  2D        		.byte	45
  53    2944  00        		.byte	0
  54                    	L5171:
  55    2945  25        		.byte	37
  56    2946  30        		.byte	48
  57    2947  32        		.byte	50
  58    2948  78        		.byte	120
  59    2949  25        		.byte	37
  60    294A  30        		.byte	48
  61    294B  32        		.byte	50
  62    294C  78        		.byte	120
  63    294D  2D        		.byte	45
  64    294E  00        		.byte	0
  65                    	L5271:
  66    294F  25        		.byte	37
  67    2950  30        		.byte	48
  68    2951  32        		.byte	50
  69    2952  78        		.byte	120
  70    2953  25        		.byte	37
  71    2954  30        		.byte	48
  72    2955  32        		.byte	50
  73    2956  78        		.byte	120
  74    2957  25        		.byte	37
  75    2958  30        		.byte	48
  76    2959  32        		.byte	50
  77    295A  78        		.byte	120
  78    295B  25        		.byte	37
  79    295C  30        		.byte	48
  80    295D  32        		.byte	50
  81    295E  78        		.byte	120
  82    295F  25        		.byte	37
  83    2960  30        		.byte	48
  84    2961  32        		.byte	50
  85    2962  78        		.byte	120
  86    2963  25        		.byte	37
  87    2964  30        		.byte	48
  88    2965  32        		.byte	50
  89    2966  78        		.byte	120
  90    2967  00        		.byte	0
  91                    	; 1079  
  92                    	; 1080  /* Print GUID (mixed endian format)
  93                    	; 1081   */
  94                    	; 1082  void prtguid(unsigned char *guidptr)
  95                    	; 1083      {
  96                    	_prtguid:
  97    2968  CD0000    		call	c.savs
  98    296B  F5        		push	af
  99    296C  F5        		push	af
 100    296D  F5        		push	af
 101    296E  F5        		push	af
 102                    	; 1084      int index;
 103                    	; 1085  
 104                    	; 1086      printf("%02x%02x%02x%02x-", guidptr[3], guidptr[2], guidptr[1], guidptr[0]);
 105    296F  DD6E04    		ld	l,(ix+4)
 106    2972  DD6605    		ld	h,(ix+5)
 107    2975  4E        		ld	c,(hl)
 108    2976  97        		sub	a
 109    2977  47        		ld	b,a
 110    2978  C5        		push	bc
 111    2979  DD6E04    		ld	l,(ix+4)
 112    297C  DD6605    		ld	h,(ix+5)
 113    297F  23        		inc	hl
 114    2980  4E        		ld	c,(hl)
 115    2981  97        		sub	a
 116    2982  47        		ld	b,a
 117    2983  C5        		push	bc
 118    2984  DD6E04    		ld	l,(ix+4)
 119    2987  DD6605    		ld	h,(ix+5)
 120    298A  23        		inc	hl
 121    298B  23        		inc	hl
 122    298C  4E        		ld	c,(hl)
 123    298D  97        		sub	a
 124    298E  47        		ld	b,a
 125    298F  C5        		push	bc
 126    2990  DD6E04    		ld	l,(ix+4)
 127    2993  DD6605    		ld	h,(ix+5)
 128    2996  23        		inc	hl
 129    2997  23        		inc	hl
 130    2998  23        		inc	hl
 131    2999  4E        		ld	c,(hl)
 132    299A  97        		sub	a
 133    299B  47        		ld	b,a
 134    299C  C5        		push	bc
 135    299D  211F29    		ld	hl,L5661
 136    29A0  CD0000    		call	_printf
 137    29A3  F1        		pop	af
 138    29A4  F1        		pop	af
 139    29A5  F1        		pop	af
 140    29A6  F1        		pop	af
 141                    	; 1087      printf("%02x%02x-", guidptr[5], guidptr[4]);
 142    29A7  DD6E04    		ld	l,(ix+4)
 143    29AA  DD6605    		ld	h,(ix+5)
 144    29AD  23        		inc	hl
 145    29AE  23        		inc	hl
 146    29AF  23        		inc	hl
 147    29B0  23        		inc	hl
 148    29B1  4E        		ld	c,(hl)
 149    29B2  97        		sub	a
 150    29B3  47        		ld	b,a
 151    29B4  C5        		push	bc
 152    29B5  DD6E04    		ld	l,(ix+4)
 153    29B8  DD6605    		ld	h,(ix+5)
 154    29BB  010500    		ld	bc,5
 155    29BE  09        		add	hl,bc
 156    29BF  4E        		ld	c,(hl)
 157    29C0  97        		sub	a
 158    29C1  47        		ld	b,a
 159    29C2  C5        		push	bc
 160    29C3  213129    		ld	hl,L5761
 161    29C6  CD0000    		call	_printf
 162    29C9  F1        		pop	af
 163    29CA  F1        		pop	af
 164                    	; 1088      printf("%02x%02x-", guidptr[7], guidptr[6]);
 165    29CB  DD6E04    		ld	l,(ix+4)
 166    29CE  DD6605    		ld	h,(ix+5)
 167    29D1  010600    		ld	bc,6
 168    29D4  09        		add	hl,bc
 169    29D5  4E        		ld	c,(hl)
 170    29D6  97        		sub	a
 171    29D7  47        		ld	b,a
 172    29D8  C5        		push	bc
 173    29D9  DD6E04    		ld	l,(ix+4)
 174    29DC  DD6605    		ld	h,(ix+5)
 175    29DF  010700    		ld	bc,7
 176    29E2  09        		add	hl,bc
 177    29E3  4E        		ld	c,(hl)
 178    29E4  97        		sub	a
 179    29E5  47        		ld	b,a
 180    29E6  C5        		push	bc
 181    29E7  213B29    		ld	hl,L5071
 182    29EA  CD0000    		call	_printf
 183    29ED  F1        		pop	af
 184    29EE  F1        		pop	af
 185                    	; 1089      printf("%02x%02x-", guidptr[8], guidptr[9]);
 186    29EF  DD6E04    		ld	l,(ix+4)
 187    29F2  DD6605    		ld	h,(ix+5)
 188    29F5  010900    		ld	bc,9
 189    29F8  09        		add	hl,bc
 190    29F9  4E        		ld	c,(hl)
 191    29FA  97        		sub	a
 192    29FB  47        		ld	b,a
 193    29FC  C5        		push	bc
 194    29FD  DD6E04    		ld	l,(ix+4)
 195    2A00  DD6605    		ld	h,(ix+5)
 196    2A03  010800    		ld	bc,8
 197    2A06  09        		add	hl,bc
 198    2A07  4E        		ld	c,(hl)
 199    2A08  97        		sub	a
 200    2A09  47        		ld	b,a
 201    2A0A  C5        		push	bc
 202    2A0B  214529    		ld	hl,L5171
 203    2A0E  CD0000    		call	_printf
 204    2A11  F1        		pop	af
 205    2A12  F1        		pop	af
 206                    	; 1090      printf("%02x%02x%02x%02x%02x%02x",
 207                    	; 1091             guidptr[10], guidptr[11], guidptr[12], guidptr[13], guidptr[14], guidptr[15]);
 208    2A13  DD6E04    		ld	l,(ix+4)
 209    2A16  DD6605    		ld	h,(ix+5)
 210    2A19  010F00    		ld	bc,15
 211    2A1C  09        		add	hl,bc
 212    2A1D  4E        		ld	c,(hl)
 213    2A1E  97        		sub	a
 214    2A1F  47        		ld	b,a
 215    2A20  C5        		push	bc
 216    2A21  DD6E04    		ld	l,(ix+4)
 217    2A24  DD6605    		ld	h,(ix+5)
 218    2A27  010E00    		ld	bc,14
 219    2A2A  09        		add	hl,bc
 220    2A2B  4E        		ld	c,(hl)
 221    2A2C  97        		sub	a
 222    2A2D  47        		ld	b,a
 223    2A2E  C5        		push	bc
 224    2A2F  DD6E04    		ld	l,(ix+4)
 225    2A32  DD6605    		ld	h,(ix+5)
 226    2A35  010D00    		ld	bc,13
 227    2A38  09        		add	hl,bc
 228    2A39  4E        		ld	c,(hl)
 229    2A3A  97        		sub	a
 230    2A3B  47        		ld	b,a
 231    2A3C  C5        		push	bc
 232    2A3D  DD6E04    		ld	l,(ix+4)
 233    2A40  DD6605    		ld	h,(ix+5)
 234    2A43  010C00    		ld	bc,12
 235    2A46  09        		add	hl,bc
 236    2A47  4E        		ld	c,(hl)
 237    2A48  97        		sub	a
 238    2A49  47        		ld	b,a
 239    2A4A  C5        		push	bc
 240    2A4B  DD6E04    		ld	l,(ix+4)
 241    2A4E  DD6605    		ld	h,(ix+5)
 242    2A51  010B00    		ld	bc,11
 243    2A54  09        		add	hl,bc
 244    2A55  4E        		ld	c,(hl)
 245    2A56  97        		sub	a
 246    2A57  47        		ld	b,a
 247    2A58  C5        		push	bc
 248    2A59  DD6E04    		ld	l,(ix+4)
 249    2A5C  DD6605    		ld	h,(ix+5)
 250    2A5F  010A00    		ld	bc,10
 251    2A62  09        		add	hl,bc
 252    2A63  4E        		ld	c,(hl)
 253    2A64  97        		sub	a
 254    2A65  47        		ld	b,a
 255    2A66  C5        		push	bc
 256    2A67  214F29    		ld	hl,L5271
 257    2A6A  CD0000    		call	_printf
 258    2A6D  210C00    		ld	hl,12
 259    2A70  39        		add	hl,sp
 260    2A71  F9        		ld	sp,hl
 261                    	; 1092      }
 262    2A72  C30000    		jp	c.rets
 263                    	L5371:
 264    2A75  43        		.byte	67
 265    2A76  61        		.byte	97
 266    2A77  6E        		.byte	110
 267    2A78  27        		.byte	39
 268    2A79  74        		.byte	116
 269    2A7A  20        		.byte	32
 270    2A7B  72        		.byte	114
 271    2A7C  65        		.byte	101
 272    2A7D  61        		.byte	97
 273    2A7E  64        		.byte	100
 274    2A7F  20        		.byte	32
 275    2A80  47        		.byte	71
 276    2A81  50        		.byte	80
 277    2A82  54        		.byte	84
 278    2A83  20        		.byte	32
 279    2A84  65        		.byte	101
 280    2A85  6E        		.byte	110
 281    2A86  74        		.byte	116
 282    2A87  72        		.byte	114
 283    2A88  79        		.byte	121
 284    2A89  20        		.byte	32
 285    2A8A  62        		.byte	98
 286    2A8B  6C        		.byte	108
 287    2A8C  6F        		.byte	111
 288    2A8D  63        		.byte	99
 289    2A8E  6B        		.byte	107
 290    2A8F  0A        		.byte	10
 291    2A90  00        		.byte	0
 292                    	L5471:
 293    2A91  47        		.byte	71
 294    2A92  50        		.byte	80
 295    2A93  54        		.byte	84
 296    2A94  20        		.byte	32
 297    2A95  70        		.byte	112
 298    2A96  61        		.byte	97
 299    2A97  72        		.byte	114
 300    2A98  74        		.byte	116
 301    2A99  69        		.byte	105
 302    2A9A  74        		.byte	116
 303    2A9B  69        		.byte	105
 304    2A9C  6F        		.byte	111
 305    2A9D  6E        		.byte	110
 306    2A9E  20        		.byte	32
 307    2A9F  65        		.byte	101
 308    2AA0  6E        		.byte	110
 309    2AA1  74        		.byte	116
 310    2AA2  72        		.byte	114
 311    2AA3  79        		.byte	121
 312    2AA4  20        		.byte	32
 313    2AA5  25        		.byte	37
 314    2AA6  64        		.byte	100
 315    2AA7  3A        		.byte	58
 316    2AA8  00        		.byte	0
 317                    	L5571:
 318    2AA9  20        		.byte	32
 319    2AAA  4E        		.byte	78
 320    2AAB  6F        		.byte	111
 321    2AAC  74        		.byte	116
 322    2AAD  20        		.byte	32
 323    2AAE  75        		.byte	117
 324    2AAF  73        		.byte	115
 325    2AB0  65        		.byte	101
 326    2AB1  64        		.byte	100
 327    2AB2  20        		.byte	32
 328    2AB3  65        		.byte	101
 329    2AB4  6E        		.byte	110
 330    2AB5  74        		.byte	116
 331    2AB6  72        		.byte	114
 332    2AB7  79        		.byte	121
 333    2AB8  0A        		.byte	10
 334    2AB9  00        		.byte	0
 335                    	L5671:
 336    2ABA  0A        		.byte	10
 337    2ABB  20        		.byte	32
 338    2ABC  20        		.byte	32
 339    2ABD  50        		.byte	80
 340    2ABE  61        		.byte	97
 341    2ABF  72        		.byte	114
 342    2AC0  74        		.byte	116
 343    2AC1  69        		.byte	105
 344    2AC2  74        		.byte	116
 345    2AC3  69        		.byte	105
 346    2AC4  6F        		.byte	111
 347    2AC5  6E        		.byte	110
 348    2AC6  20        		.byte	32
 349    2AC7  74        		.byte	116
 350    2AC8  79        		.byte	121
 351    2AC9  70        		.byte	112
 352    2ACA  65        		.byte	101
 353    2ACB  20        		.byte	32
 354    2ACC  47        		.byte	71
 355    2ACD  55        		.byte	85
 356    2ACE  49        		.byte	73
 357    2ACF  44        		.byte	68
 358    2AD0  3A        		.byte	58
 359    2AD1  20        		.byte	32
 360    2AD2  00        		.byte	0
 361                    	L5771:
 362    2AD3  0A        		.byte	10
 363    2AD4  20        		.byte	32
 364    2AD5  20        		.byte	32
 365    2AD6  5B        		.byte	91
 366    2AD7  00        		.byte	0
 367                    	L5002:
 368    2AD8  25        		.byte	37
 369    2AD9  30        		.byte	48
 370    2ADA  32        		.byte	50
 371    2ADB  78        		.byte	120
 372    2ADC  20        		.byte	32
 373    2ADD  00        		.byte	0
 374                    	L5102:
 375    2ADE  08        		.byte	8
 376    2ADF  5D        		.byte	93
 377    2AE0  00        		.byte	0
 378                    	L5202:
 379    2AE1  0A        		.byte	10
 380    2AE2  20        		.byte	32
 381    2AE3  20        		.byte	32
 382    2AE4  55        		.byte	85
 383    2AE5  6E        		.byte	110
 384    2AE6  69        		.byte	105
 385    2AE7  71        		.byte	113
 386    2AE8  75        		.byte	117
 387    2AE9  65        		.byte	101
 388    2AEA  20        		.byte	32
 389    2AEB  70        		.byte	112
 390    2AEC  61        		.byte	97
 391    2AED  72        		.byte	114
 392    2AEE  74        		.byte	116
 393    2AEF  69        		.byte	105
 394    2AF0  74        		.byte	116
 395    2AF1  69        		.byte	105
 396    2AF2  6F        		.byte	111
 397    2AF3  6E        		.byte	110
 398    2AF4  20        		.byte	32
 399    2AF5  47        		.byte	71
 400    2AF6  55        		.byte	85
 401    2AF7  49        		.byte	73
 402    2AF8  44        		.byte	68
 403    2AF9  3A        		.byte	58
 404    2AFA  20        		.byte	32
 405    2AFB  00        		.byte	0
 406                    	L5302:
 407    2AFC  0A        		.byte	10
 408    2AFD  20        		.byte	32
 409    2AFE  20        		.byte	32
 410    2AFF  5B        		.byte	91
 411    2B00  00        		.byte	0
 412                    	L5402:
 413    2B01  25        		.byte	37
 414    2B02  30        		.byte	48
 415    2B03  32        		.byte	50
 416    2B04  78        		.byte	120
 417    2B05  20        		.byte	32
 418    2B06  00        		.byte	0
 419                    	L5502:
 420    2B07  08        		.byte	8
 421    2B08  5D        		.byte	93
 422    2B09  00        		.byte	0
 423                    	L5602:
 424    2B0A  0A        		.byte	10
 425    2B0B  20        		.byte	32
 426    2B0C  20        		.byte	32
 427    2B0D  46        		.byte	70
 428    2B0E  69        		.byte	105
 429    2B0F  72        		.byte	114
 430    2B10  73        		.byte	115
 431    2B11  74        		.byte	116
 432    2B12  20        		.byte	32
 433    2B13  4C        		.byte	76
 434    2B14  42        		.byte	66
 435    2B15  41        		.byte	65
 436    2B16  3A        		.byte	58
 437    2B17  20        		.byte	32
 438    2B18  00        		.byte	0
 439                    	L5702:
 440    2B19  25        		.byte	37
 441    2B1A  6C        		.byte	108
 442    2B1B  75        		.byte	117
 443    2B1C  00        		.byte	0
 444                    	L5012:
 445    2B1D  20        		.byte	32
 446    2B1E  5B        		.byte	91
 447    2B1F  00        		.byte	0
 448                    	L5112:
 449    2B20  25        		.byte	37
 450    2B21  30        		.byte	48
 451    2B22  32        		.byte	50
 452    2B23  78        		.byte	120
 453    2B24  20        		.byte	32
 454    2B25  00        		.byte	0
 455                    	L5212:
 456    2B26  08        		.byte	8
 457    2B27  5D        		.byte	93
 458    2B28  00        		.byte	0
 459                    	L5312:
 460    2B29  0A        		.byte	10
 461    2B2A  20        		.byte	32
 462    2B2B  20        		.byte	32
 463    2B2C  4C        		.byte	76
 464    2B2D  61        		.byte	97
 465    2B2E  73        		.byte	115
 466    2B2F  74        		.byte	116
 467    2B30  20        		.byte	32
 468    2B31  4C        		.byte	76
 469    2B32  42        		.byte	66
 470    2B33  41        		.byte	65
 471    2B34  3A        		.byte	58
 472    2B35  20        		.byte	32
 473    2B36  00        		.byte	0
 474                    	L5412:
 475    2B37  25        		.byte	37
 476    2B38  6C        		.byte	108
 477    2B39  75        		.byte	117
 478    2B3A  2C        		.byte	44
 479    2B3B  20        		.byte	32
 480    2B3C  73        		.byte	115
 481    2B3D  69        		.byte	105
 482    2B3E  7A        		.byte	122
 483    2B3F  65        		.byte	101
 484    2B40  20        		.byte	32
 485    2B41  25        		.byte	37
 486    2B42  6C        		.byte	108
 487    2B43  75        		.byte	117
 488    2B44  20        		.byte	32
 489    2B45  4D        		.byte	77
 490    2B46  42        		.byte	66
 491    2B47  79        		.byte	121
 492    2B48  74        		.byte	116
 493    2B49  65        		.byte	101
 494    2B4A  00        		.byte	0
 495                    	L5512:
 496    2B4B  20        		.byte	32
 497    2B4C  5B        		.byte	91
 498    2B4D  00        		.byte	0
 499                    	L5612:
 500    2B4E  25        		.byte	37
 501    2B4F  30        		.byte	48
 502    2B50  32        		.byte	50
 503    2B51  78        		.byte	120
 504    2B52  20        		.byte	32
 505    2B53  00        		.byte	0
 506                    	L5712:
 507    2B54  08        		.byte	8
 508    2B55  5D        		.byte	93
 509    2B56  00        		.byte	0
 510                    	L5022:
 511    2B57  0A        		.byte	10
 512    2B58  20        		.byte	32
 513    2B59  20        		.byte	32
 514    2B5A  41        		.byte	65
 515    2B5B  74        		.byte	116
 516    2B5C  74        		.byte	116
 517    2B5D  72        		.byte	114
 518    2B5E  69        		.byte	105
 519    2B5F  62        		.byte	98
 520    2B60  75        		.byte	117
 521    2B61  74        		.byte	116
 522    2B62  65        		.byte	101
 523    2B63  20        		.byte	32
 524    2B64  66        		.byte	102
 525    2B65  6C        		.byte	108
 526    2B66  61        		.byte	97
 527    2B67  67        		.byte	103
 528    2B68  73        		.byte	115
 529    2B69  3A        		.byte	58
 530    2B6A  20        		.byte	32
 531    2B6B  5B        		.byte	91
 532    2B6C  00        		.byte	0
 533                    	L5122:
 534    2B6D  25        		.byte	37
 535    2B6E  30        		.byte	48
 536    2B6F  32        		.byte	50
 537    2B70  78        		.byte	120
 538    2B71  20        		.byte	32
 539    2B72  00        		.byte	0
 540                    	L5222:
 541    2B73  08        		.byte	8
 542    2B74  5D        		.byte	93
 543    2B75  0A        		.byte	10
 544    2B76  20        		.byte	32
 545    2B77  20        		.byte	32
 546    2B78  50        		.byte	80
 547    2B79  61        		.byte	97
 548    2B7A  72        		.byte	114
 549    2B7B  74        		.byte	116
 550    2B7C  69        		.byte	105
 551    2B7D  74        		.byte	116
 552    2B7E  69        		.byte	105
 553    2B7F  6F        		.byte	111
 554    2B80  6E        		.byte	110
 555    2B81  20        		.byte	32
 556    2B82  6E        		.byte	110
 557    2B83  61        		.byte	97
 558    2B84  6D        		.byte	109
 559    2B85  65        		.byte	101
 560    2B86  3A        		.byte	58
 561    2B87  20        		.byte	32
 562    2B88  20        		.byte	32
 563    2B89  00        		.byte	0
 564                    	L5322:
 565    2B8A  6E        		.byte	110
 566    2B8B  61        		.byte	97
 567    2B8C  6D        		.byte	109
 568    2B8D  65        		.byte	101
 569    2B8E  20        		.byte	32
 570    2B8F  66        		.byte	102
 571    2B90  69        		.byte	105
 572    2B91  65        		.byte	101
 573    2B92  6C        		.byte	108
 574    2B93  64        		.byte	100
 575    2B94  20        		.byte	32
 576    2B95  65        		.byte	101
 577    2B96  6D        		.byte	109
 578    2B97  70        		.byte	112
 579    2B98  74        		.byte	116
 580    2B99  79        		.byte	121
 581    2B9A  00        		.byte	0
 582                    	L5422:
 583    2B9B  0A        		.byte	10
 584    2B9C  00        		.byte	0
 585                    	L5522:
 586    2B9D  20        		.byte	32
 587    2B9E  20        		.byte	32
 588    2B9F  20        		.byte	32
 589    2BA0  5B        		.byte	91
 590    2BA1  00        		.byte	0
 591                    	L5622:
 592    2BA2  0A        		.byte	10
 593    2BA3  20        		.byte	32
 594    2BA4  20        		.byte	32
 595    2BA5  20        		.byte	32
 596    2BA6  20        		.byte	32
 597    2BA7  00        		.byte	0
 598                    	L5722:
 599    2BA8  25        		.byte	37
 600    2BA9  30        		.byte	48
 601    2BAA  32        		.byte	50
 602    2BAB  78        		.byte	120
 603    2BAC  20        		.byte	32
 604    2BAD  00        		.byte	0
 605                    	L5032:
 606    2BAE  08        		.byte	8
 607    2BAF  5D        		.byte	93
 608    2BB0  0A        		.byte	10
 609    2BB1  00        		.byte	0
 610                    	; 1093  
 611                    	; 1094  /* Analyze and print GPT entry
 612                    	; 1095   */
 613                    	; 1096  int prtgptent(unsigned int entryno)
 614                    	; 1097      {
 615                    	_prtgptent:
 616    2BB2  CD0000    		call	c.savs
 617    2BB5  21E4FF    		ld	hl,65508
 618    2BB8  39        		add	hl,sp
 619    2BB9  F9        		ld	sp,hl
 620                    	; 1098      int index;
 621                    	; 1099      int entryidx;
 622                    	; 1100      int hasname;
 623                    	; 1101      unsigned int block;
 624                    	; 1102      unsigned char *rxdata;
 625                    	; 1103      unsigned char *entryptr;
 626                    	; 1104      unsigned char tstzero = 0;
 627    2BBA  DD36ED00  		ld	(ix-19),0
 628                    	; 1105      unsigned long flba;
 629                    	; 1106      unsigned long llba;
 630                    	; 1107  
 631                    	; 1108      block = 2 + (entryno / 4);
 632    2BBE  DD6E04    		ld	l,(ix+4)
 633    2BC1  DD6605    		ld	h,(ix+5)
 634    2BC4  E5        		push	hl
 635    2BC5  210400    		ld	hl,4
 636    2BC8  E5        		push	hl
 637    2BC9  CD0000    		call	c.udiv
 638    2BCC  E1        		pop	hl
 639    2BCD  23        		inc	hl
 640    2BCE  23        		inc	hl
 641    2BCF  DD75F2    		ld	(ix-14),l
 642    2BD2  DD74F3    		ld	(ix-13),h
 643                    	; 1109      if ((curblkno != block) || !curblkok)
 644    2BD5  210200    		ld	hl,_curblkno
 645    2BD8  E5        		push	hl
 646    2BD9  DDE5      		push	ix
 647    2BDB  C1        		pop	bc
 648    2BDC  21F2FF    		ld	hl,65522
 649    2BDF  09        		add	hl,bc
 650    2BE0  4D        		ld	c,l
 651    2BE1  44        		ld	b,h
 652    2BE2  97        		sub	a
 653    2BE3  320000    		ld	(c.r0),a
 654    2BE6  320100    		ld	(c.r0+1),a
 655    2BE9  0A        		ld	a,(bc)
 656    2BEA  320200    		ld	(c.r0+2),a
 657    2BED  03        		inc	bc
 658    2BEE  0A        		ld	a,(bc)
 659    2BEF  320300    		ld	(c.r0+3),a
 660    2BF2  210000    		ld	hl,c.r0
 661    2BF5  E5        		push	hl
 662    2BF6  CD0000    		call	c.lcmp
 663    2BF9  2008      		jr	nz,L1704
 664    2BFB  2A1000    		ld	hl,(_curblkok)
 665    2BFE  7C        		ld	a,h
 666    2BFF  B5        		or	l
 667    2C00  C2602C    		jp	nz,L1604
 668                    	L1704:
 669                    	; 1110          {
 670                    	; 1111          if (!sdread(sdrdbuf, block))
 671    2C03  DDE5      		push	ix
 672    2C05  C1        		pop	bc
 673    2C06  21F2FF    		ld	hl,65522
 674    2C09  09        		add	hl,bc
 675    2C0A  4D        		ld	c,l
 676    2C0B  44        		ld	b,h
 677    2C0C  97        		sub	a
 678    2C0D  320000    		ld	(c.r0),a
 679    2C10  320100    		ld	(c.r0+1),a
 680    2C13  0A        		ld	a,(bc)
 681    2C14  320200    		ld	(c.r0+2),a
 682    2C17  03        		inc	bc
 683    2C18  0A        		ld	a,(bc)
 684    2C19  320300    		ld	(c.r0+3),a
 685    2C1C  210300    		ld	hl,c.r0+3
 686    2C1F  46        		ld	b,(hl)
 687    2C20  2B        		dec	hl
 688    2C21  4E        		ld	c,(hl)
 689    2C22  C5        		push	bc
 690    2C23  2B        		dec	hl
 691    2C24  46        		ld	b,(hl)
 692    2C25  2B        		dec	hl
 693    2C26  4E        		ld	c,(hl)
 694    2C27  C5        		push	bc
 695    2C28  214C00    		ld	hl,_sdrdbuf
 696    2C2B  CDE320    		call	_sdread
 697    2C2E  F1        		pop	af
 698    2C2F  F1        		pop	af
 699    2C30  79        		ld	a,c
 700    2C31  B0        		or	b
 701    2C32  2013      		jr	nz,L1014
 702                    	; 1112              {
 703                    	; 1113              if (sdtestflg)
 704    2C34  2A0000    		ld	hl,(_sdtestflg)
 705    2C37  7C        		ld	a,h
 706    2C38  B5        		or	l
 707    2C39  280C      		jr	z,L1014
 708                    	; 1114                  {
 709                    	; 1115                  printf("Can't read GPT entry block\n");
 710    2C3B  21752A    		ld	hl,L5371
 711    2C3E  CD0000    		call	_printf
 712                    	; 1116                  return (NO);
 713    2C41  010000    		ld	bc,0
 714    2C44  C30000    		jp	c.rets
 715                    	L1014:
 716                    	; 1117                  } /* sdtestflg */
 717                    	; 1118              }
 718                    	; 1119          curblkno = block;
 719    2C47  97        		sub	a
 720    2C48  320200    		ld	(_curblkno),a
 721    2C4B  320300    		ld	(_curblkno+1),a
 722    2C4E  DD7EF2    		ld	a,(ix-14)
 723    2C51  320400    		ld	(_curblkno+2),a
 724                    	; 1120          curblkok = YES;
 725    2C54  210100    		ld	hl,1
 726    2C57  DD7EF3    		ld	a,(ix-13)
 727    2C5A  320500    		ld	(_curblkno+3),a
 728    2C5D  221000    		ld	(_curblkok),hl
 729                    	L1604:
 730                    	; 1121          }
 731                    	; 1122      rxdata = sdrdbuf;
 732    2C60  214C00    		ld	hl,_sdrdbuf
 733    2C63  DD75F0    		ld	(ix-16),l
 734    2C66  DD74F1    		ld	(ix-15),h
 735                    	; 1123      entryptr = rxdata + (128 * (entryno % 4));
 736    2C69  DD6E04    		ld	l,(ix+4)
 737    2C6C  DD6605    		ld	h,(ix+5)
 738    2C6F  E5        		push	hl
 739    2C70  210400    		ld	hl,4
 740    2C73  E5        		push	hl
 741    2C74  CD0000    		call	c.umod
 742    2C77  218000    		ld	hl,128
 743    2C7A  E5        		push	hl
 744    2C7B  CD0000    		call	c.imul
 745    2C7E  E1        		pop	hl
 746    2C7F  DD4EF0    		ld	c,(ix-16)
 747    2C82  DD46F1    		ld	b,(ix-15)
 748    2C85  09        		add	hl,bc
 749    2C86  DD75EE    		ld	(ix-18),l
 750    2C89  DD74EF    		ld	(ix-17),h
 751                    	; 1124      for (index = 0; index < 16; index++)
 752    2C8C  DD36F800  		ld	(ix-8),0
 753    2C90  DD36F900  		ld	(ix-7),0
 754                    	L1214:
 755    2C94  DD7EF8    		ld	a,(ix-8)
 756    2C97  D610      		sub	16
 757    2C99  DD7EF9    		ld	a,(ix-7)
 758    2C9C  DE00      		sbc	a,0
 759    2C9E  F2BF2C    		jp	p,L1314
 760                    	; 1125          tstzero |= entryptr[index];
 761    2CA1  DD6EEE    		ld	l,(ix-18)
 762    2CA4  DD66EF    		ld	h,(ix-17)
 763    2CA7  DD4EF8    		ld	c,(ix-8)
 764    2CAA  DD46F9    		ld	b,(ix-7)
 765    2CAD  09        		add	hl,bc
 766    2CAE  DD7EED    		ld	a,(ix-19)
 767    2CB1  B6        		or	(hl)
 768    2CB2  DD77ED    		ld	(ix-19),a
 769    2CB5  DD34F8    		inc	(ix-8)
 770    2CB8  2003      		jr	nz,L631
 771    2CBA  DD34F9    		inc	(ix-7)
 772                    	L631:
 773    2CBD  18D5      		jr	L1214
 774                    	L1314:
 775                    	; 1126      if (sdtestflg)
 776    2CBF  2A0000    		ld	hl,(_sdtestflg)
 777    2CC2  7C        		ld	a,h
 778    2CC3  B5        		or	l
 779    2CC4  280F      		jr	z,L1614
 780                    	; 1127          {
 781                    	; 1128          printf("GPT partition entry %d:", entryno + 1);
 782    2CC6  DD6E04    		ld	l,(ix+4)
 783    2CC9  DD6605    		ld	h,(ix+5)
 784    2CCC  23        		inc	hl
 785    2CCD  E5        		push	hl
 786    2CCE  21912A    		ld	hl,L5471
 787    2CD1  CD0000    		call	_printf
 788    2CD4  F1        		pop	af
 789                    	L1614:
 790                    	; 1129          } /* sdtestflg */
 791                    	; 1130      if (!tstzero)
 792    2CD5  DD7EED    		ld	a,(ix-19)
 793    2CD8  B7        		or	a
 794    2CD9  2013      		jr	nz,L1714
 795                    	; 1131          {
 796                    	; 1132          if (sdtestflg)
 797    2CDB  2A0000    		ld	hl,(_sdtestflg)
 798    2CDE  7C        		ld	a,h
 799    2CDF  B5        		or	l
 800    2CE0  2806      		jr	z,L1024
 801                    	; 1133              {
 802                    	; 1134              printf(" Not used entry\n");
 803    2CE2  21A92A    		ld	hl,L5571
 804    2CE5  CD0000    		call	_printf
 805                    	L1024:
 806                    	; 1135              } /* sdtestflg */
 807                    	; 1136          return (NO);
 808    2CE8  010000    		ld	bc,0
 809    2CEB  C30000    		jp	c.rets
 810                    	L1714:
 811                    	; 1137          }
 812                    	; 1138      if (sdtestflg)
 813    2CEE  2A0000    		ld	hl,(_sdtestflg)
 814    2CF1  7C        		ld	a,h
 815    2CF2  B5        		or	l
 816    2CF3  CAA82D    		jp	z,L1124
 817                    	; 1139          {
 818                    	; 1140          printf("\n  Partition type GUID: ");
 819    2CF6  21BA2A    		ld	hl,L5671
 820    2CF9  CD0000    		call	_printf
 821                    	; 1141          prtguid(entryptr);
 822    2CFC  DD6EEE    		ld	l,(ix-18)
 823    2CFF  DD66EF    		ld	h,(ix-17)
 824    2D02  CD6829    		call	_prtguid
 825                    	; 1142          printf("\n  [");
 826    2D05  21D32A    		ld	hl,L5771
 827    2D08  CD0000    		call	_printf
 828                    	; 1143          for (index = 0; index < 16; index++)
 829    2D0B  DD36F800  		ld	(ix-8),0
 830    2D0F  DD36F900  		ld	(ix-7),0
 831                    	L1224:
 832    2D13  DD7EF8    		ld	a,(ix-8)
 833    2D16  D610      		sub	16
 834    2D18  DD7EF9    		ld	a,(ix-7)
 835    2D1B  DE00      		sbc	a,0
 836    2D1D  F2422D    		jp	p,L1324
 837                    	; 1144              printf("%02x ", entryptr[index]);
 838    2D20  DD6EEE    		ld	l,(ix-18)
 839    2D23  DD66EF    		ld	h,(ix-17)
 840    2D26  DD4EF8    		ld	c,(ix-8)
 841    2D29  DD46F9    		ld	b,(ix-7)
 842    2D2C  09        		add	hl,bc
 843    2D2D  4E        		ld	c,(hl)
 844    2D2E  97        		sub	a
 845    2D2F  47        		ld	b,a
 846    2D30  C5        		push	bc
 847    2D31  21D82A    		ld	hl,L5002
 848    2D34  CD0000    		call	_printf
 849    2D37  F1        		pop	af
 850    2D38  DD34F8    		inc	(ix-8)
 851    2D3B  2003      		jr	nz,L041
 852    2D3D  DD34F9    		inc	(ix-7)
 853                    	L041:
 854    2D40  18D1      		jr	L1224
 855                    	L1324:
 856                    	; 1145          printf("\b]");
 857    2D42  21DE2A    		ld	hl,L5102
 858    2D45  CD0000    		call	_printf
 859                    	; 1146          printf("\n  Unique partition GUID: ");
 860    2D48  21E12A    		ld	hl,L5202
 861    2D4B  CD0000    		call	_printf
 862                    	; 1147          prtguid(entryptr + 16);
 863    2D4E  DD6EEE    		ld	l,(ix-18)
 864    2D51  DD66EF    		ld	h,(ix-17)
 865    2D54  011000    		ld	bc,16
 866    2D57  09        		add	hl,bc
 867    2D58  CD6829    		call	_prtguid
 868                    	; 1148          printf("\n  [");
 869    2D5B  21FC2A    		ld	hl,L5302
 870    2D5E  CD0000    		call	_printf
 871                    	; 1149          for (index = 0; index < 16; index++)
 872    2D61  DD36F800  		ld	(ix-8),0
 873    2D65  DD36F900  		ld	(ix-7),0
 874                    	L1624:
 875    2D69  DD7EF8    		ld	a,(ix-8)
 876    2D6C  D610      		sub	16
 877    2D6E  DD7EF9    		ld	a,(ix-7)
 878    2D71  DE00      		sbc	a,0
 879    2D73  F29C2D    		jp	p,L1724
 880                    	; 1150              printf("%02x ", (entryptr + 16)[index]);
 881    2D76  DD6EEE    		ld	l,(ix-18)
 882    2D79  DD66EF    		ld	h,(ix-17)
 883    2D7C  011000    		ld	bc,16
 884    2D7F  09        		add	hl,bc
 885    2D80  DD4EF8    		ld	c,(ix-8)
 886    2D83  DD46F9    		ld	b,(ix-7)
 887    2D86  09        		add	hl,bc
 888    2D87  4E        		ld	c,(hl)
 889    2D88  97        		sub	a
 890    2D89  47        		ld	b,a
 891    2D8A  C5        		push	bc
 892    2D8B  21012B    		ld	hl,L5402
 893    2D8E  CD0000    		call	_printf
 894    2D91  F1        		pop	af
 895    2D92  DD34F8    		inc	(ix-8)
 896    2D95  2003      		jr	nz,L241
 897    2D97  DD34F9    		inc	(ix-7)
 898                    	L241:
 899    2D9A  18CD      		jr	L1624
 900                    	L1724:
 901                    	; 1151          printf("\b]");
 902    2D9C  21072B    		ld	hl,L5502
 903    2D9F  CD0000    		call	_printf
 904                    	; 1152          printf("\n  First LBA: ");
 905    2DA2  210A2B    		ld	hl,L5602
 906    2DA5  CD0000    		call	_printf
 907                    	L1124:
 908                    	; 1153          /* lower 32 bits of LBA should be sufficient (I hope) */
 909                    	; 1154          } /* sdtestflg */
 910                    	; 1155      flba = (unsigned long)entryptr[32] + ((unsigned long)entryptr[33] << 8) +
 911                    	; 1156             ((unsigned long)entryptr[34] << 16) + ((unsigned long)entryptr[35] << 24);
 912    2DA8  DDE5      		push	ix
 913    2DAA  C1        		pop	bc
 914    2DAB  21E8FF    		ld	hl,65512
 915    2DAE  09        		add	hl,bc
 916    2DAF  E5        		push	hl
 917    2DB0  DD6EEE    		ld	l,(ix-18)
 918    2DB3  DD66EF    		ld	h,(ix-17)
 919    2DB6  012000    		ld	bc,32
 920    2DB9  09        		add	hl,bc
 921    2DBA  4D        		ld	c,l
 922    2DBB  44        		ld	b,h
 923    2DBC  97        		sub	a
 924    2DBD  320000    		ld	(c.r0),a
 925    2DC0  320100    		ld	(c.r0+1),a
 926    2DC3  0A        		ld	a,(bc)
 927    2DC4  320200    		ld	(c.r0+2),a
 928    2DC7  97        		sub	a
 929    2DC8  320300    		ld	(c.r0+3),a
 930    2DCB  210000    		ld	hl,c.r0
 931    2DCE  E5        		push	hl
 932    2DCF  DD6EEE    		ld	l,(ix-18)
 933    2DD2  DD66EF    		ld	h,(ix-17)
 934    2DD5  012100    		ld	bc,33
 935    2DD8  09        		add	hl,bc
 936    2DD9  4D        		ld	c,l
 937    2DDA  44        		ld	b,h
 938    2DDB  97        		sub	a
 939    2DDC  320000    		ld	(c.r1),a
 940    2DDF  320100    		ld	(c.r1+1),a
 941    2DE2  0A        		ld	a,(bc)
 942    2DE3  320200    		ld	(c.r1+2),a
 943    2DE6  97        		sub	a
 944    2DE7  320300    		ld	(c.r1+3),a
 945    2DEA  210000    		ld	hl,c.r1
 946    2DED  E5        		push	hl
 947    2DEE  210800    		ld	hl,8
 948    2DF1  E5        		push	hl
 949    2DF2  CD0000    		call	c.llsh
 950    2DF5  CD0000    		call	c.ladd
 951    2DF8  DD6EEE    		ld	l,(ix-18)
 952    2DFB  DD66EF    		ld	h,(ix-17)
 953    2DFE  012200    		ld	bc,34
 954    2E01  09        		add	hl,bc
 955    2E02  4D        		ld	c,l
 956    2E03  44        		ld	b,h
 957    2E04  97        		sub	a
 958    2E05  320000    		ld	(c.r1),a
 959    2E08  320100    		ld	(c.r1+1),a
 960    2E0B  0A        		ld	a,(bc)
 961    2E0C  320200    		ld	(c.r1+2),a
 962    2E0F  97        		sub	a
 963    2E10  320300    		ld	(c.r1+3),a
 964    2E13  210000    		ld	hl,c.r1
 965    2E16  E5        		push	hl
 966    2E17  211000    		ld	hl,16
 967    2E1A  E5        		push	hl
 968    2E1B  CD0000    		call	c.llsh
 969    2E1E  CD0000    		call	c.ladd
 970    2E21  DD6EEE    		ld	l,(ix-18)
 971    2E24  DD66EF    		ld	h,(ix-17)
 972    2E27  012300    		ld	bc,35
 973    2E2A  09        		add	hl,bc
 974    2E2B  4D        		ld	c,l
 975    2E2C  44        		ld	b,h
 976    2E2D  97        		sub	a
 977    2E2E  320000    		ld	(c.r1),a
 978    2E31  320100    		ld	(c.r1+1),a
 979    2E34  0A        		ld	a,(bc)
 980    2E35  320200    		ld	(c.r1+2),a
 981    2E38  97        		sub	a
 982    2E39  320300    		ld	(c.r1+3),a
 983    2E3C  210000    		ld	hl,c.r1
 984    2E3F  E5        		push	hl
 985    2E40  211800    		ld	hl,24
 986    2E43  E5        		push	hl
 987    2E44  CD0000    		call	c.llsh
 988    2E47  CD0000    		call	c.ladd
 989    2E4A  CD0000    		call	c.mvl
 990    2E4D  F1        		pop	af
 991                    	; 1157      if (sdtestflg)
 992    2E4E  2A0000    		ld	hl,(_sdtestflg)
 993    2E51  7C        		ld	a,h
 994    2E52  B5        		or	l
 995    2E53  CAB52E    		jp	z,L1234
 996                    	; 1158          {
 997                    	; 1159          printf("%lu", flba);
 998    2E56  DD66EB    		ld	h,(ix-21)
 999    2E59  DD6EEA    		ld	l,(ix-22)
1000    2E5C  E5        		push	hl
1001    2E5D  DD66E9    		ld	h,(ix-23)
1002    2E60  DD6EE8    		ld	l,(ix-24)
1003    2E63  E5        		push	hl
1004    2E64  21192B    		ld	hl,L5702
1005    2E67  CD0000    		call	_printf
1006    2E6A  F1        		pop	af
1007    2E6B  F1        		pop	af
1008                    	; 1160          printf(" [");
1009    2E6C  211D2B    		ld	hl,L5012
1010    2E6F  CD0000    		call	_printf
1011                    	; 1161          for (index = 32; index < (32 + 8); index++)
1012    2E72  DD36F820  		ld	(ix-8),32
1013    2E76  DD36F900  		ld	(ix-7),0
1014                    	L1334:
1015    2E7A  DD7EF8    		ld	a,(ix-8)
1016    2E7D  D628      		sub	40
1017    2E7F  DD7EF9    		ld	a,(ix-7)
1018    2E82  DE00      		sbc	a,0
1019    2E84  F2A92E    		jp	p,L1434
1020                    	; 1162              printf("%02x ", entryptr[index]);
1021    2E87  DD6EEE    		ld	l,(ix-18)
1022    2E8A  DD66EF    		ld	h,(ix-17)
1023    2E8D  DD4EF8    		ld	c,(ix-8)
1024    2E90  DD46F9    		ld	b,(ix-7)
1025    2E93  09        		add	hl,bc
1026    2E94  4E        		ld	c,(hl)
1027    2E95  97        		sub	a
1028    2E96  47        		ld	b,a
1029    2E97  C5        		push	bc
1030    2E98  21202B    		ld	hl,L5112
1031    2E9B  CD0000    		call	_printf
1032    2E9E  F1        		pop	af
1033    2E9F  DD34F8    		inc	(ix-8)
1034    2EA2  2003      		jr	nz,L441
1035    2EA4  DD34F9    		inc	(ix-7)
1036                    	L441:
1037    2EA7  18D1      		jr	L1334
1038                    	L1434:
1039                    	; 1163          printf("\b]");
1040    2EA9  21262B    		ld	hl,L5212
1041    2EAC  CD0000    		call	_printf
1042                    	; 1164          printf("\n  Last LBA: ");
1043    2EAF  21292B    		ld	hl,L5312
1044    2EB2  CD0000    		call	_printf
1045                    	L1234:
1046                    	; 1165          } /* sdtestflg */
1047                    	; 1166      /* lower 32 bits of LBA should be sufficient (I hope) */
1048                    	; 1167      llba = (unsigned long)entryptr[40] + ((unsigned long)entryptr[41] << 8) +
1049                    	; 1168             ((unsigned long)entryptr[42] << 16) + ((unsigned long)entryptr[43] << 24);
1050    2EB5  DDE5      		push	ix
1051    2EB7  C1        		pop	bc
1052    2EB8  21E4FF    		ld	hl,65508
1053    2EBB  09        		add	hl,bc
1054    2EBC  E5        		push	hl
1055    2EBD  DD6EEE    		ld	l,(ix-18)
1056    2EC0  DD66EF    		ld	h,(ix-17)
1057    2EC3  012800    		ld	bc,40
1058    2EC6  09        		add	hl,bc
1059    2EC7  4D        		ld	c,l
1060    2EC8  44        		ld	b,h
1061    2EC9  97        		sub	a
1062    2ECA  320000    		ld	(c.r0),a
1063    2ECD  320100    		ld	(c.r0+1),a
1064    2ED0  0A        		ld	a,(bc)
1065    2ED1  320200    		ld	(c.r0+2),a
1066    2ED4  97        		sub	a
1067    2ED5  320300    		ld	(c.r0+3),a
1068    2ED8  210000    		ld	hl,c.r0
1069    2EDB  E5        		push	hl
1070    2EDC  DD6EEE    		ld	l,(ix-18)
1071    2EDF  DD66EF    		ld	h,(ix-17)
1072    2EE2  012900    		ld	bc,41
1073    2EE5  09        		add	hl,bc
1074    2EE6  4D        		ld	c,l
1075    2EE7  44        		ld	b,h
1076    2EE8  97        		sub	a
1077    2EE9  320000    		ld	(c.r1),a
1078    2EEC  320100    		ld	(c.r1+1),a
1079    2EEF  0A        		ld	a,(bc)
1080    2EF0  320200    		ld	(c.r1+2),a
1081    2EF3  97        		sub	a
1082    2EF4  320300    		ld	(c.r1+3),a
1083    2EF7  210000    		ld	hl,c.r1
1084    2EFA  E5        		push	hl
1085    2EFB  210800    		ld	hl,8
1086    2EFE  E5        		push	hl
1087    2EFF  CD0000    		call	c.llsh
1088    2F02  CD0000    		call	c.ladd
1089    2F05  DD6EEE    		ld	l,(ix-18)
1090    2F08  DD66EF    		ld	h,(ix-17)
1091    2F0B  012A00    		ld	bc,42
1092    2F0E  09        		add	hl,bc
1093    2F0F  4D        		ld	c,l
1094    2F10  44        		ld	b,h
1095    2F11  97        		sub	a
1096    2F12  320000    		ld	(c.r1),a
1097    2F15  320100    		ld	(c.r1+1),a
1098    2F18  0A        		ld	a,(bc)
1099    2F19  320200    		ld	(c.r1+2),a
1100    2F1C  97        		sub	a
1101    2F1D  320300    		ld	(c.r1+3),a
1102    2F20  210000    		ld	hl,c.r1
1103    2F23  E5        		push	hl
1104    2F24  211000    		ld	hl,16
1105    2F27  E5        		push	hl
1106    2F28  CD0000    		call	c.llsh
1107    2F2B  CD0000    		call	c.ladd
1108    2F2E  DD6EEE    		ld	l,(ix-18)
1109    2F31  DD66EF    		ld	h,(ix-17)
1110    2F34  012B00    		ld	bc,43
1111    2F37  09        		add	hl,bc
1112    2F38  4D        		ld	c,l
1113    2F39  44        		ld	b,h
1114    2F3A  97        		sub	a
1115    2F3B  320000    		ld	(c.r1),a
1116    2F3E  320100    		ld	(c.r1+1),a
1117    2F41  0A        		ld	a,(bc)
1118    2F42  320200    		ld	(c.r1+2),a
1119    2F45  97        		sub	a
1120    2F46  320300    		ld	(c.r1+3),a
1121    2F49  210000    		ld	hl,c.r1
1122    2F4C  E5        		push	hl
1123    2F4D  211800    		ld	hl,24
1124    2F50  E5        		push	hl
1125    2F51  CD0000    		call	c.llsh
1126    2F54  CD0000    		call	c.ladd
1127    2F57  CD0000    		call	c.mvl
1128    2F5A  F1        		pop	af
1129                    	; 1169  
1130                    	; 1170      if (entryptr[48] & 0x04)
1131    2F5B  DD6EEE    		ld	l,(ix-18)
1132    2F5E  DD66EF    		ld	h,(ix-17)
1133    2F61  013000    		ld	bc,48
1134    2F64  09        		add	hl,bc
1135    2F65  7E        		ld	a,(hl)
1136    2F66  CB57      		bit	2,a
1137    2F68  6F        		ld	l,a
1138    2F69  2815      		jr	z,L1734
1139                    	; 1171          dskmap[partdsk].bootable = YES;
1140    2F6B  2A0E00    		ld	hl,(_partdsk)
1141    2F6E  E5        		push	hl
1142    2F6F  212000    		ld	hl,32
1143    2F72  E5        		push	hl
1144    2F73  CD0000    		call	c.imul
1145    2F76  E1        		pop	hl
1146    2F77  015402    		ld	bc,_dskmap+2
1147    2F7A  09        		add	hl,bc
1148    2F7B  3601      		ld	(hl),1
1149    2F7D  23        		inc	hl
1150    2F7E  3600      		ld	(hl),0
1151                    	L1734:
1152                    	; 1172      dskmap[partdsk].partype = PARTGPT;
1153    2F80  2A0E00    		ld	hl,(_partdsk)
1154    2F83  E5        		push	hl
1155    2F84  212000    		ld	hl,32
1156    2F87  E5        		push	hl
1157    2F88  CD0000    		call	c.imul
1158    2F8B  E1        		pop	hl
1159    2F8C  015202    		ld	bc,_dskmap
1160    2F8F  09        		add	hl,bc
1161    2F90  3603      		ld	(hl),3
1162                    	; 1173      dskmap[partdsk].dskletter = 'A' + partdsk;
1163    2F92  2A0E00    		ld	hl,(_partdsk)
1164    2F95  E5        		push	hl
1165    2F96  212000    		ld	hl,32
1166    2F99  E5        		push	hl
1167    2F9A  CD0000    		call	c.imul
1168    2F9D  E1        		pop	hl
1169    2F9E  015302    		ld	bc,_dskmap+1
1170    2FA1  09        		add	hl,bc
1171    2FA2  3A0E00    		ld	a,(_partdsk)
1172    2FA5  C641      		add	a,65
1173    2FA7  4F        		ld	c,a
1174    2FA8  71        		ld	(hl),c
1175                    	; 1174      dskmap[partdsk].dskstart = flba;
1176    2FA9  2A0E00    		ld	hl,(_partdsk)
1177    2FAC  E5        		push	hl
1178    2FAD  212000    		ld	hl,32
1179    2FB0  E5        		push	hl
1180    2FB1  CD0000    		call	c.imul
1181    2FB4  E1        		pop	hl
1182    2FB5  015602    		ld	bc,_dskmap+4
1183    2FB8  09        		add	hl,bc
1184    2FB9  E5        		push	hl
1185    2FBA  DDE5      		push	ix
1186    2FBC  C1        		pop	bc
1187    2FBD  21E8FF    		ld	hl,65512
1188    2FC0  09        		add	hl,bc
1189    2FC1  E5        		push	hl
1190    2FC2  CD0000    		call	c.mvl
1191    2FC5  F1        		pop	af
1192                    	; 1175      dskmap[partdsk].dskend = llba;
1193    2FC6  2A0E00    		ld	hl,(_partdsk)
1194    2FC9  E5        		push	hl
1195    2FCA  212000    		ld	hl,32
1196    2FCD  E5        		push	hl
1197    2FCE  CD0000    		call	c.imul
1198    2FD1  E1        		pop	hl
1199    2FD2  015A02    		ld	bc,_dskmap+8
1200    2FD5  09        		add	hl,bc
1201    2FD6  E5        		push	hl
1202    2FD7  DDE5      		push	ix
1203    2FD9  C1        		pop	bc
1204    2FDA  21E4FF    		ld	hl,65508
1205    2FDD  09        		add	hl,bc
1206    2FDE  E5        		push	hl
1207    2FDF  CD0000    		call	c.mvl
1208    2FE2  F1        		pop	af
1209                    	; 1176      dskmap[partdsk].dsksize = llba - flba + 1;
1210    2FE3  2A0E00    		ld	hl,(_partdsk)
1211    2FE6  E5        		push	hl
1212    2FE7  212000    		ld	hl,32
1213    2FEA  E5        		push	hl
1214    2FEB  CD0000    		call	c.imul
1215    2FEE  E1        		pop	hl
1216    2FEF  015E02    		ld	bc,_dskmap+12
1217    2FF2  09        		add	hl,bc
1218    2FF3  E5        		push	hl
1219    2FF4  DDE5      		push	ix
1220    2FF6  C1        		pop	bc
1221    2FF7  21E4FF    		ld	hl,65508
1222    2FFA  09        		add	hl,bc
1223    2FFB  CD0000    		call	c.0mvf
1224    2FFE  210000    		ld	hl,c.r0
1225    3001  E5        		push	hl
1226    3002  DDE5      		push	ix
1227    3004  C1        		pop	bc
1228    3005  21E8FF    		ld	hl,65512
1229    3008  09        		add	hl,bc
1230    3009  E5        		push	hl
1231    300A  CD0000    		call	c.lsub
1232    300D  3E01      		ld	a,1
1233    300F  320200    		ld	(c.r1+2),a
1234    3012  87        		add	a,a
1235    3013  9F        		sbc	a,a
1236    3014  320300    		ld	(c.r1+3),a
1237    3017  320100    		ld	(c.r1+1),a
1238    301A  320000    		ld	(c.r1),a
1239    301D  210000    		ld	hl,c.r1
1240    3020  E5        		push	hl
1241    3021  CD0000    		call	c.ladd
1242    3024  CD0000    		call	c.mvl
1243    3027  F1        		pop	af
1244                    	; 1177      memcpy(dskmap[partdsk].dsktype, entryptr, 16);
1245    3028  211000    		ld	hl,16
1246    302B  E5        		push	hl
1247    302C  DD6EEE    		ld	l,(ix-18)
1248    302F  DD66EF    		ld	h,(ix-17)
1249    3032  E5        		push	hl
1250    3033  2A0E00    		ld	hl,(_partdsk)
1251    3036  E5        		push	hl
1252    3037  212000    		ld	hl,32
1253    303A  E5        		push	hl
1254    303B  CD0000    		call	c.imul
1255    303E  E1        		pop	hl
1256    303F  016202    		ld	bc,_dskmap+16
1257    3042  09        		add	hl,bc
1258    3043  CD0000    		call	_memcpy
1259    3046  F1        		pop	af
1260    3047  F1        		pop	af
1261                    	; 1178      partdsk++;
1262    3048  2A0E00    		ld	hl,(_partdsk)
1263    304B  23        		inc	hl
1264    304C  220E00    		ld	(_partdsk),hl
1265                    	; 1179  
1266                    	; 1180      if (sdtestflg)
1267    304F  2A0000    		ld	hl,(_sdtestflg)
1268    3052  7C        		ld	a,h
1269    3053  B5        		or	l
1270    3054  CA3331    		jp	z,L1044
1271                    	; 1181          {
1272                    	; 1182          printf("%lu, size %lu MByte", llba, (llba - flba) >> 11);
1273    3057  DDE5      		push	ix
1274    3059  C1        		pop	bc
1275    305A  21E4FF    		ld	hl,65508
1276    305D  09        		add	hl,bc
1277    305E  CD0000    		call	c.0mvf
1278    3061  210000    		ld	hl,c.r0
1279    3064  E5        		push	hl
1280    3065  DDE5      		push	ix
1281    3067  C1        		pop	bc
1282    3068  21E8FF    		ld	hl,65512
1283    306B  09        		add	hl,bc
1284    306C  E5        		push	hl
1285    306D  CD0000    		call	c.lsub
1286    3070  210B00    		ld	hl,11
1287    3073  E5        		push	hl
1288    3074  CD0000    		call	c.ulrsh
1289    3077  E1        		pop	hl
1290    3078  23        		inc	hl
1291    3079  23        		inc	hl
1292    307A  4E        		ld	c,(hl)
1293    307B  23        		inc	hl
1294    307C  46        		ld	b,(hl)
1295    307D  C5        		push	bc
1296    307E  2B        		dec	hl
1297    307F  2B        		dec	hl
1298    3080  2B        		dec	hl
1299    3081  4E        		ld	c,(hl)
1300    3082  23        		inc	hl
1301    3083  46        		ld	b,(hl)
1302    3084  C5        		push	bc
1303    3085  DD66E7    		ld	h,(ix-25)
1304    3088  DD6EE6    		ld	l,(ix-26)
1305    308B  E5        		push	hl
1306    308C  DD66E5    		ld	h,(ix-27)
1307    308F  DD6EE4    		ld	l,(ix-28)
1308    3092  E5        		push	hl
1309    3093  21372B    		ld	hl,L5412
1310    3096  CD0000    		call	_printf
1311    3099  F1        		pop	af
1312    309A  F1        		pop	af
1313    309B  F1        		pop	af
1314    309C  F1        		pop	af
1315                    	; 1183          printf(" [");
1316    309D  214B2B    		ld	hl,L5512
1317    30A0  CD0000    		call	_printf
1318                    	; 1184          for (index = 40; index < (40 + 8); index++)
1319    30A3  DD36F828  		ld	(ix-8),40
1320    30A7  DD36F900  		ld	(ix-7),0
1321                    	L1144:
1322    30AB  DD7EF8    		ld	a,(ix-8)
1323    30AE  D630      		sub	48
1324    30B0  DD7EF9    		ld	a,(ix-7)
1325    30B3  DE00      		sbc	a,0
1326    30B5  F2DA30    		jp	p,L1244
1327                    	; 1185              printf("%02x ", entryptr[index]);
1328    30B8  DD6EEE    		ld	l,(ix-18)
1329    30BB  DD66EF    		ld	h,(ix-17)
1330    30BE  DD4EF8    		ld	c,(ix-8)
1331    30C1  DD46F9    		ld	b,(ix-7)
1332    30C4  09        		add	hl,bc
1333    30C5  4E        		ld	c,(hl)
1334    30C6  97        		sub	a
1335    30C7  47        		ld	b,a
1336    30C8  C5        		push	bc
1337    30C9  214E2B    		ld	hl,L5612
1338    30CC  CD0000    		call	_printf
1339    30CF  F1        		pop	af
1340    30D0  DD34F8    		inc	(ix-8)
1341    30D3  2003      		jr	nz,L641
1342    30D5  DD34F9    		inc	(ix-7)
1343                    	L641:
1344    30D8  18D1      		jr	L1144
1345                    	L1244:
1346                    	; 1186          printf("\b]");
1347    30DA  21542B    		ld	hl,L5712
1348    30DD  CD0000    		call	_printf
1349                    	; 1187          printf("\n  Attribute flags: [");
1350    30E0  21572B    		ld	hl,L5022
1351    30E3  CD0000    		call	_printf
1352                    	; 1188          /* bits 0 - 2 and 60 - 63 should be decoded */
1353                    	; 1189          for (index = 0; index < 8; index++)
1354    30E6  DD36F800  		ld	(ix-8),0
1355    30EA  DD36F900  		ld	(ix-7),0
1356                    	L1544:
1357    30EE  DD7EF8    		ld	a,(ix-8)
1358    30F1  D608      		sub	8
1359    30F3  DD7EF9    		ld	a,(ix-7)
1360    30F6  DE00      		sbc	a,0
1361    30F8  F22D31    		jp	p,L1644
1362                    	; 1190              {
1363                    	; 1191              entryidx = index + 48;
1364    30FB  DD6EF8    		ld	l,(ix-8)
1365    30FE  DD66F9    		ld	h,(ix-7)
1366    3101  013000    		ld	bc,48
1367    3104  09        		add	hl,bc
1368    3105  DD75F6    		ld	(ix-10),l
1369    3108  DD74F7    		ld	(ix-9),h
1370                    	; 1192              printf("%02x ", entryptr[entryidx]);
1371    310B  DD6EEE    		ld	l,(ix-18)
1372    310E  DD66EF    		ld	h,(ix-17)
1373    3111  DD4EF6    		ld	c,(ix-10)
1374    3114  DD46F7    		ld	b,(ix-9)
1375    3117  09        		add	hl,bc
1376    3118  4E        		ld	c,(hl)
1377    3119  97        		sub	a
1378    311A  47        		ld	b,a
1379    311B  C5        		push	bc
1380    311C  216D2B    		ld	hl,L5122
1381    311F  CD0000    		call	_printf
1382    3122  F1        		pop	af
1383                    	; 1193              }
1384    3123  DD34F8    		inc	(ix-8)
1385    3126  2003      		jr	nz,L051
1386    3128  DD34F9    		inc	(ix-7)
1387                    	L051:
1388    312B  18C1      		jr	L1544
1389                    	L1644:
1390                    	; 1194          printf("\b]\n  Partition name:  ");
1391    312D  21732B    		ld	hl,L5222
1392    3130  CD0000    		call	_printf
1393                    	L1044:
1394                    	; 1195          } /* sdtestflg */
1395                    	; 1196      /* partition name is in UTF-16LE code units */
1396                    	; 1197      hasname = NO;
1397    3133  DD36F400  		ld	(ix-12),0
1398    3137  DD36F500  		ld	(ix-11),0
1399                    	; 1198      for (index = 0; index < 72; index += 2)
1400    313B  DD36F800  		ld	(ix-8),0
1401    313F  DD36F900  		ld	(ix-7),0
1402                    	L1154:
1403    3143  DD7EF8    		ld	a,(ix-8)
1404    3146  D648      		sub	72
1405    3148  DD7EF9    		ld	a,(ix-7)
1406    314B  DE00      		sbc	a,0
1407    314D  F2E331    		jp	p,L1254
1408                    	; 1199          {
1409                    	; 1200          entryidx = index + 56;
1410    3150  DD6EF8    		ld	l,(ix-8)
1411    3153  DD66F9    		ld	h,(ix-7)
1412    3156  013800    		ld	bc,56
1413    3159  09        		add	hl,bc
1414    315A  DD75F6    		ld	(ix-10),l
1415    315D  DD74F7    		ld	(ix-9),h
1416                    	; 1201          if ((entryptr[entryidx] | entryptr[entryidx + 1]) == 0)
1417    3160  DD6EEE    		ld	l,(ix-18)
1418    3163  DD66EF    		ld	h,(ix-17)
1419    3166  DD4EF6    		ld	c,(ix-10)
1420    3169  DD46F7    		ld	b,(ix-9)
1421    316C  09        		add	hl,bc
1422    316D  6E        		ld	l,(hl)
1423    316E  E5        		push	hl
1424    316F  DD6EF6    		ld	l,(ix-10)
1425    3172  DD66F7    		ld	h,(ix-9)
1426    3175  23        		inc	hl
1427    3176  DD4EEE    		ld	c,(ix-18)
1428    3179  DD46EF    		ld	b,(ix-17)
1429    317C  09        		add	hl,bc
1430    317D  C1        		pop	bc
1431    317E  79        		ld	a,c
1432    317F  B6        		or	(hl)
1433    3180  4F        		ld	c,a
1434    3181  CAE331    		jp	z,L1254
1435                    	; 1202              break;
1436                    	; 1203          if (sdtestflg)
1437    3184  2A0000    		ld	hl,(_sdtestflg)
1438    3187  7C        		ld	a,h
1439    3188  B5        		or	l
1440    3189  283F      		jr	z,L1654
1441                    	; 1204              {
1442                    	; 1205              if ((' ' <= entryptr[entryidx]) && (entryptr[entryidx] < 127))
1443    318B  DD6EEE    		ld	l,(ix-18)
1444    318E  DD66EF    		ld	h,(ix-17)
1445    3191  DD4EF6    		ld	c,(ix-10)
1446    3194  DD46F7    		ld	b,(ix-9)
1447    3197  09        		add	hl,bc
1448    3198  7E        		ld	a,(hl)
1449    3199  FE20      		cp	32
1450    319B  3827      		jr	c,L1754
1451    319D  DD6EEE    		ld	l,(ix-18)
1452    31A0  DD66EF    		ld	h,(ix-17)
1453    31A3  DD4EF6    		ld	c,(ix-10)
1454    31A6  DD46F7    		ld	b,(ix-9)
1455    31A9  09        		add	hl,bc
1456    31AA  7E        		ld	a,(hl)
1457    31AB  FE7F      		cp	127
1458    31AD  3015      		jr	nc,L1754
1459                    	; 1206                  putchar(entryptr[entryidx]);
1460    31AF  DD6EEE    		ld	l,(ix-18)
1461    31B2  DD66EF    		ld	h,(ix-17)
1462    31B5  DD4EF6    		ld	c,(ix-10)
1463    31B8  DD46F7    		ld	b,(ix-9)
1464    31BB  09        		add	hl,bc
1465    31BC  6E        		ld	l,(hl)
1466    31BD  97        		sub	a
1467    31BE  67        		ld	h,a
1468    31BF  CD0000    		call	_putchar
1469                    	; 1207              else
1470    31C2  1806      		jr	L1654
1471                    	L1754:
1472                    	; 1208                  putchar('.');
1473    31C4  212E00    		ld	hl,46
1474    31C7  CD0000    		call	_putchar
1475                    	L1654:
1476                    	; 1209              } /* sdtestflg */
1477                    	; 1210          hasname = YES;
1478    31CA  DD36F401  		ld	(ix-12),1
1479    31CE  DD36F500  		ld	(ix-11),0
1480                    	; 1211          }
1481    31D2  DD6EF8    		ld	l,(ix-8)
1482    31D5  DD66F9    		ld	h,(ix-7)
1483    31D8  23        		inc	hl
1484    31D9  23        		inc	hl
1485    31DA  DD75F8    		ld	(ix-8),l
1486    31DD  DD74F9    		ld	(ix-7),h
1487    31E0  C34331    		jp	L1154
1488                    	L1254:
1489                    	; 1212      if (sdtestflg)
1490    31E3  2A0000    		ld	hl,(_sdtestflg)
1491    31E6  7C        		ld	a,h
1492    31E7  B5        		or	l
1493    31E8  CA6C32    		jp	z,L1164
1494                    	; 1213          {
1495                    	; 1214          if (!hasname)
1496    31EB  DD7EF4    		ld	a,(ix-12)
1497    31EE  DDB6F5    		or	(ix-11)
1498    31F1  2006      		jr	nz,L1264
1499                    	; 1215              printf("name field empty");
1500    31F3  218A2B    		ld	hl,L5322
1501    31F6  CD0000    		call	_printf
1502                    	L1264:
1503                    	; 1216          printf("\n");
1504    31F9  219B2B    		ld	hl,L5422
1505    31FC  CD0000    		call	_printf
1506                    	; 1217          printf("   [");
1507    31FF  219D2B    		ld	hl,L5522
1508    3202  CD0000    		call	_printf
1509                    	; 1218          for (index = 0; index < 72; index++)
1510    3205  DD36F800  		ld	(ix-8),0
1511    3209  DD36F900  		ld	(ix-7),0
1512                    	L1364:
1513    320D  DD7EF8    		ld	a,(ix-8)
1514    3210  D648      		sub	72
1515    3212  DD7EF9    		ld	a,(ix-7)
1516    3215  DE00      		sbc	a,0
1517    3217  F26632    		jp	p,L1464
1518                    	; 1219              {
1519                    	; 1220              if (((index & 0xf) == 0) && (index != 0))
1520    321A  DD6EF8    		ld	l,(ix-8)
1521    321D  DD66F9    		ld	h,(ix-7)
1522    3220  7D        		ld	a,l
1523    3221  E60F      		and	15
1524    3223  200E      		jr	nz,L1764
1525    3225  DD7EF8    		ld	a,(ix-8)
1526    3228  DDB6F9    		or	(ix-7)
1527    322B  2806      		jr	z,L1764
1528                    	; 1221                  printf("\n    ");
1529    322D  21A22B    		ld	hl,L5622
1530    3230  CD0000    		call	_printf
1531                    	L1764:
1532                    	; 1222              entryidx = index + 56;
1533    3233  DD6EF8    		ld	l,(ix-8)
1534    3236  DD66F9    		ld	h,(ix-7)
1535    3239  013800    		ld	bc,56
1536    323C  09        		add	hl,bc
1537    323D  DD75F6    		ld	(ix-10),l
1538    3240  DD74F7    		ld	(ix-9),h
1539                    	; 1223              printf("%02x ", entryptr[entryidx]);
1540    3243  DD6EEE    		ld	l,(ix-18)
1541    3246  DD66EF    		ld	h,(ix-17)
1542    3249  DD4EF6    		ld	c,(ix-10)
1543    324C  DD46F7    		ld	b,(ix-9)
1544    324F  09        		add	hl,bc
1545    3250  4E        		ld	c,(hl)
1546    3251  97        		sub	a
1547    3252  47        		ld	b,a
1548    3253  C5        		push	bc
1549    3254  21A82B    		ld	hl,L5722
1550    3257  CD0000    		call	_printf
1551    325A  F1        		pop	af
1552                    	; 1224              }
1553    325B  DD34F8    		inc	(ix-8)
1554    325E  2003      		jr	nz,L251
1555    3260  DD34F9    		inc	(ix-7)
1556                    	L251:
1557    3263  C30D32    		jp	L1364
1558                    	L1464:
1559                    	; 1225          printf("\b]\n");
1560    3266  21AE2B    		ld	hl,L5032
1561    3269  CD0000    		call	_printf
1562                    	L1164:
1563                    	; 1226          } /* sdtestflg */
1564                    	; 1227      return (YES);
1565    326C  010100    		ld	bc,1
1566    326F  C30000    		jp	c.rets
1567                    	L5132:
1568    3272  47        		.byte	71
1569    3273  50        		.byte	80
1570    3274  54        		.byte	84
1571    3275  20        		.byte	32
1572    3276  68        		.byte	104
1573    3277  65        		.byte	101
1574    3278  61        		.byte	97
1575    3279  64        		.byte	100
1576    327A  65        		.byte	101
1577    327B  72        		.byte	114
1578    327C  0A        		.byte	10
1579    327D  00        		.byte	0
1580                    	L5232:
1581    327E  43        		.byte	67
1582    327F  61        		.byte	97
1583    3280  6E        		.byte	110
1584    3281  27        		.byte	39
1585    3282  74        		.byte	116
1586    3283  20        		.byte	32
1587    3284  72        		.byte	114
1588    3285  65        		.byte	101
1589    3286  61        		.byte	97
1590    3287  64        		.byte	100
1591    3288  20        		.byte	32
1592    3289  47        		.byte	71
1593    328A  50        		.byte	80
1594    328B  54        		.byte	84
1595    328C  20        		.byte	32
1596    328D  70        		.byte	112
1597    328E  61        		.byte	97
1598    328F  72        		.byte	114
1599    3290  74        		.byte	116
1600    3291  69        		.byte	105
1601    3292  74        		.byte	116
1602    3293  69        		.byte	105
1603    3294  6F        		.byte	111
1604    3295  6E        		.byte	110
1605    3296  20        		.byte	32
1606    3297  74        		.byte	116
1607    3298  61        		.byte	97
1608    3299  62        		.byte	98
1609    329A  6C        		.byte	108
1610    329B  65        		.byte	101
1611    329C  20        		.byte	32
1612    329D  68        		.byte	104
1613    329E  65        		.byte	101
1614    329F  61        		.byte	97
1615    32A0  64        		.byte	100
1616    32A1  65        		.byte	101
1617    32A2  72        		.byte	114
1618    32A3  0A        		.byte	10
1619    32A4  00        		.byte	0
1620                    	L5332:
1621    32A5  20        		.byte	32
1622    32A6  20        		.byte	32
1623    32A7  53        		.byte	83
1624    32A8  69        		.byte	105
1625    32A9  67        		.byte	103
1626    32AA  6E        		.byte	110
1627    32AB  61        		.byte	97
1628    32AC  74        		.byte	116
1629    32AD  75        		.byte	117
1630    32AE  72        		.byte	114
1631    32AF  65        		.byte	101
1632    32B0  3A        		.byte	58
1633    32B1  20        		.byte	32
1634    32B2  25        		.byte	37
1635    32B3  2E        		.byte	46
1636    32B4  38        		.byte	56
1637    32B5  73        		.byte	115
1638    32B6  0A        		.byte	10
1639    32B7  00        		.byte	0
1640                    	L5432:
1641    32B8  20        		.byte	32
1642    32B9  20        		.byte	32
1643    32BA  52        		.byte	82
1644    32BB  65        		.byte	101
1645    32BC  76        		.byte	118
1646    32BD  69        		.byte	105
1647    32BE  73        		.byte	115
1648    32BF  69        		.byte	105
1649    32C0  6F        		.byte	111
1650    32C1  6E        		.byte	110
1651    32C2  3A        		.byte	58
1652    32C3  20        		.byte	32
1653    32C4  25        		.byte	37
1654    32C5  64        		.byte	100
1655    32C6  2E        		.byte	46
1656    32C7  25        		.byte	37
1657    32C8  64        		.byte	100
1658    32C9  20        		.byte	32
1659    32CA  5B        		.byte	91
1660    32CB  25        		.byte	37
1661    32CC  30        		.byte	48
1662    32CD  32        		.byte	50
1663    32CE  78        		.byte	120
1664    32CF  20        		.byte	32
1665    32D0  25        		.byte	37
1666    32D1  30        		.byte	48
1667    32D2  32        		.byte	50
1668    32D3  78        		.byte	120
1669    32D4  20        		.byte	32
1670    32D5  25        		.byte	37
1671    32D6  30        		.byte	48
1672    32D7  32        		.byte	50
1673    32D8  78        		.byte	120
1674    32D9  20        		.byte	32
1675    32DA  25        		.byte	37
1676    32DB  30        		.byte	48
1677    32DC  32        		.byte	50
1678    32DD  78        		.byte	120
1679    32DE  5D        		.byte	93
1680    32DF  0A        		.byte	10
1681    32E0  00        		.byte	0
1682                    	L5532:
1683    32E1  20        		.byte	32
1684    32E2  20        		.byte	32
1685    32E3  4E        		.byte	78
1686    32E4  75        		.byte	117
1687    32E5  6D        		.byte	109
1688    32E6  62        		.byte	98
1689    32E7  65        		.byte	101
1690    32E8  72        		.byte	114
1691    32E9  20        		.byte	32
1692    32EA  6F        		.byte	111
1693    32EB  66        		.byte	102
1694    32EC  20        		.byte	32
1695    32ED  70        		.byte	112
1696    32EE  61        		.byte	97
1697    32EF  72        		.byte	114
1698    32F0  74        		.byte	116
1699    32F1  69        		.byte	105
1700    32F2  74        		.byte	116
1701    32F3  69        		.byte	105
1702    32F4  6F        		.byte	111
1703    32F5  6E        		.byte	110
1704    32F6  20        		.byte	32
1705    32F7  65        		.byte	101
1706    32F8  6E        		.byte	110
1707    32F9  74        		.byte	116
1708    32FA  72        		.byte	114
1709    32FB  69        		.byte	105
1710    32FC  65        		.byte	101
1711    32FD  73        		.byte	115
1712    32FE  3A        		.byte	58
1713    32FF  20        		.byte	32
1714    3300  25        		.byte	37
1715    3301  6C        		.byte	108
1716    3302  75        		.byte	117
1717    3303  20        		.byte	32
1718    3304  28        		.byte	40
1719    3305  6D        		.byte	109
1720    3306  61        		.byte	97
1721    3307  79        		.byte	121
1722    3308  20        		.byte	32
1723    3309  62        		.byte	98
1724    330A  65        		.byte	101
1725    330B  20        		.byte	32
1726    330C  61        		.byte	97
1727    330D  63        		.byte	99
1728    330E  74        		.byte	116
1729    330F  75        		.byte	117
1730    3310  61        		.byte	97
1731    3311  6C        		.byte	108
1732    3312  20        		.byte	32
1733    3313  6F        		.byte	111
1734    3314  72        		.byte	114
1735    3315  20        		.byte	32
1736    3316  6D        		.byte	109
1737    3317  61        		.byte	97
1738    3318  78        		.byte	120
1739    3319  69        		.byte	105
1740    331A  6D        		.byte	109
1741    331B  75        		.byte	117
1742    331C  6D        		.byte	109
1743    331D  29        		.byte	41
1744    331E  0A        		.byte	10
1745    331F  00        		.byte	0
1746                    	L5632:
1747    3320  46        		.byte	70
1748    3321  69        		.byte	105
1749    3322  72        		.byte	114
1750    3323  73        		.byte	115
1751    3324  74        		.byte	116
1752    3325  20        		.byte	32
1753    3326  31        		.byte	49
1754    3327  36        		.byte	54
1755    3328  20        		.byte	32
1756    3329  47        		.byte	71
1757    332A  50        		.byte	80
1758    332B  54        		.byte	84
1759    332C  20        		.byte	32
1760    332D  65        		.byte	101
1761    332E  6E        		.byte	110
1762    332F  74        		.byte	116
1763    3330  72        		.byte	114
1764    3331  69        		.byte	105
1765    3332  65        		.byte	101
1766    3333  73        		.byte	115
1767    3334  20        		.byte	32
1768    3335  73        		.byte	115
1769    3336  63        		.byte	99
1770    3337  61        		.byte	97
1771    3338  6E        		.byte	110
1772    3339  6E        		.byte	110
1773    333A  65        		.byte	101
1774    333B  64        		.byte	100
1775    333C  0A        		.byte	10
1776    333D  00        		.byte	0
1777                    	; 1228      }
1778                    	; 1229  
1779                    	; 1230  /* Analyze and print GPT header
1780                    	; 1231   */
1781                    	; 1232  void sdgpthdr(unsigned long block)
1782                    	; 1233      {
1783                    	_sdgpthdr:
1784    333E  CD0000    		call	c.savs
1785    3341  21F0FF    		ld	hl,65520
1786    3344  39        		add	hl,sp
1787    3345  F9        		ld	sp,hl
1788                    	; 1234      int index;
1789                    	; 1235      unsigned int partno;
1790                    	; 1236      unsigned char *rxdata;
1791                    	; 1237      unsigned long entries;
1792                    	; 1238  
1793                    	; 1239      if (sdtestflg)
1794    3346  2A0000    		ld	hl,(_sdtestflg)
1795    3349  7C        		ld	a,h
1796    334A  B5        		or	l
1797    334B  2806      		jr	z,L1074
1798                    	; 1240          {
1799                    	; 1241          printf("GPT header\n");
1800    334D  217232    		ld	hl,L5132
1801    3350  CD0000    		call	_printf
1802                    	L1074:
1803                    	; 1242          } /* sdtestflg */
1804                    	; 1243      if (!sdread(sdrdbuf, block))
1805    3353  DD6607    		ld	h,(ix+7)
1806    3356  DD6E06    		ld	l,(ix+6)
1807    3359  E5        		push	hl
1808    335A  DD6605    		ld	h,(ix+5)
1809    335D  DD6E04    		ld	l,(ix+4)
1810    3360  E5        		push	hl
1811    3361  214C00    		ld	hl,_sdrdbuf
1812    3364  CDE320    		call	_sdread
1813    3367  F1        		pop	af
1814    3368  F1        		pop	af
1815    3369  79        		ld	a,c
1816    336A  B0        		or	b
1817    336B  2010      		jr	nz,L1174
1818                    	; 1244          {
1819                    	; 1245          if (sdtestflg)
1820    336D  2A0000    		ld	hl,(_sdtestflg)
1821    3370  7C        		ld	a,h
1822    3371  B5        		or	l
1823    3372  2806      		jr	z,L1274
1824                    	; 1246              {
1825                    	; 1247              printf("Can't read GPT partition table header\n");
1826    3374  217E32    		ld	hl,L5232
1827    3377  CD0000    		call	_printf
1828                    	L1274:
1829                    	; 1248              } /* sdtestflg */
1830                    	; 1249          return;
1831    337A  C30000    		jp	c.rets
1832                    	L1174:
1833                    	; 1250          }
1834                    	; 1251      curblkno = block;
1835    337D  210200    		ld	hl,_curblkno
1836    3380  E5        		push	hl
1837    3381  DDE5      		push	ix
1838    3383  C1        		pop	bc
1839    3384  210400    		ld	hl,4
1840    3387  09        		add	hl,bc
1841    3388  E5        		push	hl
1842    3389  CD0000    		call	c.mvl
1843    338C  F1        		pop	af
1844                    	; 1252      curblkok = YES;
1845    338D  210100    		ld	hl,1
1846    3390  221000    		ld	(_curblkok),hl
1847                    	; 1253  
1848                    	; 1254      rxdata = sdrdbuf;
1849    3393  214C00    		ld	hl,_sdrdbuf
1850    3396  DD75F4    		ld	(ix-12),l
1851    3399  DD74F5    		ld	(ix-11),h
1852                    	; 1255      if (sdtestflg)
1853    339C  2A0000    		ld	hl,(_sdtestflg)
1854    339F  7C        		ld	a,h
1855    33A0  B5        		or	l
1856    33A1  CAFF34    		jp	z,L1374
1857                    	; 1256          {
1858                    	; 1257          printf("  Signature: %.8s\n", &rxdata[0]);
1859    33A4  DD6EF4    		ld	l,(ix-12)
1860    33A7  DD66F5    		ld	h,(ix-11)
1861    33AA  E5        		push	hl
1862    33AB  21A532    		ld	hl,L5332
1863    33AE  CD0000    		call	_printf
1864    33B1  F1        		pop	af
1865                    	; 1258          printf("  Revision: %d.%d [%02x %02x %02x %02x]\n",
1866                    	; 1259                 (int)rxdata[8] * ((int)rxdata[9] << 8),
1867                    	; 1260                 (int)rxdata[10] + ((int)rxdata[11] << 8),
1868                    	; 1261                 rxdata[8], rxdata[9], rxdata[10], rxdata[11]);
1869    33B2  DD6EF4    		ld	l,(ix-12)
1870    33B5  DD66F5    		ld	h,(ix-11)
1871    33B8  010B00    		ld	bc,11
1872    33BB  09        		add	hl,bc
1873    33BC  4E        		ld	c,(hl)
1874    33BD  97        		sub	a
1875    33BE  47        		ld	b,a
1876    33BF  C5        		push	bc
1877    33C0  DD6EF4    		ld	l,(ix-12)
1878    33C3  DD66F5    		ld	h,(ix-11)
1879    33C6  010A00    		ld	bc,10
1880    33C9  09        		add	hl,bc
1881    33CA  4E        		ld	c,(hl)
1882    33CB  97        		sub	a
1883    33CC  47        		ld	b,a
1884    33CD  C5        		push	bc
1885    33CE  DD6EF4    		ld	l,(ix-12)
1886    33D1  DD66F5    		ld	h,(ix-11)
1887    33D4  010900    		ld	bc,9
1888    33D7  09        		add	hl,bc
1889    33D8  4E        		ld	c,(hl)
1890    33D9  97        		sub	a
1891    33DA  47        		ld	b,a
1892    33DB  C5        		push	bc
1893    33DC  DD6EF4    		ld	l,(ix-12)
1894    33DF  DD66F5    		ld	h,(ix-11)
1895    33E2  010800    		ld	bc,8
1896    33E5  09        		add	hl,bc
1897    33E6  4E        		ld	c,(hl)
1898    33E7  97        		sub	a
1899    33E8  47        		ld	b,a
1900    33E9  C5        		push	bc
1901    33EA  DD6EF4    		ld	l,(ix-12)
1902    33ED  DD66F5    		ld	h,(ix-11)
1903    33F0  010A00    		ld	bc,10
1904    33F3  09        		add	hl,bc
1905    33F4  6E        		ld	l,(hl)
1906    33F5  97        		sub	a
1907    33F6  67        		ld	h,a
1908    33F7  E5        		push	hl
1909    33F8  DD6EF4    		ld	l,(ix-12)
1910    33FB  DD66F5    		ld	h,(ix-11)
1911    33FE  010B00    		ld	bc,11
1912    3401  09        		add	hl,bc
1913    3402  6E        		ld	l,(hl)
1914    3403  97        		sub	a
1915    3404  67        		ld	h,a
1916    3405  29        		add	hl,hl
1917    3406  29        		add	hl,hl
1918    3407  29        		add	hl,hl
1919    3408  29        		add	hl,hl
1920    3409  29        		add	hl,hl
1921    340A  29        		add	hl,hl
1922    340B  29        		add	hl,hl
1923    340C  29        		add	hl,hl
1924    340D  E3        		ex	(sp),hl
1925    340E  C1        		pop	bc
1926    340F  09        		add	hl,bc
1927    3410  E5        		push	hl
1928    3411  DD6EF4    		ld	l,(ix-12)
1929    3414  DD66F5    		ld	h,(ix-11)
1930    3417  010800    		ld	bc,8
1931    341A  09        		add	hl,bc
1932    341B  6E        		ld	l,(hl)
1933    341C  97        		sub	a
1934    341D  67        		ld	h,a
1935    341E  E5        		push	hl
1936    341F  DD6EF4    		ld	l,(ix-12)
1937    3422  DD66F5    		ld	h,(ix-11)
1938    3425  010900    		ld	bc,9
1939    3428  09        		add	hl,bc
1940    3429  6E        		ld	l,(hl)
1941    342A  97        		sub	a
1942    342B  67        		ld	h,a
1943    342C  29        		add	hl,hl
1944    342D  29        		add	hl,hl
1945    342E  29        		add	hl,hl
1946    342F  29        		add	hl,hl
1947    3430  29        		add	hl,hl
1948    3431  29        		add	hl,hl
1949    3432  29        		add	hl,hl
1950    3433  29        		add	hl,hl
1951    3434  E5        		push	hl
1952    3435  CD0000    		call	c.imul
1953    3438  21B832    		ld	hl,L5432
1954    343B  CD0000    		call	_printf
1955    343E  210C00    		ld	hl,12
1956    3441  39        		add	hl,sp
1957    3442  F9        		ld	sp,hl
1958                    	; 1262          entries = (unsigned long)rxdata[80] + ((unsigned long)rxdata[81] << 8) +
1959                    	; 1263                    ((unsigned long)rxdata[82] << 16) + ((unsigned long)rxdata[83] << 24);
1960    3443  DDE5      		push	ix
1961    3445  C1        		pop	bc
1962    3446  21F0FF    		ld	hl,65520
1963    3449  09        		add	hl,bc
1964    344A  E5        		push	hl
1965    344B  DD6EF4    		ld	l,(ix-12)
1966    344E  DD66F5    		ld	h,(ix-11)
1967    3451  015000    		ld	bc,80
1968    3454  09        		add	hl,bc
1969    3455  4D        		ld	c,l
1970    3456  44        		ld	b,h
1971    3457  97        		sub	a
1972    3458  320000    		ld	(c.r0),a
1973    345B  320100    		ld	(c.r0+1),a
1974    345E  0A        		ld	a,(bc)
1975    345F  320200    		ld	(c.r0+2),a
1976    3462  97        		sub	a
1977    3463  320300    		ld	(c.r0+3),a
1978    3466  210000    		ld	hl,c.r0
1979    3469  E5        		push	hl
1980    346A  DD6EF4    		ld	l,(ix-12)
1981    346D  DD66F5    		ld	h,(ix-11)
1982    3470  015100    		ld	bc,81
1983    3473  09        		add	hl,bc
1984    3474  4D        		ld	c,l
1985    3475  44        		ld	b,h
1986    3476  97        		sub	a
1987    3477  320000    		ld	(c.r1),a
1988    347A  320100    		ld	(c.r1+1),a
1989    347D  0A        		ld	a,(bc)
1990    347E  320200    		ld	(c.r1+2),a
1991    3481  97        		sub	a
1992    3482  320300    		ld	(c.r1+3),a
1993    3485  210000    		ld	hl,c.r1
1994    3488  E5        		push	hl
1995    3489  210800    		ld	hl,8
1996    348C  E5        		push	hl
1997    348D  CD0000    		call	c.llsh
1998    3490  CD0000    		call	c.ladd
1999    3493  DD6EF4    		ld	l,(ix-12)
2000    3496  DD66F5    		ld	h,(ix-11)
2001    3499  015200    		ld	bc,82
2002    349C  09        		add	hl,bc
2003    349D  4D        		ld	c,l
2004    349E  44        		ld	b,h
2005    349F  97        		sub	a
2006    34A0  320000    		ld	(c.r1),a
2007    34A3  320100    		ld	(c.r1+1),a
2008    34A6  0A        		ld	a,(bc)
2009    34A7  320200    		ld	(c.r1+2),a
2010    34AA  97        		sub	a
2011    34AB  320300    		ld	(c.r1+3),a
2012    34AE  210000    		ld	hl,c.r1
2013    34B1  E5        		push	hl
2014    34B2  211000    		ld	hl,16
2015    34B5  E5        		push	hl
2016    34B6  CD0000    		call	c.llsh
2017    34B9  CD0000    		call	c.ladd
2018    34BC  DD6EF4    		ld	l,(ix-12)
2019    34BF  DD66F5    		ld	h,(ix-11)
2020    34C2  015300    		ld	bc,83
2021    34C5  09        		add	hl,bc
2022    34C6  4D        		ld	c,l
2023    34C7  44        		ld	b,h
2024    34C8  97        		sub	a
2025    34C9  320000    		ld	(c.r1),a
2026    34CC  320100    		ld	(c.r1+1),a
2027    34CF  0A        		ld	a,(bc)
2028    34D0  320200    		ld	(c.r1+2),a
2029    34D3  97        		sub	a
2030    34D4  320300    		ld	(c.r1+3),a
2031    34D7  210000    		ld	hl,c.r1
2032    34DA  E5        		push	hl
2033    34DB  211800    		ld	hl,24
2034    34DE  E5        		push	hl
2035    34DF  CD0000    		call	c.llsh
2036    34E2  CD0000    		call	c.ladd
2037    34E5  CD0000    		call	c.mvl
2038    34E8  F1        		pop	af
2039                    	; 1264          printf("  Number of partition entries: %lu (may be actual or maximum)\n", entries);
2040    34E9  DD66F3    		ld	h,(ix-13)
2041    34EC  DD6EF2    		ld	l,(ix-14)
2042    34EF  E5        		push	hl
2043    34F0  DD66F1    		ld	h,(ix-15)
2044    34F3  DD6EF0    		ld	l,(ix-16)
2045    34F6  E5        		push	hl
2046    34F7  21E132    		ld	hl,L5532
2047    34FA  CD0000    		call	_printf
2048    34FD  F1        		pop	af
2049    34FE  F1        		pop	af
2050                    	L1374:
2051                    	; 1265          } /* sdtestflg */
2052                    	; 1266      for (partno = 0; (partno < 16) && (partdsk < 16); partno++)
2053    34FF  DD36F600  		ld	(ix-10),0
2054    3503  DD36F700  		ld	(ix-9),0
2055                    	L1474:
2056    3507  DD7EF6    		ld	a,(ix-10)
2057    350A  D610      		sub	16
2058    350C  DD7EF7    		ld	a,(ix-9)
2059    350F  DE00      		sbc	a,0
2060    3511  302E      		jr	nc,L1574
2061    3513  3A0E00    		ld	a,(_partdsk)
2062    3516  D610      		sub	16
2063    3518  3A0F00    		ld	a,(_partdsk+1)
2064    351B  DE00      		sbc	a,0
2065    351D  F24135    		jp	p,L1574
2066                    	; 1267          {
2067                    	; 1268          if (!prtgptent(partno))
2068    3520  DD6EF6    		ld	l,(ix-10)
2069    3523  DD66F7    		ld	h,(ix-9)
2070    3526  CDB22B    		call	_prtgptent
2071    3529  79        		ld	a,c
2072    352A  B0        		or	b
2073    352B  200A      		jr	nz,L1674
2074                    	; 1269              {
2075                    	; 1270              if (!sdtestflg)
2076    352D  2A0000    		ld	hl,(_sdtestflg)
2077    3530  7C        		ld	a,h
2078    3531  B5        		or	l
2079    3532  2003      		jr	nz,L1674
2080                    	; 1271                  {
2081                    	; 1272                  /* go through all entries if compiled as test program */
2082                    	; 1273                  return;
2083    3534  C30000    		jp	c.rets
2084                    	L1674:
2085    3537  DD34F6    		inc	(ix-10)
2086    353A  2003      		jr	nz,L651
2087    353C  DD34F7    		inc	(ix-9)
2088                    	L651:
2089    353F  18C6      		jr	L1474
2090                    	L1574:
2091                    	; 1274                  } /* sdtestflg */
2092                    	; 1275              }
2093                    	; 1276          }
2094                    	; 1277      if (sdtestflg)
2095    3541  2A0000    		ld	hl,(_sdtestflg)
2096    3544  7C        		ld	a,h
2097    3545  B5        		or	l
2098    3546  2806      		jr	z,L1205
2099                    	; 1278          {
2100                    	; 1279          printf("First 16 GPT entries scanned\n");
2101    3548  212033    		ld	hl,L5632
2102    354B  CD0000    		call	_printf
2103                    	L1205:
2104                    	; 1280          } /* sdtestflg */
2105                    	; 1281      }
2106    354E  C30000    		jp	c.rets
2107                    	L5732:
2108    3551  4E        		.byte	78
2109    3552  6F        		.byte	111
2110    3553  74        		.byte	116
2111    3554  20        		.byte	32
2112    3555  75        		.byte	117
2113    3556  73        		.byte	115
2114    3557  65        		.byte	101
2115    3558  64        		.byte	100
2116    3559  20        		.byte	32
2117    355A  65        		.byte	101
2118    355B  6E        		.byte	110
2119    355C  74        		.byte	116
2120    355D  72        		.byte	114
2121    355E  79        		.byte	121
2122    355F  0A        		.byte	10
2123    3560  00        		.byte	0
2124                    	L5042:
2125    3561  42        		.byte	66
2126    3562  6F        		.byte	111
2127    3563  6F        		.byte	111
2128    3564  74        		.byte	116
2129    3565  20        		.byte	32
2130    3566  69        		.byte	105
2131    3567  6E        		.byte	110
2132    3568  64        		.byte	100
2133    3569  69        		.byte	105
2134    356A  63        		.byte	99
2135    356B  61        		.byte	97
2136    356C  74        		.byte	116
2137    356D  6F        		.byte	111
2138    356E  72        		.byte	114
2139    356F  3A        		.byte	58
2140    3570  20        		.byte	32
2141    3571  30        		.byte	48
2142    3572  78        		.byte	120
2143    3573  25        		.byte	37
2144    3574  30        		.byte	48
2145    3575  32        		.byte	50
2146    3576  78        		.byte	120
2147    3577  2C        		.byte	44
2148    3578  20        		.byte	32
2149    3579  53        		.byte	83
2150    357A  79        		.byte	121
2151    357B  73        		.byte	115
2152    357C  74        		.byte	116
2153    357D  65        		.byte	101
2154    357E  6D        		.byte	109
2155    357F  20        		.byte	32
2156    3580  49        		.byte	73
2157    3581  44        		.byte	68
2158    3582  3A        		.byte	58
2159    3583  20        		.byte	32
2160    3584  30        		.byte	48
2161    3585  78        		.byte	120
2162    3586  25        		.byte	37
2163    3587  30        		.byte	48
2164    3588  32        		.byte	50
2165    3589  78        		.byte	120
2166    358A  0A        		.byte	10
2167    358B  00        		.byte	0
2168                    	L5142:
2169    358C  20        		.byte	32
2170    358D  20        		.byte	32
2171    358E  45        		.byte	69
2172    358F  78        		.byte	120
2173    3590  74        		.byte	116
2174    3591  65        		.byte	101
2175    3592  6E        		.byte	110
2176    3593  64        		.byte	100
2177    3594  65        		.byte	101
2178    3595  64        		.byte	100
2179    3596  20        		.byte	32
2180    3597  70        		.byte	112
2181    3598  61        		.byte	97
2182    3599  72        		.byte	114
2183    359A  74        		.byte	116
2184    359B  69        		.byte	105
2185    359C  74        		.byte	116
2186    359D  69        		.byte	105
2187    359E  6F        		.byte	111
2188    359F  6E        		.byte	110
2189    35A0  20        		.byte	32
2190    35A1  65        		.byte	101
2191    35A2  6E        		.byte	110
2192    35A3  74        		.byte	116
2193    35A4  72        		.byte	114
2194    35A5  79        		.byte	121
2195    35A6  0A        		.byte	10
2196    35A7  00        		.byte	0
2197                    	L5242:
2198    35A8  20        		.byte	32
2199    35A9  20        		.byte	32
2200    35AA  55        		.byte	85
2201    35AB  6E        		.byte	110
2202    35AC  6F        		.byte	111
2203    35AD  66        		.byte	102
2204    35AE  66        		.byte	102
2205    35AF  69        		.byte	105
2206    35B0  63        		.byte	99
2207    35B1  69        		.byte	105
2208    35B2  61        		.byte	97
2209    35B3  6C        		.byte	108
2210    35B4  20        		.byte	32
2211    35B5  34        		.byte	52
2212    35B6  38        		.byte	56
2213    35B7  20        		.byte	32
2214    35B8  62        		.byte	98
2215    35B9  69        		.byte	105
2216    35BA  74        		.byte	116
2217    35BB  20        		.byte	32
2218    35BC  4C        		.byte	76
2219    35BD  42        		.byte	66
2220    35BE  41        		.byte	65
2221    35BF  20        		.byte	32
2222    35C0  50        		.byte	80
2223    35C1  72        		.byte	114
2224    35C2  6F        		.byte	111
2225    35C3  70        		.byte	112
2226    35C4  6F        		.byte	111
2227    35C5  73        		.byte	115
2228    35C6  65        		.byte	101
2229    35C7  64        		.byte	100
2230    35C8  20        		.byte	32
2231    35C9  4D        		.byte	77
2232    35CA  42        		.byte	66
2233    35CB  52        		.byte	82
2234    35CC  20        		.byte	32
2235    35CD  46        		.byte	70
2236    35CE  6F        		.byte	111
2237    35CF  72        		.byte	114
2238    35D0  6D        		.byte	109
2239    35D1  61        		.byte	97
2240    35D2  74        		.byte	116
2241    35D3  2C        		.byte	44
2242    35D4  20        		.byte	32
2243    35D5  6E        		.byte	110
2244    35D6  6F        		.byte	111
2245    35D7  20        		.byte	32
2246    35D8  43        		.byte	67
2247    35D9  48        		.byte	72
2248    35DA  53        		.byte	83
2249    35DB  0A        		.byte	10
2250    35DC  00        		.byte	0
2251                    	L5342:
2252    35DD  20        		.byte	32
2253    35DE  20        		.byte	32
2254    35DF  62        		.byte	98
2255    35E0  65        		.byte	101
2256    35E1  67        		.byte	103
2257    35E2  69        		.byte	105
2258    35E3  6E        		.byte	110
2259    35E4  20        		.byte	32
2260    35E5  43        		.byte	67
2261    35E6  48        		.byte	72
2262    35E7  53        		.byte	83
2263    35E8  3A        		.byte	58
2264    35E9  20        		.byte	32
2265    35EA  30        		.byte	48
2266    35EB  78        		.byte	120
2267    35EC  25        		.byte	37
2268    35ED  30        		.byte	48
2269    35EE  32        		.byte	50
2270    35EF  78        		.byte	120
2271    35F0  2D        		.byte	45
2272    35F1  30        		.byte	48
2273    35F2  78        		.byte	120
2274    35F3  25        		.byte	37
2275    35F4  30        		.byte	48
2276    35F5  32        		.byte	50
2277    35F6  78        		.byte	120
2278    35F7  2D        		.byte	45
2279    35F8  30        		.byte	48
2280    35F9  78        		.byte	120
2281    35FA  25        		.byte	37
2282    35FB  30        		.byte	48
2283    35FC  32        		.byte	50
2284    35FD  78        		.byte	120
2285    35FE  20        		.byte	32
2286    35FF  28        		.byte	40
2287    3600  63        		.byte	99
2288    3601  79        		.byte	121
2289    3602  6C        		.byte	108
2290    3603  3A        		.byte	58
2291    3604  20        		.byte	32
2292    3605  25        		.byte	37
2293    3606  64        		.byte	100
2294    3607  2C        		.byte	44
2295    3608  20        		.byte	32
2296    3609  68        		.byte	104
2297    360A  65        		.byte	101
2298    360B  61        		.byte	97
2299    360C  64        		.byte	100
2300    360D  3A        		.byte	58
2301    360E  20        		.byte	32
2302    360F  25        		.byte	37
2303    3610  64        		.byte	100
2304    3611  20        		.byte	32
2305    3612  73        		.byte	115
2306    3613  65        		.byte	101
2307    3614  63        		.byte	99
2308    3615  74        		.byte	116
2309    3616  6F        		.byte	111
2310    3617  72        		.byte	114
2311    3618  3A        		.byte	58
2312    3619  20        		.byte	32
2313    361A  25        		.byte	37
2314    361B  64        		.byte	100
2315    361C  29        		.byte	41
2316    361D  0A        		.byte	10
2317    361E  00        		.byte	0
2318                    	L5442:
2319    361F  20        		.byte	32
2320    3620  20        		.byte	32
2321    3621  65        		.byte	101
2322    3622  6E        		.byte	110
2323    3623  64        		.byte	100
2324    3624  20        		.byte	32
2325    3625  43        		.byte	67
2326    3626  48        		.byte	72
2327    3627  53        		.byte	83
2328    3628  20        		.byte	32
2329    3629  30        		.byte	48
2330    362A  78        		.byte	120
2331    362B  25        		.byte	37
2332    362C  30        		.byte	48
2333    362D  32        		.byte	50
2334    362E  78        		.byte	120
2335    362F  2D        		.byte	45
2336    3630  30        		.byte	48
2337    3631  78        		.byte	120
2338    3632  25        		.byte	37
2339    3633  30        		.byte	48
2340    3634  32        		.byte	50
2341    3635  78        		.byte	120
2342    3636  2D        		.byte	45
2343    3637  30        		.byte	48
2344    3638  78        		.byte	120
2345    3639  25        		.byte	37
2346    363A  30        		.byte	48
2347    363B  32        		.byte	50
2348    363C  78        		.byte	120
2349    363D  20        		.byte	32
2350    363E  28        		.byte	40
2351    363F  63        		.byte	99
2352    3640  79        		.byte	121
2353    3641  6C        		.byte	108
2354    3642  3A        		.byte	58
2355    3643  20        		.byte	32
2356    3644  25        		.byte	37
2357    3645  64        		.byte	100
2358    3646  2C        		.byte	44
2359    3647  20        		.byte	32
2360    3648  68        		.byte	104
2361    3649  65        		.byte	101
2362    364A  61        		.byte	97
2363    364B  64        		.byte	100
2364    364C  3A        		.byte	58
2365    364D  20        		.byte	32
2366    364E  25        		.byte	37
2367    364F  64        		.byte	100
2368    3650  20        		.byte	32
2369    3651  73        		.byte	115
2370    3652  65        		.byte	101
2371    3653  63        		.byte	99
2372    3654  74        		.byte	116
2373    3655  6F        		.byte	111
2374    3656  72        		.byte	114
2375    3657  3A        		.byte	58
2376    3658  20        		.byte	32
2377    3659  25        		.byte	37
2378    365A  64        		.byte	100
2379    365B  29        		.byte	41
2380    365C  0A        		.byte	10
2381    365D  00        		.byte	0
2382                    	L5542:
2383    365E  20        		.byte	32
2384    365F  20        		.byte	32
2385    3660  70        		.byte	112
2386    3661  61        		.byte	97
2387    3662  72        		.byte	114
2388    3663  74        		.byte	116
2389    3664  69        		.byte	105
2390    3665  74        		.byte	116
2391    3666  69        		.byte	105
2392    3667  6F        		.byte	111
2393    3668  6E        		.byte	110
2394    3669  20        		.byte	32
2395    366A  73        		.byte	115
2396    366B  74        		.byte	116
2397    366C  61        		.byte	97
2398    366D  72        		.byte	114
2399    366E  74        		.byte	116
2400    366F  20        		.byte	32
2401    3670  4C        		.byte	76
2402    3671  42        		.byte	66
2403    3672  41        		.byte	65
2404    3673  3A        		.byte	58
2405    3674  20        		.byte	32
2406    3675  25        		.byte	37
2407    3676  6C        		.byte	108
2408    3677  75        		.byte	117
2409    3678  20        		.byte	32
2410    3679  5B        		.byte	91
2411    367A  25        		.byte	37
2412    367B  30        		.byte	48
2413    367C  38        		.byte	56
2414    367D  6C        		.byte	108
2415    367E  78        		.byte	120
2416    367F  5D        		.byte	93
2417    3680  0A        		.byte	10
2418    3681  00        		.byte	0
2419                    	L5642:
2420    3682  20        		.byte	32
2421    3683  20        		.byte	32
2422    3684  70        		.byte	112
2423    3685  61        		.byte	97
2424    3686  72        		.byte	114
2425    3687  74        		.byte	116
2426    3688  69        		.byte	105
2427    3689  74        		.byte	116
2428    368A  69        		.byte	105
2429    368B  6F        		.byte	111
2430    368C  6E        		.byte	110
2431    368D  20        		.byte	32
2432    368E  73        		.byte	115
2433    368F  69        		.byte	105
2434    3690  7A        		.byte	122
2435    3691  65        		.byte	101
2436    3692  20        		.byte	32
2437    3693  4C        		.byte	76
2438    3694  42        		.byte	66
2439    3695  41        		.byte	65
2440    3696  3A        		.byte	58
2441    3697  20        		.byte	32
2442    3698  25        		.byte	37
2443    3699  6C        		.byte	108
2444    369A  75        		.byte	117
2445    369B  20        		.byte	32
2446    369C  5B        		.byte	91
2447    369D  25        		.byte	37
2448    369E  30        		.byte	48
2449    369F  38        		.byte	56
2450    36A0  6C        		.byte	108
2451    36A1  78        		.byte	120
2452    36A2  5D        		.byte	93
2453    36A3  2C        		.byte	44
2454    36A4  20        		.byte	32
2455    36A5  25        		.byte	37
2456    36A6  6C        		.byte	108
2457    36A7  75        		.byte	117
2458    36A8  20        		.byte	32
2459    36A9  4D        		.byte	77
2460    36AA  42        		.byte	66
2461    36AB  79        		.byte	121
2462    36AC  74        		.byte	116
2463    36AD  65        		.byte	101
2464    36AE  0A        		.byte	10
2465    36AF  00        		.byte	0
2466                    	L5742:
2467    36B0  47        		.byte	71
2468    36B1  54        		.byte	84
2469    36B2  50        		.byte	80
2470    36B3  20        		.byte	32
2471    36B4  70        		.byte	112
2472    36B5  61        		.byte	97
2473    36B6  72        		.byte	114
2474    36B7  74        		.byte	116
2475    36B8  69        		.byte	105
2476    36B9  74        		.byte	116
2477    36BA  69        		.byte	105
2478    36BB  6F        		.byte	111
2479    36BC  6E        		.byte	110
2480    36BD  73        		.byte	115
2481    36BE  0A        		.byte	10
2482    36BF  00        		.byte	0
2483                    	L261:
2484    36C0  00        		.byte	0
2485    36C1  00        		.byte	0
2486    36C2  00        		.byte	0
2487    36C3  00        		.byte	0
2488                    	L5052:
2489    36C4  20        		.byte	32
2490    36C5  20        		.byte	32
2491    36C6  63        		.byte	99
2492    36C7  61        		.byte	97
2493    36C8  6E        		.byte	110
2494    36C9  27        		.byte	39
2495    36CA  74        		.byte	116
2496    36CB  20        		.byte	32
2497    36CC  72        		.byte	114
2498    36CD  65        		.byte	101
2499    36CE  61        		.byte	97
2500    36CF  64        		.byte	100
2501    36D0  20        		.byte	32
2502    36D1  4D        		.byte	77
2503    36D2  42        		.byte	66
2504    36D3  52        		.byte	82
2505    36D4  20        		.byte	32
2506    36D5  6F        		.byte	111
2507    36D6  6E        		.byte	110
2508    36D7  20        		.byte	32
2509    36D8  73        		.byte	115
2510    36D9  65        		.byte	101
2511    36DA  63        		.byte	99
2512    36DB  74        		.byte	116
2513    36DC  6F        		.byte	111
2514    36DD  72        		.byte	114
2515    36DE  20        		.byte	32
2516    36DF  30        		.byte	48
2517    36E0  0A        		.byte	10
2518    36E1  00        		.byte	0
2519                    	; 1282  
2520                    	; 1283  /* Analyze and print MBR partition entry
2521                    	; 1284   * Returns:
2522                    	; 1285   *    -1 if errror - should not happen
2523                    	; 1286   *     0 if not used entry
2524                    	; 1287   *     1 if MBR entry
2525                    	; 1288   *     2 if EBR entry
2526                    	; 1289   *     3 if GTP entry
2527                    	; 1290   */
2528                    	; 1291  int sdmbrentry(unsigned char *partptr)
2529                    	; 1292      {
2530                    	_sdmbrentry:
2531    36E2  CD0000    		call	c.savs
2532    36E5  21EEFF    		ld	hl,65518
2533    36E8  39        		add	hl,sp
2534    36E9  F9        		ld	sp,hl
2535                    	; 1293      int index;
2536                    	; 1294      int parttype;
2537                    	; 1295      unsigned long lbastart;
2538                    	; 1296      unsigned long lbasize;
2539                    	; 1297  
2540                    	; 1298      parttype = PARTMBR;
2541    36EA  DD36F601  		ld	(ix-10),1
2542    36EE  DD36F700  		ld	(ix-9),0
2543                    	; 1299      if (!partptr[4])
2544    36F2  DD6E04    		ld	l,(ix+4)
2545    36F5  DD6605    		ld	h,(ix+5)
2546    36F8  23        		inc	hl
2547    36F9  23        		inc	hl
2548    36FA  23        		inc	hl
2549    36FB  23        		inc	hl
2550    36FC  7E        		ld	a,(hl)
2551    36FD  B7        		or	a
2552    36FE  2013      		jr	nz,L1305
2553                    	; 1300          {
2554                    	; 1301          if (sdtestflg)
2555    3700  2A0000    		ld	hl,(_sdtestflg)
2556    3703  7C        		ld	a,h
2557    3704  B5        		or	l
2558    3705  2806      		jr	z,L1405
2559                    	; 1302              {
2560                    	; 1303              printf("Not used entry\n");
2561    3707  215135    		ld	hl,L5732
2562    370A  CD0000    		call	_printf
2563                    	L1405:
2564                    	; 1304              } /* sdtestflg */
2565                    	; 1305          return (PARTZRO);
2566    370D  010000    		ld	bc,0
2567    3710  C30000    		jp	c.rets
2568                    	L1305:
2569                    	; 1306          }
2570                    	; 1307      if (sdtestflg)
2571    3713  2A0000    		ld	hl,(_sdtestflg)
2572    3716  7C        		ld	a,h
2573    3717  B5        		or	l
2574    3718  CA7038    		jp	z,L1505
2575                    	; 1308          {
2576                    	; 1309          printf("Boot indicator: 0x%02x, System ID: 0x%02x\n",
2577                    	; 1310                 partptr[0], partptr[4]);
2578    371B  DD6E04    		ld	l,(ix+4)
2579    371E  DD6605    		ld	h,(ix+5)
2580    3721  23        		inc	hl
2581    3722  23        		inc	hl
2582    3723  23        		inc	hl
2583    3724  23        		inc	hl
2584    3725  4E        		ld	c,(hl)
2585    3726  97        		sub	a
2586    3727  47        		ld	b,a
2587    3728  C5        		push	bc
2588    3729  DD6E04    		ld	l,(ix+4)
2589    372C  DD6605    		ld	h,(ix+5)
2590    372F  4E        		ld	c,(hl)
2591    3730  97        		sub	a
2592    3731  47        		ld	b,a
2593    3732  C5        		push	bc
2594    3733  216135    		ld	hl,L5042
2595    3736  CD0000    		call	_printf
2596    3739  F1        		pop	af
2597    373A  F1        		pop	af
2598                    	; 1311  
2599                    	; 1312          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f))
2600    373B  DD6E04    		ld	l,(ix+4)
2601    373E  DD6605    		ld	h,(ix+5)
2602    3741  23        		inc	hl
2603    3742  23        		inc	hl
2604    3743  23        		inc	hl
2605    3744  23        		inc	hl
2606    3745  7E        		ld	a,(hl)
2607    3746  FE05      		cp	5
2608    3748  280F      		jr	z,L1705
2609    374A  DD6E04    		ld	l,(ix+4)
2610    374D  DD6605    		ld	h,(ix+5)
2611    3750  23        		inc	hl
2612    3751  23        		inc	hl
2613    3752  23        		inc	hl
2614    3753  23        		inc	hl
2615    3754  7E        		ld	a,(hl)
2616    3755  FE0F      		cp	15
2617    3757  2006      		jr	nz,L1605
2618                    	L1705:
2619                    	; 1313              {
2620                    	; 1314              printf("  Extended partition entry\n");
2621    3759  218C35    		ld	hl,L5142
2622    375C  CD0000    		call	_printf
2623                    	L1605:
2624                    	; 1315              }
2625                    	; 1316          if (partptr[0] & 0x01)
2626    375F  DD6E04    		ld	l,(ix+4)
2627    3762  DD6605    		ld	h,(ix+5)
2628    3765  7E        		ld	a,(hl)
2629    3766  CB47      		bit	0,a
2630    3768  6F        		ld	l,a
2631    3769  2809      		jr	z,L1015
2632                    	; 1317              {
2633                    	; 1318              printf("  Unofficial 48 bit LBA Proposed MBR Format, no CHS\n");
2634    376B  21A835    		ld	hl,L5242
2635    376E  CD0000    		call	_printf
2636                    	; 1319              /* this is however discussed
2637                    	; 1320                 https://wiki.osdev.org/Partition_Table#.22Unofficial.22_48_bit_LBA_Proposed_MBR_Format
2638                    	; 1321              */
2639                    	; 1322              }
2640                    	; 1323          else
2641    3771  C37038    		jp	L1505
2642                    	L1015:
2643                    	; 1324              {
2644                    	; 1325              printf("  begin CHS: 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
2645                    	; 1326                     partptr[1], partptr[2], partptr[3],
2646                    	; 1327                     ((partptr[2] & 0xc0) >> 2) + partptr[3],
2647                    	; 1328                     partptr[1],
2648                    	; 1329                     partptr[2] & 0x3f);
2649    3774  DD6E04    		ld	l,(ix+4)
2650    3777  DD6605    		ld	h,(ix+5)
2651    377A  23        		inc	hl
2652    377B  23        		inc	hl
2653    377C  6E        		ld	l,(hl)
2654    377D  97        		sub	a
2655    377E  67        		ld	h,a
2656    377F  7D        		ld	a,l
2657    3780  E63F      		and	63
2658    3782  6F        		ld	l,a
2659    3783  97        		sub	a
2660    3784  67        		ld	h,a
2661    3785  E5        		push	hl
2662    3786  DD6E04    		ld	l,(ix+4)
2663    3789  DD6605    		ld	h,(ix+5)
2664    378C  23        		inc	hl
2665    378D  4E        		ld	c,(hl)
2666    378E  97        		sub	a
2667    378F  47        		ld	b,a
2668    3790  C5        		push	bc
2669    3791  DD6E04    		ld	l,(ix+4)
2670    3794  DD6605    		ld	h,(ix+5)
2671    3797  23        		inc	hl
2672    3798  23        		inc	hl
2673    3799  6E        		ld	l,(hl)
2674    379A  97        		sub	a
2675    379B  67        		ld	h,a
2676    379C  7D        		ld	a,l
2677    379D  E6C0      		and	192
2678    379F  6F        		ld	l,a
2679    37A0  97        		sub	a
2680    37A1  67        		ld	h,a
2681    37A2  E5        		push	hl
2682    37A3  210200    		ld	hl,2
2683    37A6  E5        		push	hl
2684    37A7  CD0000    		call	c.irsh
2685    37AA  E1        		pop	hl
2686    37AB  E5        		push	hl
2687    37AC  DD6E04    		ld	l,(ix+4)
2688    37AF  DD6605    		ld	h,(ix+5)
2689    37B2  23        		inc	hl
2690    37B3  23        		inc	hl
2691    37B4  23        		inc	hl
2692    37B5  6E        		ld	l,(hl)
2693    37B6  97        		sub	a
2694    37B7  67        		ld	h,a
2695    37B8  E3        		ex	(sp),hl
2696    37B9  C1        		pop	bc
2697    37BA  09        		add	hl,bc
2698    37BB  E5        		push	hl
2699    37BC  DD6E04    		ld	l,(ix+4)
2700    37BF  DD6605    		ld	h,(ix+5)
2701    37C2  23        		inc	hl
2702    37C3  23        		inc	hl
2703    37C4  23        		inc	hl
2704    37C5  4E        		ld	c,(hl)
2705    37C6  97        		sub	a
2706    37C7  47        		ld	b,a
2707    37C8  C5        		push	bc
2708    37C9  DD6E04    		ld	l,(ix+4)
2709    37CC  DD6605    		ld	h,(ix+5)
2710    37CF  23        		inc	hl
2711    37D0  23        		inc	hl
2712    37D1  4E        		ld	c,(hl)
2713    37D2  97        		sub	a
2714    37D3  47        		ld	b,a
2715    37D4  C5        		push	bc
2716    37D5  DD6E04    		ld	l,(ix+4)
2717    37D8  DD6605    		ld	h,(ix+5)
2718    37DB  23        		inc	hl
2719    37DC  4E        		ld	c,(hl)
2720    37DD  97        		sub	a
2721    37DE  47        		ld	b,a
2722    37DF  C5        		push	bc
2723    37E0  21DD35    		ld	hl,L5342
2724    37E3  CD0000    		call	_printf
2725    37E6  210C00    		ld	hl,12
2726    37E9  39        		add	hl,sp
2727    37EA  F9        		ld	sp,hl
2728                    	; 1330              printf("  end CHS 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
2729                    	; 1331                     partptr[5], partptr[6], partptr[7],
2730                    	; 1332                     ((partptr[6] & 0xc0) >> 2) + partptr[7],
2731                    	; 1333                     partptr[5],
2732                    	; 1334                     partptr[6] & 0x3f);
2733    37EB  DD6E04    		ld	l,(ix+4)
2734    37EE  DD6605    		ld	h,(ix+5)
2735    37F1  010600    		ld	bc,6
2736    37F4  09        		add	hl,bc
2737    37F5  6E        		ld	l,(hl)
2738    37F6  97        		sub	a
2739    37F7  67        		ld	h,a
2740    37F8  7D        		ld	a,l
2741    37F9  E63F      		and	63
2742    37FB  6F        		ld	l,a
2743    37FC  97        		sub	a
2744    37FD  67        		ld	h,a
2745    37FE  E5        		push	hl
2746    37FF  DD6E04    		ld	l,(ix+4)
2747    3802  DD6605    		ld	h,(ix+5)
2748    3805  010500    		ld	bc,5
2749    3808  09        		add	hl,bc
2750    3809  4E        		ld	c,(hl)
2751    380A  97        		sub	a
2752    380B  47        		ld	b,a
2753    380C  C5        		push	bc
2754    380D  DD6E04    		ld	l,(ix+4)
2755    3810  DD6605    		ld	h,(ix+5)
2756    3813  010600    		ld	bc,6
2757    3816  09        		add	hl,bc
2758    3817  6E        		ld	l,(hl)
2759    3818  97        		sub	a
2760    3819  67        		ld	h,a
2761    381A  7D        		ld	a,l
2762    381B  E6C0      		and	192
2763    381D  6F        		ld	l,a
2764    381E  97        		sub	a
2765    381F  67        		ld	h,a
2766    3820  E5        		push	hl
2767    3821  210200    		ld	hl,2
2768    3824  E5        		push	hl
2769    3825  CD0000    		call	c.irsh
2770    3828  E1        		pop	hl
2771    3829  E5        		push	hl
2772    382A  DD6E04    		ld	l,(ix+4)
2773    382D  DD6605    		ld	h,(ix+5)
2774    3830  010700    		ld	bc,7
2775    3833  09        		add	hl,bc
2776    3834  6E        		ld	l,(hl)
2777    3835  97        		sub	a
2778    3836  67        		ld	h,a
2779    3837  E3        		ex	(sp),hl
2780    3838  C1        		pop	bc
2781    3839  09        		add	hl,bc
2782    383A  E5        		push	hl
2783    383B  DD6E04    		ld	l,(ix+4)
2784    383E  DD6605    		ld	h,(ix+5)
2785    3841  010700    		ld	bc,7
2786    3844  09        		add	hl,bc
2787    3845  4E        		ld	c,(hl)
2788    3846  97        		sub	a
2789    3847  47        		ld	b,a
2790    3848  C5        		push	bc
2791    3849  DD6E04    		ld	l,(ix+4)
2792    384C  DD6605    		ld	h,(ix+5)
2793    384F  010600    		ld	bc,6
2794    3852  09        		add	hl,bc
2795    3853  4E        		ld	c,(hl)
2796    3854  97        		sub	a
2797    3855  47        		ld	b,a
2798    3856  C5        		push	bc
2799    3857  DD6E04    		ld	l,(ix+4)
2800    385A  DD6605    		ld	h,(ix+5)
2801    385D  010500    		ld	bc,5
2802    3860  09        		add	hl,bc
2803    3861  4E        		ld	c,(hl)
2804    3862  97        		sub	a
2805    3863  47        		ld	b,a
2806    3864  C5        		push	bc
2807    3865  211F36    		ld	hl,L5442
2808    3868  CD0000    		call	_printf
2809    386B  210C00    		ld	hl,12
2810    386E  39        		add	hl,sp
2811    386F  F9        		ld	sp,hl
2812                    	L1505:
2813                    	; 1335              }
2814                    	; 1336          } /* sdtestflg */
2815                    	; 1337      /* not showing high 16 bits if 48 bit LBA */
2816                    	; 1338      lbastart = (unsigned long)partptr[8] +
2817                    	; 1339                 ((unsigned long)partptr[9] << 8) +
2818                    	; 1340                 ((unsigned long)partptr[10] << 16) +
2819                    	; 1341                 ((unsigned long)partptr[11] << 24);
2820    3870  DDE5      		push	ix
2821    3872  C1        		pop	bc
2822    3873  21F2FF    		ld	hl,65522
2823    3876  09        		add	hl,bc
2824    3877  E5        		push	hl
2825    3878  DD6E04    		ld	l,(ix+4)
2826    387B  DD6605    		ld	h,(ix+5)
2827    387E  010800    		ld	bc,8
2828    3881  09        		add	hl,bc
2829    3882  4D        		ld	c,l
2830    3883  44        		ld	b,h
2831    3884  97        		sub	a
2832    3885  320000    		ld	(c.r0),a
2833    3888  320100    		ld	(c.r0+1),a
2834    388B  0A        		ld	a,(bc)
2835    388C  320200    		ld	(c.r0+2),a
2836    388F  97        		sub	a
2837    3890  320300    		ld	(c.r0+3),a
2838    3893  210000    		ld	hl,c.r0
2839    3896  E5        		push	hl
2840    3897  DD6E04    		ld	l,(ix+4)
2841    389A  DD6605    		ld	h,(ix+5)
2842    389D  010900    		ld	bc,9
2843    38A0  09        		add	hl,bc
2844    38A1  4D        		ld	c,l
2845    38A2  44        		ld	b,h
2846    38A3  97        		sub	a
2847    38A4  320000    		ld	(c.r1),a
2848    38A7  320100    		ld	(c.r1+1),a
2849    38AA  0A        		ld	a,(bc)
2850    38AB  320200    		ld	(c.r1+2),a
2851    38AE  97        		sub	a
2852    38AF  320300    		ld	(c.r1+3),a
2853    38B2  210000    		ld	hl,c.r1
2854    38B5  E5        		push	hl
2855    38B6  210800    		ld	hl,8
2856    38B9  E5        		push	hl
2857    38BA  CD0000    		call	c.llsh
2858    38BD  CD0000    		call	c.ladd
2859    38C0  DD6E04    		ld	l,(ix+4)
2860    38C3  DD6605    		ld	h,(ix+5)
2861    38C6  010A00    		ld	bc,10
2862    38C9  09        		add	hl,bc
2863    38CA  4D        		ld	c,l
2864    38CB  44        		ld	b,h
2865    38CC  97        		sub	a
2866    38CD  320000    		ld	(c.r1),a
2867    38D0  320100    		ld	(c.r1+1),a
2868    38D3  0A        		ld	a,(bc)
2869    38D4  320200    		ld	(c.r1+2),a
2870    38D7  97        		sub	a
2871    38D8  320300    		ld	(c.r1+3),a
2872    38DB  210000    		ld	hl,c.r1
2873    38DE  E5        		push	hl
2874    38DF  211000    		ld	hl,16
2875    38E2  E5        		push	hl
2876    38E3  CD0000    		call	c.llsh
2877    38E6  CD0000    		call	c.ladd
2878    38E9  DD6E04    		ld	l,(ix+4)
2879    38EC  DD6605    		ld	h,(ix+5)
2880    38EF  010B00    		ld	bc,11
2881    38F2  09        		add	hl,bc
2882    38F3  4D        		ld	c,l
2883    38F4  44        		ld	b,h
2884    38F5  97        		sub	a
2885    38F6  320000    		ld	(c.r1),a
2886    38F9  320100    		ld	(c.r1+1),a
2887    38FC  0A        		ld	a,(bc)
2888    38FD  320200    		ld	(c.r1+2),a
2889    3900  97        		sub	a
2890    3901  320300    		ld	(c.r1+3),a
2891    3904  210000    		ld	hl,c.r1
2892    3907  E5        		push	hl
2893    3908  211800    		ld	hl,24
2894    390B  E5        		push	hl
2895    390C  CD0000    		call	c.llsh
2896    390F  CD0000    		call	c.ladd
2897    3912  CD0000    		call	c.mvl
2898    3915  F1        		pop	af
2899                    	; 1342      lbasize = (unsigned long)partptr[12] +
2900                    	; 1343                ((unsigned long)partptr[13] << 8) +
2901                    	; 1344                ((unsigned long)partptr[14] << 16) +
2902                    	; 1345                ((unsigned long)partptr[15] << 24);
2903    3916  DDE5      		push	ix
2904    3918  C1        		pop	bc
2905    3919  21EEFF    		ld	hl,65518
2906    391C  09        		add	hl,bc
2907    391D  E5        		push	hl
2908    391E  DD6E04    		ld	l,(ix+4)
2909    3921  DD6605    		ld	h,(ix+5)
2910    3924  010C00    		ld	bc,12
2911    3927  09        		add	hl,bc
2912    3928  4D        		ld	c,l
2913    3929  44        		ld	b,h
2914    392A  97        		sub	a
2915    392B  320000    		ld	(c.r0),a
2916    392E  320100    		ld	(c.r0+1),a
2917    3931  0A        		ld	a,(bc)
2918    3932  320200    		ld	(c.r0+2),a
2919    3935  97        		sub	a
2920    3936  320300    		ld	(c.r0+3),a
2921    3939  210000    		ld	hl,c.r0
2922    393C  E5        		push	hl
2923    393D  DD6E04    		ld	l,(ix+4)
2924    3940  DD6605    		ld	h,(ix+5)
2925    3943  010D00    		ld	bc,13
2926    3946  09        		add	hl,bc
2927    3947  4D        		ld	c,l
2928    3948  44        		ld	b,h
2929    3949  97        		sub	a
2930    394A  320000    		ld	(c.r1),a
2931    394D  320100    		ld	(c.r1+1),a
2932    3950  0A        		ld	a,(bc)
2933    3951  320200    		ld	(c.r1+2),a
2934    3954  97        		sub	a
2935    3955  320300    		ld	(c.r1+3),a
2936    3958  210000    		ld	hl,c.r1
2937    395B  E5        		push	hl
2938    395C  210800    		ld	hl,8
2939    395F  E5        		push	hl
2940    3960  CD0000    		call	c.llsh
2941    3963  CD0000    		call	c.ladd
2942    3966  DD6E04    		ld	l,(ix+4)
2943    3969  DD6605    		ld	h,(ix+5)
2944    396C  010E00    		ld	bc,14
2945    396F  09        		add	hl,bc
2946    3970  4D        		ld	c,l
2947    3971  44        		ld	b,h
2948    3972  97        		sub	a
2949    3973  320000    		ld	(c.r1),a
2950    3976  320100    		ld	(c.r1+1),a
2951    3979  0A        		ld	a,(bc)
2952    397A  320200    		ld	(c.r1+2),a
2953    397D  97        		sub	a
2954    397E  320300    		ld	(c.r1+3),a
2955    3981  210000    		ld	hl,c.r1
2956    3984  E5        		push	hl
2957    3985  211000    		ld	hl,16
2958    3988  E5        		push	hl
2959    3989  CD0000    		call	c.llsh
2960    398C  CD0000    		call	c.ladd
2961    398F  DD6E04    		ld	l,(ix+4)
2962    3992  DD6605    		ld	h,(ix+5)
2963    3995  010F00    		ld	bc,15
2964    3998  09        		add	hl,bc
2965    3999  4D        		ld	c,l
2966    399A  44        		ld	b,h
2967    399B  97        		sub	a
2968    399C  320000    		ld	(c.r1),a
2969    399F  320100    		ld	(c.r1+1),a
2970    39A2  0A        		ld	a,(bc)
2971    39A3  320200    		ld	(c.r1+2),a
2972    39A6  97        		sub	a
2973    39A7  320300    		ld	(c.r1+3),a
2974    39AA  210000    		ld	hl,c.r1
2975    39AD  E5        		push	hl
2976    39AE  211800    		ld	hl,24
2977    39B1  E5        		push	hl
2978    39B2  CD0000    		call	c.llsh
2979    39B5  CD0000    		call	c.ladd
2980    39B8  CD0000    		call	c.mvl
2981    39BB  F1        		pop	af
2982                    	; 1346  
2983                    	; 1347      if (!(partptr[4] == 0xee)) /* not pointing to a GPT partition */
2984    39BC  DD6E04    		ld	l,(ix+4)
2985    39BF  DD6605    		ld	h,(ix+5)
2986    39C2  23        		inc	hl
2987    39C3  23        		inc	hl
2988    39C4  23        		inc	hl
2989    39C5  23        		inc	hl
2990    39C6  7E        		ld	a,(hl)
2991    39C7  FEEE      		cp	238
2992    39C9  CA463C    		jp	z,L1215
2993                    	; 1348          {
2994                    	; 1349          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f)) /* EBR partition */
2995    39CC  DD6E04    		ld	l,(ix+4)
2996    39CF  DD6605    		ld	h,(ix+5)
2997    39D2  23        		inc	hl
2998    39D3  23        		inc	hl
2999    39D4  23        		inc	hl
3000    39D5  23        		inc	hl
3001    39D6  7E        		ld	a,(hl)
3002    39D7  FE05      		cp	5
3003    39D9  2810      		jr	z,L1415
3004    39DB  DD6E04    		ld	l,(ix+4)
3005    39DE  DD6605    		ld	h,(ix+5)
3006    39E1  23        		inc	hl
3007    39E2  23        		inc	hl
3008    39E3  23        		inc	hl
3009    39E4  23        		inc	hl
3010    39E5  7E        		ld	a,(hl)
3011    39E6  FE0F      		cp	15
3012    39E8  C2173B    		jp	nz,L1315
3013                    	L1415:
3014                    	; 1350              {
3015                    	; 1351              parttype = PARTEBR;
3016    39EB  DD36F602  		ld	(ix-10),2
3017    39EF  DD36F700  		ld	(ix-9),0
3018                    	; 1352              if (curblkno == 0) /* points to EBR in the MBR */
3019    39F3  210200    		ld	hl,_curblkno
3020    39F6  7E        		ld	a,(hl)
3021    39F7  23        		inc	hl
3022    39F8  B6        		or	(hl)
3023    39F9  23        		inc	hl
3024    39FA  B6        		or	(hl)
3025    39FB  23        		inc	hl
3026    39FC  B6        		or	(hl)
3027    39FD  C2F73A    		jp	nz,L1515
3028                    	; 1353                  {
3029                    	; 1354                  ebrnext = 0;
3030    3A00  97        		sub	a
3031    3A01  321200    		ld	(_ebrnext),a
3032    3A04  321300    		ld	(_ebrnext+1),a
3033    3A07  321400    		ld	(_ebrnext+2),a
3034    3A0A  321500    		ld	(_ebrnext+3),a
3035                    	; 1355                  dskmap[partdsk].partype = EBRCONT;
3036    3A0D  2A0E00    		ld	hl,(_partdsk)
3037    3A10  E5        		push	hl
3038    3A11  212000    		ld	hl,32
3039    3A14  E5        		push	hl
3040    3A15  CD0000    		call	c.imul
3041    3A18  E1        		pop	hl
3042    3A19  015202    		ld	bc,_dskmap
3043    3A1C  09        		add	hl,bc
3044    3A1D  3614      		ld	(hl),20
3045                    	; 1356                  dskmap[partdsk].dskletter = 'A' + partdsk;
3046    3A1F  2A0E00    		ld	hl,(_partdsk)
3047    3A22  E5        		push	hl
3048    3A23  212000    		ld	hl,32
3049    3A26  E5        		push	hl
3050    3A27  CD0000    		call	c.imul
3051    3A2A  E1        		pop	hl
3052    3A2B  015302    		ld	bc,_dskmap+1
3053    3A2E  09        		add	hl,bc
3054    3A2F  3A0E00    		ld	a,(_partdsk)
3055    3A32  C641      		add	a,65
3056    3A34  4F        		ld	c,a
3057    3A35  71        		ld	(hl),c
3058                    	; 1357                  dskmap[partdsk].dskstart = lbastart;
3059    3A36  2A0E00    		ld	hl,(_partdsk)
3060    3A39  E5        		push	hl
3061    3A3A  212000    		ld	hl,32
3062    3A3D  E5        		push	hl
3063    3A3E  CD0000    		call	c.imul
3064    3A41  E1        		pop	hl
3065    3A42  015602    		ld	bc,_dskmap+4
3066    3A45  09        		add	hl,bc
3067    3A46  E5        		push	hl
3068    3A47  DDE5      		push	ix
3069    3A49  C1        		pop	bc
3070    3A4A  21F2FF    		ld	hl,65522
3071    3A4D  09        		add	hl,bc
3072    3A4E  E5        		push	hl
3073    3A4F  CD0000    		call	c.mvl
3074    3A52  F1        		pop	af
3075                    	; 1358                  dskmap[partdsk].dskend = lbastart + lbasize - 1;
3076    3A53  2A0E00    		ld	hl,(_partdsk)
3077    3A56  E5        		push	hl
3078    3A57  212000    		ld	hl,32
3079    3A5A  E5        		push	hl
3080    3A5B  CD0000    		call	c.imul
3081    3A5E  E1        		pop	hl
3082    3A5F  015A02    		ld	bc,_dskmap+8
3083    3A62  09        		add	hl,bc
3084    3A63  E5        		push	hl
3085    3A64  DDE5      		push	ix
3086    3A66  C1        		pop	bc
3087    3A67  21F2FF    		ld	hl,65522
3088    3A6A  09        		add	hl,bc
3089    3A6B  CD0000    		call	c.0mvf
3090    3A6E  210000    		ld	hl,c.r0
3091    3A71  E5        		push	hl
3092    3A72  DDE5      		push	ix
3093    3A74  C1        		pop	bc
3094    3A75  21EEFF    		ld	hl,65518
3095    3A78  09        		add	hl,bc
3096    3A79  E5        		push	hl
3097    3A7A  CD0000    		call	c.ladd
3098    3A7D  3EFF      		ld	a,255
3099    3A7F  320200    		ld	(c.r1+2),a
3100    3A82  87        		add	a,a
3101    3A83  9F        		sbc	a,a
3102    3A84  320300    		ld	(c.r1+3),a
3103    3A87  320100    		ld	(c.r1+1),a
3104    3A8A  320000    		ld	(c.r1),a
3105    3A8D  210000    		ld	hl,c.r1
3106    3A90  E5        		push	hl
3107    3A91  CD0000    		call	c.ladd
3108    3A94  CD0000    		call	c.mvl
3109    3A97  F1        		pop	af
3110                    	; 1359                  dskmap[partdsk].dsksize = lbasize;
3111    3A98  2A0E00    		ld	hl,(_partdsk)
3112    3A9B  E5        		push	hl
3113    3A9C  212000    		ld	hl,32
3114    3A9F  E5        		push	hl
3115    3AA0  CD0000    		call	c.imul
3116    3AA3  E1        		pop	hl
3117    3AA4  015E02    		ld	bc,_dskmap+12
3118    3AA7  09        		add	hl,bc
3119    3AA8  E5        		push	hl
3120    3AA9  DDE5      		push	ix
3121    3AAB  C1        		pop	bc
3122    3AAC  21EEFF    		ld	hl,65518
3123    3AAF  09        		add	hl,bc
3124    3AB0  E5        		push	hl
3125    3AB1  CD0000    		call	c.mvl
3126    3AB4  F1        		pop	af
3127                    	; 1360                  dskmap[partdsk].dsktype[0] = partptr[4];
3128    3AB5  2A0E00    		ld	hl,(_partdsk)
3129    3AB8  E5        		push	hl
3130    3AB9  212000    		ld	hl,32
3131    3ABC  E5        		push	hl
3132    3ABD  CD0000    		call	c.imul
3133    3AC0  E1        		pop	hl
3134    3AC1  016202    		ld	bc,_dskmap+16
3135    3AC4  09        		add	hl,bc
3136    3AC5  DD4E04    		ld	c,(ix+4)
3137    3AC8  DD4605    		ld	b,(ix+5)
3138    3ACB  03        		inc	bc
3139    3ACC  03        		inc	bc
3140    3ACD  03        		inc	bc
3141    3ACE  03        		inc	bc
3142    3ACF  0A        		ld	a,(bc)
3143    3AD0  77        		ld	(hl),a
3144                    	; 1361                  partdsk++;
3145    3AD1  2A0E00    		ld	hl,(_partdsk)
3146    3AD4  23        		inc	hl
3147    3AD5  220E00    		ld	(_partdsk),hl
3148                    	; 1362                  ebrrecs[ebrrecidx++] = lbastart; /* save to handle later */
3149    3AD8  2A1600    		ld	hl,(_ebrrecidx)
3150    3ADB  E5        		push	hl
3151    3ADC  23        		inc	hl
3152    3ADD  221600    		ld	(_ebrrecidx),hl
3153    3AE0  E1        		pop	hl
3154    3AE1  29        		add	hl,hl
3155    3AE2  29        		add	hl,hl
3156    3AE3  011800    		ld	bc,_ebrrecs
3157    3AE6  09        		add	hl,bc
3158    3AE7  E5        		push	hl
3159    3AE8  DDE5      		push	ix
3160    3AEA  C1        		pop	bc
3161    3AEB  21F2FF    		ld	hl,65522
3162    3AEE  09        		add	hl,bc
3163    3AEF  E5        		push	hl
3164    3AF0  CD0000    		call	c.mvl
3165    3AF3  F1        		pop	af
3166                    	; 1363                  }
3167                    	; 1364              else
3168    3AF4  C3463C    		jp	L1215
3169                    	L1515:
3170                    	; 1365                  {
3171                    	; 1366                  ebrnext = curblkno + lbastart;
3172    3AF7  211200    		ld	hl,_ebrnext
3173    3AFA  E5        		push	hl
3174    3AFB  210200    		ld	hl,_curblkno
3175    3AFE  CD0000    		call	c.0mvf
3176    3B01  210000    		ld	hl,c.r0
3177    3B04  E5        		push	hl
3178    3B05  DDE5      		push	ix
3179    3B07  C1        		pop	bc
3180    3B08  21F2FF    		ld	hl,65522
3181    3B0B  09        		add	hl,bc
3182    3B0C  E5        		push	hl
3183    3B0D  CD0000    		call	c.ladd
3184    3B10  CD0000    		call	c.mvl
3185    3B13  F1        		pop	af
3186    3B14  C3463C    		jp	L1215
3187                    	L1315:
3188                    	; 1367                  }
3189                    	; 1368              }
3190                    	; 1369          else
3191                    	; 1370              {
3192                    	; 1371              if (0 < lbasize) /* one more ugly hack to avoid empty partitions */
3193    3B17  DD7EEE    		ld	a,(ix-18)
3194    3B1A  DDB6EF    		or	(ix-17)
3195    3B1D  DDB6F0    		or	(ix-16)
3196    3B20  DDB6F1    		or	(ix-15)
3197    3B23  CA463C    		jp	z,L1215
3198                    	; 1372                  {
3199                    	; 1373                  if (partptr[0] & 0x80)
3200    3B26  DD6E04    		ld	l,(ix+4)
3201    3B29  DD6605    		ld	h,(ix+5)
3202    3B2C  7E        		ld	a,(hl)
3203    3B2D  CB7F      		bit	7,a
3204    3B2F  6F        		ld	l,a
3205    3B30  2815      		jr	z,L1125
3206                    	; 1374                      dskmap[partdsk].bootable = YES;
3207    3B32  2A0E00    		ld	hl,(_partdsk)
3208    3B35  E5        		push	hl
3209    3B36  212000    		ld	hl,32
3210    3B39  E5        		push	hl
3211    3B3A  CD0000    		call	c.imul
3212    3B3D  E1        		pop	hl
3213    3B3E  015402    		ld	bc,_dskmap+2
3214    3B41  09        		add	hl,bc
3215    3B42  3601      		ld	(hl),1
3216    3B44  23        		inc	hl
3217    3B45  3600      		ld	(hl),0
3218                    	L1125:
3219                    	; 1375                  if (curblkno == 0)
3220    3B47  210200    		ld	hl,_curblkno
3221    3B4A  7E        		ld	a,(hl)
3222    3B4B  23        		inc	hl
3223    3B4C  B6        		or	(hl)
3224    3B4D  23        		inc	hl
3225    3B4E  B6        		or	(hl)
3226    3B4F  23        		inc	hl
3227    3B50  B6        		or	(hl)
3228    3B51  2014      		jr	nz,L1225
3229                    	; 1376                      dskmap[partdsk].partype = PARTMBR;
3230    3B53  2A0E00    		ld	hl,(_partdsk)
3231    3B56  E5        		push	hl
3232    3B57  212000    		ld	hl,32
3233    3B5A  E5        		push	hl
3234    3B5B  CD0000    		call	c.imul
3235    3B5E  E1        		pop	hl
3236    3B5F  015202    		ld	bc,_dskmap
3237    3B62  09        		add	hl,bc
3238    3B63  3601      		ld	(hl),1
3239                    	; 1377                  else
3240    3B65  1812      		jr	L1325
3241                    	L1225:
3242                    	; 1378                      dskmap[partdsk].partype = PARTEBR;
3243    3B67  2A0E00    		ld	hl,(_partdsk)
3244    3B6A  E5        		push	hl
3245    3B6B  212000    		ld	hl,32
3246    3B6E  E5        		push	hl
3247    3B6F  CD0000    		call	c.imul
3248    3B72  E1        		pop	hl
3249    3B73  015202    		ld	bc,_dskmap
3250    3B76  09        		add	hl,bc
3251    3B77  3602      		ld	(hl),2
3252                    	L1325:
3253                    	; 1379                  dskmap[partdsk].dskletter = 'A' + partdsk;
3254    3B79  2A0E00    		ld	hl,(_partdsk)
3255    3B7C  E5        		push	hl
3256    3B7D  212000    		ld	hl,32
3257    3B80  E5        		push	hl
3258    3B81  CD0000    		call	c.imul
3259    3B84  E1        		pop	hl
3260    3B85  015302    		ld	bc,_dskmap+1
3261    3B88  09        		add	hl,bc
3262    3B89  3A0E00    		ld	a,(_partdsk)
3263    3B8C  C641      		add	a,65
3264    3B8E  4F        		ld	c,a
3265    3B8F  71        		ld	(hl),c
3266                    	; 1380                  dskmap[partdsk].dskstart = curblkno + lbastart;
3267    3B90  2A0E00    		ld	hl,(_partdsk)
3268    3B93  E5        		push	hl
3269    3B94  212000    		ld	hl,32
3270    3B97  E5        		push	hl
3271    3B98  CD0000    		call	c.imul
3272    3B9B  E1        		pop	hl
3273    3B9C  015602    		ld	bc,_dskmap+4
3274    3B9F  09        		add	hl,bc
3275    3BA0  E5        		push	hl
3276    3BA1  210200    		ld	hl,_curblkno
3277    3BA4  CD0000    		call	c.0mvf
3278    3BA7  210000    		ld	hl,c.r0
3279    3BAA  E5        		push	hl
3280    3BAB  DDE5      		push	ix
3281    3BAD  C1        		pop	bc
3282    3BAE  21F2FF    		ld	hl,65522
3283    3BB1  09        		add	hl,bc
3284    3BB2  E5        		push	hl
3285    3BB3  CD0000    		call	c.ladd
3286    3BB6  CD0000    		call	c.mvl
3287    3BB9  F1        		pop	af
3288                    	; 1381                  dskmap[partdsk].dskend = curblkno + lbastart + lbasize - 1;
3289    3BBA  2A0E00    		ld	hl,(_partdsk)
3290    3BBD  E5        		push	hl
3291    3BBE  212000    		ld	hl,32
3292    3BC1  E5        		push	hl
3293    3BC2  CD0000    		call	c.imul
3294    3BC5  E1        		pop	hl
3295    3BC6  015A02    		ld	bc,_dskmap+8
3296    3BC9  09        		add	hl,bc
3297    3BCA  E5        		push	hl
3298    3BCB  210200    		ld	hl,_curblkno
3299    3BCE  CD0000    		call	c.0mvf
3300    3BD1  210000    		ld	hl,c.r0
3301    3BD4  E5        		push	hl
3302    3BD5  DDE5      		push	ix
3303    3BD7  C1        		pop	bc
3304    3BD8  21F2FF    		ld	hl,65522
3305    3BDB  09        		add	hl,bc
3306    3BDC  E5        		push	hl
3307    3BDD  CD0000    		call	c.ladd
3308    3BE0  DDE5      		push	ix
3309    3BE2  C1        		pop	bc
3310    3BE3  21EEFF    		ld	hl,65518
3311    3BE6  09        		add	hl,bc
3312    3BE7  E5        		push	hl
3313    3BE8  CD0000    		call	c.ladd
3314    3BEB  3EFF      		ld	a,255
3315    3BED  320200    		ld	(c.r1+2),a
3316    3BF0  87        		add	a,a
3317    3BF1  9F        		sbc	a,a
3318    3BF2  320300    		ld	(c.r1+3),a
3319    3BF5  320100    		ld	(c.r1+1),a
3320    3BF8  320000    		ld	(c.r1),a
3321    3BFB  210000    		ld	hl,c.r1
3322    3BFE  E5        		push	hl
3323    3BFF  CD0000    		call	c.ladd
3324    3C02  CD0000    		call	c.mvl
3325    3C05  F1        		pop	af
3326                    	; 1382                  dskmap[partdsk].dsksize = lbasize;
3327    3C06  2A0E00    		ld	hl,(_partdsk)
3328    3C09  E5        		push	hl
3329    3C0A  212000    		ld	hl,32
3330    3C0D  E5        		push	hl
3331    3C0E  CD0000    		call	c.imul
3332    3C11  E1        		pop	hl
3333    3C12  015E02    		ld	bc,_dskmap+12
3334    3C15  09        		add	hl,bc
3335    3C16  E5        		push	hl
3336    3C17  DDE5      		push	ix
3337    3C19  C1        		pop	bc
3338    3C1A  21EEFF    		ld	hl,65518
3339    3C1D  09        		add	hl,bc
3340    3C1E  E5        		push	hl
3341    3C1F  CD0000    		call	c.mvl
3342    3C22  F1        		pop	af
3343                    	; 1383                  dskmap[partdsk].dsktype[0] = partptr[4];
3344    3C23  2A0E00    		ld	hl,(_partdsk)
3345    3C26  E5        		push	hl
3346    3C27  212000    		ld	hl,32
3347    3C2A  E5        		push	hl
3348    3C2B  CD0000    		call	c.imul
3349    3C2E  E1        		pop	hl
3350    3C2F  016202    		ld	bc,_dskmap+16
3351    3C32  09        		add	hl,bc
3352    3C33  DD4E04    		ld	c,(ix+4)
3353    3C36  DD4605    		ld	b,(ix+5)
3354    3C39  03        		inc	bc
3355    3C3A  03        		inc	bc
3356    3C3B  03        		inc	bc
3357    3C3C  03        		inc	bc
3358    3C3D  0A        		ld	a,(bc)
3359    3C3E  77        		ld	(hl),a
3360                    	; 1384                  partdsk++;
3361    3C3F  2A0E00    		ld	hl,(_partdsk)
3362    3C42  23        		inc	hl
3363    3C43  220E00    		ld	(_partdsk),hl
3364                    	L1215:
3365                    	; 1385                  }
3366                    	; 1386              }
3367                    	; 1387          }
3368                    	; 1388  
3369                    	; 1389      if (sdtestflg)
3370    3C46  2A0000    		ld	hl,(_sdtestflg)
3371    3C49  7C        		ld	a,h
3372    3C4A  B5        		or	l
3373    3C4B  CAE83C    		jp	z,L1425
3374                    	; 1390          {
3375                    	; 1391          printf("  partition start LBA: %lu [%08lx]\n",
3376                    	; 1392                 curblkno + lbastart, curblkno + lbastart);
3377    3C4E  210200    		ld	hl,_curblkno
3378    3C51  CD0000    		call	c.0mvf
3379    3C54  210000    		ld	hl,c.r0
3380    3C57  E5        		push	hl
3381    3C58  DDE5      		push	ix
3382    3C5A  C1        		pop	bc
3383    3C5B  21F2FF    		ld	hl,65522
3384    3C5E  09        		add	hl,bc
3385    3C5F  E5        		push	hl
3386    3C60  CD0000    		call	c.ladd
3387    3C63  E1        		pop	hl
3388    3C64  23        		inc	hl
3389    3C65  23        		inc	hl
3390    3C66  4E        		ld	c,(hl)
3391    3C67  23        		inc	hl
3392    3C68  46        		ld	b,(hl)
3393    3C69  C5        		push	bc
3394    3C6A  2B        		dec	hl
3395    3C6B  2B        		dec	hl
3396    3C6C  2B        		dec	hl
3397    3C6D  4E        		ld	c,(hl)
3398    3C6E  23        		inc	hl
3399    3C6F  46        		ld	b,(hl)
3400    3C70  C5        		push	bc
3401    3C71  210200    		ld	hl,_curblkno
3402    3C74  CD0000    		call	c.0mvf
3403    3C77  210000    		ld	hl,c.r0
3404    3C7A  E5        		push	hl
3405    3C7B  DDE5      		push	ix
3406    3C7D  C1        		pop	bc
3407    3C7E  21F2FF    		ld	hl,65522
3408    3C81  09        		add	hl,bc
3409    3C82  E5        		push	hl
3410    3C83  CD0000    		call	c.ladd
3411    3C86  E1        		pop	hl
3412    3C87  23        		inc	hl
3413    3C88  23        		inc	hl
3414    3C89  4E        		ld	c,(hl)
3415    3C8A  23        		inc	hl
3416    3C8B  46        		ld	b,(hl)
3417    3C8C  C5        		push	bc
3418    3C8D  2B        		dec	hl
3419    3C8E  2B        		dec	hl
3420    3C8F  2B        		dec	hl
3421    3C90  4E        		ld	c,(hl)
3422    3C91  23        		inc	hl
3423    3C92  46        		ld	b,(hl)
3424    3C93  C5        		push	bc
3425    3C94  215E36    		ld	hl,L5542
3426    3C97  CD0000    		call	_printf
3427    3C9A  F1        		pop	af
3428    3C9B  F1        		pop	af
3429    3C9C  F1        		pop	af
3430    3C9D  F1        		pop	af
3431                    	; 1393          printf("  partition size LBA: %lu [%08lx], %lu MByte\n",
3432                    	; 1394                 lbasize, lbasize, lbasize >> 11);
3433    3C9E  DDE5      		push	ix
3434    3CA0  C1        		pop	bc
3435    3CA1  21EEFF    		ld	hl,65518
3436    3CA4  09        		add	hl,bc
3437    3CA5  CD0000    		call	c.0mvf
3438    3CA8  210000    		ld	hl,c.r0
3439    3CAB  E5        		push	hl
3440    3CAC  210B00    		ld	hl,11
3441    3CAF  E5        		push	hl
3442    3CB0  CD0000    		call	c.ulrsh
3443    3CB3  E1        		pop	hl
3444    3CB4  23        		inc	hl
3445    3CB5  23        		inc	hl
3446    3CB6  4E        		ld	c,(hl)
3447    3CB7  23        		inc	hl
3448    3CB8  46        		ld	b,(hl)
3449    3CB9  C5        		push	bc
3450    3CBA  2B        		dec	hl
3451    3CBB  2B        		dec	hl
3452    3CBC  2B        		dec	hl
3453    3CBD  4E        		ld	c,(hl)
3454    3CBE  23        		inc	hl
3455    3CBF  46        		ld	b,(hl)
3456    3CC0  C5        		push	bc
3457    3CC1  DD66F1    		ld	h,(ix-15)
3458    3CC4  DD6EF0    		ld	l,(ix-16)
3459    3CC7  E5        		push	hl
3460    3CC8  DD66EF    		ld	h,(ix-17)
3461    3CCB  DD6EEE    		ld	l,(ix-18)
3462    3CCE  E5        		push	hl
3463    3CCF  DD66F1    		ld	h,(ix-15)
3464    3CD2  DD6EF0    		ld	l,(ix-16)
3465    3CD5  E5        		push	hl
3466    3CD6  DD66EF    		ld	h,(ix-17)
3467    3CD9  DD6EEE    		ld	l,(ix-18)
3468    3CDC  E5        		push	hl
3469    3CDD  218236    		ld	hl,L5642
3470    3CE0  CD0000    		call	_printf
3471    3CE3  210C00    		ld	hl,12
3472    3CE6  39        		add	hl,sp
3473    3CE7  F9        		ld	sp,hl
3474                    	L1425:
3475                    	; 1395          } /* sdtestflg */
3476                    	; 1396      if (partptr[4] == 0xee) /* GPT partitions */
3477    3CE8  DD6E04    		ld	l,(ix+4)
3478    3CEB  DD6605    		ld	h,(ix+5)
3479    3CEE  23        		inc	hl
3480    3CEF  23        		inc	hl
3481    3CF0  23        		inc	hl
3482    3CF1  23        		inc	hl
3483    3CF2  7E        		ld	a,(hl)
3484    3CF3  FEEE      		cp	238
3485    3CF5  C25E3D    		jp	nz,L1525
3486                    	; 1397          {
3487                    	; 1398          parttype = PARTGPT;
3488    3CF8  DD36F603  		ld	(ix-10),3
3489    3CFC  DD36F700  		ld	(ix-9),0
3490                    	; 1399          if (sdtestflg)
3491    3D00  2A0000    		ld	hl,(_sdtestflg)
3492    3D03  7C        		ld	a,h
3493    3D04  B5        		or	l
3494    3D05  2806      		jr	z,L1625
3495                    	; 1400              {
3496                    	; 1401              printf("GTP partitions\n");
3497    3D07  21B036    		ld	hl,L5742
3498    3D0A  CD0000    		call	_printf
3499                    	L1625:
3500                    	; 1402              } /* sdtestflg */
3501                    	; 1403          sdgpthdr(lbastart); /* handle GTP partitions */
3502    3D0D  DD66F5    		ld	h,(ix-11)
3503    3D10  DD6EF4    		ld	l,(ix-12)
3504    3D13  E5        		push	hl
3505    3D14  DD66F3    		ld	h,(ix-13)
3506    3D17  DD6EF2    		ld	l,(ix-14)
3507    3D1A  CD3E33    		call	_sdgpthdr
3508    3D1D  F1        		pop	af
3509                    	; 1404          /* re-read MBR on sector 0
3510                    	; 1405             This is probably not needed as there
3511                    	; 1406             is only one entry (the first one)
3512                    	; 1407             in the MBR when using GPT */
3513                    	; 1408          if (sdread(sdrdbuf, 0))
3514    3D1E  21C336    		ld	hl,L261+3
3515    3D21  46        		ld	b,(hl)
3516    3D22  2B        		dec	hl
3517    3D23  4E        		ld	c,(hl)
3518    3D24  C5        		push	bc
3519    3D25  2B        		dec	hl
3520    3D26  46        		ld	b,(hl)
3521    3D27  2B        		dec	hl
3522    3D28  4E        		ld	c,(hl)
3523    3D29  C5        		push	bc
3524    3D2A  214C00    		ld	hl,_sdrdbuf
3525    3D2D  CDE320    		call	_sdread
3526    3D30  F1        		pop	af
3527    3D31  F1        		pop	af
3528    3D32  79        		ld	a,c
3529    3D33  B0        		or	b
3530    3D34  2815      		jr	z,L1725
3531                    	; 1409              {
3532                    	; 1410              curblkno = 0;
3533                    	; 1411              curblkok = YES;
3534    3D36  210100    		ld	hl,1
3535                    	;    1  /*  z80sdbt.c Boot and SD card test program.
3536                    	;    2   *
3537                    	;    3   *  Boot code for my DIY Z80 Computer. This
3538                    	;    4   *  program is compiled with Whitesmiths/COSMIC
3539                    	;    5   *  C compiler for Z80.
3540                    	;    6   *
3541                    	;    7   *  Initializes the hardware and detects the
3542                    	;    8   *  presence and partitioning of an attached SD card.
3543                    	;    9   *
3544                    	;   10   *  You are free to use, modify, and redistribute
3545                    	;   11   *  this source code. No warranties are given.
3546                    	;   12   *  Hastily Cobbled Together 2021 and 2022
3547                    	;   13   *  by Hans-Ake Lund
3548                    	;   14   *
3549                    	;   15   */
3550                    	;   16  
3551                    	;   17  #include <std.h>
3552                    	;   18  #include "z80computer.h"
3553                    	;   19  #include "builddate.h"
3554                    	;   20  
3555                    	;   21  /* Program name and version */
3556                    	;   22  #define PRGNAME "z80sdbt "
3557                    	;   23  #define VERSION "version 0.8, "
3558                    	;   24  /* Address in high RAM where to copy uploader */
3559                    	;   25  #define UPLADDR 0xf000
3560                    	;   26  
3561                    	;   27  /* This code should be cleaned up when
3562                    	;   28     remaining functions are implemented
3563                    	;   29   */
3564                    	;   30  #define PARTZRO 0  /* Empty partition entry */
3565                    	;   31  #define PARTMBR 1  /* MBR partition */
3566                    	;   32  #define PARTEBR 2  /* EBR logical partition */
3567                    	;   33  #define PARTGPT 3  /* GPT partition */
3568                    	;   34  #define EBRCONT 20 /* EBR container partition in MBR */
3569                    	;   35  
3570                    	;   36  struct partentry
3571                    	;   37      {
3572                    	;   38      char partype;
3573                    	;   39      char dskletter;
3574                    	;   40      int bootable;
3575                    	;   41      unsigned long dskstart;
3576                    	;   42      unsigned long dskend;
3577                    	;   43      unsigned long dsksize;
3578                    	;   44      unsigned char dsktype[16];
3579                    	;   45      } dskmap[16];
3580                    	;   46  
3581                    	;   47  unsigned char dsksign[4]; /* MBR/EBR disk signature */
3582                    	;   48  
3583                    	;   49  /* Function prototypes */
3584                    	;   50  void sdmbrpart(unsigned long);
3585                    	;   51  
3586                    	;   52  /* External data */
3587                    	;   53  extern const char upload[];
3588                    	;   54  extern const int upload_size;
3589                    	;   55  
3590                    	;   56  /* RAM/EPROM probe */
3591                    	;   57  const int ramprobe = 0;
3592                    	;   58  int *rampptr;
3593                    	;   59  
3594                    	;   60  /* Response length in bytes
3595                    	;   61   */
3596                    	;   62  #define R1_LEN 1
3597                    	;   63  #define R3_LEN 5
3598                    	;   64  #define R7_LEN 5
3599                    	;   65  
3600                    	;   66  /* The SD card commands (5 bytes) and a CRC7 byte as the last byte.
3601                    	;   67   * (The CRC7 byte in the tables below are only for information,
3602                    	;   68   * it is calculated by the sdcommand routine.)
3603                    	;   69   */
3604                    	;   70  const unsigned char cmd0[] = {0x40, 0x00, 0x00, 0x00, 0x00, 0x95};
3605                    	;   71  const unsigned char cmd8[] = {0x48, 0x00, 0x00, 0x01, 0xaa, 0x87};
3606                    	;   72  const unsigned char cmd9[] = {0x49, 0x00, 0x00, 0x00, 0x00, 0xaf};
3607                    	;   73  const unsigned char cmd10[] = {0x4a, 0x00, 0x00, 0x00, 0x00, 0x1b};
3608                    	;   74  const unsigned char cmd16[] = {0x50, 0x00, 0x00, 0x02, 0x00, 0x15};
3609                    	;   75  const unsigned char cmd17[] = {0x51, 0x00, 0x00, 0x00, 0x00, 0x55};
3610                    	;   76  const unsigned char cmd24[] = {0x58, 0x00, 0x00, 0x00, 0x00, 0x6f};
3611                    	;   77  const unsigned char cmd55[] = {0x77, 0x00, 0x00, 0x00, 0x00, 0x65};
3612                    	;   78  const unsigned char cmd58[] = {0x7a, 0x00, 0x00, 0x00, 0x00, 0xfd};
3613                    	;   79  const unsigned char acmd41[] = {0x69, 0x40, 0x00, 0x01, 0xaa, 0x33};
3614                    	;   80  
3615                    	;   81  /* Partition identifiers
3616                    	;   82   */
3617                    	;   83  /* For GPT I have decided that a CP/M partition
3618                    	;   84   * has GUID: AC7176FD-8D55-4FFF-86A5-A36D6368D0CB
3619                    	;   85   */
3620                    	;   86  const unsigned char gptcpm[] =
3621                    	;   87      {
3622                    	;   88      0xfd, 0x76, 0x71, 0xac, 0x55, 0x8d, 0xff, 0x4f,
3623                    	;   89      0x86, 0xa5, 0xa3, 0x6d, 0x63, 0x68, 0xd0, 0xcb
3624                    	;   90      };
3625                    	;   91  /* For MBR/EBR the partition type for CP/M is 0x52
3626                    	;   92   * according to: https://en.wikipedia.org/wiki/Partition_type
3627                    	;   93   */
3628                    	;   94  const unsigned char mbrcpm = 0x52;    /* CP/M partition */
3629                    	;   95  const unsigned char mbrexcode = 0x5f; /* Z80 executable code partition */
3630                    	;   96  /* has a special format that */
3631                    	;   97  /* includes number of sectors to */
3632                    	;   98  /* load and a signature, TBD */
3633                    	;   99  
3634                    	;  100  /* Buffers
3635                    	;  101   */
3636                    	;  102  unsigned char sdrdbuf[512];  /* recieved data from the SD card */
3637                    	;  103  
3638                    	;  104  unsigned char ocrreg[4];     /* SD card OCR register */
3639                    	;  105  unsigned char cidreg[16];    /* SD card CID register */
3640                    	;  106  unsigned char csdreg[16];    /* SD card CSD register */
3641                    	;  107  unsigned long ebrrecs[4];    /* detected EBR records to process */
3642                    	;  108  int ebrrecidx; /* how many EBR records that are populated */
3643                    	;  109  unsigned long ebrnext; /* next chained ebr record */
3644                    	;  110  
3645                    	;  111  /* Variables
3646                    	;  112   */
3647                    	;  113  int curblkok;  /* if YES curblockno is read into buffer */
3648                    	;  114  int partdsk;   /* partition/disk number, 0 = disk A */
3649                    	;  115  int sdinitok;  /* SD card initialized and ready */
3650                    	;  116  int sdver2;    /* SD card version 2 if YES, version 1 if NO */
3651                    	;  117  unsigned long blkmult;   /* block address multiplier */
3652                    	;  118  unsigned long curblkno;  /* block in buffer if curblkok == YES */
3653                    	;  119  
3654                    	;  120  /* debug bool */
3655                    	;  121  int sdtestflg;
3656                    	;  122  
3657                    	;  123  /* CRC routines from:
3658                    	;  124   * https://github.com/LonelyWolf/stm32/blob/master/stm32l-dosfs/sdcard.c
3659                    	;  125   */
3660                    	;  126  
3661                    	;  127  /*
3662                    	;  128  // Calculate CRC7
3663                    	;  129  // It's a 7 bit CRC with polynomial x^7 + x^3 + 1
3664                    	;  130  // input:
3665                    	;  131  //   crcIn - the CRC before (0 for first step)
3666                    	;  132  //   data - byte for CRC calculation
3667                    	;  133  // return: the new CRC7
3668                    	;  134  */
3669                    	;  135  unsigned char CRC7_one(unsigned char crcIn, unsigned char data)
3670                    	;  136      {
3671                    	;  137      const unsigned char g = 0x89;
3672                    	;  138      unsigned char i;
3673                    	;  139  
3674                    	;  140      crcIn ^= data;
3675                    	;  141      for (i = 0; i < 8; i++)
3676                    	;  142          {
3677                    	;  143          if (crcIn & 0x80) crcIn ^= g;
3678                    	;  144          crcIn <<= 1;
3679                    	;  145          }
3680                    	;  146  
3681                    	;  147      return crcIn;
3682                    	;  148      }
3683                    	;  149  
3684                    	;  150  /*
3685                    	;  151  // Calculate CRC16 CCITT
3686                    	;  152  // It's a 16 bit CRC with polynomial x^16 + x^12 + x^5 + 1
3687                    	;  153  // input:
3688                    	;  154  //   crcIn - the CRC before (0 for rist step)
3689                    	;  155  //   data - byte for CRC calculation
3690                    	;  156  // return: the CRC16 value
3691                    	;  157  */
3692                    	;  158  unsigned int CRC16_one(unsigned int crcIn, unsigned char data)
3693                    	;  159      {
3694                    	;  160      crcIn  = (unsigned char)(crcIn >> 8)|(crcIn << 8);
3695                    	;  161      crcIn ^=  data;
3696                    	;  162      crcIn ^= (unsigned char)(crcIn & 0xff) >> 4;
3697                    	;  163      crcIn ^= (crcIn << 8) << 4;
3698                    	;  164      crcIn ^= ((crcIn & 0xff) << 4) << 1;
3699                    	;  165  
3700                    	;  166      return crcIn;
3701                    	;  167      }
3702                    	;  168  
3703                    	;  169  /* Send command to SD card and recieve answer.
3704                    	;  170   * A command is 5 bytes long and is followed by
3705                    	;  171   * a CRC7 checksum byte.
3706                    	;  172   * Returns a pointer to the response
3707                    	;  173   * or 0 if no response start bit found.
3708                    	;  174   */
3709                    	;  175  unsigned char *sdcommand(unsigned char *sdcmdp,
3710                    	;  176                           unsigned char *recbuf, int recbytes)
3711                    	;  177      {
3712                    	;  178      int searchn;  /* byte counter to search for response */
3713                    	;  179      int sdcbytes; /* byte counter for bytes to send */
3714                    	;  180      unsigned char *retptr; /* pointer used to store response */
3715                    	;  181      unsigned char rbyte;   /* recieved byte */
3716                    	;  182      unsigned char crc = 0; /* calculated CRC7 */
3717                    	;  183  
3718                    	;  184      /* send 8*2 clockpules */
3719                    	;  185      spiio(0xff);
3720                    	;  186      spiio(0xff);
3721                    	;  187      for (sdcbytes = 5; 0 < sdcbytes; sdcbytes--) /* send bytes */
3722                    	;  188          {
3723                    	;  189          crc = CRC7_one(crc, *sdcmdp);
3724                    	;  190          spiio(*sdcmdp++);
3725                    	;  191          }
3726                    	;  192      spiio(crc | 0x01);
3727                    	;  193      /* search for recieved byte with start bit
3728                    	;  194         for a maximum of 10 recieved bytes  */
3729                    	;  195      for (searchn = 10; 0 < searchn; searchn--)
3730                    	;  196          {
3731                    	;  197          rbyte = spiio(0xff);
3732                    	;  198          if ((rbyte & 0x80) == 0)
3733                    	;  199              break;
3734                    	;  200          }
3735                    	;  201      if (searchn == 0) /* no start bit found */
3736                    	;  202          return (NO);
3737                    	;  203      retptr = recbuf;
3738                    	;  204      *retptr++ = rbyte;
3739                    	;  205      for (; 1 < recbytes; recbytes--) /* recieve bytes */
3740                    	;  206          *retptr++ = spiio(0xff);
3741                    	;  207      return (recbuf);
3742                    	;  208      }
3743                    	;  209  
3744                    	;  210  /* Initialise SD card interface
3745                    	;  211   *
3746                    	;  212   * returns YES if ok and NO if not ok
3747                    	;  213   *
3748                    	;  214   * References:
3749                    	;  215   *   https://www.sdcard.org/downloads/pls/
3750                    	;  216   *      Physical Layer Simplified Specification version 8.0
3751                    	;  217   *
3752                    	;  218   * A nice flowchart how to initialize:
3753                    	;  219   *   https://www.totalphase.com/blog/2018/08/set-sdc-mmc-cards-spi-mode-verify-files-successfully-programmed/
3754                    	;  220   *
3755                    	;  221   */
3756                    	;  222  int sdinit()
3757                    	;  223      {
3758                    	;  224      int nbytes;  /* byte counter */
3759                    	;  225      int tries;   /* tries to get to active state or searching for data  */
3760                    	;  226      int wtloop;  /* timer loop when trying to enter active state */
3761                    	;  227      unsigned char cmdbuf[5];   /* buffer to build command in */
3762                    	;  228      unsigned char rstatbuf[5]; /* buffer to recieve status in */
3763                    	;  229      unsigned char *statptr;    /* pointer to returned status from SD command */
3764                    	;  230      unsigned char crc;         /* crc register for CID and CSD */
3765                    	;  231      unsigned char rbyte;       /* recieved byte */
3766                    	;  232      unsigned char *prtptr;     /* for debug printing */
3767                    	;  233  
3768                    	;  234      ledon();
3769                    	;  235      spideselect();
3770                    	;  236      sdinitok = NO;
3771                    	;  237  
3772                    	;  238      /* start to generate 9*8 clock pulses with not selected SD card */
3773                    	;  239      for (nbytes = 9; 0 < nbytes; nbytes--)
3774                    	;  240          spiio(0xff);
3775                    	;  241      if (sdtestflg)
3776                    	;  242          {
3777                    	;  243          printf("\nSent 8*8 (72) clock pulses, select not active\n");
3778                    	;  244          } /* sdtestflg */
3779                    	;  245      spiselect();
3780                    	;  246  
3781                    	;  247      /* CMD0: GO_IDLE_STATE */
3782                    	;  248      for (tries = 0; tries < 10; tries++)
3783                    	;  249          {
3784                    	;  250          memcpy(cmdbuf, cmd0, 5);
3785                    	;  251          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3786                    	;  252          if (sdtestflg)
3787                    	;  253              {
3788                    	;  254              if (!statptr)
3789                    	;  255                  printf("CMD0: no response\n");
3790                    	;  256              else
3791                    	;  257                  printf("CMD0: GO_IDLE_STATE, R1 response [%02x]\n", statptr[0]);
3792                    	;  258              } /* sdtestflg */
3793                    	;  259          if (!statptr)
3794                    	;  260              {
3795                    	;  261              spideselect();
3796                    	;  262              ledoff();
3797                    	;  263              return (NO);
3798                    	;  264              }
3799                    	;  265          if (statptr[0] == 0x01)
3800                    	;  266              break;
3801                    	;  267          for (wtloop = 0; wtloop < tries * 10; wtloop++)
3802                    	;  268              {
3803                    	;  269              /* wait loop, time increasing for each try */
3804                    	;  270              spiio(0xff);
3805                    	;  271              }
3806                    	;  272          }
3807                    	;  273  
3808                    	;  274      /* CMD8: SEND_IF_COND */
3809                    	;  275      memcpy(cmdbuf, cmd8, 5);
3810                    	;  276      statptr = sdcommand(cmdbuf, rstatbuf, R7_LEN);
3811                    	;  277      if (sdtestflg)
3812                    	;  278          {
3813                    	;  279          if (!statptr)
3814                    	;  280              printf("CMD8: no response\n");
3815                    	;  281          else
3816                    	;  282              {
3817                    	;  283              printf("CMD8: SEND_IF_COND, R7 response [%02x %02x %02x %02x %02x], ",
3818                    	;  284                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
3819                    	;  285              if (!(statptr[0] & 0xfe)) /* no error */
3820                    	;  286                  {
3821                    	;  287                  if (statptr[4] == 0xaa)
3822                    	;  288                      printf("echo back ok, ");
3823                    	;  289                  else
3824                    	;  290                      printf("invalid echo back\n");
3825                    	;  291                  }
3826                    	;  292              }
3827                    	;  293          } /* sdtestflg */
3828                    	;  294      if (!statptr || (statptr[0] & 0xfe)) /* if no answer or error */
3829                    	;  295          {
3830                    	;  296          sdver2 = NO;
3831                    	;  297          if (sdtestflg)
3832                    	;  298              {
3833                    	;  299              printf("probably SD ver. 1\n");
3834                    	;  300              } /* sdtestflg */
3835                    	;  301          }
3836                    	;  302      else
3837                    	;  303          {
3838                    	;  304          sdver2 = YES;
3839                    	;  305          if (statptr[4] != 0xaa) /* but invalid echo back */
3840                    	;  306              {
3841                    	;  307              spideselect();
3842                    	;  308              ledoff();
3843                    	;  309              return (NO);
3844                    	;  310              }
3845                    	;  311          if (sdtestflg)
3846                    	;  312              {
3847                    	;  313              printf("SD ver 2\n");
3848                    	;  314              } /* sdtestflg */
3849                    	;  315          }
3850                    	;  316  
3851                    	;  317      /* CMD55: APP_CMD followed by ACMD41: SEND_OP_COND until status is 0x00 */
3852                    	;  318      for (tries = 0; tries < 20; tries++)
3853                    	;  319          {
3854                    	;  320          memcpy(cmdbuf, cmd55, 5);
3855                    	;  321          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3856                    	;  322          if (sdtestflg)
3857                    	;  323              {
3858                    	;  324              if (!statptr)
3859                    	;  325                  printf("CMD55: no response\n");
3860                    	;  326              else
3861                    	;  327                  printf("CMD55: APP_CMD, R1 response [%02x]\n", statptr[0]);
3862                    	;  328              } /* sdtestflg */
3863                    	;  329          if (!statptr)
3864                    	;  330              {
3865                    	;  331              spideselect();
3866                    	;  332              ledoff();
3867                    	;  333              return (NO);
3868                    	;  334              }
3869                    	;  335          memcpy(cmdbuf, acmd41, 5);
3870                    	;  336          if (sdver2)
3871                    	;  337              cmdbuf[1] = 0x40;
3872                    	;  338          else
3873                    	;  339              cmdbuf[1] = 0x00;
3874                    	;  340          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3875                    	;  341          if (sdtestflg)
3876                    	;  342              {
3877                    	;  343              if (!statptr)
3878                    	;  344                  printf("ACMD41: no response\n");
3879                    	;  345              else
3880                    	;  346                  printf("ACMD41: SEND_OP_COND, R1 response [%02x]%s\n",
3881                    	;  347                         statptr[0], (statptr[0] == 0x00) ? " - ready" : "");
3882                    	;  348              } /* sdtestflg */
3883                    	;  349          if (!statptr)
3884                    	;  350              {
3885                    	;  351              spideselect();
3886                    	;  352              ledoff();
3887                    	;  353              return (NO);
3888                    	;  354              }
3889                    	;  355          if (statptr[0] == 0x00) /* now the SD card is ready */
3890                    	;  356              {
3891                    	;  357              break;
3892                    	;  358              }
3893                    	;  359          for (wtloop = 0; wtloop < tries * 10; wtloop++)
3894                    	;  360              {
3895                    	;  361              /* wait loop, time increasing for each try */
3896                    	;  362              spiio(0xff);
3897                    	;  363              }
3898                    	;  364          }
3899                    	;  365  
3900                    	;  366      /* CMD58: READ_OCR */
3901                    	;  367      /* According to the flow chart this should not work
3902                    	;  368         for SD ver. 1 but the response is ok anyway
3903                    	;  369         all tested SD cards  */
3904                    	;  370      memcpy(cmdbuf, cmd58, 5);
3905                    	;  371      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
3906                    	;  372      if (sdtestflg)
3907                    	;  373          {
3908                    	;  374          if (!statptr)
3909                    	;  375              printf("CMD58: no response\n");
3910                    	;  376          else
3911                    	;  377              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
3912                    	;  378                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
3913                    	;  379          } /* sdtestflg */
3914                    	;  380      if (!statptr)
3915                    	;  381          {
3916                    	;  382          spideselect();
3917                    	;  383          ledoff();
3918                    	;  384          return (NO);
3919                    	;  385          }
3920                    	;  386      memcpy(&ocrreg[0], &statptr[1], sizeof (ocrreg));
3921                    	;  387      blkmult = 1; /* assume block address */
3922                    	;  388      if (ocrreg[0] & 0x80)
3923                    	;  389          {
3924                    	;  390          /* SD Ver.2+ */
3925                    	;  391          if (!(ocrreg[0] & 0x40))
3926                    	;  392              {
3927                    	;  393              /* SD Ver.2+, Byte address */
3928                    	;  394              blkmult = 512;
3929                    	;  395              }
3930                    	;  396          }
3931                    	;  397  
3932                    	;  398      /* CMD 16: SET_BLOCKLEN, only if Byte addressing */
3933                    	;  399      if (blkmult == 512)
3934                    	;  400          {
3935                    	;  401          memcpy(cmdbuf, cmd16, 5);
3936                    	;  402          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3937                    	;  403          if (sdtestflg)
3938                    	;  404              {
3939                    	;  405              if (!statptr)
3940                    	;  406                  printf("CMD16: no response\n");
3941                    	;  407              else
3942                    	;  408                  printf("CMD16: SET_BLOCKLEN (to 512 bytes), R1 response [%02x]\n",
3943                    	;  409                         statptr[0]);
3944                    	;  410              } /* sdtestflg */
3945                    	;  411          if (!statptr)
3946                    	;  412              {
3947                    	;  413              spideselect();
3948                    	;  414              ledoff();
3949                    	;  415              return (NO);
3950                    	;  416              }
3951                    	;  417          }
3952                    	;  418      /* Register information:
3953                    	;  419       *   https://www.cameramemoryspeed.com/sd-memory-card-faq/reading-sd-card-cid-serial-psn-internal-numbers/
3954                    	;  420       */
3955                    	;  421  
3956                    	;  422      /* CMD10: SEND_CID */
3957                    	;  423      memcpy(cmdbuf, cmd10, 5);
3958                    	;  424      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3959                    	;  425      if (sdtestflg)
3960                    	;  426          {
3961                    	;  427          if (!statptr)
3962                    	;  428              printf("CMD10: no response\n");
3963                    	;  429          else
3964                    	;  430              printf("CMD10: SEND_CID, R1 response [%02x]\n", statptr[0]);
3965                    	;  431          } /* sdtestflg */
3966                    	;  432      if (!statptr)
3967                    	;  433          {
3968                    	;  434          spideselect();
3969                    	;  435          ledoff();
3970                    	;  436          return (NO);
3971                    	;  437          }
3972                    	;  438      /* looking for 0xfe that is the byte before data */
3973                    	;  439      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
3974                    	;  440          ;
3975                    	;  441      if (tries == 0) /* tried too many times */
3976                    	;  442          {
3977                    	;  443          if (sdtestflg)
3978                    	;  444              {
3979                    	;  445              printf("  No data found\n");
3980                    	;  446              } /* sdtestflg */
3981                    	;  447          spideselect();
3982                    	;  448          ledoff();
3983                    	;  449          return (NO);
3984                    	;  450          }
3985                    	;  451      else
3986                    	;  452          {
3987                    	;  453          crc = 0;
3988                    	;  454          for (nbytes = 0; nbytes < 15; nbytes++)
3989                    	;  455              {
3990                    	;  456              rbyte = spiio(0xff);
3991                    	;  457              cidreg[nbytes] = rbyte;
3992                    	;  458              crc = CRC7_one(crc, rbyte);
3993                    	;  459              }
3994                    	;  460          cidreg[15] = spiio(0xff);
3995                    	;  461          crc |= 0x01;
3996                    	;  462          /* some SD cards need additional clock pulses */
3997                    	;  463          for (nbytes = 9; 0 < nbytes; nbytes--)
3998                    	;  464              spiio(0xff);
3999                    	;  465          if (sdtestflg)
4000                    	;  466              {
4001                    	;  467              prtptr = &cidreg[0];
4002                    	;  468              printf("  CID: [");
4003                    	;  469              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
4004                    	;  470                  printf("%02x ", *prtptr);
4005                    	;  471              prtptr = &cidreg[0];
4006                    	;  472              printf("\b] |");
4007                    	;  473              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
4008                    	;  474                  {
4009                    	;  475                  if ((' ' <= *prtptr) && (*prtptr < 127))
4010                    	;  476                      putchar(*prtptr);
4011                    	;  477                  else
4012                    	;  478                      putchar('.');
4013                    	;  479                  }
4014                    	;  480              printf("|\n");
4015                    	;  481              if (crc == cidreg[15])
4016                    	;  482                  {
4017                    	;  483                  printf("CRC7 ok: [%02x]\n", crc);
4018                    	;  484                  }
4019                    	;  485              else
4020                    	;  486                  {
4021                    	;  487                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
4022                    	;  488                         crc, cidreg[15]);
4023                    	;  489                  /* could maybe return failure here */
4024                    	;  490                  }
4025                    	;  491              } /* sdtestflg */
4026                    	;  492          }
4027                    	;  493  
4028                    	;  494      /* CMD9: SEND_CSD */
4029                    	;  495      memcpy(cmdbuf, cmd9, 5);
4030                    	;  496      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
4031                    	;  497      if (sdtestflg)
4032                    	;  498          {
4033                    	;  499          if (!statptr)
4034                    	;  500              printf("CMD9: no response\n");
4035                    	;  501          else
4036                    	;  502              printf("CMD9: SEND_CSD, R1 response [%02x]\n", statptr[0]);
4037                    	;  503          } /* sdtestflg */
4038                    	;  504      if (!statptr)
4039                    	;  505          {
4040                    	;  506          spideselect();
4041                    	;  507          ledoff();
4042                    	;  508          return (NO);
4043                    	;  509          }
4044                    	;  510      /* looking for 0xfe that is the byte before data */
4045                    	;  511      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
4046                    	;  512          ;
4047                    	;  513      if (tries == 0) /* tried too many times */
4048                    	;  514          {
4049                    	;  515          if (sdtestflg)
4050                    	;  516              {
4051                    	;  517              printf("  No data found\n");
4052                    	;  518              } /* sdtestflg */
4053                    	;  519          return (NO);
4054                    	;  520          }
4055                    	;  521      else
4056                    	;  522          {
4057                    	;  523          crc = 0;
4058                    	;  524          for (nbytes = 0; nbytes < 15; nbytes++)
4059                    	;  525              {
4060                    	;  526              rbyte = spiio(0xff);
4061                    	;  527              csdreg[nbytes] = rbyte;
4062                    	;  528              crc = CRC7_one(crc, rbyte);
4063                    	;  529              }
4064                    	;  530          csdreg[15] = spiio(0xff);
4065                    	;  531          crc |= 0x01;
4066                    	;  532          /* some SD cards need additional clock pulses */
4067                    	;  533          for (nbytes = 9; 0 < nbytes; nbytes--)
4068                    	;  534              spiio(0xff);
4069                    	;  535          if (sdtestflg)
4070                    	;  536              {
4071                    	;  537              prtptr = &csdreg[0];
4072                    	;  538              printf("  CSD: [");
4073                    	;  539              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
4074                    	;  540                  printf("%02x ", *prtptr);
4075                    	;  541              prtptr = &csdreg[0];
4076                    	;  542              printf("\b] |");
4077                    	;  543              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
4078                    	;  544                  {
4079                    	;  545                  if ((' ' <= *prtptr) && (*prtptr < 127))
4080                    	;  546                      putchar(*prtptr);
4081                    	;  547                  else
4082                    	;  548                      putchar('.');
4083                    	;  549                  }
4084                    	;  550              printf("|\n");
4085                    	;  551              if (crc == csdreg[15])
4086                    	;  552                  {
4087                    	;  553                  printf("CRC7 ok: [%02x]\n", crc);
4088                    	;  554                  }
4089                    	;  555              else
4090                    	;  556                  {
4091                    	;  557                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
4092                    	;  558                         crc, csdreg[15]);
4093                    	;  559                  /* could maybe return failure here */
4094                    	;  560                  }
4095                    	;  561              } /* sdtestflg */
   0                    	;  562          }
   1                    	;  563  
   2                    	;  564      for (nbytes = 9; 0 < nbytes; nbytes--)
   3                    	;  565          spiio(0xff);
   4                    	;  566      if (sdtestflg)
   5                    	;  567          {
   6                    	;  568          printf("Sent 9*8 (72) clock pulses, select active\n");
   7                    	;  569          } /* sdtestflg */
   8                    	;  570  
   9                    	;  571      sdinitok = YES;
  10                    	;  572  
  11                    	;  573      spideselect();
  12                    	;  574      ledoff();
  13                    	;  575  
  14                    	;  576      return (YES);
  15                    	;  577      }
  16                    	;  578  
  17                    	;  579  int sdprobe()
  18                    	;  580      {
  19                    	;  581      unsigned char cmdbuf[5];   /* buffer to build command in */
  20                    	;  582      unsigned char rstatbuf[5]; /* buffer to recieve status in */
  21                    	;  583      unsigned char *statptr;    /* pointer to returned status from SD command */
  22                    	;  584      int nbytes;  /* byte counter */
  23                    	;  585      int allzero = YES;
  24                    	;  586  
  25                    	;  587      ledon();
  26                    	;  588      spiselect();
  27                    	;  589  
  28                    	;  590      /* CMD58: READ_OCR */
  29                    	;  591      memcpy(cmdbuf, cmd58, 5);
  30                    	;  592      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
  31                    	;  593      for (nbytes = 0; nbytes < 5; nbytes++)
  32                    	;  594          {
  33                    	;  595          if (statptr[nbytes] != 0)
  34                    	;  596              allzero = NO;
  35                    	;  597          }
  36                    	;  598      if (sdtestflg)
  37                    	;  599          {
  38                    	;  600          if (!statptr)
  39                    	;  601              printf("CMD58: no response\n");
  40                    	;  602          else
  41                    	;  603              {
  42                    	;  604              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
  43                    	;  605                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
  44                    	;  606              if (allzero)
  45                    	;  607                  printf("SD card not inserted or not initialized\n");
  46                    	;  608              }
  47                    	;  609          } /* sdtestflg */
  48                    	;  610      if (!statptr || allzero)
  49                    	;  611          {
  50                    	;  612          sdinitok = NO;
  51                    	;  613          spideselect();
  52                    	;  614          ledoff();
  53                    	;  615          return (NO);
  54                    	;  616          }
  55                    	;  617  
  56                    	;  618      spideselect();
  57                    	;  619      ledoff();
  58                    	;  620  
  59                    	;  621      return (YES);
  60                    	;  622      }
  61                    	;  623  
  62                    	;  624  /* print OCR, CID and CSD registers*/
  63                    	;  625  void sdprtreg()
  64                    	;  626      {
  65                    	;  627      unsigned int n;
  66                    	;  628      unsigned int csize;
  67                    	;  629      unsigned long devsize;
  68                    	;  630      unsigned long capacity;
  69                    	;  631  
  70                    	;  632      if (!sdinitok)
  71                    	;  633          {
  72                    	;  634          printf("SD card not initialized\n");
  73                    	;  635          return;
  74                    	;  636          }
  75                    	;  637      printf("SD card information:");
  76                    	;  638      if (ocrreg[0] & 0x80)
  77                    	;  639          {
  78                    	;  640          if (ocrreg[0] & 0x40)
  79                    	;  641              printf("  SD card ver. 2+, Block address\n");
  80                    	;  642          else
  81                    	;  643              {
  82                    	;  644              if (sdver2)
  83                    	;  645                  printf("  SD card ver. 2+, Byte address\n");
  84                    	;  646              else
  85                    	;  647                  printf("  SD card ver. 1, Byte address\n");
  86                    	;  648              }
  87                    	;  649          }
  88                    	;  650      printf("  Manufacturer ID: 0x%02x, ", cidreg[0]);
  89                    	;  651      printf("OEM ID: %.2s, ", &cidreg[1]);
  90                    	;  652      printf("Product name: %.5s\n", &cidreg[3]);
  91                    	;  653      printf("  Product revision: %d.%d, ",
  92                    	;  654             (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
  93                    	;  655      printf("Serial number: %lu\n",
  94                    	;  656             (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
  95                    	;  657      printf("  Manufacturing date: %d-%d, ",
  96                    	;  658             2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
  97                    	;  659      if ((csdreg[0] & 0xc0) == 0x00) /* CSD version 1 */
  98                    	;  660          {
  99                    	;  661          n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
 100                    	;  662          csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
 101                    	;  663                  ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
 102                    	;  664          capacity = (unsigned long) csize << (n-10);
 103                    	;  665          printf("Device capacity: %lu MByte\n", capacity >> 10);
 104                    	;  666          }
 105                    	;  667      if ((csdreg[0] & 0xc0) == 0x40) /* CSD version 2 */
 106                    	;  668          {
 107                    	;  669          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
 108                    	;  670                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
 109                    	;  671          capacity = devsize << 9;
 110                    	;  672          printf("Device capacity: %lu MByte\n", capacity >> 10);
 111                    	;  673          }
 112                    	;  674      if ((csdreg[0] & 0xc0) == 0x80) /* CSD version 3 */
 113                    	;  675          {
 114                    	;  676          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
 115                    	;  677                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
 116                    	;  678          capacity = devsize << 9;
 117                    	;  679          printf("Device ultra capacity: %lu MByte\n", capacity >> 10);
 118                    	;  680          }
 119                    	;  681  
 120                    	;  682      if (sdtestflg)
 121                    	;  683          {
 122                    	;  684  
 123                    	;  685          printf("--------------------------------------\n");
 124                    	;  686          printf("OCR register:\n");
 125                    	;  687          if (ocrreg[2] & 0x80)
 126                    	;  688              printf("2.7-2.8V (bit 15) ");
 127                    	;  689          if (ocrreg[1] & 0x01)
 128                    	;  690              printf("2.8-2.9V (bit 16) ");
 129                    	;  691          if (ocrreg[1] & 0x02)
 130                    	;  692              printf("2.9-3.0V (bit 17) ");
 131                    	;  693          if (ocrreg[1] & 0x04)
 132                    	;  694              printf("3.0-3.1V (bit 18) \n");
 133                    	;  695          if (ocrreg[1] & 0x08)
 134                    	;  696              printf("3.1-3.2V (bit 19) ");
 135                    	;  697          if (ocrreg[1] & 0x10)
 136                    	;  698              printf("3.2-3.3V (bit 20) ");
 137                    	;  699          if (ocrreg[1] & 0x20)
 138                    	;  700              printf("3.3-3.4V (bit 21) ");
 139                    	;  701          if (ocrreg[1] & 0x40)
 140                    	;  702              printf("3.4-3.5V (bit 22) \n");
 141                    	;  703          if (ocrreg[1] & 0x80)
 142                    	;  704              printf("3.5-3.6V (bit 23) \n");
 143                    	;  705          if (ocrreg[0] & 0x01)
 144                    	;  706              printf("Switching to 1.8V Accepted (S18A) (bit 24) set ");
 145                    	;  707          if (ocrreg[0] & 0x08)
 146                    	;  708              printf("Over 2TB support Status (CO2T) (bit 27) set\n");
 147                    	;  709          if (ocrreg[0] & 0x20)
 148                    	;  710              printf("UHS-II Card Status (bit 29) set ");
 149                    	;  711          if (ocrreg[0] & 0x80)
 150                    	;  712              {
 151                    	;  713              if (ocrreg[0] & 0x40)
 152                    	;  714                  {
 153                    	;  715                  printf("Card Capacity Status (CCS) (bit 30) set\n");
 154                    	;  716                  printf("  SD Ver.2+, Block address");
 155                    	;  717                  }
 156                    	;  718              else
 157                    	;  719                  {
 158                    	;  720                  printf("Card Capacity Status (CCS) (bit 30) not set\n");
 159                    	;  721                  if (sdver2)
 160                    	;  722                      printf("  SD Ver.2+, Byte address");
 161                    	;  723                  else
 162                    	;  724                      printf("  SD Ver.1, Byte address");
 163                    	;  725                  }
 164                    	;  726              printf("\nCard power up status bit (busy) (bit 31) set\n");
 165                    	;  727              }
 166                    	;  728          else
 167                    	;  729              {
 168                    	;  730              printf("\nCard power up status bit (busy) (bit 31) not set.\n");
 169                    	;  731              printf("  This bit is not set if the card has not finished the power up routine.\n");
 170                    	;  732              }
 171                    	;  733          printf("--------------------------------------\n");
 172                    	;  734          printf("CID register:\n");
 173                    	;  735          printf("MID: 0x%02x, ", cidreg[0]);
 174                    	;  736          printf("OID: %.2s, ", &cidreg[1]);
 175                    	;  737          printf("PNM: %.5s, ", &cidreg[3]);
 176                    	;  738          printf("PRV: %d.%d, ",
 177                    	;  739                 (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
 178                    	;  740          printf("PSN: %lu, ",
 179                    	;  741                 (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
 180                    	;  742          printf("MDT: %d-%d\n",
 181                    	;  743                 2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
 182                    	;  744          printf("--------------------------------------\n");
 183                    	;  745          printf("CSD register:\n");
 184                    	;  746          if ((csdreg[0] & 0xc0) == 0x00)
 185                    	;  747              {
 186                    	;  748              printf("CSD Version 1.0, Standard Capacity\n");
 187                    	;  749              n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
 188                    	;  750              csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
 189                    	;  751                      ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
 190                    	;  752              capacity = (unsigned long) csize << (n-10);
 191                    	;  753              printf(" Device capacity: %lu KByte, %lu MByte\n",
 192                    	;  754                     capacity, capacity >> 10);
 193                    	;  755              }
 194                    	;  756          if ((csdreg[0] & 0xc0) == 0x40)
 195                    	;  757              {
 196                    	;  758              printf("CSD Version 2.0, High Capacity and Extended Capacity\n");
 197                    	;  759              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
 198                    	;  760                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
 199                    	;  761              capacity = devsize << 9;
 200                    	;  762              printf(" Device capacity: %lu KByte, %lu MByte\n",
 201                    	;  763                     capacity, capacity >> 10);
 202                    	;  764              }
 203                    	;  765          if ((csdreg[0] & 0xc0) == 0x80)
 204                    	;  766              {
 205                    	;  767              printf("CSD Version 3.0, Ultra Capacity (SDUC)\n");
 206                    	;  768              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
 207                    	;  769                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
 208                    	;  770              capacity = devsize << 9;
 209                    	;  771              printf(" Device capacity: %lu KByte, %lu MByte\n",
 210                    	;  772                     capacity, capacity >> 10);
 211                    	;  773              }
 212                    	;  774          printf("--------------------------------------\n");
 213                    	;  775  
 214                    	;  776          } /* sdtestflg */ /* SDTEST */
 215                    	;  777  
 216                    	;  778      }
 217                    	;  779  
 218                    	;  780  /* Read data block of 512 bytes to buffer
 219                    	;  781   * Returns YES if ok or NO if error
 220                    	;  782   */
 221                    	;  783  int sdread(unsigned char *rdbuf, unsigned long rdblkno)
 222                    	;  784      {
 223                    	;  785      unsigned char *statptr;
 224                    	;  786      unsigned char rbyte;
 225                    	;  787      unsigned char cmdbuf[5];   /* buffer to build command in */
 226                    	;  788      unsigned char rstatbuf[5]; /* buffer to recieve status in */
 227                    	;  789      int nbytes;
 228                    	;  790      int tries;
 229                    	;  791      unsigned long blktoread;
 230                    	;  792      unsigned int rxcrc16;
 231                    	;  793      unsigned int calcrc16;
 232                    	;  794  
 233                    	;  795      ledon();
 234                    	;  796      spiselect();
 235                    	;  797  
 236                    	;  798      if (!sdinitok)
 237                    	;  799          {
 238                    	;  800          if (sdtestflg)
 239                    	;  801              {
 240                    	;  802              printf("SD card not initialized\n");
 241                    	;  803              } /* sdtestflg */
 242                    	;  804          spideselect();
 243                    	;  805          ledoff();
 244                    	;  806          return (NO);
 245                    	;  807          }
 246                    	;  808  
 247                    	;  809      /* CMD17: READ_SINGLE_BLOCK */
 248                    	;  810      /* Insert block # into command */
 249                    	;  811      memcpy(cmdbuf, cmd17, 5);
 250                    	;  812      blktoread = blkmult * rdblkno;
 251                    	;  813      cmdbuf[4] = blktoread & 0xff;
 252                    	;  814      blktoread = blktoread >> 8;
 253                    	;  815      cmdbuf[3] = blktoread & 0xff;
 254                    	;  816      blktoread = blktoread >> 8;
 255                    	;  817      cmdbuf[2] = blktoread & 0xff;
 256                    	;  818      blktoread = blktoread >> 8;
 257                    	;  819      cmdbuf[1] = blktoread & 0xff;
 258                    	;  820  
 259                    	;  821      if (sdtestflg)
 260                    	;  822          {
 261                    	;  823          printf("\nCMD17: READ_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
 262                    	;  824                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
 263                    	;  825          } /* sdtestflg */
 264                    	;  826      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
 265                    	;  827      if (sdtestflg)
 266                    	;  828          {
 267                    	;  829          printf("CMD17 R1 response [%02x]\n", statptr[0]);
 268                    	;  830          } /* sdtestflg */
 269                    	;  831      if (statptr[0])
 270                    	;  832          {
 271                    	;  833          if (sdtestflg)
 272                    	;  834              {
 273                    	;  835              printf("  could not read block\n");
 274                    	;  836              } /* sdtestflg */
 275                    	;  837          spideselect();
 276                    	;  838          ledoff();
 277                    	;  839          return (NO);
 278                    	;  840          }
 279                    	;  841      /* looking for 0xfe that is the byte before data */
 280                    	;  842      for (tries = 80; (0 < tries) && ((rbyte = spiio(0xff)) != 0xfe); tries--)
 281                    	;  843          {
 282                    	;  844          if ((rbyte & 0xe0) == 0x00)
 283                    	;  845              {
 284                    	;  846              /* If a read operation fails and the card cannot provide
 285                    	;  847                 the required data, it will send a data error token instead
 286                    	;  848               */
 287                    	;  849              if (sdtestflg)
 288                    	;  850                  {
 289                    	;  851                  printf("  read error: [%02x]\n", rbyte);
 290                    	;  852                  } /* sdtestflg */
 291                    	;  853              spideselect();
 292                    	;  854              ledoff();
 293                    	;  855              return (NO);
 294                    	;  856              }
 295                    	;  857          }
 296                    	;  858      if (tries == 0) /* tried too many times */
 297                    	;  859          {
 298                    	;  860          if (sdtestflg)
 299                    	;  861              {
 300                    	;  862              printf("  no data found\n");
 301                    	;  863              } /* sdtestflg */
 302                    	;  864          spideselect();
 303                    	;  865          ledoff();
 304                    	;  866          return (NO);
 305                    	;  867          }
 306                    	;  868      else
 307                    	;  869          {
 308                    	;  870          calcrc16 = 0;
 309                    	;  871          for (nbytes = 0; nbytes < 512; nbytes++)
 310                    	;  872              {
 311                    	;  873              rbyte = spiio(0xff);
 312                    	;  874              calcrc16 = CRC16_one(calcrc16, rbyte);
 313                    	;  875              rdbuf[nbytes] = rbyte;
 314                    	;  876              }
 315                    	;  877          rxcrc16 = spiio(0xff) << 8;
 316                    	;  878          rxcrc16 += spiio(0xff);
 317                    	;  879  
 318                    	;  880          if (sdtestflg)
 319                    	;  881              {
 320                    	;  882              printf("  read data block %ld:\n", rdblkno);
 321                    	;  883              } /* sdtestflg */
 322                    	;  884          if (rxcrc16 != calcrc16)
 323                    	;  885              {
 324                    	;  886              if (sdtestflg)
 325                    	;  887                  {
 326                    	;  888                  printf("  CRC16 error, recieved: 0x%04x, calc: 0x%04hi\n",
 327                    	;  889                         rxcrc16, calcrc16);
 328                    	;  890                  } /* sdtestflg */
 329                    	;  891              spideselect();
 330                    	;  892              ledoff();
 331                    	;  893              return (NO);
 332                    	;  894              }
 333                    	;  895          }
 334                    	;  896      spideselect();
 335                    	;  897      ledoff();
 336                    	;  898      return (YES);
 337                    	;  899      }
 338                    	;  900  
 339                    	;  901  /* Write data block of 512 bytes from buffer
 340                    	;  902   * Returns YES if ok or NO if error
 341                    	;  903   */
 342                    	;  904  int sdwrite(unsigned char *wrbuf, unsigned long wrblkno)
 343                    	;  905      {
 344                    	;  906      unsigned char *statptr;
 345                    	;  907      unsigned char rbyte;
 346                    	;  908      unsigned char tbyte;
 347                    	;  909      unsigned char cmdbuf[5];   /* buffer to build command in */
 348                    	;  910      unsigned char rstatbuf[5]; /* buffer to recieve status in */
 349                    	;  911      int nbytes;
 350                    	;  912      int tries;
 351                    	;  913      unsigned long blktowrite;
 352                    	;  914      unsigned int calcrc16;
 353                    	;  915  
 354                    	;  916      ledon();
 355                    	;  917      spiselect();
 356                    	;  918  
 357                    	;  919      if (!sdinitok)
 358                    	;  920          {
 359                    	;  921          if (sdtestflg)
 360                    	;  922              {
 361                    	;  923              printf("SD card not initialized\n");
 362                    	;  924              } /* sdtestflg */
 363                    	;  925          spideselect();
 364                    	;  926          ledoff();
 365                    	;  927          return (NO);
 366                    	;  928          }
 367                    	;  929  
 368                    	;  930      if (sdtestflg)
 369                    	;  931          {
 370                    	;  932          printf("  write data block %ld:\n", wrblkno);
 371                    	;  933          } /* sdtestflg */
 372                    	;  934      /* CMD24: WRITE_SINGLE_BLOCK */
 373                    	;  935      /* Insert block # into command */
 374                    	;  936      memcpy(cmdbuf, cmd24, 5);
 375                    	;  937      blktowrite = blkmult * wrblkno;
 376                    	;  938      cmdbuf[4] = blktowrite & 0xff;
 377                    	;  939      blktowrite = blktowrite >> 8;
 378                    	;  940      cmdbuf[3] = blktowrite & 0xff;
 379                    	;  941      blktowrite = blktowrite >> 8;
 380                    	;  942      cmdbuf[2] = blktowrite & 0xff;
 381                    	;  943      blktowrite = blktowrite >> 8;
 382                    	;  944      cmdbuf[1] = blktowrite & 0xff;
 383                    	;  945  
 384                    	;  946      if (sdtestflg)
 385                    	;  947          {
 386                    	;  948          printf("\nCMD24: WRITE_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
 387                    	;  949                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
 388                    	;  950          } /* sdtestflg */
 389                    	;  951      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
 390                    	;  952      if (sdtestflg)
 391                    	;  953          {
 392                    	;  954          printf("CMD24 R1 response [%02x]\n", statptr[0]);
 393                    	;  955          } /* sdtestflg */
 394                    	;  956      if (statptr[0])
 395                    	;  957          {
 396                    	;  958          if (sdtestflg)
 397                    	;  959              {
 398                    	;  960              printf("  could not write block\n");
 399                    	;  961              } /* sdtestflg */
 400                    	;  962          spideselect();
 401                    	;  963          ledoff();
 402                    	;  964          return (NO);
 403                    	;  965          }
 404                    	;  966      /* send 0xfe, the byte before data */
 405                    	;  967      spiio(0xfe);
 406                    	;  968      /* initialize crc and send block */
 407                    	;  969      calcrc16 = 0;
 408                    	;  970      for (nbytes = 0; nbytes < 512; nbytes++)
 409                    	;  971          {
 410                    	;  972          tbyte = wrbuf[nbytes];
 411                    	;  973          spiio(tbyte);
 412                    	;  974          calcrc16 = CRC16_one(calcrc16, tbyte);
 413                    	;  975          }
 414                    	;  976      spiio((calcrc16 >> 8) & 0xff);
 415                    	;  977      spiio(calcrc16 & 0xff);
 416                    	;  978  
 417                    	;  979      /* check data resposnse */
 418                    	;  980      for (tries = 20;
 419                    	;  981              0 < tries && (((rbyte = spiio(0xff)) & 0x11) != 0x01);
 420                    	;  982              tries--)
 421                    	;  983          ;
 422                    	;  984      if (tries == 0)
 423                    	;  985          {
 424                    	;  986          if (sdtestflg)
 425                    	;  987              {
 426                    	;  988              printf("No data response\n");
 427                    	;  989              } /* sdtestflg */
 428                    	;  990          spideselect();
 429                    	;  991          ledoff();
 430                    	;  992          return (NO);
 431                    	;  993          }
 432                    	;  994      else
 433                    	;  995          {
 434                    	;  996          if (sdtestflg)
 435                    	;  997              {
 436                    	;  998              printf("Data response [%02x]", 0x1f & rbyte);
 437                    	;  999              } /* sdtestflg */
 438                    	; 1000          if ((0x1f & rbyte) == 0x05)
 439                    	; 1001              {
 440                    	; 1002              if (sdtestflg)
 441                    	; 1003                  {
 442                    	; 1004                  printf(", data accepted\n");
 443                    	; 1005                  } /* sdtestflg */
 444                    	; 1006              for (nbytes = 9; 0 < nbytes; nbytes--)
 445                    	; 1007                  spiio(0xff);
 446                    	; 1008              if (sdtestflg)
 447                    	; 1009                  {
 448                    	; 1010                  printf("Sent 9*8 (72) clock pulses, select active\n");
 449                    	; 1011                  } /* sdtestflg */
 450                    	; 1012              spideselect();
 451                    	; 1013              ledoff();
 452                    	; 1014              return (YES);
 453                    	; 1015              }
 454                    	; 1016          else
 455                    	; 1017              {
 456                    	; 1018              if (sdtestflg)
 457                    	; 1019                  {
 458                    	; 1020                  printf(", data not accepted\n");
 459                    	; 1021                  } /* sdtestflg */
 460                    	; 1022              spideselect();
 461                    	; 1023              ledoff();
 462                    	; 1024              return (NO);
 463                    	; 1025              }
 464                    	; 1026          }
 465                    	; 1027      }
 466                    	; 1028  
 467                    	; 1029  /* Print data in 512 byte buffer */
 468                    	; 1030  void sddatprt(unsigned char *prtbuf)
 469                    	; 1031      {
 470                    	; 1032      /* Variables used for "pretty-print" */
 471                    	; 1033      int allzero, dmpline, dotprted, lastallz, nbytes;
 472                    	; 1034      unsigned char *prtptr;
 473                    	; 1035  
 474                    	; 1036      prtptr = prtbuf;
 475                    	; 1037      dotprted = NO;
 476                    	; 1038      lastallz = NO;
 477                    	; 1039      for (dmpline = 0; dmpline < 32; dmpline++)
 478                    	; 1040          {
 479                    	; 1041          /* test if all 16 bytes are 0x00 */
 480                    	; 1042          allzero = YES;
 481                    	; 1043          for (nbytes = 0; nbytes < 16; nbytes++)
 482                    	; 1044              {
 483                    	; 1045              if (prtptr[nbytes] != 0)
 484                    	; 1046                  allzero = NO;
 485                    	; 1047              }
 486                    	; 1048          if (lastallz && allzero)
 487                    	; 1049              {
 488                    	; 1050              if (!dotprted)
 489                    	; 1051                  {
 490                    	; 1052                  printf("*\n");
 491                    	; 1053                  dotprted = YES;
 492                    	; 1054                  }
 493                    	; 1055              }
 494                    	; 1056          else
 495                    	; 1057              {
 496                    	; 1058              dotprted = NO;
 497                    	; 1059              /* print offset */
 498                    	; 1060              printf("%04x ", dmpline * 16);
 499                    	; 1061              /* print 16 bytes in hex */
 500                    	; 1062              for (nbytes = 0; nbytes < 16; nbytes++)
 501                    	; 1063                  printf("%02x ", prtptr[nbytes]);
 502                    	; 1064              /* print these bytes in ASCII if printable */
 503                    	; 1065              printf(" |");
 504                    	; 1066              for (nbytes = 0; nbytes < 16; nbytes++)
 505                    	; 1067                  {
 506                    	; 1068                  if ((' ' <= prtptr[nbytes]) && (prtptr[nbytes] < 127))
 507                    	; 1069                      putchar(prtptr[nbytes]);
 508                    	; 1070                  else
 509                    	; 1071                      putchar('.');
 510                    	; 1072                  }
 511                    	; 1073              printf("|\n");
 512                    	; 1074              }
 513                    	; 1075          prtptr += 16;
 514                    	; 1076          lastallz = allzero;
 515                    	; 1077          }
 516                    	; 1078      }
 517                    	; 1079  
 518                    	; 1080  /* Print GUID (mixed endian format)
 519                    	; 1081   */
 520                    	; 1082  void prtguid(unsigned char *guidptr)
 521                    	; 1083      {
 522                    	; 1084      int index;
 523                    	; 1085  
 524                    	; 1086      printf("%02x%02x%02x%02x-", guidptr[3], guidptr[2], guidptr[1], guidptr[0]);
 525                    	; 1087      printf("%02x%02x-", guidptr[5], guidptr[4]);
 526                    	; 1088      printf("%02x%02x-", guidptr[7], guidptr[6]);
 527                    	; 1089      printf("%02x%02x-", guidptr[8], guidptr[9]);
 528                    	; 1090      printf("%02x%02x%02x%02x%02x%02x",
 529                    	; 1091             guidptr[10], guidptr[11], guidptr[12], guidptr[13], guidptr[14], guidptr[15]);
 530                    	; 1092      }
 531                    	; 1093  
 532                    	; 1094  /* Analyze and print GPT entry
 533                    	; 1095   */
 534                    	; 1096  int prtgptent(unsigned int entryno)
 535                    	; 1097      {
 536                    	; 1098      int index;
 537                    	; 1099      int entryidx;
 538                    	; 1100      int hasname;
 539                    	; 1101      unsigned int block;
 540                    	; 1102      unsigned char *rxdata;
 541                    	; 1103      unsigned char *entryptr;
 542                    	; 1104      unsigned char tstzero = 0;
 543                    	; 1105      unsigned long flba;
 544                    	; 1106      unsigned long llba;
 545                    	; 1107  
 546                    	; 1108      block = 2 + (entryno / 4);
 547                    	; 1109      if ((curblkno != block) || !curblkok)
 548                    	; 1110          {
 549                    	; 1111          if (!sdread(sdrdbuf, block))
 550                    	; 1112              {
 551                    	; 1113              if (sdtestflg)
 552                    	; 1114                  {
 553                    	; 1115                  printf("Can't read GPT entry block\n");
 554                    	; 1116                  return (NO);
 555                    	; 1117                  } /* sdtestflg */
 556                    	; 1118              }
 557                    	; 1119          curblkno = block;
 558                    	; 1120          curblkok = YES;
 559                    	; 1121          }
 560                    	; 1122      rxdata = sdrdbuf;
 561                    	; 1123      entryptr = rxdata + (128 * (entryno % 4));
 562                    	; 1124      for (index = 0; index < 16; index++)
 563                    	; 1125          tstzero |= entryptr[index];
 564                    	; 1126      if (sdtestflg)
 565                    	; 1127          {
 566                    	; 1128          printf("GPT partition entry %d:", entryno + 1);
 567                    	; 1129          } /* sdtestflg */
 568                    	; 1130      if (!tstzero)
 569                    	; 1131          {
 570                    	; 1132          if (sdtestflg)
 571                    	; 1133              {
 572                    	; 1134              printf(" Not used entry\n");
 573                    	; 1135              } /* sdtestflg */
 574                    	; 1136          return (NO);
 575                    	; 1137          }
 576                    	; 1138      if (sdtestflg)
 577                    	; 1139          {
 578                    	; 1140          printf("\n  Partition type GUID: ");
 579                    	; 1141          prtguid(entryptr);
 580                    	; 1142          printf("\n  [");
 581                    	; 1143          for (index = 0; index < 16; index++)
 582                    	; 1144              printf("%02x ", entryptr[index]);
 583                    	; 1145          printf("\b]");
 584                    	; 1146          printf("\n  Unique partition GUID: ");
 585                    	; 1147          prtguid(entryptr + 16);
 586                    	; 1148          printf("\n  [");
 587                    	; 1149          for (index = 0; index < 16; index++)
 588                    	; 1150              printf("%02x ", (entryptr + 16)[index]);
 589                    	; 1151          printf("\b]");
 590                    	; 1152          printf("\n  First LBA: ");
 591                    	; 1153          /* lower 32 bits of LBA should be sufficient (I hope) */
 592                    	; 1154          } /* sdtestflg */
 593                    	; 1155      flba = (unsigned long)entryptr[32] + ((unsigned long)entryptr[33] << 8) +
 594                    	; 1156             ((unsigned long)entryptr[34] << 16) + ((unsigned long)entryptr[35] << 24);
 595                    	; 1157      if (sdtestflg)
 596                    	; 1158          {
 597                    	; 1159          printf("%lu", flba);
 598                    	; 1160          printf(" [");
 599                    	; 1161          for (index = 32; index < (32 + 8); index++)
 600                    	; 1162              printf("%02x ", entryptr[index]);
 601                    	; 1163          printf("\b]");
 602                    	; 1164          printf("\n  Last LBA: ");
 603                    	; 1165          } /* sdtestflg */
 604                    	; 1166      /* lower 32 bits of LBA should be sufficient (I hope) */
 605                    	; 1167      llba = (unsigned long)entryptr[40] + ((unsigned long)entryptr[41] << 8) +
 606                    	; 1168             ((unsigned long)entryptr[42] << 16) + ((unsigned long)entryptr[43] << 24);
 607                    	; 1169  
 608                    	; 1170      if (entryptr[48] & 0x04)
 609                    	; 1171          dskmap[partdsk].bootable = YES;
 610                    	; 1172      dskmap[partdsk].partype = PARTGPT;
 611                    	; 1173      dskmap[partdsk].dskletter = 'A' + partdsk;
 612                    	; 1174      dskmap[partdsk].dskstart = flba;
 613                    	; 1175      dskmap[partdsk].dskend = llba;
 614                    	; 1176      dskmap[partdsk].dsksize = llba - flba + 1;
 615                    	; 1177      memcpy(dskmap[partdsk].dsktype, entryptr, 16);
 616                    	; 1178      partdsk++;
 617                    	; 1179  
 618                    	; 1180      if (sdtestflg)
 619                    	; 1181          {
 620                    	; 1182          printf("%lu, size %lu MByte", llba, (llba - flba) >> 11);
 621                    	; 1183          printf(" [");
 622                    	; 1184          for (index = 40; index < (40 + 8); index++)
 623                    	; 1185              printf("%02x ", entryptr[index]);
 624                    	; 1186          printf("\b]");
 625                    	; 1187          printf("\n  Attribute flags: [");
 626                    	; 1188          /* bits 0 - 2 and 60 - 63 should be decoded */
 627                    	; 1189          for (index = 0; index < 8; index++)
 628                    	; 1190              {
 629                    	; 1191              entryidx = index + 48;
 630                    	; 1192              printf("%02x ", entryptr[entryidx]);
 631                    	; 1193              }
 632                    	; 1194          printf("\b]\n  Partition name:  ");
 633                    	; 1195          } /* sdtestflg */
 634                    	; 1196      /* partition name is in UTF-16LE code units */
 635                    	; 1197      hasname = NO;
 636                    	; 1198      for (index = 0; index < 72; index += 2)
 637                    	; 1199          {
 638                    	; 1200          entryidx = index + 56;
 639                    	; 1201          if ((entryptr[entryidx] | entryptr[entryidx + 1]) == 0)
 640                    	; 1202              break;
 641                    	; 1203          if (sdtestflg)
 642                    	; 1204              {
 643                    	; 1205              if ((' ' <= entryptr[entryidx]) && (entryptr[entryidx] < 127))
 644                    	; 1206                  putchar(entryptr[entryidx]);
 645                    	; 1207              else
 646                    	; 1208                  putchar('.');
 647                    	; 1209              } /* sdtestflg */
 648                    	; 1210          hasname = YES;
 649                    	; 1211          }
 650                    	; 1212      if (sdtestflg)
 651                    	; 1213          {
 652                    	; 1214          if (!hasname)
 653                    	; 1215              printf("name field empty");
 654                    	; 1216          printf("\n");
 655                    	; 1217          printf("   [");
 656                    	; 1218          for (index = 0; index < 72; index++)
 657                    	; 1219              {
 658                    	; 1220              if (((index & 0xf) == 0) && (index != 0))
 659                    	; 1221                  printf("\n    ");
 660                    	; 1222              entryidx = index + 56;
 661                    	; 1223              printf("%02x ", entryptr[entryidx]);
 662                    	; 1224              }
 663                    	; 1225          printf("\b]\n");
 664                    	; 1226          } /* sdtestflg */
 665                    	; 1227      return (YES);
 666                    	; 1228      }
 667                    	; 1229  
 668                    	; 1230  /* Analyze and print GPT header
 669                    	; 1231   */
 670                    	; 1232  void sdgpthdr(unsigned long block)
 671                    	; 1233      {
 672                    	; 1234      int index;
 673                    	; 1235      unsigned int partno;
 674                    	; 1236      unsigned char *rxdata;
 675                    	; 1237      unsigned long entries;
 676                    	; 1238  
 677                    	; 1239      if (sdtestflg)
 678                    	; 1240          {
 679                    	; 1241          printf("GPT header\n");
 680                    	; 1242          } /* sdtestflg */
 681                    	; 1243      if (!sdread(sdrdbuf, block))
 682                    	; 1244          {
 683                    	; 1245          if (sdtestflg)
 684                    	; 1246              {
 685                    	; 1247              printf("Can't read GPT partition table header\n");
 686                    	; 1248              } /* sdtestflg */
 687                    	; 1249          return;
 688                    	; 1250          }
 689                    	; 1251      curblkno = block;
 690                    	; 1252      curblkok = YES;
 691                    	; 1253  
 692                    	; 1254      rxdata = sdrdbuf;
 693                    	; 1255      if (sdtestflg)
 694                    	; 1256          {
 695                    	; 1257          printf("  Signature: %.8s\n", &rxdata[0]);
 696                    	; 1258          printf("  Revision: %d.%d [%02x %02x %02x %02x]\n",
 697                    	; 1259                 (int)rxdata[8] * ((int)rxdata[9] << 8),
 698                    	; 1260                 (int)rxdata[10] + ((int)rxdata[11] << 8),
 699                    	; 1261                 rxdata[8], rxdata[9], rxdata[10], rxdata[11]);
 700                    	; 1262          entries = (unsigned long)rxdata[80] + ((unsigned long)rxdata[81] << 8) +
 701                    	; 1263                    ((unsigned long)rxdata[82] << 16) + ((unsigned long)rxdata[83] << 24);
 702                    	; 1264          printf("  Number of partition entries: %lu (may be actual or maximum)\n", entries);
 703                    	; 1265          } /* sdtestflg */
 704                    	; 1266      for (partno = 0; (partno < 16) && (partdsk < 16); partno++)
 705                    	; 1267          {
 706                    	; 1268          if (!prtgptent(partno))
 707                    	; 1269              {
 708                    	; 1270              if (!sdtestflg)
 709                    	; 1271                  {
 710                    	; 1272                  /* go through all entries if compiled as test program */
 711                    	; 1273                  return;
 712                    	; 1274                  } /* sdtestflg */
 713                    	; 1275              }
 714                    	; 1276          }
 715                    	; 1277      if (sdtestflg)
 716                    	; 1278          {
 717                    	; 1279          printf("First 16 GPT entries scanned\n");
 718                    	; 1280          } /* sdtestflg */
 719                    	; 1281      }
 720                    	; 1282  
 721                    	; 1283  /* Analyze and print MBR partition entry
 722                    	; 1284   * Returns:
 723                    	; 1285   *    -1 if errror - should not happen
 724                    	; 1286   *     0 if not used entry
 725                    	; 1287   *     1 if MBR entry
 726                    	; 1288   *     2 if EBR entry
 727                    	; 1289   *     3 if GTP entry
 728                    	; 1290   */
 729                    	; 1291  int sdmbrentry(unsigned char *partptr)
 730                    	; 1292      {
 731                    	; 1293      int index;
 732                    	; 1294      int parttype;
 733                    	; 1295      unsigned long lbastart;
 734                    	; 1296      unsigned long lbasize;
 735                    	; 1297  
 736                    	; 1298      parttype = PARTMBR;
 737                    	; 1299      if (!partptr[4])
 738                    	; 1300          {
 739                    	; 1301          if (sdtestflg)
 740                    	; 1302              {
 741                    	; 1303              printf("Not used entry\n");
 742                    	; 1304              } /* sdtestflg */
 743                    	; 1305          return (PARTZRO);
 744                    	; 1306          }
 745                    	; 1307      if (sdtestflg)
 746                    	; 1308          {
 747                    	; 1309          printf("Boot indicator: 0x%02x, System ID: 0x%02x\n",
 748                    	; 1310                 partptr[0], partptr[4]);
 749                    	; 1311  
 750                    	; 1312          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f))
 751                    	; 1313              {
 752                    	; 1314              printf("  Extended partition entry\n");
 753                    	; 1315              }
 754                    	; 1316          if (partptr[0] & 0x01)
 755                    	; 1317              {
 756                    	; 1318              printf("  Unofficial 48 bit LBA Proposed MBR Format, no CHS\n");
 757                    	; 1319              /* this is however discussed
 758                    	; 1320                 https://wiki.osdev.org/Partition_Table#.22Unofficial.22_48_bit_LBA_Proposed_MBR_Format
 759                    	; 1321              */
 760                    	; 1322              }
 761                    	; 1323          else
 762                    	; 1324              {
 763                    	; 1325              printf("  begin CHS: 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
 764                    	; 1326                     partptr[1], partptr[2], partptr[3],
 765                    	; 1327                     ((partptr[2] & 0xc0) >> 2) + partptr[3],
 766                    	; 1328                     partptr[1],
 767                    	; 1329                     partptr[2] & 0x3f);
 768                    	; 1330              printf("  end CHS 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
 769                    	; 1331                     partptr[5], partptr[6], partptr[7],
 770                    	; 1332                     ((partptr[6] & 0xc0) >> 2) + partptr[7],
 771                    	; 1333                     partptr[5],
 772                    	; 1334                     partptr[6] & 0x3f);
 773                    	; 1335              }
 774                    	; 1336          } /* sdtestflg */
 775                    	; 1337      /* not showing high 16 bits if 48 bit LBA */
 776                    	; 1338      lbastart = (unsigned long)partptr[8] +
 777                    	; 1339                 ((unsigned long)partptr[9] << 8) +
 778                    	; 1340                 ((unsigned long)partptr[10] << 16) +
 779                    	; 1341                 ((unsigned long)partptr[11] << 24);
 780                    	; 1342      lbasize = (unsigned long)partptr[12] +
 781                    	; 1343                ((unsigned long)partptr[13] << 8) +
 782                    	; 1344                ((unsigned long)partptr[14] << 16) +
 783                    	; 1345                ((unsigned long)partptr[15] << 24);
 784                    	; 1346  
 785                    	; 1347      if (!(partptr[4] == 0xee)) /* not pointing to a GPT partition */
 786                    	; 1348          {
 787                    	; 1349          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f)) /* EBR partition */
 788                    	; 1350              {
 789                    	; 1351              parttype = PARTEBR;
 790                    	; 1352              if (curblkno == 0) /* points to EBR in the MBR */
 791                    	; 1353                  {
 792                    	; 1354                  ebrnext = 0;
 793                    	; 1355                  dskmap[partdsk].partype = EBRCONT;
 794                    	; 1356                  dskmap[partdsk].dskletter = 'A' + partdsk;
 795                    	; 1357                  dskmap[partdsk].dskstart = lbastart;
 796                    	; 1358                  dskmap[partdsk].dskend = lbastart + lbasize - 1;
 797                    	; 1359                  dskmap[partdsk].dsksize = lbasize;
 798                    	; 1360                  dskmap[partdsk].dsktype[0] = partptr[4];
 799                    	; 1361                  partdsk++;
 800                    	; 1362                  ebrrecs[ebrrecidx++] = lbastart; /* save to handle later */
 801                    	; 1363                  }
 802                    	; 1364              else
 803                    	; 1365                  {
 804                    	; 1366                  ebrnext = curblkno + lbastart;
 805                    	; 1367                  }
 806                    	; 1368              }
 807                    	; 1369          else
 808                    	; 1370              {
 809                    	; 1371              if (0 < lbasize) /* one more ugly hack to avoid empty partitions */
 810                    	; 1372                  {
 811                    	; 1373                  if (partptr[0] & 0x80)
 812                    	; 1374                      dskmap[partdsk].bootable = YES;
 813                    	; 1375                  if (curblkno == 0)
 814                    	; 1376                      dskmap[partdsk].partype = PARTMBR;
 815                    	; 1377                  else
 816                    	; 1378                      dskmap[partdsk].partype = PARTEBR;
 817                    	; 1379                  dskmap[partdsk].dskletter = 'A' + partdsk;
 818                    	; 1380                  dskmap[partdsk].dskstart = curblkno + lbastart;
 819                    	; 1381                  dskmap[partdsk].dskend = curblkno + lbastart + lbasize - 1;
 820                    	; 1382                  dskmap[partdsk].dsksize = lbasize;
 821                    	; 1383                  dskmap[partdsk].dsktype[0] = partptr[4];
 822                    	; 1384                  partdsk++;
 823                    	; 1385                  }
 824                    	; 1386              }
 825                    	; 1387          }
 826                    	; 1388  
 827                    	; 1389      if (sdtestflg)
 828                    	; 1390          {
 829                    	; 1391          printf("  partition start LBA: %lu [%08lx]\n",
 830                    	; 1392                 curblkno + lbastart, curblkno + lbastart);
 831                    	; 1393          printf("  partition size LBA: %lu [%08lx], %lu MByte\n",
 832                    	; 1394                 lbasize, lbasize, lbasize >> 11);
 833                    	; 1395          } /* sdtestflg */
 834                    	; 1396      if (partptr[4] == 0xee) /* GPT partitions */
 835                    	; 1397          {
 836                    	; 1398          parttype = PARTGPT;
 837                    	; 1399          if (sdtestflg)
 838                    	; 1400              {
 839                    	; 1401              printf("GTP partitions\n");
 840                    	; 1402              } /* sdtestflg */
 841                    	; 1403          sdgpthdr(lbastart); /* handle GTP partitions */
 842                    	; 1404          /* re-read MBR on sector 0
 843                    	; 1405             This is probably not needed as there
 844                    	; 1406             is only one entry (the first one)
 845                    	; 1407             in the MBR when using GPT */
 846                    	; 1408          if (sdread(sdrdbuf, 0))
 847                    	; 1409              {
 848                    	; 1410              curblkno = 0;
 849    3D39  97        		sub	a
 850    3D3A  320200    		ld	(_curblkno),a
 851    3D3D  320300    		ld	(_curblkno+1),a
 852    3D40  320400    		ld	(_curblkno+2),a
 853    3D43  320500    		ld	(_curblkno+3),a
 854    3D46  221000    		ld	(_curblkok),hl
 855                    	; 1411              curblkok = YES;
 856                    	; 1412              }
 857                    	; 1413          else
 858    3D49  1813      		jr	L1525
 859                    	L1725:
 860                    	; 1414              {
 861                    	; 1415              if (sdtestflg)
 862    3D4B  2A0000    		ld	hl,(_sdtestflg)
 863    3D4E  7C        		ld	a,h
 864    3D4F  B5        		or	l
 865    3D50  2806      		jr	z,L1135
 866                    	; 1416                  {
 867                    	; 1417                  printf("  can't read MBR on sector 0\n");
 868    3D52  21C436    		ld	hl,L5052
 869    3D55  CD0000    		call	_printf
 870                    	L1135:
 871                    	; 1418                  } /* sdtestflg */
 872                    	; 1419              return(-1);
 873    3D58  01FFFF    		ld	bc,65535
 874    3D5B  C30000    		jp	c.rets
 875                    	L1525:
 876                    	; 1420              }
 877                    	; 1421          }
 878                    	; 1422      return (parttype);
 879    3D5E  DD4EF6    		ld	c,(ix-10)
 880    3D61  DD46F7    		ld	b,(ix-9)
 881    3D64  C30000    		jp	c.rets
 882                    	L5152:
 883    3D67  4D        		.byte	77
 884    3D68  42        		.byte	66
 885    3D69  52        		.byte	82
 886    3D6A  00        		.byte	0
 887                    	L5252:
 888    3D6B  45        		.byte	69
 889    3D6C  42        		.byte	66
 890    3D6D  52        		.byte	82
 891    3D6E  00        		.byte	0
 892                    	L5352:
 893    3D6F  52        		.byte	82
 894    3D70  65        		.byte	101
 895    3D71  61        		.byte	97
 896    3D72  64        		.byte	100
 897    3D73  20        		.byte	32
 898    3D74  25        		.byte	37
 899    3D75  73        		.byte	115
 900    3D76  20        		.byte	32
 901    3D77  66        		.byte	102
 902    3D78  72        		.byte	114
 903    3D79  6F        		.byte	111
 904    3D7A  6D        		.byte	109
 905    3D7B  20        		.byte	32
 906    3D7C  73        		.byte	115
 907    3D7D  65        		.byte	101
 908    3D7E  63        		.byte	99
 909    3D7F  74        		.byte	116
 910    3D80  6F        		.byte	111
 911    3D81  72        		.byte	114
 912    3D82  20        		.byte	32
 913    3D83  25        		.byte	37
 914    3D84  6C        		.byte	108
 915    3D85  75        		.byte	117
 916    3D86  0A        		.byte	10
 917    3D87  00        		.byte	0
 918                    	L5452:
 919    3D88  20        		.byte	32
 920    3D89  20        		.byte	32
 921    3D8A  63        		.byte	99
 922    3D8B  61        		.byte	97
 923    3D8C  6E        		.byte	110
 924    3D8D  27        		.byte	39
 925    3D8E  74        		.byte	116
 926    3D8F  20        		.byte	32
 927    3D90  72        		.byte	114
 928    3D91  65        		.byte	101
 929    3D92  61        		.byte	97
 930    3D93  64        		.byte	100
 931    3D94  20        		.byte	32
 932    3D95  25        		.byte	37
 933    3D96  73        		.byte	115
 934    3D97  20        		.byte	32
 935    3D98  73        		.byte	115
 936    3D99  65        		.byte	101
 937    3D9A  63        		.byte	99
 938    3D9B  74        		.byte	116
 939    3D9C  6F        		.byte	111
 940    3D9D  72        		.byte	114
 941    3D9E  20        		.byte	32
 942    3D9F  25        		.byte	37
 943    3DA0  6C        		.byte	108
 944    3DA1  75        		.byte	117
 945    3DA2  0A        		.byte	10
 946    3DA3  00        		.byte	0
 947                    	L5552:
 948    3DA4  20        		.byte	32
 949    3DA5  20        		.byte	32
 950    3DA6  6E        		.byte	110
 951    3DA7  6F        		.byte	111
 952    3DA8  20        		.byte	32
 953    3DA9  25        		.byte	37
 954    3DAA  73        		.byte	115
 955    3DAB  20        		.byte	32
 956    3DAC  62        		.byte	98
 957    3DAD  6F        		.byte	111
 958    3DAE  6F        		.byte	111
 959    3DAF  74        		.byte	116
 960    3DB0  20        		.byte	32
 961    3DB1  73        		.byte	115
 962    3DB2  69        		.byte	105
 963    3DB3  67        		.byte	103
 964    3DB4  6E        		.byte	110
 965    3DB5  61        		.byte	97
 966    3DB6  74        		.byte	116
 967    3DB7  75        		.byte	117
 968    3DB8  72        		.byte	114
 969    3DB9  65        		.byte	101
 970    3DBA  20        		.byte	32
 971    3DBB  66        		.byte	102
 972    3DBC  6F        		.byte	111
 973    3DBD  75        		.byte	117
 974    3DBE  6E        		.byte	110
 975    3DBF  64        		.byte	100
 976    3DC0  0A        		.byte	10
 977    3DC1  00        		.byte	0
 978                    	L5652:
 979    3DC2  20        		.byte	32
 980    3DC3  20        		.byte	32
 981    3DC4  64        		.byte	100
 982    3DC5  69        		.byte	105
 983    3DC6  73        		.byte	115
 984    3DC7  6B        		.byte	107
 985    3DC8  20        		.byte	32
 986    3DC9  69        		.byte	105
 987    3DCA  64        		.byte	100
 988    3DCB  65        		.byte	101
 989    3DCC  6E        		.byte	110
 990    3DCD  74        		.byte	116
 991    3DCE  69        		.byte	105
 992    3DCF  66        		.byte	102
 993    3DD0  69        		.byte	105
 994    3DD1  65        		.byte	101
 995    3DD2  72        		.byte	114
 996    3DD3  3A        		.byte	58
 997    3DD4  20        		.byte	32
 998    3DD5  30        		.byte	48
 999    3DD6  78        		.byte	120
1000    3DD7  25        		.byte	37
1001    3DD8  30        		.byte	48
1002    3DD9  32        		.byte	50
1003    3DDA  78        		.byte	120
1004    3DDB  25        		.byte	37
1005    3DDC  30        		.byte	48
1006    3DDD  32        		.byte	50
1007    3DDE  78        		.byte	120
1008    3DDF  25        		.byte	37
1009    3DE0  30        		.byte	48
1010    3DE1  32        		.byte	50
1011    3DE2  78        		.byte	120
1012    3DE3  25        		.byte	37
1013    3DE4  30        		.byte	48
1014    3DE5  32        		.byte	50
1015    3DE6  78        		.byte	120
1016    3DE7  0A        		.byte	10
1017    3DE8  00        		.byte	0
1018                    	L5752:
1019    3DE9  25        		.byte	37
1020    3DEA  73        		.byte	115
1021    3DEB  20        		.byte	32
1022    3DEC  70        		.byte	112
1023    3DED  61        		.byte	97
1024    3DEE  72        		.byte	114
1025    3DEF  74        		.byte	116
1026    3DF0  69        		.byte	105
1027    3DF1  74        		.byte	116
1028    3DF2  69        		.byte	105
1029    3DF3  6F        		.byte	111
1030    3DF4  6E        		.byte	110
1031    3DF5  20        		.byte	32
1032    3DF6  65        		.byte	101
1033    3DF7  6E        		.byte	110
1034    3DF8  74        		.byte	116
1035    3DF9  72        		.byte	114
1036    3DFA  79        		.byte	121
1037    3DFB  20        		.byte	32
1038    3DFC  25        		.byte	37
1039    3DFD  64        		.byte	100
1040    3DFE  3A        		.byte	58
1041    3DFF  20        		.byte	32
1042    3E00  00        		.byte	0
1043                    	L5062:
1044    3E01  20        		.byte	32
1045    3E02  20        		.byte	32
1046    3E03  63        		.byte	99
1047    3E04  61        		.byte	97
1048    3E05  6E        		.byte	110
1049    3E06  27        		.byte	39
1050    3E07  74        		.byte	116
1051    3E08  20        		.byte	32
1052    3E09  72        		.byte	114
1053    3E0A  65        		.byte	101
1054    3E0B  61        		.byte	97
1055    3E0C  64        		.byte	100
1056    3E0D  20        		.byte	32
1057    3E0E  25        		.byte	37
1058    3E0F  73        		.byte	115
1059    3E10  20        		.byte	32
1060    3E11  73        		.byte	115
1061    3E12  65        		.byte	101
1062    3E13  63        		.byte	99
1063    3E14  74        		.byte	116
1064    3E15  6F        		.byte	111
1065    3E16  72        		.byte	114
1066    3E17  20        		.byte	32
1067    3E18  25        		.byte	37
1068    3E19  6C        		.byte	108
1069    3E1A  75        		.byte	117
1070    3E1B  0A        		.byte	10
1071    3E1C  00        		.byte	0
1072                    	L5162:
1073    3E1D  45        		.byte	69
1074    3E1E  42        		.byte	66
1075    3E1F  52        		.byte	82
1076    3E20  20        		.byte	32
1077    3E21  70        		.byte	112
1078    3E22  61        		.byte	97
1079    3E23  72        		.byte	114
1080    3E24  74        		.byte	116
1081    3E25  69        		.byte	105
1082    3E26  74        		.byte	116
1083    3E27  69        		.byte	105
1084    3E28  6F        		.byte	111
1085    3E29  6E        		.byte	110
1086    3E2A  20        		.byte	32
1087    3E2B  65        		.byte	101
1088    3E2C  6E        		.byte	110
1089    3E2D  74        		.byte	116
1090    3E2E  72        		.byte	114
1091    3E2F  79        		.byte	121
1092    3E30  20        		.byte	32
1093    3E31  25        		.byte	37
1094    3E32  64        		.byte	100
1095    3E33  3A        		.byte	58
1096    3E34  20        		.byte	32
1097    3E35  00        		.byte	0
1098                    	L5262:
1099    3E36  45        		.byte	69
1100    3E37  6D        		.byte	109
1101    3E38  70        		.byte	112
1102    3E39  74        		.byte	116
1103    3E3A  79        		.byte	121
1104    3E3B  20        		.byte	32
1105    3E3C  70        		.byte	112
1106    3E3D  61        		.byte	97
1107    3E3E  72        		.byte	114
1108    3E3F  74        		.byte	116
1109    3E40  69        		.byte	105
1110    3E41  74        		.byte	116
1111    3E42  69        		.byte	105
1112    3E43  6F        		.byte	111
1113    3E44  6E        		.byte	110
1114    3E45  20        		.byte	32
1115    3E46  65        		.byte	101
1116    3E47  6E        		.byte	110
1117    3E48  74        		.byte	116
1118    3E49  72        		.byte	114
1119    3E4A  79        		.byte	121
1120    3E4B  0A        		.byte	10
1121    3E4C  00        		.byte	0
1122                    	L5362:
1123    3E4D  45        		.byte	69
1124    3E4E  42        		.byte	66
1125    3E4F  52        		.byte	82
1126    3E50  20        		.byte	32
1127    3E51  63        		.byte	99
1128    3E52  68        		.byte	104
1129    3E53  61        		.byte	97
1130    3E54  69        		.byte	105
1131    3E55  6E        		.byte	110
1132    3E56  0A        		.byte	10
1133    3E57  00        		.byte	0
1134                    	L5462:
1135    3E58  20        		.byte	32
1136    3E59  20        		.byte	32
1137    3E5A  63        		.byte	99
1138    3E5B  61        		.byte	97
1139    3E5C  6E        		.byte	110
1140    3E5D  27        		.byte	39
1141    3E5E  74        		.byte	116
1142    3E5F  20        		.byte	32
1143    3E60  72        		.byte	114
1144    3E61  65        		.byte	101
1145    3E62  61        		.byte	97
1146    3E63  64        		.byte	100
1147    3E64  20        		.byte	32
1148    3E65  25        		.byte	37
1149    3E66  73        		.byte	115
1150    3E67  20        		.byte	32
1151    3E68  73        		.byte	115
1152    3E69  65        		.byte	101
1153    3E6A  63        		.byte	99
1154    3E6B  74        		.byte	116
1155    3E6C  6F        		.byte	111
1156    3E6D  72        		.byte	114
1157    3E6E  20        		.byte	32
1158    3E6F  25        		.byte	37
1159    3E70  6C        		.byte	108
1160    3E71  75        		.byte	117
1161    3E72  0A        		.byte	10
1162    3E73  00        		.byte	0
1163                    	L5562:
1164    3E74  45        		.byte	69
1165    3E75  42        		.byte	66
1166    3E76  52        		.byte	82
1167    3E77  20        		.byte	32
1168    3E78  63        		.byte	99
1169    3E79  68        		.byte	104
1170    3E7A  61        		.byte	97
1171    3E7B  69        		.byte	105
1172    3E7C  6E        		.byte	110
1173    3E7D  65        		.byte	101
1174    3E7E  64        		.byte	100
1175    3E7F  20        		.byte	32
1176    3E80  20        		.byte	32
1177    3E81  70        		.byte	112
1178    3E82  61        		.byte	97
1179    3E83  72        		.byte	114
1180    3E84  74        		.byte	116
1181    3E85  69        		.byte	105
1182    3E86  74        		.byte	116
1183    3E87  69        		.byte	105
1184    3E88  6F        		.byte	111
1185    3E89  6E        		.byte	110
1186    3E8A  20        		.byte	32
1187    3E8B  65        		.byte	101
1188    3E8C  6E        		.byte	110
1189    3E8D  74        		.byte	116
1190    3E8E  72        		.byte	114
1191    3E8F  79        		.byte	121
1192    3E90  20        		.byte	32
1193    3E91  25        		.byte	37
1194    3E92  64        		.byte	100
1195    3E93  3A        		.byte	58
1196    3E94  20        		.byte	32
1197    3E95  00        		.byte	0
1198                    	; 1423      }
1199                    	; 1424  
1200                    	; 1425  /* Read and analyze MBR/EBR partition sector block
1201                    	; 1426   * and go through and print partition entries.
1202                    	; 1427   */
1203                    	; 1428  void sdmbrpart(unsigned long sector)
1204                    	; 1429      {
1205                    	_sdmbrpart:
1206    3E96  CD0000    		call	c.savs
1207    3E99  21EEFF    		ld	hl,65518
1208    3E9C  39        		add	hl,sp
1209    3E9D  F9        		ld	sp,hl
1210                    	; 1430      int partidx;  /* partition index 1 - 4 */
1211                    	; 1431      int cpartidx; /* chain partition index 1 - 4 */
1212                    	; 1432      int chainidx;
1213                    	; 1433      int enttype;
1214                    	; 1434      unsigned char *entp; /* pointer to partition entry */
1215                    	; 1435      char *mbrebr;
1216                    	; 1436  
1217                    	; 1437      if (sdtestflg)
1218    3E9E  2A0000    		ld	hl,(_sdtestflg)
1219    3EA1  7C        		ld	a,h
1220    3EA2  B5        		or	l
1221    3EA3  2840      		jr	z,L1235
1222                    	; 1438          {
1223                    	; 1439          if (sector == 0) /* if sector 0 it is MBR else it is EBR */
1224    3EA5  DD7E04    		ld	a,(ix+4)
1225    3EA8  DDB605    		or	(ix+5)
1226    3EAB  DDB606    		or	(ix+6)
1227    3EAE  DDB607    		or	(ix+7)
1228    3EB1  200B      		jr	nz,L1335
1229                    	; 1440              mbrebr = "MBR";
1230    3EB3  21673D    		ld	hl,L5152
1231    3EB6  DD75EE    		ld	(ix-18),l
1232    3EB9  DD74EF    		ld	(ix-17),h
1233                    	; 1441          else
1234    3EBC  1809      		jr	L1435
1235                    	L1335:
1236                    	; 1442              mbrebr = "EBR";
1237    3EBE  216B3D    		ld	hl,L5252
1238    3EC1  DD75EE    		ld	(ix-18),l
1239    3EC4  DD74EF    		ld	(ix-17),h
1240                    	L1435:
1241                    	; 1443          printf("Read %s from sector %lu\n", mbrebr, sector);
1242    3EC7  DD6607    		ld	h,(ix+7)
1243    3ECA  DD6E06    		ld	l,(ix+6)
1244    3ECD  E5        		push	hl
1245    3ECE  DD6605    		ld	h,(ix+5)
1246    3ED1  DD6E04    		ld	l,(ix+4)
1247    3ED4  E5        		push	hl
1248    3ED5  DD6EEE    		ld	l,(ix-18)
1249    3ED8  DD66EF    		ld	h,(ix-17)
1250    3EDB  E5        		push	hl
1251    3EDC  216F3D    		ld	hl,L5352
1252    3EDF  CD0000    		call	_printf
1253    3EE2  F1        		pop	af
1254    3EE3  F1        		pop	af
1255    3EE4  F1        		pop	af
1256                    	L1235:
1257                    	; 1444          } /* sdtestflg */
1258                    	; 1445      if (sdread(sdrdbuf, sector))
1259    3EE5  DD6607    		ld	h,(ix+7)
1260    3EE8  DD6E06    		ld	l,(ix+6)
1261    3EEB  E5        		push	hl
1262    3EEC  DD6605    		ld	h,(ix+5)
1263    3EEF  DD6E04    		ld	l,(ix+4)
1264    3EF2  E5        		push	hl
1265    3EF3  214C00    		ld	hl,_sdrdbuf
1266    3EF6  CDE320    		call	_sdread
1267    3EF9  F1        		pop	af
1268    3EFA  F1        		pop	af
1269    3EFB  79        		ld	a,c
1270    3EFC  B0        		or	b
1271    3EFD  2827      		jr	z,L1535
1272                    	; 1446          {
1273                    	; 1447          curblkno = sector;
1274    3EFF  210200    		ld	hl,_curblkno
1275    3F02  E5        		push	hl
1276    3F03  DDE5      		push	ix
1277    3F05  C1        		pop	bc
1278    3F06  210400    		ld	hl,4
1279    3F09  09        		add	hl,bc
1280    3F0A  E5        		push	hl
1281    3F0B  CD0000    		call	c.mvl
1282    3F0E  F1        		pop	af
1283                    	; 1448          curblkok = YES;
1284    3F0F  210100    		ld	hl,1
1285    3F12  221000    		ld	(_curblkok),hl
1286                    	; 1449          }
1287                    	; 1450      else
1288                    	; 1451          {
1289                    	; 1452          if (sdtestflg)
1290                    	; 1453              {
1291                    	; 1454              printf("  can't read %s sector %lu\n", mbrebr, sector);
1292                    	; 1455              } /* sdtestflg */
1293                    	; 1456          return;
1294                    	; 1457          }
1295                    	; 1458      if (!((sdrdbuf[0x1fe] == 0x55) && (sdrdbuf[0x1ff] == 0xaa)))
1296    3F15  3A4A02    		ld	a,(_sdrdbuf+510)
1297    3F18  FE55      		cp	85
1298    3F1A  2032      		jr	nz,L1145
1299    3F1C  3A4B02    		ld	a,(_sdrdbuf+511)
1300    3F1F  FEAA      		cp	170
1301    3F21  CA663F    		jp	z,L1045
1302    3F24  1828      		jr	L1145
1303                    	L1535:
1304    3F26  2A0000    		ld	hl,(_sdtestflg)
1305    3F29  7C        		ld	a,h
1306    3F2A  B5        		or	l
1307    3F2B  281E      		jr	z,L1735
1308    3F2D  DD6607    		ld	h,(ix+7)
1309    3F30  DD6E06    		ld	l,(ix+6)
1310    3F33  E5        		push	hl
1311    3F34  DD6605    		ld	h,(ix+5)
1312    3F37  DD6E04    		ld	l,(ix+4)
1313    3F3A  E5        		push	hl
1314    3F3B  DD6EEE    		ld	l,(ix-18)
1315    3F3E  DD66EF    		ld	h,(ix-17)
1316    3F41  E5        		push	hl
1317    3F42  21883D    		ld	hl,L5452
1318    3F45  CD0000    		call	_printf
1319    3F48  F1        		pop	af
1320    3F49  F1        		pop	af
1321    3F4A  F1        		pop	af
1322                    	L1735:
1323    3F4B  C30000    		jp	c.rets
1324                    	L1145:
1325                    	; 1459          {
1326                    	; 1460          if (sdtestflg)
1327    3F4E  2A0000    		ld	hl,(_sdtestflg)
1328    3F51  7C        		ld	a,h
1329    3F52  B5        		or	l
1330    3F53  280E      		jr	z,L1245
1331                    	; 1461              {
1332                    	; 1462              printf("  no %s boot signature found\n", mbrebr);
1333    3F55  DD6EEE    		ld	l,(ix-18)
1334    3F58  DD66EF    		ld	h,(ix-17)
1335    3F5B  E5        		push	hl
1336    3F5C  21A43D    		ld	hl,L5552
1337    3F5F  CD0000    		call	_printf
1338    3F62  F1        		pop	af
1339                    	L1245:
1340                    	; 1463              } /* sdtestflg */
1341                    	; 1464          return;
1342    3F63  C30000    		jp	c.rets
1343                    	L1045:
1344                    	; 1465          }
1345                    	; 1466      if (curblkno == 0)
1346    3F66  210200    		ld	hl,_curblkno
1347    3F69  7E        		ld	a,(hl)
1348    3F6A  23        		inc	hl
1349    3F6B  B6        		or	(hl)
1350    3F6C  23        		inc	hl
1351    3F6D  B6        		or	(hl)
1352    3F6E  23        		inc	hl
1353    3F6F  B6        		or	(hl)
1354    3F70  203D      		jr	nz,L1345
1355                    	; 1467          {
1356                    	; 1468          memcpy(dsksign, &sdrdbuf[0x1b8], sizeof dsksign);
1357    3F72  210400    		ld	hl,4
1358    3F75  E5        		push	hl
1359    3F76  210402    		ld	hl,_sdrdbuf+440
1360    3F79  E5        		push	hl
1361    3F7A  214E02    		ld	hl,_dsksign
1362    3F7D  CD0000    		call	_memcpy
1363    3F80  F1        		pop	af
1364    3F81  F1        		pop	af
1365                    	; 1469          if (sdtestflg)
1366    3F82  2A0000    		ld	hl,(_sdtestflg)
1367    3F85  7C        		ld	a,h
1368    3F86  B5        		or	l
1369    3F87  2826      		jr	z,L1345
1370                    	; 1470              {
1371                    	; 1471  
1372                    	; 1472              printf("  disk identifier: 0x%02x%02x%02x%02x\n",
1373                    	; 1473                     dsksign[3], dsksign[2], dsksign[1], dsksign[0]);
1374    3F89  3A4E02    		ld	a,(_dsksign)
1375    3F8C  4F        		ld	c,a
1376    3F8D  97        		sub	a
1377    3F8E  47        		ld	b,a
1378    3F8F  C5        		push	bc
1379    3F90  3A4F02    		ld	a,(_dsksign+1)
1380    3F93  4F        		ld	c,a
1381    3F94  97        		sub	a
1382    3F95  47        		ld	b,a
1383    3F96  C5        		push	bc
1384    3F97  3A5002    		ld	a,(_dsksign+2)
1385    3F9A  4F        		ld	c,a
1386    3F9B  97        		sub	a
1387    3F9C  47        		ld	b,a
1388    3F9D  C5        		push	bc
1389    3F9E  3A5102    		ld	a,(_dsksign+3)
1390    3FA1  4F        		ld	c,a
1391    3FA2  97        		sub	a
1392    3FA3  47        		ld	b,a
1393    3FA4  C5        		push	bc
1394    3FA5  21C23D    		ld	hl,L5652
1395    3FA8  CD0000    		call	_printf
1396    3FAB  F1        		pop	af
1397    3FAC  F1        		pop	af
1398    3FAD  F1        		pop	af
1399    3FAE  F1        		pop	af
1400                    	L1345:
1401                    	; 1474              } /* sdtestflg */
1402                    	; 1475          }
1403                    	; 1476      /* go through MBR partition entries until first empty */
1404                    	; 1477      /* !!as the MBR entry routine is called recusively a way is
1405                    	; 1478         needed to read sector 0 when going back to MBR if
1406                    	; 1479         there is a primary partition entry after an EBR entry!! */
1407                    	; 1480      entp = &sdrdbuf[0x01be] ;
1408    3FAF  210A02    		ld	hl,_sdrdbuf+446
1409    3FB2  DD75F0    		ld	(ix-16),l
1410    3FB5  DD74F1    		ld	(ix-15),h
1411                    	; 1481      for (partidx = 1; (partidx <= 4) && (partdsk < 16); partidx++, entp += 16)
1412    3FB8  DD36F801  		ld	(ix-8),1
1413    3FBC  DD36F900  		ld	(ix-7),0
1414                    	L1545:
1415    3FC0  3E04      		ld	a,4
1416    3FC2  DD96F8    		sub	(ix-8)
1417    3FC5  3E00      		ld	a,0
1418    3FC7  DD9EF9    		sbc	a,(ix-7)
1419    3FCA  FA4640    		jp	m,L1645
1420    3FCD  3A0E00    		ld	a,(_partdsk)
1421    3FD0  D610      		sub	16
1422    3FD2  3A0F00    		ld	a,(_partdsk+1)
1423    3FD5  DE00      		sbc	a,0
1424    3FD7  F24640    		jp	p,L1645
1425                    	; 1482          {
1426                    	; 1483          if (sdtestflg)
1427    3FDA  2A0000    		ld	hl,(_sdtestflg)
1428    3FDD  7C        		ld	a,h
1429    3FDE  B5        		or	l
1430    3FDF  2836      		jr	z,L1155
1431                    	; 1484              {
1432                    	; 1485              printf("%s partition entry %d: ", mbrebr, partidx);
1433    3FE1  DD6EF8    		ld	l,(ix-8)
1434    3FE4  DD66F9    		ld	h,(ix-7)
1435    3FE7  E5        		push	hl
1436    3FE8  DD6EEE    		ld	l,(ix-18)
1437    3FEB  DD66EF    		ld	h,(ix-17)
1438    3FEE  E5        		push	hl
1439    3FEF  21E93D    		ld	hl,L5752
1440    3FF2  CD0000    		call	_printf
1441    3FF5  F1        		pop	af
1442    3FF6  F1        		pop	af
1443    3FF7  181E      		jr	L1155
1444                    	L1745:
1445    3FF9  DD34F8    		inc	(ix-8)
1446    3FFC  2003      		jr	nz,L661
1447    3FFE  DD34F9    		inc	(ix-7)
1448                    	L661:
1449    4001  DD6EF0    		ld	l,(ix-16)
1450    4004  DD66F1    		ld	h,(ix-15)
1451    4007  7D        		ld	a,l
1452    4008  C610      		add	a,16
1453    400A  6F        		ld	l,a
1454    400B  7C        		ld	a,h
1455    400C  CE00      		adc	a,0
1456    400E  67        		ld	h,a
1457    400F  DD75F0    		ld	(ix-16),l
1458    4012  DD74F1    		ld	(ix-15),h
1459    4015  18A9      		jr	L1545
1460                    	L1155:
1461                    	; 1486              } /* sdtestflg */
1462                    	; 1487          enttype = sdmbrentry(entp);
1463    4017  DD6EF0    		ld	l,(ix-16)
1464    401A  DD66F1    		ld	h,(ix-15)
1465    401D  CDE236    		call	_sdmbrentry
1466    4020  DD71F2    		ld	(ix-14),c
1467    4023  DD70F3    		ld	(ix-13),b
1468                    	; 1488          if (enttype == -1) /* read error */
1469    4026  DD7EF2    		ld	a,(ix-14)
1470    4029  FEFF      		cp	255
1471    402B  2005      		jr	nz,L071
1472    402D  DD7EF3    		ld	a,(ix-13)
1473    4030  FEFF      		cp	255
1474                    	L071:
1475    4032  2003      		jr	nz,L1255
1476                    	; 1489                   return;
1477    4034  C30000    		jp	c.rets
1478                    	L1255:
1479                    	; 1490          else if (enttype == PARTZRO)
1480    4037  DD7EF2    		ld	a,(ix-14)
1481    403A  DDB6F3    		or	(ix-13)
1482    403D  20BA      		jr	nz,L1745
1483                    	; 1491              {
1484                    	; 1492              if (!sdtestflg)
1485    403F  2A0000    		ld	hl,(_sdtestflg)
1486    4042  7C        		ld	a,h
1487    4043  B5        		or	l
1488    4044  20B3      		jr	nz,L1745
1489                    	; 1493                  {
1490                    	; 1494                  /* if compiled as test program show also empty partitions */
1491                    	; 1495                  break;
1492                    	L1645:
1493                    	; 1496                  } /* sdtestflg */
1494                    	; 1497              }
1495                    	; 1498          }
1496                    	; 1499      /* now handle the previously saved EBR partition sectors */
1497                    	; 1500      for (partidx = 0; (partidx < ebrrecidx) && (partdsk < 16); partidx++)
1498    4046  DD36F800  		ld	(ix-8),0
1499    404A  DD36F900  		ld	(ix-7),0
1500                    	L1655:
1501    404E  211600    		ld	hl,_ebrrecidx
1502    4051  DD7EF8    		ld	a,(ix-8)
1503    4054  96        		sub	(hl)
1504    4055  DD7EF9    		ld	a,(ix-7)
1505    4058  23        		inc	hl
1506    4059  9E        		sbc	a,(hl)
1507    405A  F2AF42    		jp	p,L1755
1508    405D  3A0E00    		ld	a,(_partdsk)
1509    4060  D610      		sub	16
1510    4062  3A0F00    		ld	a,(_partdsk+1)
1511    4065  DE00      		sbc	a,0
1512    4067  F2AF42    		jp	p,L1755
1513                    	; 1501          {
1514                    	; 1502          if (sdread(sdrdbuf, ebrrecs[partidx]))
1515    406A  DD6EF8    		ld	l,(ix-8)
1516    406D  DD66F9    		ld	h,(ix-7)
1517    4070  29        		add	hl,hl
1518    4071  29        		add	hl,hl
1519    4072  011800    		ld	bc,_ebrrecs
1520    4075  09        		add	hl,bc
1521    4076  23        		inc	hl
1522    4077  23        		inc	hl
1523    4078  4E        		ld	c,(hl)
1524    4079  23        		inc	hl
1525    407A  46        		ld	b,(hl)
1526    407B  C5        		push	bc
1527    407C  2B        		dec	hl
1528    407D  2B        		dec	hl
1529    407E  2B        		dec	hl
1530    407F  4E        		ld	c,(hl)
1531    4080  23        		inc	hl
1532    4081  46        		ld	b,(hl)
1533    4082  C5        		push	bc
1534    4083  214C00    		ld	hl,_sdrdbuf
1535    4086  CDE320    		call	_sdread
1536    4089  F1        		pop	af
1537    408A  F1        		pop	af
1538    408B  79        		ld	a,c
1539    408C  B0        		or	b
1540    408D  CAFA40    		jp	z,L1265
1541                    	; 1503              {
1542                    	; 1504              curblkno = ebrrecs[partidx];
1543    4090  210200    		ld	hl,_curblkno
1544    4093  E5        		push	hl
1545    4094  DD6EF8    		ld	l,(ix-8)
1546    4097  DD66F9    		ld	h,(ix-7)
1547    409A  29        		add	hl,hl
1548    409B  29        		add	hl,hl
1549    409C  011800    		ld	bc,_ebrrecs
1550    409F  09        		add	hl,bc
1551    40A0  E5        		push	hl
1552    40A1  CD0000    		call	c.mvl
1553    40A4  F1        		pop	af
1554                    	; 1505              curblkok = YES;
1555    40A5  210100    		ld	hl,1
1556    40A8  221000    		ld	(_curblkok),hl
1557                    	; 1506              }
1558                    	; 1507          else
1559                    	; 1508              {
1560                    	; 1509              if (sdtestflg)
1561                    	; 1510                  {
1562                    	; 1511                  printf("  can't read %s sector %lu\n", mbrebr, sector);
1563                    	; 1512                  } /* sdtestflg */
1564                    	; 1513              return;
1565                    	; 1514              }
1566                    	; 1515          entp = &sdrdbuf[0x01be] ;
1567    40AB  210A02    		ld	hl,_sdrdbuf+446
1568    40AE  DD75F0    		ld	(ix-16),l
1569    40B1  DD74F1    		ld	(ix-15),h
1570                    	; 1516          for (partidx = 1; (partidx <= 4) && (partdsk < 16); partidx++, entp += 16)
1571    40B4  DD36F801  		ld	(ix-8),1
1572    40B8  DD36F900  		ld	(ix-7),0
1573                    	L1565:
1574    40BC  3E04      		ld	a,4
1575    40BE  DD96F8    		sub	(ix-8)
1576    40C1  3E00      		ld	a,0
1577    40C3  DD9EF9    		sbc	a,(ix-7)
1578    40C6  FAEF40    		jp	m,L1065
1579    40C9  3A0E00    		ld	a,(_partdsk)
1580    40CC  D610      		sub	16
1581    40CE  3A0F00    		ld	a,(_partdsk+1)
1582    40D1  DE00      		sbc	a,0
1583    40D3  F2EF40    		jp	p,L1065
1584                    	; 1517              {
1585                    	; 1518              if (sdtestflg)
1586    40D6  2A0000    		ld	hl,(_sdtestflg)
1587    40D9  7C        		ld	a,h
1588    40DA  B5        		or	l
1589    40DB  CA4141    		jp	z,L1175
1590                    	; 1519                  {
1591                    	; 1520                  printf("EBR partition entry %d: ", partidx);
1592    40DE  DD6EF8    		ld	l,(ix-8)
1593    40E1  DD66F9    		ld	h,(ix-7)
1594    40E4  E5        		push	hl
1595    40E5  211D3E    		ld	hl,L5162
1596    40E8  CD0000    		call	_printf
1597    40EB  F1        		pop	af
1598    40EC  C34141    		jp	L1175
1599                    	L1065:
1600    40EF  DD34F8    		inc	(ix-8)
1601    40F2  2003      		jr	nz,L271
1602    40F4  DD34F9    		inc	(ix-7)
1603                    	L271:
1604    40F7  C34E40    		jp	L1655
1605                    	L1265:
1606    40FA  2A0000    		ld	hl,(_sdtestflg)
1607    40FD  7C        		ld	a,h
1608    40FE  B5        		or	l
1609    40FF  281E      		jr	z,L1465
1610    4101  DD6607    		ld	h,(ix+7)
1611    4104  DD6E06    		ld	l,(ix+6)
1612    4107  E5        		push	hl
1613    4108  DD6605    		ld	h,(ix+5)
1614    410B  DD6E04    		ld	l,(ix+4)
1615    410E  E5        		push	hl
1616    410F  DD6EEE    		ld	l,(ix-18)
1617    4112  DD66EF    		ld	h,(ix-17)
1618    4115  E5        		push	hl
1619    4116  21013E    		ld	hl,L5062
1620    4119  CD0000    		call	_printf
1621    411C  F1        		pop	af
1622    411D  F1        		pop	af
1623    411E  F1        		pop	af
1624                    	L1465:
1625    411F  C30000    		jp	c.rets
1626                    	L1765:
1627    4122  DD34F8    		inc	(ix-8)
1628    4125  2003      		jr	nz,L471
1629    4127  DD34F9    		inc	(ix-7)
1630                    	L471:
1631    412A  DD6EF0    		ld	l,(ix-16)
1632    412D  DD66F1    		ld	h,(ix-15)
1633    4130  7D        		ld	a,l
1634    4131  C610      		add	a,16
1635    4133  6F        		ld	l,a
1636    4134  7C        		ld	a,h
1637    4135  CE00      		adc	a,0
1638    4137  67        		ld	h,a
1639    4138  DD75F0    		ld	(ix-16),l
1640    413B  DD74F1    		ld	(ix-15),h
1641    413E  C3BC40    		jp	L1565
1642                    	L1175:
1643                    	; 1521                  } /* sdtestflg */
1644                    	; 1522              enttype = sdmbrentry(entp);
1645    4141  DD6EF0    		ld	l,(ix-16)
1646    4144  DD66F1    		ld	h,(ix-15)
1647    4147  CDE236    		call	_sdmbrentry
1648    414A  DD71F2    		ld	(ix-14),c
1649    414D  DD70F3    		ld	(ix-13),b
1650                    	; 1523              if (enttype == -1) /* read error */
1651    4150  DD7EF2    		ld	a,(ix-14)
1652    4153  FEFF      		cp	255
1653    4155  2005      		jr	nz,L671
1654    4157  DD7EF3    		ld	a,(ix-13)
1655    415A  FEFF      		cp	255
1656                    	L671:
1657    415C  2003      		jr	nz,L1275
1658                    	; 1524                   return;
1659    415E  C30000    		jp	c.rets
1660                    	L1275:
1661                    	; 1525              else if (enttype == PARTZRO) /* empty partition entry */
1662    4161  DD7EF2    		ld	a,(ix-14)
1663    4164  DDB6F3    		or	(ix-13)
1664    4167  2010      		jr	nz,L1475
1665                    	; 1526                  {
1666                    	; 1527                  if (sdtestflg)
1667    4169  2A0000    		ld	hl,(_sdtestflg)
1668    416C  7C        		ld	a,h
1669    416D  B5        		or	l
1670    416E  CAEF40    		jp	z,L1065
1671                    	; 1528                      {
1672                    	; 1529                      /* if compiled as test program show also empty partitions */
1673                    	; 1530                      printf("Empty partition entry\n");
1674    4171  21363E    		ld	hl,L5262
1675    4174  CD0000    		call	_printf
1676                    	; 1531                      } /* sdtestflg */
1677                    	; 1532                  else
1678    4177  18A9      		jr	L1765
1679                    	L1475:
1680                    	; 1533                      break;
1681                    	; 1534                  }
1682                    	; 1535              else if (enttype == PARTEBR) /* next chained EBR */
1683    4179  DD7EF2    		ld	a,(ix-14)
1684    417C  FE02      		cp	2
1685    417E  2005      		jr	nz,L002
1686    4180  DD7EF3    		ld	a,(ix-13)
1687    4183  FE00      		cp	0
1688                    	L002:
1689    4185  C22241    		jp	nz,L1765
1690                    	; 1536                  {
1691                    	; 1537                  if (sdtestflg)
1692    4188  2A0000    		ld	hl,(_sdtestflg)
1693    418B  7C        		ld	a,h
1694    418C  B5        		or	l
1695    418D  2806      		jr	z,L1106
1696                    	; 1538                      {
1697                    	; 1539                      printf("EBR chain\n");
1698    418F  214D3E    		ld	hl,L5362
1699    4192  CD0000    		call	_printf
1700                    	L1106:
1701                    	; 1540                      } /* sdtestflg */
1702                    	; 1541                  /* follow the EBR chain */
1703                    	; 1542                  for (chainidx = 0;
1704    4195  DD36F400  		ld	(ix-12),0
1705    4199  DD36F500  		ld	(ix-11),0
1706                    	L1206:
1707                    	; 1543                      ebrnext && (chainidx < 16) && (partdsk < 16);
1708    419D  211200    		ld	hl,_ebrnext
1709    41A0  7E        		ld	a,(hl)
1710    41A1  23        		inc	hl
1711    41A2  B6        		or	(hl)
1712    41A3  23        		inc	hl
1713    41A4  B6        		or	(hl)
1714    41A5  23        		inc	hl
1715    41A6  B6        		or	(hl)
1716    41A7  CA2241    		jp	z,L1765
1717    41AA  DD7EF4    		ld	a,(ix-12)
1718    41AD  D610      		sub	16
1719    41AF  DD7EF5    		ld	a,(ix-11)
1720    41B2  DE00      		sbc	a,0
1721    41B4  F22241    		jp	p,L1765
1722    41B7  3A0E00    		ld	a,(_partdsk)
1723    41BA  D610      		sub	16
1724    41BC  3A0F00    		ld	a,(_partdsk+1)
1725    41BF  DE00      		sbc	a,0
1726    41C1  F22241    		jp	p,L1765
1727                    	; 1544                      chainidx++)
1728                    	; 1545                      {
1729                    	; 1546                      /* ugly hack to stop reading the same sector */
1730                    	; 1547                      if (ebrnext == curblkno)
1731    41C4  211200    		ld	hl,_ebrnext
1732    41C7  E5        		push	hl
1733    41C8  210200    		ld	hl,_curblkno
1734    41CB  E5        		push	hl
1735    41CC  CD0000    		call	c.lcmp
1736    41CF  200D      		jr	nz,L1606
1737                    	; 1548                           break;
1738    41D1  C32241    		jp	L1765
1739                    	L1406:
1740    41D4  DD34F4    		inc	(ix-12)
1741    41D7  2003      		jr	nz,L202
1742    41D9  DD34F5    		inc	(ix-11)
1743                    	L202:
1744    41DC  18BF      		jr	L1206
1745                    	L1606:
1746                    	; 1549                      if (sdread(sdrdbuf, ebrnext))
1747    41DE  211500    		ld	hl,_ebrnext+3
1748    41E1  46        		ld	b,(hl)
1749    41E2  2B        		dec	hl
1750    41E3  4E        		ld	c,(hl)
1751    41E4  C5        		push	bc
1752    41E5  2B        		dec	hl
1753    41E6  46        		ld	b,(hl)
1754    41E7  2B        		dec	hl
1755    41E8  4E        		ld	c,(hl)
1756    41E9  C5        		push	bc
1757    41EA  214C00    		ld	hl,_sdrdbuf
1758    41ED  CDE320    		call	_sdread
1759    41F0  F1        		pop	af
1760    41F1  F1        		pop	af
1761    41F2  79        		ld	a,c
1762    41F3  B0        		or	b
1763    41F4  2855      		jr	z,L1706
1764                    	; 1550                          {
1765                    	; 1551                          curblkno = ebrnext;
1766    41F6  210200    		ld	hl,_curblkno
1767    41F9  E5        		push	hl
1768    41FA  211200    		ld	hl,_ebrnext
1769    41FD  E5        		push	hl
1770    41FE  CD0000    		call	c.mvl
1771    4201  F1        		pop	af
1772                    	; 1552                          curblkok = YES;
1773    4202  210100    		ld	hl,1
1774    4205  221000    		ld	(_curblkok),hl
1775                    	; 1553                          }
1776                    	; 1554                      else
1777                    	; 1555                          {
1778                    	; 1556                          if (sdtestflg)
1779                    	; 1557                              {
1780                    	; 1558                              printf("  can't read %s sector %lu\n", mbrebr, sector);
1781                    	; 1559                              } /* sdtestflg */
1782                    	; 1560                          return;
1783                    	; 1561                          }
1784                    	; 1562                      entp = &sdrdbuf[0x01be] ;
1785    4208  210A02    		ld	hl,_sdrdbuf+446
1786    420B  DD75F0    		ld	(ix-16),l
1787    420E  DD74F1    		ld	(ix-15),h
1788                    	; 1563                      for (cpartidx = 1;
1789    4211  DD36F601  		ld	(ix-10),1
1790    4215  DD36F700  		ld	(ix-9),0
1791                    	L1216:
1792                    	; 1564                          (cpartidx <= 4) && (partdsk < 16);
1793    4219  3E04      		ld	a,4
1794    421B  DD96F6    		sub	(ix-10)
1795    421E  3E00      		ld	a,0
1796    4220  DD9EF7    		sbc	a,(ix-9)
1797    4223  FAD441    		jp	m,L1406
1798    4226  3A0E00    		ld	a,(_partdsk)
1799    4229  D610      		sub	16
1800    422B  3A0F00    		ld	a,(_partdsk+1)
1801    422E  DE00      		sbc	a,0
1802    4230  F2D441    		jp	p,L1406
1803                    	; 1565                          cpartidx++, entp += 16)
1804                    	; 1566                          {
1805                    	; 1567                          if (sdtestflg)
1806    4233  2A0000    		ld	hl,(_sdtestflg)
1807    4236  7C        		ld	a,h
1808    4237  B5        		or	l
1809    4238  CA9242    		jp	z,L1616
1810                    	; 1568                              {
1811                    	; 1569                              printf("EBR chained  partition entry %d: ",
1812                    	; 1570                                   cpartidx);
1813    423B  DD6EF6    		ld	l,(ix-10)
1814    423E  DD66F7    		ld	h,(ix-9)
1815    4241  E5        		push	hl
1816    4242  21743E    		ld	hl,L5562
1817    4245  CD0000    		call	_printf
1818    4248  F1        		pop	af
1819    4249  1847      		jr	L1616
1820                    	L1706:
1821    424B  2A0000    		ld	hl,(_sdtestflg)
1822    424E  7C        		ld	a,h
1823    424F  B5        		or	l
1824    4250  281E      		jr	z,L1116
1825    4252  DD6607    		ld	h,(ix+7)
1826    4255  DD6E06    		ld	l,(ix+6)
1827    4258  E5        		push	hl
1828    4259  DD6605    		ld	h,(ix+5)
1829    425C  DD6E04    		ld	l,(ix+4)
1830    425F  E5        		push	hl
1831    4260  DD6EEE    		ld	l,(ix-18)
1832    4263  DD66EF    		ld	h,(ix-17)
1833    4266  E5        		push	hl
1834    4267  21583E    		ld	hl,L5462
1835    426A  CD0000    		call	_printf
1836    426D  F1        		pop	af
1837    426E  F1        		pop	af
1838    426F  F1        		pop	af
1839                    	L1116:
1840    4270  C30000    		jp	c.rets
1841                    	L1416:
1842    4273  DD34F6    		inc	(ix-10)
1843    4276  2003      		jr	nz,L402
1844    4278  DD34F7    		inc	(ix-9)
1845                    	L402:
1846    427B  DD6EF0    		ld	l,(ix-16)
1847    427E  DD66F1    		ld	h,(ix-15)
1848    4281  7D        		ld	a,l
1849    4282  C610      		add	a,16
1850    4284  6F        		ld	l,a
1851    4285  7C        		ld	a,h
1852    4286  CE00      		adc	a,0
1853    4288  67        		ld	h,a
1854    4289  DD75F0    		ld	(ix-16),l
1855    428C  DD74F1    		ld	(ix-15),h
1856    428F  C31942    		jp	L1216
1857                    	L1616:
1858                    	; 1571                              } /* sdtestflg */
1859                    	; 1572                          enttype = sdmbrentry(entp);
1860    4292  DD6EF0    		ld	l,(ix-16)
1861    4295  DD66F1    		ld	h,(ix-15)
1862    4298  CDE236    		call	_sdmbrentry
1863    429B  DD71F2    		ld	(ix-14),c
1864    429E  DD70F3    		ld	(ix-13),b
1865                    	; 1573                          if (enttype == -1) /* read error */
1866    42A1  DD7EF2    		ld	a,(ix-14)
1867    42A4  FEFF      		cp	255
1868    42A6  2005      		jr	nz,L602
1869    42A8  DD7EF3    		ld	a,(ix-13)
1870    42AB  FEFF      		cp	255
1871                    	L602:
1872    42AD  20C4      		jr	nz,L1416
1873                    	; 1574                              return;
1874                    	; 1575                          }
1875                    	; 1576                      }
1876                    	; 1577                  }
1877                    	; 1578              }
1878                    	; 1579          }
1879                    	; 1580      }
1880                    	L1755:
1881                    	;    1  /*  z80sdbt.c Boot and SD card test program.
1882                    	;    2   *
1883                    	;    3   *  Boot code for my DIY Z80 Computer. This
1884                    	;    4   *  program is compiled with Whitesmiths/COSMIC
1885                    	;    5   *  C compiler for Z80.
1886                    	;    6   *
1887                    	;    7   *  Initializes the hardware and detects the
1888                    	;    8   *  presence and partitioning of an attached SD card.
1889                    	;    9   *
1890                    	;   10   *  You are free to use, modify, and redistribute
1891                    	;   11   *  this source code. No warranties are given.
1892                    	;   12   *  Hastily Cobbled Together 2021 and 2022
1893                    	;   13   *  by Hans-Ake Lund
1894                    	;   14   *
1895                    	;   15   */
1896                    	;   16  
1897                    	;   17  #include <std.h>
1898                    	;   18  #include "z80computer.h"
1899                    	;   19  #include "builddate.h"
1900                    	;   20  
1901                    	;   21  /* Program name and version */
1902                    	;   22  #define PRGNAME "z80sdbt "
1903                    	;   23  #define VERSION "version 0.8, "
1904                    	;   24  /* Address in high RAM where to copy uploader */
1905                    	;   25  #define UPLADDR 0xf000
1906                    	;   26  
1907                    	;   27  /* This code should be cleaned up when
1908                    	;   28     remaining functions are implemented
1909                    	;   29   */
1910                    	;   30  #define PARTZRO 0  /* Empty partition entry */
1911                    	;   31  #define PARTMBR 1  /* MBR partition */
1912                    	;   32  #define PARTEBR 2  /* EBR logical partition */
1913                    	;   33  #define PARTGPT 3  /* GPT partition */
1914                    	;   34  #define EBRCONT 20 /* EBR container partition in MBR */
1915                    	;   35  
1916                    	;   36  struct partentry
1917                    	;   37      {
1918                    	;   38      char partype;
1919                    	;   39      char dskletter;
1920                    	;   40      int bootable;
1921                    	;   41      unsigned long dskstart;
1922                    	;   42      unsigned long dskend;
1923                    	;   43      unsigned long dsksize;
1924                    	;   44      unsigned char dsktype[16];
1925                    	;   45      } dskmap[16];
1926                    	;   46  
1927                    	;   47  unsigned char dsksign[4]; /* MBR/EBR disk signature */
1928                    	;   48  
1929                    	;   49  /* Function prototypes */
1930                    	;   50  void sdmbrpart(unsigned long);
1931                    	;   51  
1932                    	;   52  /* External data */
1933                    	;   53  extern const char upload[];
1934                    	;   54  extern const int upload_size;
1935                    	;   55  
1936                    	;   56  /* RAM/EPROM probe */
1937                    	;   57  const int ramprobe = 0;
1938                    	;   58  int *rampptr;
1939                    	;   59  
1940                    	;   60  /* Response length in bytes
1941                    	;   61   */
1942                    	;   62  #define R1_LEN 1
1943                    	;   63  #define R3_LEN 5
1944                    	;   64  #define R7_LEN 5
1945                    	;   65  
1946                    	;   66  /* The SD card commands (5 bytes) and a CRC7 byte as the last byte.
1947                    	;   67   * (The CRC7 byte in the tables below are only for information,
1948                    	;   68   * it is calculated by the sdcommand routine.)
1949                    	;   69   */
1950                    	;   70  const unsigned char cmd0[] = {0x40, 0x00, 0x00, 0x00, 0x00, 0x95};
1951                    	;   71  const unsigned char cmd8[] = {0x48, 0x00, 0x00, 0x01, 0xaa, 0x87};
1952                    	;   72  const unsigned char cmd9[] = {0x49, 0x00, 0x00, 0x00, 0x00, 0xaf};
1953                    	;   73  const unsigned char cmd10[] = {0x4a, 0x00, 0x00, 0x00, 0x00, 0x1b};
1954                    	;   74  const unsigned char cmd16[] = {0x50, 0x00, 0x00, 0x02, 0x00, 0x15};
1955                    	;   75  const unsigned char cmd17[] = {0x51, 0x00, 0x00, 0x00, 0x00, 0x55};
1956                    	;   76  const unsigned char cmd24[] = {0x58, 0x00, 0x00, 0x00, 0x00, 0x6f};
1957                    	;   77  const unsigned char cmd55[] = {0x77, 0x00, 0x00, 0x00, 0x00, 0x65};
1958                    	;   78  const unsigned char cmd58[] = {0x7a, 0x00, 0x00, 0x00, 0x00, 0xfd};
1959                    	;   79  const unsigned char acmd41[] = {0x69, 0x40, 0x00, 0x01, 0xaa, 0x33};
1960                    	;   80  
1961                    	;   81  /* Partition identifiers
1962                    	;   82   */
1963                    	;   83  /* For GPT I have decided that a CP/M partition
1964                    	;   84   * has GUID: AC7176FD-8D55-4FFF-86A5-A36D6368D0CB
1965                    	;   85   */
1966                    	;   86  const unsigned char gptcpm[] =
1967                    	;   87      {
1968                    	;   88      0xfd, 0x76, 0x71, 0xac, 0x55, 0x8d, 0xff, 0x4f,
1969                    	;   89      0x86, 0xa5, 0xa3, 0x6d, 0x63, 0x68, 0xd0, 0xcb
1970                    	;   90      };
1971                    	;   91  /* For MBR/EBR the partition type for CP/M is 0x52
1972                    	;   92   * according to: https://en.wikipedia.org/wiki/Partition_type
1973                    	;   93   */
1974                    	;   94  const unsigned char mbrcpm = 0x52;    /* CP/M partition */
1975                    	;   95  const unsigned char mbrexcode = 0x5f; /* Z80 executable code partition */
1976                    	;   96  /* has a special format that */
1977                    	;   97  /* includes number of sectors to */
1978                    	;   98  /* load and a signature, TBD */
1979                    	;   99  
1980                    	;  100  /* Buffers
1981                    	;  101   */
1982                    	;  102  unsigned char sdrdbuf[512];  /* recieved data from the SD card */
1983                    	;  103  
1984                    	;  104  unsigned char ocrreg[4];     /* SD card OCR register */
1985                    	;  105  unsigned char cidreg[16];    /* SD card CID register */
1986                    	;  106  unsigned char csdreg[16];    /* SD card CSD register */
1987                    	;  107  unsigned long ebrrecs[4];    /* detected EBR records to process */
1988                    	;  108  int ebrrecidx; /* how many EBR records that are populated */
1989                    	;  109  unsigned long ebrnext; /* next chained ebr record */
1990                    	;  110  
1991                    	;  111  /* Variables
1992                    	;  112   */
1993                    	;  113  int curblkok;  /* if YES curblockno is read into buffer */
1994                    	;  114  int partdsk;   /* partition/disk number, 0 = disk A */
1995                    	;  115  int sdinitok;  /* SD card initialized and ready */
1996                    	;  116  int sdver2;    /* SD card version 2 if YES, version 1 if NO */
1997                    	;  117  unsigned long blkmult;   /* block address multiplier */
1998                    	;  118  unsigned long curblkno;  /* block in buffer if curblkok == YES */
1999                    	;  119  
2000                    	;  120  /* debug bool */
2001                    	;  121  int sdtestflg;
2002                    	;  122  
2003                    	;  123  /* CRC routines from:
2004                    	;  124   * https://github.com/LonelyWolf/stm32/blob/master/stm32l-dosfs/sdcard.c
2005                    	;  125   */
2006                    	;  126  
2007                    	;  127  /*
2008                    	;  128  // Calculate CRC7
2009                    	;  129  // It's a 7 bit CRC with polynomial x^7 + x^3 + 1
2010                    	;  130  // input:
2011                    	;  131  //   crcIn - the CRC before (0 for first step)
2012                    	;  132  //   data - byte for CRC calculation
2013                    	;  133  // return: the new CRC7
2014                    	;  134  */
2015                    	;  135  unsigned char CRC7_one(unsigned char crcIn, unsigned char data)
2016                    	;  136      {
2017                    	;  137      const unsigned char g = 0x89;
2018                    	;  138      unsigned char i;
2019                    	;  139  
2020                    	;  140      crcIn ^= data;
2021                    	;  141      for (i = 0; i < 8; i++)
2022                    	;  142          {
2023                    	;  143          if (crcIn & 0x80) crcIn ^= g;
2024                    	;  144          crcIn <<= 1;
2025                    	;  145          }
2026                    	;  146  
2027                    	;  147      return crcIn;
2028                    	;  148      }
2029                    	;  149  
2030                    	;  150  /*
2031                    	;  151  // Calculate CRC16 CCITT
2032                    	;  152  // It's a 16 bit CRC with polynomial x^16 + x^12 + x^5 + 1
2033                    	;  153  // input:
2034                    	;  154  //   crcIn - the CRC before (0 for rist step)
2035                    	;  155  //   data - byte for CRC calculation
2036                    	;  156  // return: the CRC16 value
2037                    	;  157  */
2038                    	;  158  unsigned int CRC16_one(unsigned int crcIn, unsigned char data)
2039                    	;  159      {
2040                    	;  160      crcIn  = (unsigned char)(crcIn >> 8)|(crcIn << 8);
2041                    	;  161      crcIn ^=  data;
2042                    	;  162      crcIn ^= (unsigned char)(crcIn & 0xff) >> 4;
2043                    	;  163      crcIn ^= (crcIn << 8) << 4;
2044                    	;  164      crcIn ^= ((crcIn & 0xff) << 4) << 1;
2045                    	;  165  
2046                    	;  166      return crcIn;
2047                    	;  167      }
2048                    	;  168  
2049                    	;  169  /* Send command to SD card and recieve answer.
2050                    	;  170   * A command is 5 bytes long and is followed by
2051                    	;  171   * a CRC7 checksum byte.
2052                    	;  172   * Returns a pointer to the response
2053                    	;  173   * or 0 if no response start bit found.
2054                    	;  174   */
2055                    	;  175  unsigned char *sdcommand(unsigned char *sdcmdp,
2056                    	;  176                           unsigned char *recbuf, int recbytes)
2057                    	;  177      {
2058                    	;  178      int searchn;  /* byte counter to search for response */
2059                    	;  179      int sdcbytes; /* byte counter for bytes to send */
2060                    	;  180      unsigned char *retptr; /* pointer used to store response */
2061                    	;  181      unsigned char rbyte;   /* recieved byte */
2062                    	;  182      unsigned char crc = 0; /* calculated CRC7 */
2063                    	;  183  
2064                    	;  184      /* send 8*2 clockpules */
2065                    	;  185      spiio(0xff);
2066                    	;  186      spiio(0xff);
2067                    	;  187      for (sdcbytes = 5; 0 < sdcbytes; sdcbytes--) /* send bytes */
2068                    	;  188          {
2069                    	;  189          crc = CRC7_one(crc, *sdcmdp);
2070                    	;  190          spiio(*sdcmdp++);
2071                    	;  191          }
2072                    	;  192      spiio(crc | 0x01);
2073                    	;  193      /* search for recieved byte with start bit
2074                    	;  194         for a maximum of 10 recieved bytes  */
2075                    	;  195      for (searchn = 10; 0 < searchn; searchn--)
2076                    	;  196          {
2077                    	;  197          rbyte = spiio(0xff);
2078                    	;  198          if ((rbyte & 0x80) == 0)
2079                    	;  199              break;
2080                    	;  200          }
2081                    	;  201      if (searchn == 0) /* no start bit found */
2082                    	;  202          return (NO);
2083                    	;  203      retptr = recbuf;
2084                    	;  204      *retptr++ = rbyte;
2085                    	;  205      for (; 1 < recbytes; recbytes--) /* recieve bytes */
2086                    	;  206          *retptr++ = spiio(0xff);
2087                    	;  207      return (recbuf);
2088                    	;  208      }
2089                    	;  209  
2090                    	;  210  /* Initialise SD card interface
2091                    	;  211   *
2092                    	;  212   * returns YES if ok and NO if not ok
2093                    	;  213   *
2094                    	;  214   * References:
2095                    	;  215   *   https://www.sdcard.org/downloads/pls/
2096                    	;  216   *      Physical Layer Simplified Specification version 8.0
2097                    	;  217   *
2098                    	;  218   * A nice flowchart how to initialize:
2099                    	;  219   *   https://www.totalphase.com/blog/2018/08/set-sdc-mmc-cards-spi-mode-verify-files-successfully-programmed/
2100                    	;  220   *
2101                    	;  221   */
2102                    	;  222  int sdinit()
2103                    	;  223      {
2104                    	;  224      int nbytes;  /* byte counter */
2105                    	;  225      int tries;   /* tries to get to active state or searching for data  */
2106                    	;  226      int wtloop;  /* timer loop when trying to enter active state */
2107                    	;  227      unsigned char cmdbuf[5];   /* buffer to build command in */
2108                    	;  228      unsigned char rstatbuf[5]; /* buffer to recieve status in */
2109                    	;  229      unsigned char *statptr;    /* pointer to returned status from SD command */
2110                    	;  230      unsigned char crc;         /* crc register for CID and CSD */
2111                    	;  231      unsigned char rbyte;       /* recieved byte */
2112                    	;  232      unsigned char *prtptr;     /* for debug printing */
2113                    	;  233  
2114                    	;  234      ledon();
2115                    	;  235      spideselect();
2116                    	;  236      sdinitok = NO;
2117                    	;  237  
2118                    	;  238      /* start to generate 9*8 clock pulses with not selected SD card */
2119                    	;  239      for (nbytes = 9; 0 < nbytes; nbytes--)
2120                    	;  240          spiio(0xff);
2121                    	;  241      if (sdtestflg)
2122                    	;  242          {
2123                    	;  243          printf("\nSent 8*8 (72) clock pulses, select not active\n");
2124                    	;  244          } /* sdtestflg */
2125                    	;  245      spiselect();
2126                    	;  246  
2127                    	;  247      /* CMD0: GO_IDLE_STATE */
2128                    	;  248      for (tries = 0; tries < 10; tries++)
2129                    	;  249          {
2130                    	;  250          memcpy(cmdbuf, cmd0, 5);
2131                    	;  251          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2132                    	;  252          if (sdtestflg)
2133                    	;  253              {
2134                    	;  254              if (!statptr)
2135                    	;  255                  printf("CMD0: no response\n");
2136                    	;  256              else
2137                    	;  257                  printf("CMD0: GO_IDLE_STATE, R1 response [%02x]\n", statptr[0]);
2138                    	;  258              } /* sdtestflg */
2139                    	;  259          if (!statptr)
2140                    	;  260              {
2141                    	;  261              spideselect();
2142                    	;  262              ledoff();
2143                    	;  263              return (NO);
2144                    	;  264              }
2145                    	;  265          if (statptr[0] == 0x01)
2146                    	;  266              break;
2147                    	;  267          for (wtloop = 0; wtloop < tries * 10; wtloop++)
2148                    	;  268              {
2149                    	;  269              /* wait loop, time increasing for each try */
2150                    	;  270              spiio(0xff);
2151                    	;  271              }
2152                    	;  272          }
2153                    	;  273  
2154                    	;  274      /* CMD8: SEND_IF_COND */
2155                    	;  275      memcpy(cmdbuf, cmd8, 5);
2156                    	;  276      statptr = sdcommand(cmdbuf, rstatbuf, R7_LEN);
2157                    	;  277      if (sdtestflg)
2158                    	;  278          {
2159                    	;  279          if (!statptr)
2160                    	;  280              printf("CMD8: no response\n");
2161                    	;  281          else
2162                    	;  282              {
2163                    	;  283              printf("CMD8: SEND_IF_COND, R7 response [%02x %02x %02x %02x %02x], ",
2164                    	;  284                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
2165                    	;  285              if (!(statptr[0] & 0xfe)) /* no error */
2166                    	;  286                  {
2167                    	;  287                  if (statptr[4] == 0xaa)
2168                    	;  288                      printf("echo back ok, ");
2169                    	;  289                  else
2170                    	;  290                      printf("invalid echo back\n");
2171                    	;  291                  }
2172                    	;  292              }
2173                    	;  293          } /* sdtestflg */
2174                    	;  294      if (!statptr || (statptr[0] & 0xfe)) /* if no answer or error */
2175                    	;  295          {
2176                    	;  296          sdver2 = NO;
2177                    	;  297          if (sdtestflg)
2178                    	;  298              {
2179                    	;  299              printf("probably SD ver. 1\n");
2180                    	;  300              } /* sdtestflg */
2181                    	;  301          }
2182                    	;  302      else
2183                    	;  303          {
2184                    	;  304          sdver2 = YES;
2185                    	;  305          if (statptr[4] != 0xaa) /* but invalid echo back */
2186                    	;  306              {
2187                    	;  307              spideselect();
2188                    	;  308              ledoff();
2189                    	;  309              return (NO);
2190                    	;  310              }
2191                    	;  311          if (sdtestflg)
2192                    	;  312              {
2193                    	;  313              printf("SD ver 2\n");
2194                    	;  314              } /* sdtestflg */
2195                    	;  315          }
2196                    	;  316  
2197                    	;  317      /* CMD55: APP_CMD followed by ACMD41: SEND_OP_COND until status is 0x00 */
2198                    	;  318      for (tries = 0; tries < 20; tries++)
2199                    	;  319          {
2200                    	;  320          memcpy(cmdbuf, cmd55, 5);
2201                    	;  321          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2202                    	;  322          if (sdtestflg)
2203                    	;  323              {
2204                    	;  324              if (!statptr)
2205                    	;  325                  printf("CMD55: no response\n");
2206                    	;  326              else
2207                    	;  327                  printf("CMD55: APP_CMD, R1 response [%02x]\n", statptr[0]);
2208                    	;  328              } /* sdtestflg */
2209                    	;  329          if (!statptr)
2210                    	;  330              {
2211                    	;  331              spideselect();
2212                    	;  332              ledoff();
2213                    	;  333              return (NO);
2214                    	;  334              }
2215                    	;  335          memcpy(cmdbuf, acmd41, 5);
2216                    	;  336          if (sdver2)
2217                    	;  337              cmdbuf[1] = 0x40;
2218                    	;  338          else
2219                    	;  339              cmdbuf[1] = 0x00;
2220                    	;  340          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2221                    	;  341          if (sdtestflg)
2222                    	;  342              {
2223                    	;  343              if (!statptr)
2224                    	;  344                  printf("ACMD41: no response\n");
2225                    	;  345              else
2226                    	;  346                  printf("ACMD41: SEND_OP_COND, R1 response [%02x]%s\n",
2227                    	;  347                         statptr[0], (statptr[0] == 0x00) ? " - ready" : "");
2228                    	;  348              } /* sdtestflg */
2229                    	;  349          if (!statptr)
2230                    	;  350              {
2231                    	;  351              spideselect();
2232                    	;  352              ledoff();
2233                    	;  353              return (NO);
2234                    	;  354              }
2235                    	;  355          if (statptr[0] == 0x00) /* now the SD card is ready */
2236                    	;  356              {
2237                    	;  357              break;
2238                    	;  358              }
2239                    	;  359          for (wtloop = 0; wtloop < tries * 10; wtloop++)
2240                    	;  360              {
2241                    	;  361              /* wait loop, time increasing for each try */
2242                    	;  362              spiio(0xff);
2243                    	;  363              }
2244                    	;  364          }
2245                    	;  365  
2246                    	;  366      /* CMD58: READ_OCR */
2247                    	;  367      /* According to the flow chart this should not work
2248                    	;  368         for SD ver. 1 but the response is ok anyway
2249                    	;  369         all tested SD cards  */
2250                    	;  370      memcpy(cmdbuf, cmd58, 5);
2251                    	;  371      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
2252                    	;  372      if (sdtestflg)
2253                    	;  373          {
2254                    	;  374          if (!statptr)
2255                    	;  375              printf("CMD58: no response\n");
2256                    	;  376          else
2257                    	;  377              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
2258                    	;  378                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
2259                    	;  379          } /* sdtestflg */
2260                    	;  380      if (!statptr)
2261                    	;  381          {
2262                    	;  382          spideselect();
2263                    	;  383          ledoff();
2264                    	;  384          return (NO);
2265                    	;  385          }
2266                    	;  386      memcpy(&ocrreg[0], &statptr[1], sizeof (ocrreg));
2267                    	;  387      blkmult = 1; /* assume block address */
2268                    	;  388      if (ocrreg[0] & 0x80)
2269                    	;  389          {
2270                    	;  390          /* SD Ver.2+ */
2271                    	;  391          if (!(ocrreg[0] & 0x40))
2272                    	;  392              {
2273                    	;  393              /* SD Ver.2+, Byte address */
2274                    	;  394              blkmult = 512;
2275                    	;  395              }
2276                    	;  396          }
2277                    	;  397  
2278                    	;  398      /* CMD 16: SET_BLOCKLEN, only if Byte addressing */
2279                    	;  399      if (blkmult == 512)
2280                    	;  400          {
2281                    	;  401          memcpy(cmdbuf, cmd16, 5);
2282                    	;  402          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2283                    	;  403          if (sdtestflg)
2284                    	;  404              {
2285                    	;  405              if (!statptr)
2286                    	;  406                  printf("CMD16: no response\n");
2287                    	;  407              else
2288                    	;  408                  printf("CMD16: SET_BLOCKLEN (to 512 bytes), R1 response [%02x]\n",
2289                    	;  409                         statptr[0]);
2290                    	;  410              } /* sdtestflg */
2291                    	;  411          if (!statptr)
2292                    	;  412              {
2293                    	;  413              spideselect();
2294                    	;  414              ledoff();
2295                    	;  415              return (NO);
2296                    	;  416              }
2297                    	;  417          }
2298                    	;  418      /* Register information:
2299                    	;  419       *   https://www.cameramemoryspeed.com/sd-memory-card-faq/reading-sd-card-cid-serial-psn-internal-numbers/
2300                    	;  420       */
2301                    	;  421  
2302                    	;  422      /* CMD10: SEND_CID */
2303                    	;  423      memcpy(cmdbuf, cmd10, 5);
2304                    	;  424      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2305                    	;  425      if (sdtestflg)
2306                    	;  426          {
2307                    	;  427          if (!statptr)
2308                    	;  428              printf("CMD10: no response\n");
2309                    	;  429          else
2310                    	;  430              printf("CMD10: SEND_CID, R1 response [%02x]\n", statptr[0]);
2311                    	;  431          } /* sdtestflg */
2312                    	;  432      if (!statptr)
2313                    	;  433          {
2314                    	;  434          spideselect();
2315                    	;  435          ledoff();
2316                    	;  436          return (NO);
2317                    	;  437          }
2318                    	;  438      /* looking for 0xfe that is the byte before data */
2319                    	;  439      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
2320                    	;  440          ;
2321                    	;  441      if (tries == 0) /* tried too many times */
2322                    	;  442          {
2323                    	;  443          if (sdtestflg)
2324                    	;  444              {
2325                    	;  445              printf("  No data found\n");
2326                    	;  446              } /* sdtestflg */
2327                    	;  447          spideselect();
2328                    	;  448          ledoff();
2329                    	;  449          return (NO);
2330                    	;  450          }
2331                    	;  451      else
2332                    	;  452          {
2333                    	;  453          crc = 0;
2334                    	;  454          for (nbytes = 0; nbytes < 15; nbytes++)
2335                    	;  455              {
2336                    	;  456              rbyte = spiio(0xff);
2337                    	;  457              cidreg[nbytes] = rbyte;
2338                    	;  458              crc = CRC7_one(crc, rbyte);
2339                    	;  459              }
2340                    	;  460          cidreg[15] = spiio(0xff);
2341                    	;  461          crc |= 0x01;
2342                    	;  462          /* some SD cards need additional clock pulses */
2343                    	;  463          for (nbytes = 9; 0 < nbytes; nbytes--)
2344                    	;  464              spiio(0xff);
2345                    	;  465          if (sdtestflg)
2346                    	;  466              {
2347                    	;  467              prtptr = &cidreg[0];
2348                    	;  468              printf("  CID: [");
2349                    	;  469              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
2350                    	;  470                  printf("%02x ", *prtptr);
2351                    	;  471              prtptr = &cidreg[0];
2352                    	;  472              printf("\b] |");
2353                    	;  473              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
2354                    	;  474                  {
2355                    	;  475                  if ((' ' <= *prtptr) && (*prtptr < 127))
2356                    	;  476                      putchar(*prtptr);
2357                    	;  477                  else
2358                    	;  478                      putchar('.');
2359                    	;  479                  }
2360                    	;  480              printf("|\n");
2361                    	;  481              if (crc == cidreg[15])
2362                    	;  482                  {
2363                    	;  483                  printf("CRC7 ok: [%02x]\n", crc);
2364                    	;  484                  }
2365                    	;  485              else
2366                    	;  486                  {
2367                    	;  487                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
2368                    	;  488                         crc, cidreg[15]);
2369                    	;  489                  /* could maybe return failure here */
2370                    	;  490                  }
2371                    	;  491              } /* sdtestflg */
2372                    	;  492          }
2373                    	;  493  
2374                    	;  494      /* CMD9: SEND_CSD */
2375                    	;  495      memcpy(cmdbuf, cmd9, 5);
2376                    	;  496      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2377                    	;  497      if (sdtestflg)
2378                    	;  498          {
2379                    	;  499          if (!statptr)
2380                    	;  500              printf("CMD9: no response\n");
2381                    	;  501          else
2382                    	;  502              printf("CMD9: SEND_CSD, R1 response [%02x]\n", statptr[0]);
2383                    	;  503          } /* sdtestflg */
2384                    	;  504      if (!statptr)
2385                    	;  505          {
2386                    	;  506          spideselect();
2387                    	;  507          ledoff();
2388                    	;  508          return (NO);
2389                    	;  509          }
2390                    	;  510      /* looking for 0xfe that is the byte before data */
2391                    	;  511      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
2392                    	;  512          ;
2393                    	;  513      if (tries == 0) /* tried too many times */
2394                    	;  514          {
2395                    	;  515          if (sdtestflg)
2396                    	;  516              {
2397                    	;  517              printf("  No data found\n");
2398                    	;  518              } /* sdtestflg */
2399                    	;  519          return (NO);
2400                    	;  520          }
2401                    	;  521      else
2402                    	;  522          {
2403                    	;  523          crc = 0;
2404                    	;  524          for (nbytes = 0; nbytes < 15; nbytes++)
2405                    	;  525              {
2406                    	;  526              rbyte = spiio(0xff);
2407                    	;  527              csdreg[nbytes] = rbyte;
2408                    	;  528              crc = CRC7_one(crc, rbyte);
2409                    	;  529              }
2410                    	;  530          csdreg[15] = spiio(0xff);
2411                    	;  531          crc |= 0x01;
2412                    	;  532          /* some SD cards need additional clock pulses */
2413                    	;  533          for (nbytes = 9; 0 < nbytes; nbytes--)
2414                    	;  534              spiio(0xff);
2415                    	;  535          if (sdtestflg)
2416                    	;  536              {
2417                    	;  537              prtptr = &csdreg[0];
2418                    	;  538              printf("  CSD: [");
2419                    	;  539              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
2420                    	;  540                  printf("%02x ", *prtptr);
2421                    	;  541              prtptr = &csdreg[0];
2422                    	;  542              printf("\b] |");
2423                    	;  543              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
2424                    	;  544                  {
2425                    	;  545                  if ((' ' <= *prtptr) && (*prtptr < 127))
2426                    	;  546                      putchar(*prtptr);
2427                    	;  547                  else
2428                    	;  548                      putchar('.');
2429                    	;  549                  }
2430                    	;  550              printf("|\n");
2431                    	;  551              if (crc == csdreg[15])
2432                    	;  552                  {
2433                    	;  553                  printf("CRC7 ok: [%02x]\n", crc);
2434                    	;  554                  }
2435                    	;  555              else
2436                    	;  556                  {
2437                    	;  557                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
2438                    	;  558                         crc, csdreg[15]);
2439                    	;  559                  /* could maybe return failure here */
2440                    	;  560                  }
2441                    	;  561              } /* sdtestflg */
2442                    	;  562          }
2443                    	;  563  
2444                    	;  564      for (nbytes = 9; 0 < nbytes; nbytes--)
2445                    	;  565          spiio(0xff);
2446                    	;  566      if (sdtestflg)
2447                    	;  567          {
2448                    	;  568          printf("Sent 9*8 (72) clock pulses, select active\n");
2449                    	;  569          } /* sdtestflg */
2450                    	;  570  
2451                    	;  571      sdinitok = YES;
2452                    	;  572  
2453                    	;  573      spideselect();
2454                    	;  574      ledoff();
2455                    	;  575  
2456                    	;  576      return (YES);
2457                    	;  577      }
2458                    	;  578  
2459                    	;  579  int sdprobe()
2460                    	;  580      {
2461                    	;  581      unsigned char cmdbuf[5];   /* buffer to build command in */
2462                    	;  582      unsigned char rstatbuf[5]; /* buffer to recieve status in */
2463                    	;  583      unsigned char *statptr;    /* pointer to returned status from SD command */
2464                    	;  584      int nbytes;  /* byte counter */
2465                    	;  585      int allzero = YES;
2466                    	;  586  
2467                    	;  587      ledon();
2468                    	;  588      spiselect();
2469                    	;  589  
2470                    	;  590      /* CMD58: READ_OCR */
2471                    	;  591      memcpy(cmdbuf, cmd58, 5);
2472                    	;  592      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
2473                    	;  593      for (nbytes = 0; nbytes < 5; nbytes++)
2474                    	;  594          {
2475                    	;  595          if (statptr[nbytes] != 0)
2476                    	;  596              allzero = NO;
2477                    	;  597          }
2478                    	;  598      if (sdtestflg)
2479                    	;  599          {
2480                    	;  600          if (!statptr)
2481                    	;  601              printf("CMD58: no response\n");
2482                    	;  602          else
2483                    	;  603              {
2484                    	;  604              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
2485                    	;  605                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
2486                    	;  606              if (allzero)
2487                    	;  607                  printf("SD card not inserted or not initialized\n");
2488                    	;  608              }
2489                    	;  609          } /* sdtestflg */
2490                    	;  610      if (!statptr || allzero)
2491                    	;  611          {
2492                    	;  612          sdinitok = NO;
2493                    	;  613          spideselect();
2494                    	;  614          ledoff();
2495                    	;  615          return (NO);
2496                    	;  616          }
2497                    	;  617  
2498                    	;  618      spideselect();
2499                    	;  619      ledoff();
2500                    	;  620  
2501                    	;  621      return (YES);
2502                    	;  622      }
2503                    	;  623  
2504                    	;  624  /* print OCR, CID and CSD registers*/
2505                    	;  625  void sdprtreg()
2506                    	;  626      {
2507                    	;  627      unsigned int n;
2508                    	;  628      unsigned int csize;
2509                    	;  629      unsigned long devsize;
2510                    	;  630      unsigned long capacity;
2511                    	;  631  
2512                    	;  632      if (!sdinitok)
2513                    	;  633          {
2514                    	;  634          printf("SD card not initialized\n");
2515                    	;  635          return;
2516                    	;  636          }
2517                    	;  637      printf("SD card information:");
2518                    	;  638      if (ocrreg[0] & 0x80)
2519                    	;  639          {
2520                    	;  640          if (ocrreg[0] & 0x40)
2521                    	;  641              printf("  SD card ver. 2+, Block address\n");
2522                    	;  642          else
2523                    	;  643              {
2524                    	;  644              if (sdver2)
2525                    	;  645                  printf("  SD card ver. 2+, Byte address\n");
2526                    	;  646              else
2527                    	;  647                  printf("  SD card ver. 1, Byte address\n");
2528                    	;  648              }
2529                    	;  649          }
2530                    	;  650      printf("  Manufacturer ID: 0x%02x, ", cidreg[0]);
2531                    	;  651      printf("OEM ID: %.2s, ", &cidreg[1]);
2532                    	;  652      printf("Product name: %.5s\n", &cidreg[3]);
2533                    	;  653      printf("  Product revision: %d.%d, ",
2534                    	;  654             (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
2535                    	;  655      printf("Serial number: %lu\n",
2536                    	;  656             (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
2537                    	;  657      printf("  Manufacturing date: %d-%d, ",
2538                    	;  658             2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
2539                    	;  659      if ((csdreg[0] & 0xc0) == 0x00) /* CSD version 1 */
2540                    	;  660          {
2541                    	;  661          n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
2542                    	;  662          csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
2543                    	;  663                  ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
2544                    	;  664          capacity = (unsigned long) csize << (n-10);
2545                    	;  665          printf("Device capacity: %lu MByte\n", capacity >> 10);
2546                    	;  666          }
2547                    	;  667      if ((csdreg[0] & 0xc0) == 0x40) /* CSD version 2 */
2548                    	;  668          {
2549                    	;  669          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
2550                    	;  670                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
2551                    	;  671          capacity = devsize << 9;
2552                    	;  672          printf("Device capacity: %lu MByte\n", capacity >> 10);
2553                    	;  673          }
2554                    	;  674      if ((csdreg[0] & 0xc0) == 0x80) /* CSD version 3 */
2555                    	;  675          {
2556                    	;  676          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
2557                    	;  677                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
2558                    	;  678          capacity = devsize << 9;
2559                    	;  679          printf("Device ultra capacity: %lu MByte\n", capacity >> 10);
2560                    	;  680          }
2561                    	;  681  
2562                    	;  682      if (sdtestflg)
2563                    	;  683          {
2564                    	;  684  
2565                    	;  685          printf("--------------------------------------\n");
2566                    	;  686          printf("OCR register:\n");
2567                    	;  687          if (ocrreg[2] & 0x80)
2568                    	;  688              printf("2.7-2.8V (bit 15) ");
2569                    	;  689          if (ocrreg[1] & 0x01)
2570                    	;  690              printf("2.8-2.9V (bit 16) ");
2571                    	;  691          if (ocrreg[1] & 0x02)
2572                    	;  692              printf("2.9-3.0V (bit 17) ");
2573                    	;  693          if (ocrreg[1] & 0x04)
2574                    	;  694              printf("3.0-3.1V (bit 18) \n");
2575                    	;  695          if (ocrreg[1] & 0x08)
2576                    	;  696              printf("3.1-3.2V (bit 19) ");
2577                    	;  697          if (ocrreg[1] & 0x10)
2578                    	;  698              printf("3.2-3.3V (bit 20) ");
2579                    	;  699          if (ocrreg[1] & 0x20)
2580                    	;  700              printf("3.3-3.4V (bit 21) ");
2581                    	;  701          if (ocrreg[1] & 0x40)
2582                    	;  702              printf("3.4-3.5V (bit 22) \n");
2583                    	;  703          if (ocrreg[1] & 0x80)
2584                    	;  704              printf("3.5-3.6V (bit 23) \n");
2585                    	;  705          if (ocrreg[0] & 0x01)
2586                    	;  706              printf("Switching to 1.8V Accepted (S18A) (bit 24) set ");
2587                    	;  707          if (ocrreg[0] & 0x08)
2588                    	;  708              printf("Over 2TB support Status (CO2T) (bit 27) set\n");
2589                    	;  709          if (ocrreg[0] & 0x20)
2590                    	;  710              printf("UHS-II Card Status (bit 29) set ");
2591                    	;  711          if (ocrreg[0] & 0x80)
2592                    	;  712              {
2593                    	;  713              if (ocrreg[0] & 0x40)
2594                    	;  714                  {
2595                    	;  715                  printf("Card Capacity Status (CCS) (bit 30) set\n");
2596                    	;  716                  printf("  SD Ver.2+, Block address");
2597                    	;  717                  }
2598                    	;  718              else
2599                    	;  719                  {
2600                    	;  720                  printf("Card Capacity Status (CCS) (bit 30) not set\n");
2601                    	;  721                  if (sdver2)
2602                    	;  722                      printf("  SD Ver.2+, Byte address");
2603                    	;  723                  else
2604                    	;  724                      printf("  SD Ver.1, Byte address");
2605                    	;  725                  }
2606                    	;  726              printf("\nCard power up status bit (busy) (bit 31) set\n");
2607                    	;  727              }
2608                    	;  728          else
2609                    	;  729              {
2610                    	;  730              printf("\nCard power up status bit (busy) (bit 31) not set.\n");
2611                    	;  731              printf("  This bit is not set if the card has not finished the power up routine.\n");
2612                    	;  732              }
2613                    	;  733          printf("--------------------------------------\n");
2614                    	;  734          printf("CID register:\n");
2615                    	;  735          printf("MID: 0x%02x, ", cidreg[0]);
2616                    	;  736          printf("OID: %.2s, ", &cidreg[1]);
2617                    	;  737          printf("PNM: %.5s, ", &cidreg[3]);
2618                    	;  738          printf("PRV: %d.%d, ",
2619                    	;  739                 (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
2620                    	;  740          printf("PSN: %lu, ",
2621                    	;  741                 (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
2622                    	;  742          printf("MDT: %d-%d\n",
2623                    	;  743                 2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
2624                    	;  744          printf("--------------------------------------\n");
2625                    	;  745          printf("CSD register:\n");
2626                    	;  746          if ((csdreg[0] & 0xc0) == 0x00)
2627                    	;  747              {
2628                    	;  748              printf("CSD Version 1.0, Standard Capacity\n");
2629                    	;  749              n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
2630                    	;  750              csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
2631                    	;  751                      ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
2632                    	;  752              capacity = (unsigned long) csize << (n-10);
2633                    	;  753              printf(" Device capacity: %lu KByte, %lu MByte\n",
2634                    	;  754                     capacity, capacity >> 10);
2635                    	;  755              }
2636                    	;  756          if ((csdreg[0] & 0xc0) == 0x40)
2637                    	;  757              {
2638                    	;  758              printf("CSD Version 2.0, High Capacity and Extended Capacity\n");
2639                    	;  759              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
2640                    	;  760                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
2641                    	;  761              capacity = devsize << 9;
2642                    	;  762              printf(" Device capacity: %lu KByte, %lu MByte\n",
2643                    	;  763                     capacity, capacity >> 10);
2644                    	;  764              }
2645                    	;  765          if ((csdreg[0] & 0xc0) == 0x80)
2646                    	;  766              {
2647                    	;  767              printf("CSD Version 3.0, Ultra Capacity (SDUC)\n");
2648                    	;  768              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
2649                    	;  769                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
2650                    	;  770              capacity = devsize << 9;
2651                    	;  771              printf(" Device capacity: %lu KByte, %lu MByte\n",
2652                    	;  772                     capacity, capacity >> 10);
2653                    	;  773              }
2654                    	;  774          printf("--------------------------------------\n");
2655                    	;  775  
2656                    	;  776          } /* sdtestflg */ /* SDTEST */
2657                    	;  777  
2658                    	;  778      }
2659                    	;  779  
2660                    	;  780  /* Read data block of 512 bytes to buffer
2661                    	;  781   * Returns YES if ok or NO if error
2662                    	;  782   */
2663                    	;  783  int sdread(unsigned char *rdbuf, unsigned long rdblkno)
2664                    	;  784      {
2665                    	;  785      unsigned char *statptr;
2666                    	;  786      unsigned char rbyte;
2667                    	;  787      unsigned char cmdbuf[5];   /* buffer to build command in */
2668                    	;  788      unsigned char rstatbuf[5]; /* buffer to recieve status in */
2669                    	;  789      int nbytes;
2670                    	;  790      int tries;
2671                    	;  791      unsigned long blktoread;
2672                    	;  792      unsigned int rxcrc16;
2673                    	;  793      unsigned int calcrc16;
2674                    	;  794  
2675                    	;  795      ledon();
2676                    	;  796      spiselect();
2677                    	;  797  
2678                    	;  798      if (!sdinitok)
2679                    	;  799          {
2680                    	;  800          if (sdtestflg)
2681                    	;  801              {
2682                    	;  802              printf("SD card not initialized\n");
2683                    	;  803              } /* sdtestflg */
2684                    	;  804          spideselect();
2685                    	;  805          ledoff();
2686                    	;  806          return (NO);
2687                    	;  807          }
2688                    	;  808  
2689                    	;  809      /* CMD17: READ_SINGLE_BLOCK */
2690                    	;  810      /* Insert block # into command */
2691                    	;  811      memcpy(cmdbuf, cmd17, 5);
2692                    	;  812      blktoread = blkmult * rdblkno;
2693                    	;  813      cmdbuf[4] = blktoread & 0xff;
2694                    	;  814      blktoread = blktoread >> 8;
2695                    	;  815      cmdbuf[3] = blktoread & 0xff;
2696                    	;  816      blktoread = blktoread >> 8;
2697                    	;  817      cmdbuf[2] = blktoread & 0xff;
2698                    	;  818      blktoread = blktoread >> 8;
2699                    	;  819      cmdbuf[1] = blktoread & 0xff;
2700                    	;  820  
2701                    	;  821      if (sdtestflg)
2702                    	;  822          {
2703                    	;  823          printf("\nCMD17: READ_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
2704                    	;  824                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
2705                    	;  825          } /* sdtestflg */
2706                    	;  826      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2707                    	;  827      if (sdtestflg)
2708                    	;  828          {
2709                    	;  829          printf("CMD17 R1 response [%02x]\n", statptr[0]);
2710                    	;  830          } /* sdtestflg */
2711                    	;  831      if (statptr[0])
2712                    	;  832          {
2713                    	;  833          if (sdtestflg)
2714                    	;  834              {
2715                    	;  835              printf("  could not read block\n");
2716                    	;  836              } /* sdtestflg */
2717                    	;  837          spideselect();
2718                    	;  838          ledoff();
2719                    	;  839          return (NO);
2720                    	;  840          }
2721                    	;  841      /* looking for 0xfe that is the byte before data */
2722                    	;  842      for (tries = 80; (0 < tries) && ((rbyte = spiio(0xff)) != 0xfe); tries--)
2723                    	;  843          {
2724                    	;  844          if ((rbyte & 0xe0) == 0x00)
2725                    	;  845              {
2726                    	;  846              /* If a read operation fails and the card cannot provide
2727                    	;  847                 the required data, it will send a data error token instead
2728                    	;  848               */
2729                    	;  849              if (sdtestflg)
2730                    	;  850                  {
2731                    	;  851                  printf("  read error: [%02x]\n", rbyte);
2732                    	;  852                  } /* sdtestflg */
2733                    	;  853              spideselect();
2734                    	;  854              ledoff();
2735                    	;  855              return (NO);
2736                    	;  856              }
2737                    	;  857          }
2738                    	;  858      if (tries == 0) /* tried too many times */
2739                    	;  859          {
2740                    	;  860          if (sdtestflg)
2741                    	;  861              {
2742                    	;  862              printf("  no data found\n");
2743                    	;  863              } /* sdtestflg */
2744                    	;  864          spideselect();
2745                    	;  865          ledoff();
2746                    	;  866          return (NO);
2747                    	;  867          }
2748                    	;  868      else
2749                    	;  869          {
2750                    	;  870          calcrc16 = 0;
2751                    	;  871          for (nbytes = 0; nbytes < 512; nbytes++)
2752                    	;  872              {
2753                    	;  873              rbyte = spiio(0xff);
2754                    	;  874              calcrc16 = CRC16_one(calcrc16, rbyte);
2755                    	;  875              rdbuf[nbytes] = rbyte;
2756                    	;  876              }
2757                    	;  877          rxcrc16 = spiio(0xff) << 8;
2758                    	;  878          rxcrc16 += spiio(0xff);
2759                    	;  879  
2760                    	;  880          if (sdtestflg)
2761                    	;  881              {
2762                    	;  882              printf("  read data block %ld:\n", rdblkno);
2763                    	;  883              } /* sdtestflg */
2764                    	;  884          if (rxcrc16 != calcrc16)
2765                    	;  885              {
2766                    	;  886              if (sdtestflg)
2767                    	;  887                  {
2768                    	;  888                  printf("  CRC16 error, recieved: 0x%04x, calc: 0x%04hi\n",
2769                    	;  889                         rxcrc16, calcrc16);
2770                    	;  890                  } /* sdtestflg */
2771                    	;  891              spideselect();
2772                    	;  892              ledoff();
2773                    	;  893              return (NO);
2774                    	;  894              }
2775                    	;  895          }
2776                    	;  896      spideselect();
2777                    	;  897      ledoff();
2778                    	;  898      return (YES);
2779                    	;  899      }
2780                    	;  900  
2781                    	;  901  /* Write data block of 512 bytes from buffer
2782                    	;  902   * Returns YES if ok or NO if error
2783                    	;  903   */
2784                    	;  904  int sdwrite(unsigned char *wrbuf, unsigned long wrblkno)
2785                    	;  905      {
2786                    	;  906      unsigned char *statptr;
2787                    	;  907      unsigned char rbyte;
2788                    	;  908      unsigned char tbyte;
2789                    	;  909      unsigned char cmdbuf[5];   /* buffer to build command in */
2790                    	;  910      unsigned char rstatbuf[5]; /* buffer to recieve status in */
2791                    	;  911      int nbytes;
2792                    	;  912      int tries;
2793                    	;  913      unsigned long blktowrite;
2794                    	;  914      unsigned int calcrc16;
2795                    	;  915  
2796                    	;  916      ledon();
2797                    	;  917      spiselect();
2798                    	;  918  
2799                    	;  919      if (!sdinitok)
2800                    	;  920          {
2801                    	;  921          if (sdtestflg)
2802                    	;  922              {
2803                    	;  923              printf("SD card not initialized\n");
2804                    	;  924              } /* sdtestflg */
2805                    	;  925          spideselect();
2806                    	;  926          ledoff();
2807                    	;  927          return (NO);
2808                    	;  928          }
2809                    	;  929  
2810                    	;  930      if (sdtestflg)
2811                    	;  931          {
2812                    	;  932          printf("  write data block %ld:\n", wrblkno);
2813                    	;  933          } /* sdtestflg */
2814                    	;  934      /* CMD24: WRITE_SINGLE_BLOCK */
2815                    	;  935      /* Insert block # into command */
2816                    	;  936      memcpy(cmdbuf, cmd24, 5);
2817                    	;  937      blktowrite = blkmult * wrblkno;
2818                    	;  938      cmdbuf[4] = blktowrite & 0xff;
2819                    	;  939      blktowrite = blktowrite >> 8;
2820                    	;  940      cmdbuf[3] = blktowrite & 0xff;
2821                    	;  941      blktowrite = blktowrite >> 8;
2822                    	;  942      cmdbuf[2] = blktowrite & 0xff;
2823                    	;  943      blktowrite = blktowrite >> 8;
2824                    	;  944      cmdbuf[1] = blktowrite & 0xff;
2825                    	;  945  
2826                    	;  946      if (sdtestflg)
2827                    	;  947          {
2828                    	;  948          printf("\nCMD24: WRITE_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
2829                    	;  949                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
2830                    	;  950          } /* sdtestflg */
2831                    	;  951      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
2832                    	;  952      if (sdtestflg)
2833                    	;  953          {
2834                    	;  954          printf("CMD24 R1 response [%02x]\n", statptr[0]);
2835                    	;  955          } /* sdtestflg */
2836                    	;  956      if (statptr[0])
2837                    	;  957          {
2838                    	;  958          if (sdtestflg)
2839                    	;  959              {
2840                    	;  960              printf("  could not write block\n");
2841                    	;  961              } /* sdtestflg */
2842                    	;  962          spideselect();
2843                    	;  963          ledoff();
2844                    	;  964          return (NO);
2845                    	;  965          }
2846                    	;  966      /* send 0xfe, the byte before data */
2847                    	;  967      spiio(0xfe);
2848                    	;  968      /* initialize crc and send block */
2849                    	;  969      calcrc16 = 0;
2850                    	;  970      for (nbytes = 0; nbytes < 512; nbytes++)
2851                    	;  971          {
2852                    	;  972          tbyte = wrbuf[nbytes];
2853                    	;  973          spiio(tbyte);
2854                    	;  974          calcrc16 = CRC16_one(calcrc16, tbyte);
2855                    	;  975          }
2856                    	;  976      spiio((calcrc16 >> 8) & 0xff);
2857                    	;  977      spiio(calcrc16 & 0xff);
2858                    	;  978  
2859                    	;  979      /* check data resposnse */
2860                    	;  980      for (tries = 20;
2861                    	;  981              0 < tries && (((rbyte = spiio(0xff)) & 0x11) != 0x01);
2862                    	;  982              tries--)
2863                    	;  983          ;
2864                    	;  984      if (tries == 0)
2865                    	;  985          {
2866                    	;  986          if (sdtestflg)
2867                    	;  987              {
2868                    	;  988              printf("No data response\n");
2869                    	;  989              } /* sdtestflg */
2870                    	;  990          spideselect();
2871                    	;  991          ledoff();
2872                    	;  992          return (NO);
2873                    	;  993          }
2874                    	;  994      else
2875                    	;  995          {
2876                    	;  996          if (sdtestflg)
2877                    	;  997              {
2878                    	;  998              printf("Data response [%02x]", 0x1f & rbyte);
2879                    	;  999              } /* sdtestflg */
2880                    	; 1000          if ((0x1f & rbyte) == 0x05)
2881                    	; 1001              {
2882                    	; 1002              if (sdtestflg)
2883                    	; 1003                  {
2884                    	; 1004                  printf(", data accepted\n");
2885                    	; 1005                  } /* sdtestflg */
2886                    	; 1006              for (nbytes = 9; 0 < nbytes; nbytes--)
2887                    	; 1007                  spiio(0xff);
2888                    	; 1008              if (sdtestflg)
2889                    	; 1009                  {
2890                    	; 1010                  printf("Sent 9*8 (72) clock pulses, select active\n");
2891                    	; 1011                  } /* sdtestflg */
2892                    	; 1012              spideselect();
2893                    	; 1013              ledoff();
2894                    	; 1014              return (YES);
2895                    	; 1015              }
2896                    	; 1016          else
2897                    	; 1017              {
2898                    	; 1018              if (sdtestflg)
2899                    	; 1019                  {
2900                    	; 1020                  printf(", data not accepted\n");
2901                    	; 1021                  } /* sdtestflg */
2902                    	; 1022              spideselect();
2903                    	; 1023              ledoff();
2904                    	; 1024              return (NO);
2905                    	; 1025              }
2906                    	; 1026          }
2907                    	; 1027      }
2908                    	; 1028  
2909                    	; 1029  /* Print data in 512 byte buffer */
2910                    	; 1030  void sddatprt(unsigned char *prtbuf)
2911                    	; 1031      {
2912                    	; 1032      /* Variables used for "pretty-print" */
2913                    	; 1033      int allzero, dmpline, dotprted, lastallz, nbytes;
2914                    	; 1034      unsigned char *prtptr;
2915                    	; 1035  
2916                    	; 1036      prtptr = prtbuf;
2917                    	; 1037      dotprted = NO;
2918                    	; 1038      lastallz = NO;
2919                    	; 1039      for (dmpline = 0; dmpline < 32; dmpline++)
2920                    	; 1040          {
2921                    	; 1041          /* test if all 16 bytes are 0x00 */
2922                    	; 1042          allzero = YES;
2923                    	; 1043          for (nbytes = 0; nbytes < 16; nbytes++)
2924                    	; 1044              {
2925                    	; 1045              if (prtptr[nbytes] != 0)
2926                    	; 1046                  allzero = NO;
2927                    	; 1047              }
2928                    	; 1048          if (lastallz && allzero)
2929                    	; 1049              {
2930                    	; 1050              if (!dotprted)
2931                    	; 1051                  {
2932                    	; 1052                  printf("*\n");
2933                    	; 1053                  dotprted = YES;
2934                    	; 1054                  }
2935                    	; 1055              }
2936                    	; 1056          else
2937                    	; 1057              {
2938                    	; 1058              dotprted = NO;
2939                    	; 1059              /* print offset */
2940                    	; 1060              printf("%04x ", dmpline * 16);
2941                    	; 1061              /* print 16 bytes in hex */
2942                    	; 1062              for (nbytes = 0; nbytes < 16; nbytes++)
2943                    	; 1063                  printf("%02x ", prtptr[nbytes]);
2944                    	; 1064              /* print these bytes in ASCII if printable */
2945                    	; 1065              printf(" |");
2946                    	; 1066              for (nbytes = 0; nbytes < 16; nbytes++)
2947                    	; 1067                  {
2948                    	; 1068                  if ((' ' <= prtptr[nbytes]) && (prtptr[nbytes] < 127))
2949                    	; 1069                      putchar(prtptr[nbytes]);
2950                    	; 1070                  else
2951                    	; 1071                      putchar('.');
2952                    	; 1072                  }
2953                    	; 1073              printf("|\n");
2954                    	; 1074              }
2955                    	; 1075          prtptr += 16;
2956                    	; 1076          lastallz = allzero;
2957                    	; 1077          }
2958                    	; 1078      }
2959                    	; 1079  
2960                    	; 1080  /* Print GUID (mixed endian format)
2961                    	; 1081   */
2962                    	; 1082  void prtguid(unsigned char *guidptr)
2963                    	; 1083      {
2964                    	; 1084      int index;
2965                    	; 1085  
2966                    	; 1086      printf("%02x%02x%02x%02x-", guidptr[3], guidptr[2], guidptr[1], guidptr[0]);
2967                    	; 1087      printf("%02x%02x-", guidptr[5], guidptr[4]);
2968                    	; 1088      printf("%02x%02x-", guidptr[7], guidptr[6]);
2969                    	; 1089      printf("%02x%02x-", guidptr[8], guidptr[9]);
2970                    	; 1090      printf("%02x%02x%02x%02x%02x%02x",
2971                    	; 1091             guidptr[10], guidptr[11], guidptr[12], guidptr[13], guidptr[14], guidptr[15]);
2972                    	; 1092      }
2973                    	; 1093  
2974                    	; 1094  /* Analyze and print GPT entry
2975                    	; 1095   */
2976                    	; 1096  int prtgptent(unsigned int entryno)
2977                    	; 1097      {
2978                    	; 1098      int index;
2979                    	; 1099      int entryidx;
2980                    	; 1100      int hasname;
2981                    	; 1101      unsigned int block;
2982                    	; 1102      unsigned char *rxdata;
2983                    	; 1103      unsigned char *entryptr;
2984                    	; 1104      unsigned char tstzero = 0;
2985                    	; 1105      unsigned long flba;
2986                    	; 1106      unsigned long llba;
2987                    	; 1107  
2988                    	; 1108      block = 2 + (entryno / 4);
2989                    	; 1109      if ((curblkno != block) || !curblkok)
2990                    	; 1110          {
2991                    	; 1111          if (!sdread(sdrdbuf, block))
2992                    	; 1112              {
2993                    	; 1113              if (sdtestflg)
2994                    	; 1114                  {
2995                    	; 1115                  printf("Can't read GPT entry block\n");
2996                    	; 1116                  return (NO);
2997                    	; 1117                  } /* sdtestflg */
2998                    	; 1118              }
2999                    	; 1119          curblkno = block;
3000                    	; 1120          curblkok = YES;
3001                    	; 1121          }
3002                    	; 1122      rxdata = sdrdbuf;
3003                    	; 1123      entryptr = rxdata + (128 * (entryno % 4));
3004                    	; 1124      for (index = 0; index < 16; index++)
3005                    	; 1125          tstzero |= entryptr[index];
3006                    	; 1126      if (sdtestflg)
3007                    	; 1127          {
3008                    	; 1128          printf("GPT partition entry %d:", entryno + 1);
3009                    	; 1129          } /* sdtestflg */
3010                    	; 1130      if (!tstzero)
3011                    	; 1131          {
3012                    	; 1132          if (sdtestflg)
3013                    	; 1133              {
3014                    	; 1134              printf(" Not used entry\n");
3015                    	; 1135              } /* sdtestflg */
3016                    	; 1136          return (NO);
3017                    	; 1137          }
3018                    	; 1138      if (sdtestflg)
3019                    	; 1139          {
3020                    	; 1140          printf("\n  Partition type GUID: ");
3021                    	; 1141          prtguid(entryptr);
3022                    	; 1142          printf("\n  [");
3023                    	; 1143          for (index = 0; index < 16; index++)
3024                    	; 1144              printf("%02x ", entryptr[index]);
3025                    	; 1145          printf("\b]");
3026                    	; 1146          printf("\n  Unique partition GUID: ");
3027                    	; 1147          prtguid(entryptr + 16);
3028                    	; 1148          printf("\n  [");
3029                    	; 1149          for (index = 0; index < 16; index++)
3030                    	; 1150              printf("%02x ", (entryptr + 16)[index]);
3031                    	; 1151          printf("\b]");
3032                    	; 1152          printf("\n  First LBA: ");
3033                    	; 1153          /* lower 32 bits of LBA should be sufficient (I hope) */
3034                    	; 1154          } /* sdtestflg */
3035                    	; 1155      flba = (unsigned long)entryptr[32] + ((unsigned long)entryptr[33] << 8) +
3036                    	; 1156             ((unsigned long)entryptr[34] << 16) + ((unsigned long)entryptr[35] << 24);
3037                    	; 1157      if (sdtestflg)
3038                    	; 1158          {
3039                    	; 1159          printf("%lu", flba);
3040                    	; 1160          printf(" [");
3041                    	; 1161          for (index = 32; index < (32 + 8); index++)
3042                    	; 1162              printf("%02x ", entryptr[index]);
3043                    	; 1163          printf("\b]");
3044                    	; 1164          printf("\n  Last LBA: ");
3045                    	; 1165          } /* sdtestflg */
3046                    	; 1166      /* lower 32 bits of LBA should be sufficient (I hope) */
3047                    	; 1167      llba = (unsigned long)entryptr[40] + ((unsigned long)entryptr[41] << 8) +
3048                    	; 1168             ((unsigned long)entryptr[42] << 16) + ((unsigned long)entryptr[43] << 24);
3049                    	; 1169  
3050                    	; 1170      if (entryptr[48] & 0x04)
3051                    	; 1171          dskmap[partdsk].bootable = YES;
3052                    	; 1172      dskmap[partdsk].partype = PARTGPT;
3053                    	; 1173      dskmap[partdsk].dskletter = 'A' + partdsk;
3054                    	; 1174      dskmap[partdsk].dskstart = flba;
3055                    	; 1175      dskmap[partdsk].dskend = llba;
3056                    	; 1176      dskmap[partdsk].dsksize = llba - flba + 1;
3057                    	; 1177      memcpy(dskmap[partdsk].dsktype, entryptr, 16);
3058                    	; 1178      partdsk++;
3059                    	; 1179  
3060                    	; 1180      if (sdtestflg)
3061                    	; 1181          {
3062                    	; 1182          printf("%lu, size %lu MByte", llba, (llba - flba) >> 11);
3063                    	; 1183          printf(" [");
3064                    	; 1184          for (index = 40; index < (40 + 8); index++)
3065                    	; 1185              printf("%02x ", entryptr[index]);
3066                    	; 1186          printf("\b]");
3067                    	; 1187          printf("\n  Attribute flags: [");
3068                    	; 1188          /* bits 0 - 2 and 60 - 63 should be decoded */
3069                    	; 1189          for (index = 0; index < 8; index++)
3070                    	; 1190              {
3071                    	; 1191              entryidx = index + 48;
3072                    	; 1192              printf("%02x ", entryptr[entryidx]);
3073                    	; 1193              }
3074                    	; 1194          printf("\b]\n  Partition name:  ");
3075                    	; 1195          } /* sdtestflg */
3076                    	; 1196      /* partition name is in UTF-16LE code units */
3077                    	; 1197      hasname = NO;
3078                    	; 1198      for (index = 0; index < 72; index += 2)
3079                    	; 1199          {
3080                    	; 1200          entryidx = index + 56;
3081                    	; 1201          if ((entryptr[entryidx] | entryptr[entryidx + 1]) == 0)
3082                    	; 1202              break;
3083                    	; 1203          if (sdtestflg)
3084                    	; 1204              {
3085                    	; 1205              if ((' ' <= entryptr[entryidx]) && (entryptr[entryidx] < 127))
3086                    	; 1206                  putchar(entryptr[entryidx]);
3087                    	; 1207              else
3088                    	; 1208                  putchar('.');
3089                    	; 1209              } /* sdtestflg */
3090                    	; 1210          hasname = YES;
3091                    	; 1211          }
3092                    	; 1212      if (sdtestflg)
3093                    	; 1213          {
3094                    	; 1214          if (!hasname)
3095                    	; 1215              printf("name field empty");
3096                    	; 1216          printf("\n");
3097                    	; 1217          printf("   [");
3098                    	; 1218          for (index = 0; index < 72; index++)
3099                    	; 1219              {
3100                    	; 1220              if (((index & 0xf) == 0) && (index != 0))
3101                    	; 1221                  printf("\n    ");
3102                    	; 1222              entryidx = index + 56;
3103                    	; 1223              printf("%02x ", entryptr[entryidx]);
3104                    	; 1224              }
3105                    	; 1225          printf("\b]\n");
3106                    	; 1226          } /* sdtestflg */
3107                    	; 1227      return (YES);
3108                    	; 1228      }
3109                    	; 1229  
3110                    	; 1230  /* Analyze and print GPT header
3111                    	; 1231   */
3112                    	; 1232  void sdgpthdr(unsigned long block)
3113                    	; 1233      {
3114                    	; 1234      int index;
3115                    	; 1235      unsigned int partno;
3116                    	; 1236      unsigned char *rxdata;
3117                    	; 1237      unsigned long entries;
3118                    	; 1238  
3119                    	; 1239      if (sdtestflg)
3120                    	; 1240          {
3121                    	; 1241          printf("GPT header\n");
3122                    	; 1242          } /* sdtestflg */
3123                    	; 1243      if (!sdread(sdrdbuf, block))
3124                    	; 1244          {
3125                    	; 1245          if (sdtestflg)
3126                    	; 1246              {
3127                    	; 1247              printf("Can't read GPT partition table header\n");
3128                    	; 1248              } /* sdtestflg */
3129                    	; 1249          return;
3130                    	; 1250          }
3131                    	; 1251      curblkno = block;
3132                    	; 1252      curblkok = YES;
3133                    	; 1253  
3134                    	; 1254      rxdata = sdrdbuf;
3135                    	; 1255      if (sdtestflg)
3136                    	; 1256          {
3137                    	; 1257          printf("  Signature: %.8s\n", &rxdata[0]);
3138                    	; 1258          printf("  Revision: %d.%d [%02x %02x %02x %02x]\n",
3139                    	; 1259                 (int)rxdata[8] * ((int)rxdata[9] << 8),
3140                    	; 1260                 (int)rxdata[10] + ((int)rxdata[11] << 8),
3141                    	; 1261                 rxdata[8], rxdata[9], rxdata[10], rxdata[11]);
3142                    	; 1262          entries = (unsigned long)rxdata[80] + ((unsigned long)rxdata[81] << 8) +
3143                    	; 1263                    ((unsigned long)rxdata[82] << 16) + ((unsigned long)rxdata[83] << 24);
3144                    	; 1264          printf("  Number of partition entries: %lu (may be actual or maximum)\n", entries);
3145                    	; 1265          } /* sdtestflg */
3146                    	; 1266      for (partno = 0; (partno < 16) && (partdsk < 16); partno++)
3147                    	; 1267          {
3148                    	; 1268          if (!prtgptent(partno))
3149                    	; 1269              {
3150                    	; 1270              if (!sdtestflg)
3151                    	; 1271                  {
3152                    	; 1272                  /* go through all entries if compiled as test program */
3153                    	; 1273                  return;
3154                    	; 1274                  } /* sdtestflg */
3155                    	; 1275              }
3156                    	; 1276          }
3157                    	; 1277      if (sdtestflg)
3158                    	; 1278          {
3159                    	; 1279          printf("First 16 GPT entries scanned\n");
3160                    	; 1280          } /* sdtestflg */
3161                    	; 1281      }
3162                    	; 1282  
3163                    	; 1283  /* Analyze and print MBR partition entry
3164                    	; 1284   * Returns:
3165                    	; 1285   *    -1 if errror - should not happen
3166                    	; 1286   *     0 if not used entry
3167                    	; 1287   *     1 if MBR entry
3168                    	; 1288   *     2 if EBR entry
3169                    	; 1289   *     3 if GTP entry
3170                    	; 1290   */
3171                    	; 1291  int sdmbrentry(unsigned char *partptr)
3172                    	; 1292      {
3173                    	; 1293      int index;
3174                    	; 1294      int parttype;
3175                    	; 1295      unsigned long lbastart;
3176                    	; 1296      unsigned long lbasize;
3177                    	; 1297  
3178                    	; 1298      parttype = PARTMBR;
3179                    	; 1299      if (!partptr[4])
3180                    	; 1300          {
3181                    	; 1301          if (sdtestflg)
3182                    	; 1302              {
3183                    	; 1303              printf("Not used entry\n");
3184                    	; 1304              } /* sdtestflg */
3185                    	; 1305          return (PARTZRO);
3186                    	; 1306          }
3187                    	; 1307      if (sdtestflg)
3188                    	; 1308          {
3189                    	; 1309          printf("Boot indicator: 0x%02x, System ID: 0x%02x\n",
3190                    	; 1310                 partptr[0], partptr[4]);
3191                    	; 1311  
3192                    	; 1312          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f))
3193                    	; 1313              {
3194                    	; 1314              printf("  Extended partition entry\n");
3195                    	; 1315              }
3196                    	; 1316          if (partptr[0] & 0x01)
3197                    	; 1317              {
3198                    	; 1318              printf("  Unofficial 48 bit LBA Proposed MBR Format, no CHS\n");
3199                    	; 1319              /* this is however discussed
3200                    	; 1320                 https://wiki.osdev.org/Partition_Table#.22Unofficial.22_48_bit_LBA_Proposed_MBR_Format
3201                    	; 1321              */
3202                    	; 1322              }
3203                    	; 1323          else
3204                    	; 1324              {
3205                    	; 1325              printf("  begin CHS: 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
3206                    	; 1326                     partptr[1], partptr[2], partptr[3],
3207                    	; 1327                     ((partptr[2] & 0xc0) >> 2) + partptr[3],
3208                    	; 1328                     partptr[1],
3209                    	; 1329                     partptr[2] & 0x3f);
3210                    	; 1330              printf("  end CHS 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
3211                    	; 1331                     partptr[5], partptr[6], partptr[7],
3212                    	; 1332                     ((partptr[6] & 0xc0) >> 2) + partptr[7],
3213                    	; 1333                     partptr[5],
3214                    	; 1334                     partptr[6] & 0x3f);
3215                    	; 1335              }
3216                    	; 1336          } /* sdtestflg */
3217                    	; 1337      /* not showing high 16 bits if 48 bit LBA */
3218                    	; 1338      lbastart = (unsigned long)partptr[8] +
3219                    	; 1339                 ((unsigned long)partptr[9] << 8) +
3220                    	; 1340                 ((unsigned long)partptr[10] << 16) +
3221                    	; 1341                 ((unsigned long)partptr[11] << 24);
3222                    	; 1342      lbasize = (unsigned long)partptr[12] +
3223                    	; 1343                ((unsigned long)partptr[13] << 8) +
3224                    	; 1344                ((unsigned long)partptr[14] << 16) +
3225                    	; 1345                ((unsigned long)partptr[15] << 24);
3226                    	; 1346  
3227                    	; 1347      if (!(partptr[4] == 0xee)) /* not pointing to a GPT partition */
3228                    	; 1348          {
3229                    	; 1349          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f)) /* EBR partition */
3230                    	; 1350              {
3231                    	; 1351              parttype = PARTEBR;
3232                    	; 1352              if (curblkno == 0) /* points to EBR in the MBR */
3233                    	; 1353                  {
3234                    	; 1354                  ebrnext = 0;
3235                    	; 1355                  dskmap[partdsk].partype = EBRCONT;
3236                    	; 1356                  dskmap[partdsk].dskletter = 'A' + partdsk;
3237                    	; 1357                  dskmap[partdsk].dskstart = lbastart;
3238                    	; 1358                  dskmap[partdsk].dskend = lbastart + lbasize - 1;
3239                    	; 1359                  dskmap[partdsk].dsksize = lbasize;
3240                    	; 1360                  dskmap[partdsk].dsktype[0] = partptr[4];
3241                    	; 1361                  partdsk++;
3242                    	; 1362                  ebrrecs[ebrrecidx++] = lbastart; /* save to handle later */
3243                    	; 1363                  }
3244                    	; 1364              else
3245                    	; 1365                  {
3246                    	; 1366                  ebrnext = curblkno + lbastart;
3247                    	; 1367                  }
3248                    	; 1368              }
3249                    	; 1369          else
3250                    	; 1370              {
3251                    	; 1371              if (0 < lbasize) /* one more ugly hack to avoid empty partitions */
3252                    	; 1372                  {
3253                    	; 1373                  if (partptr[0] & 0x80)
3254                    	; 1374                      dskmap[partdsk].bootable = YES;
3255                    	; 1375                  if (curblkno == 0)
3256                    	; 1376                      dskmap[partdsk].partype = PARTMBR;
3257                    	; 1377                  else
3258                    	; 1378                      dskmap[partdsk].partype = PARTEBR;
3259                    	; 1379                  dskmap[partdsk].dskletter = 'A' + partdsk;
3260                    	; 1380                  dskmap[partdsk].dskstart = curblkno + lbastart;
3261                    	; 1381                  dskmap[partdsk].dskend = curblkno + lbastart + lbasize - 1;
3262                    	; 1382                  dskmap[partdsk].dsksize = lbasize;
3263                    	; 1383                  dskmap[partdsk].dsktype[0] = partptr[4];
3264                    	; 1384                  partdsk++;
3265                    	; 1385                  }
3266                    	; 1386              }
3267                    	; 1387          }
3268                    	; 1388  
3269                    	; 1389      if (sdtestflg)
3270                    	; 1390          {
3271                    	; 1391          printf("  partition start LBA: %lu [%08lx]\n",
3272                    	; 1392                 curblkno + lbastart, curblkno + lbastart);
3273                    	; 1393          printf("  partition size LBA: %lu [%08lx], %lu MByte\n",
3274                    	; 1394                 lbasize, lbasize, lbasize >> 11);
3275                    	; 1395          } /* sdtestflg */
3276                    	; 1396      if (partptr[4] == 0xee) /* GPT partitions */
3277                    	; 1397          {
3278                    	; 1398          parttype = PARTGPT;
3279                    	; 1399          if (sdtestflg)
3280                    	; 1400              {
3281                    	; 1401              printf("GTP partitions\n");
3282                    	; 1402              } /* sdtestflg */
3283                    	; 1403          sdgpthdr(lbastart); /* handle GTP partitions */
3284                    	; 1404          /* re-read MBR on sector 0
3285                    	; 1405             This is probably not needed as there
3286                    	; 1406             is only one entry (the first one)
3287                    	; 1407             in the MBR when using GPT */
3288                    	; 1408          if (sdread(sdrdbuf, 0))
3289                    	; 1409              {
3290                    	; 1410              curblkno = 0;
3291                    	; 1411              curblkok = YES;
3292                    	; 1412              }
3293                    	; 1413          else
3294                    	; 1414              {
3295                    	; 1415              if (sdtestflg)
3296                    	; 1416                  {
3297                    	; 1417                  printf("  can't read MBR on sector 0\n");
3298                    	; 1418                  } /* sdtestflg */
3299                    	; 1419              return(-1);
3300                    	; 1420              }
3301                    	; 1421          }
3302                    	; 1422      return (parttype);
3303                    	; 1423      }
3304                    	; 1424  
3305                    	; 1425  /* Read and analyze MBR/EBR partition sector block
3306                    	; 1426   * and go through and print partition entries.
3307                    	; 1427   */
3308                    	; 1428  void sdmbrpart(unsigned long sector)
3309                    	; 1429      {
3310                    	; 1430      int partidx;  /* partition index 1 - 4 */
3311                    	; 1431      int cpartidx; /* chain partition index 1 - 4 */
3312                    	; 1432      int chainidx;
3313                    	; 1433      int enttype;
3314                    	; 1434      unsigned char *entp; /* pointer to partition entry */
3315                    	; 1435      char *mbrebr;
3316                    	; 1436  
3317                    	; 1437      if (sdtestflg)
3318                    	; 1438          {
3319                    	; 1439          if (sector == 0) /* if sector 0 it is MBR else it is EBR */
3320                    	; 1440              mbrebr = "MBR";
3321                    	; 1441          else
3322                    	; 1442              mbrebr = "EBR";
3323                    	; 1443          printf("Read %s from sector %lu\n", mbrebr, sector);
3324                    	; 1444          } /* sdtestflg */
3325                    	; 1445      if (sdread(sdrdbuf, sector))
3326                    	; 1446          {
3327                    	; 1447          curblkno = sector;
3328                    	; 1448          curblkok = YES;
3329                    	; 1449          }
3330                    	; 1450      else
3331                    	; 1451          {
3332                    	; 1452          if (sdtestflg)
3333                    	; 1453              {
3334                    	; 1454              printf("  can't read %s sector %lu\n", mbrebr, sector);
3335                    	; 1455              } /* sdtestflg */
3336                    	; 1456          return;
3337                    	; 1457          }
3338                    	; 1458      if (!((sdrdbuf[0x1fe] == 0x55) && (sdrdbuf[0x1ff] == 0xaa)))
3339                    	; 1459          {
3340                    	; 1460          if (sdtestflg)
3341                    	; 1461              {
3342                    	; 1462              printf("  no %s boot signature found\n", mbrebr);
3343                    	; 1463              } /* sdtestflg */
3344                    	; 1464          return;
3345                    	; 1465          }
3346                    	; 1466      if (curblkno == 0)
3347                    	; 1467          {
3348                    	; 1468          memcpy(dsksign, &sdrdbuf[0x1b8], sizeof dsksign);
3349                    	; 1469          if (sdtestflg)
3350                    	; 1470              {
3351                    	; 1471  
3352                    	; 1472              printf("  disk identifier: 0x%02x%02x%02x%02x\n",
3353                    	; 1473                     dsksign[3], dsksign[2], dsksign[1], dsksign[0]);
3354                    	; 1474              } /* sdtestflg */
3355                    	; 1475          }
3356                    	; 1476      /* go through MBR partition entries until first empty */
3357                    	; 1477      /* !!as the MBR entry routine is called recusively a way is
3358                    	; 1478         needed to read sector 0 when going back to MBR if
3359                    	; 1479         there is a primary partition entry after an EBR entry!! */
3360                    	; 1480      entp = &sdrdbuf[0x01be] ;
3361                    	; 1481      for (partidx = 1; (partidx <= 4) && (partdsk < 16); partidx++, entp += 16)
3362                    	; 1482          {
3363                    	; 1483          if (sdtestflg)
3364                    	; 1484              {
3365                    	; 1485              printf("%s partition entry %d: ", mbrebr, partidx);
3366                    	; 1486              } /* sdtestflg */
3367                    	; 1487          enttype = sdmbrentry(entp);
3368                    	; 1488          if (enttype == -1) /* read error */
3369                    	; 1489                   return;
3370                    	; 1490          else if (enttype == PARTZRO)
3371                    	; 1491              {
3372                    	; 1492              if (!sdtestflg)
3373                    	; 1493                  {
3374                    	; 1494                  /* if compiled as test program show also empty partitions */
3375                    	; 1495                  break;
3376                    	; 1496                  } /* sdtestflg */
3377                    	; 1497              }
3378                    	; 1498          }
3379                    	; 1499      /* now handle the previously saved EBR partition sectors */
3380                    	; 1500      for (partidx = 0; (partidx < ebrrecidx) && (partdsk < 16); partidx++)
3381                    	; 1501          {
3382                    	; 1502          if (sdread(sdrdbuf, ebrrecs[partidx]))
3383                    	; 1503              {
3384                    	; 1504              curblkno = ebrrecs[partidx];
3385                    	; 1505              curblkok = YES;
3386                    	; 1506              }
3387                    	; 1507          else
3388                    	; 1508              {
3389                    	; 1509              if (sdtestflg)
3390                    	; 1510                  {
3391                    	; 1511                  printf("  can't read %s sector %lu\n", mbrebr, sector);
3392                    	; 1512                  } /* sdtestflg */
3393                    	; 1513              return;
3394                    	; 1514              }
3395                    	; 1515          entp = &sdrdbuf[0x01be] ;
3396                    	; 1516          for (partidx = 1; (partidx <= 4) && (partdsk < 16); partidx++, entp += 16)
3397                    	; 1517              {
3398                    	; 1518              if (sdtestflg)
3399                    	; 1519                  {
3400                    	; 1520                  printf("EBR partition entry %d: ", partidx);
3401                    	; 1521                  } /* sdtestflg */
3402                    	; 1522              enttype = sdmbrentry(entp);
3403                    	; 1523              if (enttype == -1) /* read error */
3404                    	; 1524                   return;
3405                    	; 1525              else if (enttype == PARTZRO) /* empty partition entry */
3406                    	; 1526                  {
3407                    	; 1527                  if (sdtestflg)
3408                    	; 1528                      {
3409                    	; 1529                      /* if compiled as test program show also empty partitions */
3410                    	; 1530                      printf("Empty partition entry\n");
3411                    	; 1531                      } /* sdtestflg */
3412                    	; 1532                  else
3413                    	; 1533                      break;
3414                    	; 1534                  }
3415                    	; 1535              else if (enttype == PARTEBR) /* next chained EBR */
3416                    	; 1536                  {
3417                    	; 1537                  if (sdtestflg)
3418                    	; 1538                      {
3419                    	; 1539                      printf("EBR chain\n");
3420                    	; 1540                      } /* sdtestflg */
3421                    	; 1541                  /* follow the EBR chain */
3422                    	; 1542                  for (chainidx = 0;
3423                    	; 1543                      ebrnext && (chainidx < 16) && (partdsk < 16);
3424                    	; 1544                      chainidx++)
3425                    	; 1545                      {
3426                    	; 1546                      /* ugly hack to stop reading the same sector */
3427                    	; 1547                      if (ebrnext == curblkno)
3428                    	; 1548                           break;
3429                    	; 1549                      if (sdread(sdrdbuf, ebrnext))
3430                    	; 1550                          {
3431                    	; 1551                          curblkno = ebrnext;
3432                    	; 1552                          curblkok = YES;
3433                    	; 1553                          }
3434                    	; 1554                      else
3435                    	; 1555                          {
3436                    	; 1556                          if (sdtestflg)
3437                    	; 1557                              {
3438                    	; 1558                              printf("  can't read %s sector %lu\n", mbrebr, sector);
3439                    	; 1559                              } /* sdtestflg */
3440                    	; 1560                          return;
3441                    	; 1561                          }
3442                    	; 1562                      entp = &sdrdbuf[0x01be] ;
3443                    	; 1563                      for (cpartidx = 1;
3444                    	; 1564                          (cpartidx <= 4) && (partdsk < 16);
3445                    	; 1565                          cpartidx++, entp += 16)
3446                    	; 1566                          {
3447                    	; 1567                          if (sdtestflg)
3448                    	; 1568                              {
3449                    	; 1569                              printf("EBR chained  partition entry %d: ",
3450                    	; 1570                                   cpartidx);
3451                    	; 1571                              } /* sdtestflg */
3452                    	; 1572                          enttype = sdmbrentry(entp);
3453                    	; 1573                          if (enttype == -1) /* read error */
3454                    	; 1574                              return;
3455    42AF  C30000    		jp	c.rets
3456                    	L5662:
3457    42B2  2C        		.byte	44
3458    42B3  20        		.byte	32
3459    42B4  65        		.byte	101
3460    42B5  78        		.byte	120
3461    42B6  65        		.byte	101
3462    42B7  63        		.byte	99
3463    42B8  75        		.byte	117
3464    42B9  74        		.byte	116
3465    42BA  69        		.byte	105
3466    42BB  6E        		.byte	110
3467    42BC  67        		.byte	103
3468    42BD  20        		.byte	32
3469    42BE  69        		.byte	105
3470    42BF  6E        		.byte	110
3471    42C0  3A        		.byte	58
3472    42C1  20        		.byte	32
3473    42C2  00        		.byte	0
3474                    	L5762:
3475    42C3  52        		.byte	82
3476    42C4  41        		.byte	65
3477    42C5  4D        		.byte	77
3478    42C6  0A        		.byte	10
3479    42C7  00        		.byte	0
3480                    	L5072:
3481    42C8  45        		.byte	69
3482    42C9  50        		.byte	80
3483    42CA  52        		.byte	82
3484    42CB  4F        		.byte	79
3485    42CC  4D        		.byte	77
3486    42CD  0A        		.byte	10
3487    42CE  00        		.byte	0
3488                    	; 1575                          }
3489                    	; 1576                      }
3490                    	; 1577                  }
3491                    	; 1578              }
3492                    	; 1579          }
3493                    	; 1580      }
3494                    	; 1581  
3495                    	; 1582  /* Executing in RAM or EPROM
3496                    	; 1583   */
3497                    	; 1584  void execin()
3498                    	; 1585      {
3499                    	_execin:
3500                    	; 1586      printf(", executing in: ");
3501    42CF  21B242    		ld	hl,L5662
3502    42D2  CD0000    		call	_printf
3503                    	; 1587      rampptr = &ramprobe;
3504    42D5  211700    		ld	hl,_ramprobe
3505                    	; 1588      *rampptr = 1; /* try to change const */
3506    42D8  224C02    		ld	(_rampptr),hl
3507    42DB  3601      		ld	(hl),1
3508    42DD  23        		inc	hl
3509    42DE  3600      		ld	(hl),0
3510                    	; 1589      if (ramprobe)
3511    42E0  2A1700    		ld	hl,(_ramprobe)
3512    42E3  7C        		ld	a,h
3513    42E4  B5        		or	l
3514    42E5  2808      		jr	z,L1026
3515                    	; 1590          printf("RAM\n");
3516    42E7  21C342    		ld	hl,L5762
3517    42EA  CD0000    		call	_printf
3518                    	; 1591      else
3519    42ED  1806      		jr	L1126
3520                    	L1026:
3521                    	; 1592          printf("EPROM\n");
3522    42EF  21C842    		ld	hl,L5072
3523    42F2  CD0000    		call	_printf
3524                    	L1126:
3525                    	; 1593      *rampptr = 0;
3526    42F5  2A4C02    		ld	hl,(_rampptr)
3527    42F8  3600      		ld	(hl),0
3528    42FA  23        		inc	hl
3529    42FB  3600      		ld	(hl),0
3530                    	; 1594      }
3531    42FD  C9        		ret 
3532                    	L5172:
3533    42FE  7A        		.byte	122
3534    42FF  38        		.byte	56
3535    4300  30        		.byte	48
3536    4301  73        		.byte	115
3537    4302  64        		.byte	100
3538    4303  62        		.byte	98
3539    4304  74        		.byte	116
3540    4305  20        		.byte	32
3541    4306  00        		.byte	0
3542                    	L5272:
3543    4307  76        		.byte	118
3544    4308  65        		.byte	101
3545    4309  72        		.byte	114
3546    430A  73        		.byte	115
3547    430B  69        		.byte	105
3548    430C  6F        		.byte	111
3549    430D  6E        		.byte	110
3550    430E  20        		.byte	32
3551    430F  30        		.byte	48
3552    4310  2E        		.byte	46
3553    4311  38        		.byte	56
3554    4312  2C        		.byte	44
3555    4313  20        		.byte	32
3556    4314  00        		.byte	0
3557                    	L5372:
3558    4315  63        		.byte	99
3559    4316  6D        		.byte	109
3560    4317  64        		.byte	100
3561    4318  20        		.byte	32
3562    4319  28        		.byte	40
3563    431A  3F        		.byte	63
3564    431B  20        		.byte	32
3565    431C  66        		.byte	102
3566    431D  6F        		.byte	111
3567    431E  72        		.byte	114
3568    431F  20        		.byte	32
3569    4320  68        		.byte	104
3570    4321  65        		.byte	101
3571    4322  6C        		.byte	108
3572    4323  70        		.byte	112
3573    4324  29        		.byte	41
3574    4325  3A        		.byte	58
3575    4326  20        		.byte	32
3576    4327  00        		.byte	0
3577                    	L5472:
3578    4328  20        		.byte	32
3579    4329  3F        		.byte	63
3580    432A  20        		.byte	32
3581    432B  2D        		.byte	45
3582    432C  20        		.byte	32
3583    432D  68        		.byte	104
3584    432E  65        		.byte	101
3585    432F  6C        		.byte	108
3586    4330  70        		.byte	112
3587    4331  0A        		.byte	10
3588    4332  00        		.byte	0
3589                    	L5572:
3590    4333  7A        		.byte	122
3591    4334  38        		.byte	56
3592    4335  30        		.byte	48
3593    4336  73        		.byte	115
3594    4337  64        		.byte	100
3595    4338  62        		.byte	98
3596    4339  74        		.byte	116
3597    433A  20        		.byte	32
3598    433B  00        		.byte	0
3599                    	L5672:
3600    433C  76        		.byte	118
3601    433D  65        		.byte	101
3602    433E  72        		.byte	114
3603    433F  73        		.byte	115
3604    4340  69        		.byte	105
3605    4341  6F        		.byte	111
3606    4342  6E        		.byte	110
3607    4343  20        		.byte	32
3608    4344  30        		.byte	48
3609    4345  2E        		.byte	46
3610    4346  38        		.byte	56
3611    4347  2C        		.byte	44
3612    4348  20        		.byte	32
3613    4349  00        		.byte	0
3614                    	L5772:
3615    434A  43        		.byte	67
3616    434B  6F        		.byte	111
3617    434C  6D        		.byte	109
3618    434D  6D        		.byte	109
3619    434E  61        		.byte	97
3620    434F  6E        		.byte	110
3621    4350  64        		.byte	100
3622    4351  73        		.byte	115
3623    4352  3A        		.byte	58
3624    4353  0A        		.byte	10
3625    4354  00        		.byte	0
3626                    	L5003:
3627    4355  20        		.byte	32
3628    4356  20        		.byte	32
3629    4357  3F        		.byte	63
3630    4358  20        		.byte	32
3631    4359  2D        		.byte	45
3632    435A  20        		.byte	32
3633    435B  68        		.byte	104
3634    435C  65        		.byte	101
3635    435D  6C        		.byte	108
3636    435E  70        		.byte	112
3637    435F  0A        		.byte	10
3638    4360  00        		.byte	0
3639                    	L5103:
3640    4361  20        		.byte	32
3641    4362  20        		.byte	32
3642    4363  62        		.byte	98
3643    4364  20        		.byte	32
3644    4365  2D        		.byte	45
3645    4366  20        		.byte	32
3646    4367  62        		.byte	98
3647    4368  6F        		.byte	111
3648    4369  6F        		.byte	111
3649    436A  74        		.byte	116
3650    436B  20        		.byte	32
3651    436C  66        		.byte	102
3652    436D  72        		.byte	114
3653    436E  6F        		.byte	111
3654    436F  6D        		.byte	109
3655    4370  20        		.byte	32
3656    4371  53        		.byte	83
3657    4372  44        		.byte	68
3658    4373  20        		.byte	32
3659    4374  63        		.byte	99
3660    4375  61        		.byte	97
3661    4376  72        		.byte	114
3662    4377  64        		.byte	100
3663    4378  0A        		.byte	10
3664    4379  00        		.byte	0
3665                    	L5203:
3666    437A  20        		.byte	32
3667    437B  20        		.byte	32
3668    437C  64        		.byte	100
3669    437D  20        		.byte	32
3670    437E  2D        		.byte	45
3671    437F  20        		.byte	32
3672    4380  64        		.byte	100
3673    4381  65        		.byte	101
3674    4382  62        		.byte	98
3675    4383  75        		.byte	117
3676    4384  67        		.byte	103
3677    4385  20        		.byte	32
3678    4386  6F        		.byte	111
3679    4387  6E        		.byte	110
3680    4388  2F        		.byte	47
3681    4389  6F        		.byte	111
3682    438A  66        		.byte	102
3683    438B  66        		.byte	102
3684    438C  0A        		.byte	10
3685    438D  00        		.byte	0
3686                    	L5303:
3687    438E  20        		.byte	32
3688    438F  20        		.byte	32
3689    4390  69        		.byte	105
3690    4391  20        		.byte	32
3691    4392  2D        		.byte	45
3692    4393  20        		.byte	32
3693    4394  69        		.byte	105
3694    4395  6E        		.byte	110
3695    4396  69        		.byte	105
3696    4397  74        		.byte	116
3697    4398  69        		.byte	105
3698    4399  61        		.byte	97
3699    439A  6C        		.byte	108
3700    439B  69        		.byte	105
3701    439C  7A        		.byte	122
3702    439D  65        		.byte	101
3703    439E  20        		.byte	32
3704    439F  53        		.byte	83
3705    43A0  44        		.byte	68
3706    43A1  20        		.byte	32
3707    43A2  63        		.byte	99
3708    43A3  61        		.byte	97
3709    43A4  72        		.byte	114
3710    43A5  64        		.byte	100
3711    43A6  0A        		.byte	10
3712    43A7  00        		.byte	0
3713                    	L5403:
3714    43A8  20        		.byte	32
3715    43A9  20        		.byte	32
3716    43AA  6C        		.byte	108
3717    43AB  20        		.byte	32
3718    43AC  2D        		.byte	45
3719    43AD  20        		.byte	32
3720    43AE  70        		.byte	112
3721    43AF  72        		.byte	114
3722    43B0  69        		.byte	105
3723    43B1  6E        		.byte	110
3724    43B2  74        		.byte	116
3725    43B3  20        		.byte	32
3726    43B4  53        		.byte	83
3727    43B5  44        		.byte	68
3728    43B6  20        		.byte	32
3729    43B7  63        		.byte	99
3730    43B8  61        		.byte	97
3731    43B9  72        		.byte	114
3732    43BA  64        		.byte	100
3733    43BB  20        		.byte	32
3734    43BC  70        		.byte	112
3735    43BD  61        		.byte	97
3736    43BE  72        		.byte	114
3737    43BF  74        		.byte	116
3738    43C0  69        		.byte	105
3739    43C1  74        		.byte	116
3740    43C2  69        		.byte	105
3741    43C3  6F        		.byte	111
3742    43C4  6E        		.byte	110
3743    43C5  20        		.byte	32
3744    43C6  6C        		.byte	108
3745    43C7  61        		.byte	97
3746    43C8  79        		.byte	121
3747    43C9  6F        		.byte	111
3748    43CA  75        		.byte	117
3749    43CB  74        		.byte	116
3750    43CC  0A        		.byte	10
3751    43CD  00        		.byte	0
3752                    	L5503:
3753    43CE  20        		.byte	32
3754    43CF  20        		.byte	32
3755    43D0  6E        		.byte	110
3756    43D1  20        		.byte	32
3757    43D2  2D        		.byte	45
3758    43D3  20        		.byte	32
3759    43D4  73        		.byte	115
3760    43D5  65        		.byte	101
3761    43D6  74        		.byte	116
3762    43D7  2F        		.byte	47
3763    43D8  73        		.byte	115
3764    43D9  68        		.byte	104
3765    43DA  6F        		.byte	111
3766    43DB  77        		.byte	119
3767    43DC  20        		.byte	32
3768    43DD  73        		.byte	115
3769    43DE  65        		.byte	101
3770    43DF  63        		.byte	99
3771    43E0  74        		.byte	116
3772    43E1  6F        		.byte	111
3773    43E2  72        		.byte	114
3774    43E3  20        		.byte	32
3775    43E4  23        		.byte	35
3776    43E5  4E        		.byte	78
3777    43E6  20        		.byte	32
3778    43E7  74        		.byte	116
3779    43E8  6F        		.byte	111
3780    43E9  20        		.byte	32
3781    43EA  72        		.byte	114
3782    43EB  65        		.byte	101
3783    43EC  61        		.byte	97
3784    43ED  64        		.byte	100
3785    43EE  2F        		.byte	47
3786    43EF  77        		.byte	119
3787    43F0  72        		.byte	114
3788    43F1  69        		.byte	105
3789    43F2  74        		.byte	116
3790    43F3  65        		.byte	101
3791    43F4  0A        		.byte	10
3792    43F5  00        		.byte	0
3793                    	L5603:
3794    43F6  20        		.byte	32
3795    43F7  20        		.byte	32
3796    43F8  70        		.byte	112
3797    43F9  20        		.byte	32
3798    43FA  2D        		.byte	45
3799    43FB  20        		.byte	32
3800    43FC  70        		.byte	112
3801    43FD  72        		.byte	114
3802    43FE  69        		.byte	105
3803    43FF  6E        		.byte	110
3804    4400  74        		.byte	116
3805    4401  20        		.byte	32
3806    4402  73        		.byte	115
3807    4403  65        		.byte	101
3808    4404  63        		.byte	99
3809    4405  74        		.byte	116
3810    4406  6F        		.byte	111
3811    4407  72        		.byte	114
3812    4408  20        		.byte	32
3813    4409  6C        		.byte	108
3814    440A  61        		.byte	97
3815    440B  73        		.byte	115
3816    440C  74        		.byte	116
3817    440D  20        		.byte	32
3818    440E  72        		.byte	114
3819    440F  65        		.byte	101
3820    4410  61        		.byte	97
3821    4411  64        		.byte	100
3822    4412  2F        		.byte	47
3823    4413  74        		.byte	116
3824    4414  6F        		.byte	111
3825    4415  20        		.byte	32
3826    4416  77        		.byte	119
3827    4417  72        		.byte	114
3828    4418  69        		.byte	105
3829    4419  74        		.byte	116
3830    441A  65        		.byte	101
3831    441B  0A        		.byte	10
3832    441C  00        		.byte	0
3833                    	L5703:
3834    441D  20        		.byte	32
3835    441E  20        		.byte	32
3836    441F  72        		.byte	114
3837    4420  20        		.byte	32
3838    4421  2D        		.byte	45
3839    4422  20        		.byte	32
3840    4423  72        		.byte	114
3841    4424  65        		.byte	101
3842    4425  61        		.byte	97
3843    4426  64        		.byte	100
3844    4427  20        		.byte	32
3845    4428  73        		.byte	115
3846    4429  65        		.byte	101
3847    442A  63        		.byte	99
3848    442B  74        		.byte	116
3849    442C  6F        		.byte	111
3850    442D  72        		.byte	114
3851    442E  20        		.byte	32
3852    442F  23        		.byte	35
3853    4430  4E        		.byte	78
3854    4431  0A        		.byte	10
3855    4432  00        		.byte	0
3856                    	L5013:
3857    4433  20        		.byte	32
3858    4434  20        		.byte	32
3859    4435  73        		.byte	115
3860    4436  20        		.byte	32
3861    4437  2D        		.byte	45
3862    4438  20        		.byte	32
3863    4439  70        		.byte	112
3864    443A  72        		.byte	114
3865    443B  69        		.byte	105
3866    443C  6E        		.byte	110
3867    443D  74        		.byte	116
3868    443E  20        		.byte	32
3869    443F  53        		.byte	83
3870    4440  44        		.byte	68
3871    4441  20        		.byte	32
3872    4442  72        		.byte	114
3873    4443  65        		.byte	101
3874    4444  67        		.byte	103
3875    4445  69        		.byte	105
3876    4446  73        		.byte	115
3877    4447  74        		.byte	116
3878    4448  65        		.byte	101
3879    4449  72        		.byte	114
3880    444A  73        		.byte	115
3881    444B  0A        		.byte	10
3882    444C  00        		.byte	0
3883                    	L5113:
3884    444D  20        		.byte	32
3885    444E  20        		.byte	32
3886    444F  74        		.byte	116
3887    4450  20        		.byte	32
3888    4451  2D        		.byte	45
3889    4452  20        		.byte	32
3890    4453  74        		.byte	116
3891    4454  65        		.byte	101
3892    4455  73        		.byte	115
3893    4456  74        		.byte	116
3894    4457  20        		.byte	32
3895    4458  70        		.byte	112
3896    4459  72        		.byte	114
3897    445A  6F        		.byte	111
3898    445B  62        		.byte	98
3899    445C  65        		.byte	101
3900    445D  20        		.byte	32
3901    445E  53        		.byte	83
3902    445F  44        		.byte	68
3903    4460  20        		.byte	32
3904    4461  63        		.byte	99
3905    4462  61        		.byte	97
3906    4463  72        		.byte	114
3907    4464  64        		.byte	100
3908    4465  0A        		.byte	10
3909    4466  00        		.byte	0
3910                    	L5213:
3911    4467  20        		.byte	32
3912    4468  20        		.byte	32
3913    4469  75        		.byte	117
3914    446A  20        		.byte	32
3915    446B  2D        		.byte	45
3916    446C  20        		.byte	32
3917    446D  75        		.byte	117
3918    446E  70        		.byte	112
3919    446F  6C        		.byte	108
3920    4470  6F        		.byte	111
3921    4471  61        		.byte	97
3922    4472  64        		.byte	100
3923    4473  20        		.byte	32
3924    4474  63        		.byte	99
3925    4475  6F        		.byte	111
3926    4476  64        		.byte	100
3927    4477  65        		.byte	101
3928    4478  20        		.byte	32
3929    4479  77        		.byte	119
3930    447A  69        		.byte	105
3931    447B  74        		.byte	116
3932    447C  68        		.byte	104
3933    447D  20        		.byte	32
3934    447E  58        		.byte	88
3935    447F  6D        		.byte	109
3936    4480  6F        		.byte	111
3937    4481  64        		.byte	100
3938    4482  65        		.byte	101
3939    4483  6D        		.byte	109
3940    4484  20        		.byte	32
3941    4485  74        		.byte	116
3942    4486  6F        		.byte	111
3943    4487  20        		.byte	32
3944    4488  52        		.byte	82
3945    4489  41        		.byte	65
3946    448A  4D        		.byte	77
3947    448B  20        		.byte	32
3948    448C  61        		.byte	97
3949    448D  64        		.byte	100
3950    448E  64        		.byte	100
3951    448F  72        		.byte	114
3952    4490  65        		.byte	101
3953    4491  73        		.byte	115
3954    4492  73        		.byte	115
3955    4493  20        		.byte	32
3956    4494  30        		.byte	48
3957    4495  78        		.byte	120
3958    4496  30        		.byte	48
3959    4497  30        		.byte	48
3960    4498  30        		.byte	48
3961    4499  30        		.byte	48
3962    449A  0A        		.byte	10
3963    449B  00        		.byte	0
3964                    	L5313:
3965    449C  20        		.byte	32
3966    449D  20        		.byte	32
3967    449E  77        		.byte	119
3968    449F  20        		.byte	32
3969    44A0  2D        		.byte	45
3970    44A1  20        		.byte	32
3971    44A2  77        		.byte	119
3972    44A3  72        		.byte	114
3973    44A4  69        		.byte	105
3974    44A5  74        		.byte	116
3975    44A6  65        		.byte	101
3976    44A7  20        		.byte	32
3977    44A8  73        		.byte	115
3978    44A9  65        		.byte	101
3979    44AA  63        		.byte	99
3980    44AB  74        		.byte	116
3981    44AC  6F        		.byte	111
3982    44AD  72        		.byte	114
3983    44AE  20        		.byte	32
3984    44AF  23        		.byte	35
3985    44B0  4E        		.byte	78
3986    44B1  0A        		.byte	10
3987    44B2  00        		.byte	0
3988                    	L5413:
3989    44B3  20        		.byte	32
3990    44B4  20        		.byte	32
3991    44B5  43        		.byte	67
3992    44B6  74        		.byte	116
3993    44B7  72        		.byte	114
3994    44B8  6C        		.byte	108
3995    44B9  2D        		.byte	45
3996    44BA  43        		.byte	67
3997    44BB  20        		.byte	32
3998    44BC  74        		.byte	116
3999    44BD  6F        		.byte	111
4000    44BE  20        		.byte	32
4001    44BF  72        		.byte	114
4002    44C0  65        		.byte	101
4003    44C1  6C        		.byte	108
4004    44C2  6F        		.byte	111
4005    44C3  61        		.byte	97
4006    44C4  64        		.byte	100
4007    44C5  20        		.byte	32
4008    44C6  6D        		.byte	109
4009    44C7  6F        		.byte	111
4010    44C8  6E        		.byte	110
4011    44C9  69        		.byte	105
4012    44CA  74        		.byte	116
4013    44CB  6F        		.byte	111
4014    44CC  72        		.byte	114
4015    44CD  20        		.byte	32
4016    44CE  66        		.byte	102
4017    44CF  72        		.byte	114
4018    44D0  6F        		.byte	111
4019    44D1  6D        		.byte	109
4020    44D2  20        		.byte	32
4021    44D3  45        		.byte	69
4022    44D4  50        		.byte	80
4023    44D5  52        		.byte	82
4024    44D6  4F        		.byte	79
4025    44D7  4D        		.byte	77
4026    44D8  0A        		.byte	10
4027    44D9  00        		.byte	0
4028                    	L5513:
4029    44DA  20        		.byte	32
4030    44DB  64        		.byte	100
4031    44DC  20        		.byte	32
4032    44DD  2D        		.byte	45
4033    44DE  20        		.byte	32
4034    44DF  62        		.byte	98
4035    44E0  6F        		.byte	111
4036    44E1  6F        		.byte	111
4037    44E2  74        		.byte	116
4038    44E3  20        		.byte	32
4039    44E4  66        		.byte	102
4040    44E5  72        		.byte	114
4041    44E6  6F        		.byte	111
4042    44E7  6D        		.byte	109
4043    44E8  20        		.byte	32
4044    44E9  53        		.byte	83
4045    44EA  44        		.byte	68
4046    44EB  20        		.byte	32
4047    44EC  63        		.byte	99
4048    44ED  61        		.byte	97
4049    44EE  72        		.byte	114
4050    44EF  64        		.byte	100
4051    44F0  20        		.byte	32
4052    44F1  2D        		.byte	45
4053    44F2  20        		.byte	32
4054    44F3  00        		.byte	0
4055                    	L5613:
4056    44F4  69        		.byte	105
4057    44F5  6D        		.byte	109
4058    44F6  70        		.byte	112
4059    44F7  6C        		.byte	108
4060    44F8  65        		.byte	101
4061    44F9  6D        		.byte	109
4062    44FA  65        		.byte	101
4063    44FB  6E        		.byte	110
4064    44FC  74        		.byte	116
4065    44FD  61        		.byte	97
4066    44FE  74        		.byte	116
4067    44FF  69        		.byte	105
4068    4500  6F        		.byte	111
4069    4501  6E        		.byte	110
4070    4502  20        		.byte	32
4071    4503  6F        		.byte	111
4072    4504  6E        		.byte	110
4073    4505  67        		.byte	103
4074    4506  6F        		.byte	111
4075    4507  69        		.byte	105
4076    4508  6E        		.byte	110
4077    4509  67        		.byte	103
4078    450A  0A        		.byte	10
4079    450B  00        		.byte	0
4080                    	L5713:
4081    450C  20        		.byte	32
4082    450D  64        		.byte	100
4083    450E  20        		.byte	32
4084    450F  2D        		.byte	45
4085    4510  20        		.byte	32
4086    4511  74        		.byte	116
4087    4512  6F        		.byte	111
4088    4513  67        		.byte	103
4089    4514  67        		.byte	103
4090    4515  6C        		.byte	108
4091    4516  65        		.byte	101
4092    4517  20        		.byte	32
4093    4518  64        		.byte	100
4094    4519  65        		.byte	101
4095    451A  62        		.byte	98
   0    451B  75        		.byte	117
   1    451C  67        		.byte	103
   2    451D  20        		.byte	32
   3    451E  66        		.byte	102
   4    451F  6C        		.byte	108
   5    4520  61        		.byte	97
   6    4521  67        		.byte	103
   7    4522  20        		.byte	32
   8    4523  2D        		.byte	45
   9    4524  20        		.byte	32
  10    4525  00        		.byte	0
  11                    	L5023:
  12    4526  4F        		.byte	79
  13    4527  46        		.byte	70
  14    4528  46        		.byte	70
  15    4529  0A        		.byte	10
  16    452A  00        		.byte	0
  17                    	L5123:
  18    452B  4F        		.byte	79
  19    452C  4E        		.byte	78
  20    452D  0A        		.byte	10
  21    452E  00        		.byte	0
  22                    	L5223:
  23    452F  20        		.byte	32
  24    4530  69        		.byte	105
  25    4531  20        		.byte	32
  26    4532  2D        		.byte	45
  27    4533  20        		.byte	32
  28    4534  69        		.byte	105
  29    4535  6E        		.byte	110
  30    4536  69        		.byte	105
  31    4537  74        		.byte	116
  32    4538  69        		.byte	105
  33    4539  61        		.byte	97
  34    453A  6C        		.byte	108
  35    453B  69        		.byte	105
  36    453C  7A        		.byte	122
  37    453D  65        		.byte	101
  38    453E  20        		.byte	32
  39    453F  53        		.byte	83
  40    4540  44        		.byte	68
  41    4541  20        		.byte	32
  42    4542  63        		.byte	99
  43    4543  61        		.byte	97
  44    4544  72        		.byte	114
  45    4545  64        		.byte	100
  46    4546  00        		.byte	0
  47                    	L5323:
  48    4547  20        		.byte	32
  49    4548  2D        		.byte	45
  50    4549  20        		.byte	32
  51    454A  6F        		.byte	111
  52    454B  6B        		.byte	107
  53    454C  0A        		.byte	10
  54    454D  00        		.byte	0
  55                    	L5423:
  56    454E  20        		.byte	32
  57    454F  2D        		.byte	45
  58    4550  20        		.byte	32
  59    4551  6E        		.byte	110
  60    4552  6F        		.byte	111
  61    4553  74        		.byte	116
  62    4554  20        		.byte	32
  63    4555  69        		.byte	105
  64    4556  6E        		.byte	110
  65    4557  73        		.byte	115
  66    4558  65        		.byte	101
  67    4559  72        		.byte	114
  68    455A  74        		.byte	116
  69    455B  65        		.byte	101
  70    455C  64        		.byte	100
  71    455D  20        		.byte	32
  72    455E  6F        		.byte	111
  73    455F  72        		.byte	114
  74    4560  20        		.byte	32
  75    4561  66        		.byte	102
  76    4562  61        		.byte	97
  77    4563  75        		.byte	117
  78    4564  6C        		.byte	108
  79    4565  74        		.byte	116
  80    4566  79        		.byte	121
  81    4567  0A        		.byte	10
  82    4568  00        		.byte	0
  83                    	L5523:
  84    4569  20        		.byte	32
  85    456A  6C        		.byte	108
  86    456B  20        		.byte	32
  87    456C  2D        		.byte	45
  88    456D  20        		.byte	32
  89    456E  70        		.byte	112
  90    456F  72        		.byte	114
  91    4570  69        		.byte	105
  92    4571  6E        		.byte	110
  93    4572  74        		.byte	116
  94    4573  20        		.byte	32
  95    4574  70        		.byte	112
  96    4575  61        		.byte	97
  97    4576  72        		.byte	114
  98    4577  74        		.byte	116
  99    4578  69        		.byte	105
 100    4579  74        		.byte	116
 101    457A  69        		.byte	105
 102    457B  6F        		.byte	111
 103    457C  6E        		.byte	110
 104    457D  20        		.byte	32
 105    457E  6C        		.byte	108
 106    457F  61        		.byte	97
 107    4580  79        		.byte	121
 108    4581  6F        		.byte	111
 109    4582  75        		.byte	117
 110    4583  74        		.byte	116
 111    4584  0A        		.byte	10
 112    4585  00        		.byte	0
 113                    	L5623:
 114    4586  20        		.byte	32
 115    4587  2D        		.byte	45
 116    4588  20        		.byte	32
 117    4589  53        		.byte	83
 118    458A  44        		.byte	68
 119    458B  20        		.byte	32
 120    458C  6E        		.byte	110
 121    458D  6F        		.byte	111
 122    458E  74        		.byte	116
 123    458F  20        		.byte	32
 124    4590  69        		.byte	105
 125    4591  6E        		.byte	110
 126    4592  69        		.byte	105
 127    4593  74        		.byte	116
 128    4594  69        		.byte	105
 129    4595  61        		.byte	97
 130    4596  6C        		.byte	108
 131    4597  69        		.byte	105
 132    4598  7A        		.byte	122
 133    4599  65        		.byte	101
 134    459A  64        		.byte	100
 135    459B  20        		.byte	32
 136    459C  6F        		.byte	111
 137    459D  72        		.byte	114
 138    459E  20        		.byte	32
 139    459F  69        		.byte	105
 140    45A0  6E        		.byte	110
 141    45A1  73        		.byte	115
 142    45A2  65        		.byte	101
 143    45A3  72        		.byte	114
 144    45A4  74        		.byte	116
 145    45A5  65        		.byte	101
 146    45A6  64        		.byte	100
 147    45A7  20        		.byte	32
 148    45A8  6F        		.byte	111
 149    45A9  72        		.byte	114
 150    45AA  20        		.byte	32
 151    45AB  66        		.byte	102
 152    45AC  61        		.byte	97
 153    45AD  75        		.byte	117
 154    45AE  6C        		.byte	108
 155    45AF  74        		.byte	116
 156    45B0  79        		.byte	121
 157    45B1  0A        		.byte	10
 158    45B2  00        		.byte	0
 159                    	L412:
 160    45B3  00        		.byte	0
 161    45B4  00        		.byte	0
 162    45B5  00        		.byte	0
 163    45B6  00        		.byte	0
 164                    	L5723:
 165    45B7  20        		.byte	32
 166    45B8  20        		.byte	32
 167    45B9  20        		.byte	32
 168    45BA  20        		.byte	32
 169    45BB  20        		.byte	32
 170    45BC  20        		.byte	32
 171    45BD  44        		.byte	68
 172    45BE  69        		.byte	105
 173    45BF  73        		.byte	115
 174    45C0  6B        		.byte	107
 175    45C1  20        		.byte	32
 176    45C2  70        		.byte	112
 177    45C3  61        		.byte	97
 178    45C4  72        		.byte	114
 179    45C5  74        		.byte	116
 180    45C6  69        		.byte	105
 181    45C7  74        		.byte	116
 182    45C8  69        		.byte	105
 183    45C9  6F        		.byte	111
 184    45CA  6E        		.byte	110
 185    45CB  20        		.byte	32
 186    45CC  73        		.byte	115
 187    45CD  65        		.byte	101
 188    45CE  63        		.byte	99
 189    45CF  74        		.byte	116
 190    45D0  6F        		.byte	111
 191    45D1  72        		.byte	114
 192    45D2  73        		.byte	115
 193    45D3  20        		.byte	32
 194    45D4  6F        		.byte	111
 195    45D5  6E        		.byte	110
 196    45D6  20        		.byte	32
 197    45D7  53        		.byte	83
 198    45D8  44        		.byte	68
 199    45D9  20        		.byte	32
 200    45DA  63        		.byte	99
 201    45DB  61        		.byte	97
 202    45DC  72        		.byte	114
 203    45DD  64        		.byte	100
 204    45DE  0A        		.byte	10
 205    45DF  00        		.byte	0
 206                    	L5033:
 207    45E0  20        		.byte	32
 208    45E1  20        		.byte	32
 209    45E2  20        		.byte	32
 210    45E3  20        		.byte	32
 211    45E4  20        		.byte	32
 212    45E5  20        		.byte	32
 213    45E6  20        		.byte	32
 214    45E7  4D        		.byte	77
 215    45E8  42        		.byte	66
 216    45E9  52        		.byte	82
 217    45EA  20        		.byte	32
 218    45EB  64        		.byte	100
 219    45EC  69        		.byte	105
 220    45ED  73        		.byte	115
 221    45EE  6B        		.byte	107
 222    45EF  20        		.byte	32
 223    45F0  69        		.byte	105
 224    45F1  64        		.byte	100
 225    45F2  65        		.byte	101
 226    45F3  6E        		.byte	110
 227    45F4  74        		.byte	116
 228    45F5  69        		.byte	105
 229    45F6  66        		.byte	102
 230    45F7  69        		.byte	105
 231    45F8  65        		.byte	101
 232    45F9  72        		.byte	114
 233    45FA  3A        		.byte	58
 234    45FB  20        		.byte	32
 235    45FC  30        		.byte	48
 236    45FD  78        		.byte	120
 237    45FE  25        		.byte	37
 238    45FF  30        		.byte	48
 239    4600  32        		.byte	50
 240    4601  78        		.byte	120
 241    4602  25        		.byte	37
 242    4603  30        		.byte	48
 243    4604  32        		.byte	50
 244    4605  78        		.byte	120
 245    4606  25        		.byte	37
 246    4607  30        		.byte	48
 247    4608  32        		.byte	50
 248    4609  78        		.byte	120
 249    460A  25        		.byte	37
 250    460B  30        		.byte	48
 251    460C  32        		.byte	50
 252    460D  78        		.byte	120
 253    460E  0A        		.byte	10
 254    460F  00        		.byte	0
 255                    	L5133:
 256    4610  20        		.byte	32
 257    4611  44        		.byte	68
 258    4612  69        		.byte	105
 259    4613  73        		.byte	115
 260    4614  6B        		.byte	107
 261    4615  20        		.byte	32
 262    4616  20        		.byte	32
 263    4617  20        		.byte	32
 264    4618  20        		.byte	32
 265    4619  20        		.byte	32
 266    461A  53        		.byte	83
 267    461B  74        		.byte	116
 268    461C  61        		.byte	97
 269    461D  72        		.byte	114
 270    461E  74        		.byte	116
 271    461F  20        		.byte	32
 272    4620  20        		.byte	32
 273    4621  20        		.byte	32
 274    4622  20        		.byte	32
 275    4623  20        		.byte	32
 276    4624  20        		.byte	32
 277    4625  45        		.byte	69
 278    4626  6E        		.byte	110
 279    4627  64        		.byte	100
 280    4628  20        		.byte	32
 281    4629  20        		.byte	32
 282    462A  20        		.byte	32
 283    462B  20        		.byte	32
 284    462C  20        		.byte	32
 285    462D  53        		.byte	83
 286    462E  69        		.byte	105
 287    462F  7A        		.byte	122
 288    4630  65        		.byte	101
 289    4631  20        		.byte	32
 290    4632  50        		.byte	80
 291    4633  61        		.byte	97
 292    4634  72        		.byte	114
 293    4635  74        		.byte	116
 294    4636  20        		.byte	32
 295    4637  54        		.byte	84
 296    4638  79        		.byte	121
 297    4639  70        		.byte	112
 298    463A  65        		.byte	101
 299    463B  20        		.byte	32
 300    463C  49        		.byte	73
 301    463D  64        		.byte	100
 302    463E  0A        		.byte	10
 303    463F  00        		.byte	0
 304                    	L5233:
 305    4640  20        		.byte	32
 306    4641  2D        		.byte	45
 307    4642  2D        		.byte	45
 308    4643  2D        		.byte	45
 309    4644  2D        		.byte	45
 310    4645  20        		.byte	32
 311    4646  20        		.byte	32
 312    4647  20        		.byte	32
 313    4648  20        		.byte	32
 314    4649  20        		.byte	32
 315    464A  2D        		.byte	45
 316    464B  2D        		.byte	45
 317    464C  2D        		.byte	45
 318    464D  2D        		.byte	45
 319    464E  2D        		.byte	45
 320    464F  20        		.byte	32
 321    4650  20        		.byte	32
 322    4651  20        		.byte	32
 323    4652  20        		.byte	32
 324    4653  20        		.byte	32
 325    4654  20        		.byte	32
 326    4655  2D        		.byte	45
 327    4656  2D        		.byte	45
 328    4657  2D        		.byte	45
 329    4658  20        		.byte	32
 330    4659  20        		.byte	32
 331    465A  20        		.byte	32
 332    465B  20        		.byte	32
 333    465C  20        		.byte	32
 334    465D  2D        		.byte	45
 335    465E  2D        		.byte	45
 336    465F  2D        		.byte	45
 337    4660  2D        		.byte	45
 338    4661  20        		.byte	32
 339    4662  2D        		.byte	45
 340    4663  2D        		.byte	45
 341    4664  2D        		.byte	45
 342    4665  2D        		.byte	45
 343    4666  20        		.byte	32
 344    4667  2D        		.byte	45
 345    4668  2D        		.byte	45
 346    4669  2D        		.byte	45
 347    466A  2D        		.byte	45
 348    466B  20        		.byte	32
 349    466C  2D        		.byte	45
 350    466D  2D        		.byte	45
 351    466E  0A        		.byte	10
 352    466F  00        		.byte	0
 353                    	L5333:
 354    4670  25        		.byte	37
 355    4671  32        		.byte	50
 356    4672  64        		.byte	100
 357    4673  20        		.byte	32
 358    4674  28        		.byte	40
 359    4675  25        		.byte	37
 360    4676  63        		.byte	99
 361    4677  29        		.byte	41
 362    4678  25        		.byte	37
 363    4679  63        		.byte	99
 364    467A  00        		.byte	0
 365                    	L5433:
 366    467B  25        		.byte	37
 367    467C  38        		.byte	56
 368    467D  6C        		.byte	108
 369    467E  75        		.byte	117
 370    467F  20        		.byte	32
 371    4680  25        		.byte	37
 372    4681  38        		.byte	56
 373    4682  6C        		.byte	108
 374    4683  75        		.byte	117
 375    4684  20        		.byte	32
 376    4685  25        		.byte	37
 377    4686  38        		.byte	56
 378    4687  6C        		.byte	108
 379    4688  75        		.byte	117
 380    4689  20        		.byte	32
 381    468A  00        		.byte	0
 382                    	L5533:
 383    468B  20        		.byte	32
 384    468C  45        		.byte	69
 385    468D  42        		.byte	66
 386    468E  52        		.byte	82
 387    468F  20        		.byte	32
 388    4690  63        		.byte	99
 389    4691  6F        		.byte	111
 390    4692  6E        		.byte	110
 391    4693  74        		.byte	116
 392    4694  61        		.byte	97
 393    4695  69        		.byte	105
 394    4696  6E        		.byte	110
 395    4697  65        		.byte	101
 396    4698  72        		.byte	114
 397    4699  0A        		.byte	10
 398    469A  00        		.byte	0
 399                    	L5633:
 400    469B  20        		.byte	32
 401    469C  47        		.byte	71
 402    469D  50        		.byte	80
 403    469E  54        		.byte	84
 404    469F  20        		.byte	32
 405    46A0  00        		.byte	0
 406                    	L5733:
 407    46A1  43        		.byte	67
 408    46A2  50        		.byte	80
 409    46A3  2F        		.byte	47
 410    46A4  4D        		.byte	77
 411    46A5  20        		.byte	32
 412    46A6  00        		.byte	0
 413                    	L5043:
 414    46A7  20        		.byte	32
 415    46A8  3F        		.byte	63
 416    46A9  3F        		.byte	63
 417    46AA  20        		.byte	32
 418    46AB  20        		.byte	32
 419    46AC  00        		.byte	0
 420                    	L5143:
 421    46AD  20        		.byte	32
 422    46AE  45        		.byte	69
 423    46AF  42        		.byte	66
 424    46B0  52        		.byte	82
 425    46B1  20        		.byte	32
 426    46B2  00        		.byte	0
 427                    	L5243:
 428    46B3  20        		.byte	32
 429    46B4  4D        		.byte	77
 430    46B5  42        		.byte	66
 431    46B6  52        		.byte	82
 432    46B7  20        		.byte	32
 433    46B8  00        		.byte	0
 434                    	L5343:
 435    46B9  43        		.byte	67
 436    46BA  50        		.byte	80
 437    46BB  2F        		.byte	47
 438    46BC  4D        		.byte	77
 439    46BD  20        		.byte	32
 440    46BE  00        		.byte	0
 441                    	L5443:
 442    46BF  43        		.byte	67
 443    46C0  6F        		.byte	111
 444    46C1  64        		.byte	100
 445    46C2  65        		.byte	101
 446    46C3  20        		.byte	32
 447    46C4  00        		.byte	0
 448                    	L5543:
 449    46C5  20        		.byte	32
 450    46C6  3F        		.byte	63
 451    46C7  3F        		.byte	63
 452    46C8  20        		.byte	32
 453    46C9  20        		.byte	32
 454    46CA  00        		.byte	0
 455                    	L5643:
 456    46CB  30        		.byte	48
 457    46CC  78        		.byte	120
 458    46CD  25        		.byte	37
 459    46CE  30        		.byte	48
 460    46CF  32        		.byte	50
 461    46D0  78        		.byte	120
 462    46D1  00        		.byte	0
 463                    	L5743:
 464    46D2  0A        		.byte	10
 465    46D3  00        		.byte	0
 466                    	L5053:
 467    46D4  20        		.byte	32
 468    46D5  6E        		.byte	110
 469    46D6  20        		.byte	32
 470    46D7  2D        		.byte	45
 471    46D8  20        		.byte	32
 472    46D9  73        		.byte	115
 473    46DA  65        		.byte	101
 474    46DB  63        		.byte	99
 475    46DC  74        		.byte	116
 476    46DD  6F        		.byte	111
 477    46DE  72        		.byte	114
 478    46DF  20        		.byte	32
 479    46E0  6E        		.byte	110
 480    46E1  75        		.byte	117
 481    46E2  6D        		.byte	109
 482    46E3  62        		.byte	98
 483    46E4  65        		.byte	101
 484    46E5  72        		.byte	114
 485    46E6  3A        		.byte	58
 486    46E7  20        		.byte	32
 487    46E8  00        		.byte	0
 488                    	L5153:
 489    46E9  25        		.byte	37
 490    46EA  6C        		.byte	108
 491    46EB  75        		.byte	117
 492    46EC  00        		.byte	0
 493                    	L5253:
 494    46ED  25        		.byte	37
 495    46EE  6C        		.byte	108
 496    46EF  75        		.byte	117
 497    46F0  00        		.byte	0
 498                    	L5353:
 499    46F1  0A        		.byte	10
 500    46F2  00        		.byte	0
 501                    	L5453:
 502    46F3  20        		.byte	32
 503    46F4  70        		.byte	112
 504    46F5  20        		.byte	32
 505    46F6  2D        		.byte	45
 506    46F7  20        		.byte	32
 507    46F8  70        		.byte	112
 508    46F9  72        		.byte	114
 509    46FA  69        		.byte	105
 510    46FB  6E        		.byte	110
 511    46FC  74        		.byte	116
 512    46FD  20        		.byte	32
 513    46FE  64        		.byte	100
 514    46FF  61        		.byte	97
 515    4700  74        		.byte	116
 516    4701  61        		.byte	97
 517    4702  20        		.byte	32
 518    4703  73        		.byte	115
 519    4704  65        		.byte	101
 520    4705  63        		.byte	99
 521    4706  74        		.byte	116
 522    4707  6F        		.byte	111
 523    4708  72        		.byte	114
 524    4709  20        		.byte	32
 525    470A  25        		.byte	37
 526    470B  6C        		.byte	108
 527    470C  75        		.byte	117
 528    470D  0A        		.byte	10
 529    470E  00        		.byte	0
 530                    	L5553:
 531    470F  20        		.byte	32
 532    4710  72        		.byte	114
 533    4711  20        		.byte	32
 534    4712  2D        		.byte	45
 535    4713  20        		.byte	32
 536    4714  72        		.byte	114
 537    4715  65        		.byte	101
 538    4716  61        		.byte	97
 539    4717  64        		.byte	100
 540    4718  20        		.byte	32
 541    4719  73        		.byte	115
 542    471A  65        		.byte	101
 543    471B  63        		.byte	99
 544    471C  74        		.byte	116
 545    471D  6F        		.byte	111
 546    471E  72        		.byte	114
 547    471F  00        		.byte	0
 548                    	L5653:
 549    4720  20        		.byte	32
 550    4721  2D        		.byte	45
 551    4722  20        		.byte	32
 552    4723  6E        		.byte	110
 553    4724  6F        		.byte	111
 554    4725  74        		.byte	116
 555    4726  20        		.byte	32
 556    4727  69        		.byte	105
 557    4728  6E        		.byte	110
 558    4729  69        		.byte	105
 559    472A  74        		.byte	116
 560    472B  69        		.byte	105
 561    472C  61        		.byte	97
 562    472D  6C        		.byte	108
 563    472E  69        		.byte	105
 564    472F  7A        		.byte	122
 565    4730  65        		.byte	101
 566    4731  64        		.byte	100
 567    4732  20        		.byte	32
 568    4733  6F        		.byte	111
 569    4734  72        		.byte	114
 570    4735  20        		.byte	32
 571    4736  69        		.byte	105
 572    4737  6E        		.byte	110
 573    4738  73        		.byte	115
 574    4739  65        		.byte	101
 575    473A  72        		.byte	114
 576    473B  74        		.byte	116
 577    473C  65        		.byte	101
 578    473D  64        		.byte	100
 579    473E  20        		.byte	32
 580    473F  6F        		.byte	111
 581    4740  72        		.byte	114
 582    4741  20        		.byte	32
 583    4742  66        		.byte	102
 584    4743  61        		.byte	97
 585    4744  75        		.byte	117
 586    4745  6C        		.byte	108
 587    4746  74        		.byte	116
 588    4747  79        		.byte	121
 589    4748  0A        		.byte	10
 590    4749  00        		.byte	0
 591                    	L5753:
 592    474A  20        		.byte	32
 593    474B  2D        		.byte	45
 594    474C  20        		.byte	32
 595    474D  6F        		.byte	111
 596    474E  6B        		.byte	107
 597    474F  0A        		.byte	10
 598    4750  00        		.byte	0
 599                    	L5063:
 600    4751  20        		.byte	32
 601    4752  2D        		.byte	45
 602    4753  20        		.byte	32
 603    4754  72        		.byte	114
 604    4755  65        		.byte	101
 605    4756  61        		.byte	97
 606    4757  64        		.byte	100
 607    4758  20        		.byte	32
 608    4759  65        		.byte	101
 609    475A  72        		.byte	114
 610    475B  72        		.byte	114
 611    475C  6F        		.byte	111
 612    475D  72        		.byte	114
 613    475E  0A        		.byte	10
 614    475F  00        		.byte	0
 615                    	L5163:
 616    4760  20        		.byte	32
 617    4761  73        		.byte	115
 618    4762  20        		.byte	32
 619    4763  2D        		.byte	45
 620    4764  20        		.byte	32
 621    4765  70        		.byte	112
 622    4766  72        		.byte	114
 623    4767  69        		.byte	105
 624    4768  6E        		.byte	110
 625    4769  74        		.byte	116
 626    476A  20        		.byte	32
 627    476B  53        		.byte	83
 628    476C  44        		.byte	68
 629    476D  20        		.byte	32
 630    476E  72        		.byte	114
 631    476F  65        		.byte	101
 632    4770  67        		.byte	103
 633    4771  69        		.byte	105
 634    4772  73        		.byte	115
 635    4773  74        		.byte	116
 636    4774  65        		.byte	101
 637    4775  72        		.byte	114
 638    4776  73        		.byte	115
 639    4777  0A        		.byte	10
 640    4778  00        		.byte	0
 641                    	L5263:
 642    4779  20        		.byte	32
 643    477A  74        		.byte	116
 644    477B  20        		.byte	32
 645    477C  2D        		.byte	45
 646    477D  20        		.byte	32
 647    477E  74        		.byte	116
 648    477F  65        		.byte	101
 649    4780  73        		.byte	115
 650    4781  74        		.byte	116
 651    4782  20        		.byte	32
 652    4783  69        		.byte	105
 653    4784  66        		.byte	102
 654    4785  20        		.byte	32
 655    4786  63        		.byte	99
 656    4787  61        		.byte	97
 657    4788  72        		.byte	114
 658    4789  64        		.byte	100
 659    478A  20        		.byte	32
 660    478B  69        		.byte	105
 661    478C  6E        		.byte	110
 662    478D  73        		.byte	115
 663    478E  65        		.byte	101
 664    478F  72        		.byte	114
 665    4790  74        		.byte	116
 666    4791  65        		.byte	101
 667    4792  64        		.byte	100
 668    4793  0A        		.byte	10
 669    4794  00        		.byte	0
 670                    	L5363:
 671    4795  20        		.byte	32
 672    4796  2D        		.byte	45
 673    4797  20        		.byte	32
 674    4798  6F        		.byte	111
 675    4799  6B        		.byte	107
 676    479A  0A        		.byte	10
 677    479B  00        		.byte	0
 678                    	L5463:
 679    479C  20        		.byte	32
 680    479D  2D        		.byte	45
 681    479E  20        		.byte	32
 682    479F  6E        		.byte	110
 683    47A0  6F        		.byte	111
 684    47A1  74        		.byte	116
 685    47A2  20        		.byte	32
 686    47A3  69        		.byte	105
 687    47A4  6E        		.byte	110
 688    47A5  69        		.byte	105
 689    47A6  74        		.byte	116
 690    47A7  69        		.byte	105
 691    47A8  61        		.byte	97
 692    47A9  6C        		.byte	108
 693    47AA  69        		.byte	105
 694    47AB  7A        		.byte	122
 695    47AC  65        		.byte	101
 696    47AD  64        		.byte	100
 697    47AE  20        		.byte	32
 698    47AF  6F        		.byte	111
 699    47B0  72        		.byte	114
 700    47B1  20        		.byte	32
 701    47B2  69        		.byte	105
 702    47B3  6E        		.byte	110
 703    47B4  73        		.byte	115
 704    47B5  65        		.byte	101
 705    47B6  72        		.byte	114
 706    47B7  74        		.byte	116
 707    47B8  65        		.byte	101
 708    47B9  64        		.byte	100
 709    47BA  20        		.byte	32
 710    47BB  6F        		.byte	111
 711    47BC  72        		.byte	114
 712    47BD  20        		.byte	32
 713    47BE  66        		.byte	102
 714    47BF  61        		.byte	97
 715    47C0  75        		.byte	117
 716    47C1  6C        		.byte	108
 717    47C2  74        		.byte	116
 718    47C3  79        		.byte	121
 719    47C4  0A        		.byte	10
 720    47C5  00        		.byte	0
 721                    	L5563:
 722    47C6  20        		.byte	32
 723    47C7  75        		.byte	117
 724    47C8  20        		.byte	32
 725    47C9  2D        		.byte	45
 726    47CA  20        		.byte	32
 727    47CB  75        		.byte	117
 728    47CC  70        		.byte	112
 729    47CD  6C        		.byte	108
 730    47CE  6F        		.byte	111
 731    47CF  61        		.byte	97
 732    47D0  64        		.byte	100
 733    47D1  20        		.byte	32
 734    47D2  77        		.byte	119
 735    47D3  69        		.byte	105
 736    47D4  74        		.byte	116
 737    47D5  68        		.byte	104
 738    47D6  20        		.byte	32
 739    47D7  58        		.byte	88
 740    47D8  6D        		.byte	109
 741    47D9  6F        		.byte	111
 742    47DA  64        		.byte	100
 743    47DB  65        		.byte	101
 744    47DC  6D        		.byte	109
 745    47DD  0A        		.byte	10
 746    47DE  00        		.byte	0
 747                    	L5663:
 748    47DF  43        		.byte	67
 749    47E0  6F        		.byte	111
 750    47E1  70        		.byte	112
 751    47E2  79        		.byte	121
 752    47E3  20        		.byte	32
 753    47E4  66        		.byte	102
 754    47E5  72        		.byte	114
 755    47E6  6F        		.byte	111
 756    47E7  6D        		.byte	109
 757    47E8  3A        		.byte	58
 758    47E9  20        		.byte	32
 759    47EA  30        		.byte	48
 760    47EB  78        		.byte	120
 761    47EC  25        		.byte	37
 762    47ED  30        		.byte	48
 763    47EE  34        		.byte	52
 764    47EF  78        		.byte	120
 765    47F0  2C        		.byte	44
 766    47F1  20        		.byte	32
 767    47F2  74        		.byte	116
 768    47F3  6F        		.byte	111
 769    47F4  3A        		.byte	58
 770    47F5  20        		.byte	32
 771    47F6  30        		.byte	48
 772    47F7  78        		.byte	120
 773    47F8  25        		.byte	37
 774    47F9  30        		.byte	48
 775    47FA  34        		.byte	52
 776    47FB  78        		.byte	120
 777    47FC  2C        		.byte	44
 778    47FD  20        		.byte	32
 779    47FE  73        		.byte	115
 780    47FF  69        		.byte	105
 781    4800  7A        		.byte	122
 782    4801  65        		.byte	101
 783    4802  3A        		.byte	58
 784    4803  20        		.byte	32
 785    4804  25        		.byte	37
 786    4805  64        		.byte	100
 787    4806  0A        		.byte	10
 788    4807  00        		.byte	0
 789                    	L5763:
 790    4808  20        		.byte	32
 791    4809  77        		.byte	119
 792    480A  20        		.byte	32
 793    480B  2D        		.byte	45
 794    480C  20        		.byte	32
 795    480D  77        		.byte	119
 796    480E  72        		.byte	114
 797    480F  69        		.byte	105
 798    4810  74        		.byte	116
 799    4811  65        		.byte	101
 800    4812  20        		.byte	32
 801    4813  73        		.byte	115
 802    4814  65        		.byte	101
 803    4815  63        		.byte	99
 804    4816  74        		.byte	116
 805    4817  6F        		.byte	111
 806    4818  72        		.byte	114
 807    4819  00        		.byte	0
 808                    	L5073:
 809    481A  20        		.byte	32
 810    481B  2D        		.byte	45
 811    481C  20        		.byte	32
 812    481D  6E        		.byte	110
 813    481E  6F        		.byte	111
 814    481F  74        		.byte	116
 815    4820  20        		.byte	32
 816    4821  69        		.byte	105
 817    4822  6E        		.byte	110
 818    4823  69        		.byte	105
 819    4824  74        		.byte	116
 820    4825  69        		.byte	105
 821    4826  61        		.byte	97
 822    4827  6C        		.byte	108
 823    4828  69        		.byte	105
 824    4829  7A        		.byte	122
 825    482A  65        		.byte	101
 826    482B  64        		.byte	100
 827    482C  20        		.byte	32
 828    482D  6F        		.byte	111
 829    482E  72        		.byte	114
 830    482F  20        		.byte	32
 831    4830  69        		.byte	105
 832    4831  6E        		.byte	110
 833    4832  73        		.byte	115
 834    4833  65        		.byte	101
 835    4834  72        		.byte	114
 836    4835  74        		.byte	116
 837    4836  65        		.byte	101
 838    4837  64        		.byte	100
 839    4838  20        		.byte	32
 840    4839  6F        		.byte	111
 841    483A  72        		.byte	114
 842    483B  20        		.byte	32
 843    483C  66        		.byte	102
 844    483D  61        		.byte	97
 845    483E  75        		.byte	117
 846    483F  6C        		.byte	108
 847    4840  74        		.byte	116
 848    4841  79        		.byte	121
 849    4842  0A        		.byte	10
 850    4843  00        		.byte	0
 851                    	L5173:
 852    4844  20        		.byte	32
 853    4845  2D        		.byte	45
 854    4846  20        		.byte	32
 855    4847  6F        		.byte	111
 856    4848  6B        		.byte	107
 857    4849  0A        		.byte	10
 858    484A  00        		.byte	0
 859                    	L5273:
 860    484B  20        		.byte	32
 861    484C  2D        		.byte	45
 862    484D  20        		.byte	32
 863    484E  77        		.byte	119
 864    484F  72        		.byte	114
 865    4850  69        		.byte	105
 866    4851  74        		.byte	116
 867    4852  65        		.byte	101
 868    4853  20        		.byte	32
 869    4854  65        		.byte	101
 870    4855  72        		.byte	114
 871    4856  72        		.byte	114
 872    4857  6F        		.byte	111
 873    4858  72        		.byte	114
 874    4859  0A        		.byte	10
 875    485A  00        		.byte	0
 876                    	L5373:
 877    485B  72        		.byte	114
 878    485C  65        		.byte	101
 879    485D  6C        		.byte	108
 880    485E  6F        		.byte	111
 881    485F  61        		.byte	97
 882    4860  64        		.byte	100
 883    4861  69        		.byte	105
 884    4862  6E        		.byte	110
 885    4863  67        		.byte	103
 886    4864  20        		.byte	32
 887    4865  6D        		.byte	109
 888    4866  6F        		.byte	111
 889    4867  6E        		.byte	110
 890    4868  69        		.byte	105
 891    4869  74        		.byte	116
 892    486A  6F        		.byte	111
 893    486B  72        		.byte	114
 894    486C  20        		.byte	32
 895    486D  66        		.byte	102
 896    486E  72        		.byte	114
 897    486F  6F        		.byte	111
 898    4870  6D        		.byte	109
 899    4871  20        		.byte	32
 900    4872  45        		.byte	69
 901    4873  50        		.byte	80
 902    4874  52        		.byte	82
 903    4875  4F        		.byte	79
 904    4876  4D        		.byte	77
 905    4877  0A        		.byte	10
 906    4878  00        		.byte	0
 907                    	L5473:
 908    4879  20        		.byte	32
 909    487A  69        		.byte	105
 910    487B  6E        		.byte	110
 911    487C  76        		.byte	118
 912    487D  61        		.byte	97
 913    487E  6C        		.byte	108
 914    487F  69        		.byte	105
 915    4880  64        		.byte	100
 916    4881  20        		.byte	32
 917    4882  63        		.byte	99
 918    4883  6F        		.byte	111
 919    4884  6D        		.byte	109
 920    4885  6D        		.byte	109
 921    4886  61        		.byte	97
 922    4887  6E        		.byte	110
 923    4888  64        		.byte	100
 924    4889  0A        		.byte	10
 925    488A  00        		.byte	0
 926                    	L1426:
 927    488B  0C        		.byte	12
 928    488C  00        		.byte	0
 929    488D  6C        		.byte	108
 930    488E  00        		.byte	0
 931    488F  E949      		.word	L1636
 932    4891  434E      		.word	L1117
 933    4893  C14C      		.word	L1666
 934    4895  434E      		.word	L1117
 935    4897  134D      		.word	L1176
 936    4899  434E      		.word	L1117
 937    489B  304D      		.word	L1276
 938    489D  824D      		.word	L1676
 939    489F  8E4D      		.word	L1776
 940    48A1  AD4D      		.word	L1207
 941    48A3  434E      		.word	L1117
 942    48A5  E84D      		.word	L1407
 943    48A7  00        		.byte	0
 944    48A8  00        		.byte	0
 945    48A9  05        		.byte	5
 946    48AA  00        		.byte	0
 947    48AB  374E      		.word	L1017
 948    48AD  0300      		.word	3
 949    48AF  1E49      		.word	L1626
 950    48B1  3F00      		.word	63
 951    48B3  9049      		.word	L1726
 952    48B5  6200      		.word	98
 953    48B7  9F49      		.word	L1036
 954    48B9  6400      		.word	100
 955    48BB  CA49      		.word	L1336
 956    48BD  6900      		.word	105
 957    48BF  434E      		.word	L1117
 958                    	; 1595  
 959                    	; 1596  /* Test init, read and partitions on SD card over the SPI interface,
 960                    	; 1597   * boot from SD card, upload with Xmodem
 961                    	; 1598   */
 962                    	; 1599  int main()
 963                    	; 1600      {
 964                    	_main:
 965    48C1  CD0000    		call	c.savs0
 966    48C4  21E2FF    		ld	hl,65506
 967    48C7  39        		add	hl,sp
 968    48C8  F9        		ld	sp,hl
 969                    	; 1601      char txtin[10];
 970                    	; 1602      int cmdin;
 971                    	; 1603      int idx;
 972                    	; 1604      int cmpidx;
 973                    	; 1605      unsigned char *cmpptr;
 974                    	; 1606      int inlength;
 975                    	; 1607      unsigned long blockno;
 976                    	; 1608  
 977                    	; 1609      blockno = 0;
 978    48C9  97        		sub	a
 979    48CA  DD77E2    		ld	(ix-30),a
 980    48CD  DD77E3    		ld	(ix-29),a
 981    48D0  DD77E4    		ld	(ix-28),a
 982    48D3  DD77E5    		ld	(ix-27),a
 983                    	; 1610      curblkno = 0;
 984                    	; 1611      curblkok = NO;
 985    48D6  210000    		ld	hl,0
 986                    	;    1  /*  z80sdbt.c Boot and SD card test program.
 987                    	;    2   *
 988                    	;    3   *  Boot code for my DIY Z80 Computer. This
 989                    	;    4   *  program is compiled with Whitesmiths/COSMIC
 990                    	;    5   *  C compiler for Z80.
 991                    	;    6   *
 992                    	;    7   *  Initializes the hardware and detects the
 993                    	;    8   *  presence and partitioning of an attached SD card.
 994                    	;    9   *
 995                    	;   10   *  You are free to use, modify, and redistribute
 996                    	;   11   *  this source code. No warranties are given.
 997                    	;   12   *  Hastily Cobbled Together 2021 and 2022
 998                    	;   13   *  by Hans-Ake Lund
 999                    	;   14   *
1000                    	;   15   */
1001                    	;   16  
1002                    	;   17  #include <std.h>
1003                    	;   18  #include "z80computer.h"
1004                    	;   19  #include "builddate.h"
1005                    	;   20  
1006                    	;   21  /* Program name and version */
1007                    	;   22  #define PRGNAME "z80sdbt "
1008                    	;   23  #define VERSION "version 0.8, "
1009                    	;   24  /* Address in high RAM where to copy uploader */
1010                    	;   25  #define UPLADDR 0xf000
1011                    	;   26  
1012                    	;   27  /* This code should be cleaned up when
1013                    	;   28     remaining functions are implemented
1014                    	;   29   */
1015                    	;   30  #define PARTZRO 0  /* Empty partition entry */
1016                    	;   31  #define PARTMBR 1  /* MBR partition */
1017                    	;   32  #define PARTEBR 2  /* EBR logical partition */
1018                    	;   33  #define PARTGPT 3  /* GPT partition */
1019                    	;   34  #define EBRCONT 20 /* EBR container partition in MBR */
1020                    	;   35  
1021                    	;   36  struct partentry
1022                    	;   37      {
1023                    	;   38      char partype;
1024                    	;   39      char dskletter;
1025                    	;   40      int bootable;
1026                    	;   41      unsigned long dskstart;
1027                    	;   42      unsigned long dskend;
1028                    	;   43      unsigned long dsksize;
1029                    	;   44      unsigned char dsktype[16];
1030                    	;   45      } dskmap[16];
1031                    	;   46  
1032                    	;   47  unsigned char dsksign[4]; /* MBR/EBR disk signature */
1033                    	;   48  
1034                    	;   49  /* Function prototypes */
1035                    	;   50  void sdmbrpart(unsigned long);
1036                    	;   51  
1037                    	;   52  /* External data */
1038                    	;   53  extern const char upload[];
1039                    	;   54  extern const int upload_size;
1040                    	;   55  
1041                    	;   56  /* RAM/EPROM probe */
1042                    	;   57  const int ramprobe = 0;
1043                    	;   58  int *rampptr;
1044                    	;   59  
1045                    	;   60  /* Response length in bytes
1046                    	;   61   */
1047                    	;   62  #define R1_LEN 1
1048                    	;   63  #define R3_LEN 5
1049                    	;   64  #define R7_LEN 5
1050                    	;   65  
1051                    	;   66  /* The SD card commands (5 bytes) and a CRC7 byte as the last byte.
1052                    	;   67   * (The CRC7 byte in the tables below are only for information,
1053                    	;   68   * it is calculated by the sdcommand routine.)
1054                    	;   69   */
1055                    	;   70  const unsigned char cmd0[] = {0x40, 0x00, 0x00, 0x00, 0x00, 0x95};
1056                    	;   71  const unsigned char cmd8[] = {0x48, 0x00, 0x00, 0x01, 0xaa, 0x87};
1057                    	;   72  const unsigned char cmd9[] = {0x49, 0x00, 0x00, 0x00, 0x00, 0xaf};
1058                    	;   73  const unsigned char cmd10[] = {0x4a, 0x00, 0x00, 0x00, 0x00, 0x1b};
1059                    	;   74  const unsigned char cmd16[] = {0x50, 0x00, 0x00, 0x02, 0x00, 0x15};
1060                    	;   75  const unsigned char cmd17[] = {0x51, 0x00, 0x00, 0x00, 0x00, 0x55};
1061                    	;   76  const unsigned char cmd24[] = {0x58, 0x00, 0x00, 0x00, 0x00, 0x6f};
1062                    	;   77  const unsigned char cmd55[] = {0x77, 0x00, 0x00, 0x00, 0x00, 0x65};
1063                    	;   78  const unsigned char cmd58[] = {0x7a, 0x00, 0x00, 0x00, 0x00, 0xfd};
1064                    	;   79  const unsigned char acmd41[] = {0x69, 0x40, 0x00, 0x01, 0xaa, 0x33};
1065                    	;   80  
1066                    	;   81  /* Partition identifiers
1067                    	;   82   */
1068                    	;   83  /* For GPT I have decided that a CP/M partition
1069                    	;   84   * has GUID: AC7176FD-8D55-4FFF-86A5-A36D6368D0CB
1070                    	;   85   */
1071                    	;   86  const unsigned char gptcpm[] =
1072                    	;   87      {
1073                    	;   88      0xfd, 0x76, 0x71, 0xac, 0x55, 0x8d, 0xff, 0x4f,
1074                    	;   89      0x86, 0xa5, 0xa3, 0x6d, 0x63, 0x68, 0xd0, 0xcb
1075                    	;   90      };
1076                    	;   91  /* For MBR/EBR the partition type for CP/M is 0x52
1077                    	;   92   * according to: https://en.wikipedia.org/wiki/Partition_type
1078                    	;   93   */
1079                    	;   94  const unsigned char mbrcpm = 0x52;    /* CP/M partition */
1080                    	;   95  const unsigned char mbrexcode = 0x5f; /* Z80 executable code partition */
1081                    	;   96  /* has a special format that */
1082                    	;   97  /* includes number of sectors to */
1083                    	;   98  /* load and a signature, TBD */
1084                    	;   99  
1085                    	;  100  /* Buffers
1086                    	;  101   */
1087                    	;  102  unsigned char sdrdbuf[512];  /* recieved data from the SD card */
1088                    	;  103  
1089                    	;  104  unsigned char ocrreg[4];     /* SD card OCR register */
1090                    	;  105  unsigned char cidreg[16];    /* SD card CID register */
1091                    	;  106  unsigned char csdreg[16];    /* SD card CSD register */
1092                    	;  107  unsigned long ebrrecs[4];    /* detected EBR records to process */
1093                    	;  108  int ebrrecidx; /* how many EBR records that are populated */
1094                    	;  109  unsigned long ebrnext; /* next chained ebr record */
1095                    	;  110  
1096                    	;  111  /* Variables
1097                    	;  112   */
1098                    	;  113  int curblkok;  /* if YES curblockno is read into buffer */
1099                    	;  114  int partdsk;   /* partition/disk number, 0 = disk A */
1100                    	;  115  int sdinitok;  /* SD card initialized and ready */
1101                    	;  116  int sdver2;    /* SD card version 2 if YES, version 1 if NO */
1102                    	;  117  unsigned long blkmult;   /* block address multiplier */
1103                    	;  118  unsigned long curblkno;  /* block in buffer if curblkok == YES */
1104                    	;  119  
1105                    	;  120  /* debug bool */
1106                    	;  121  int sdtestflg;
1107                    	;  122  
1108                    	;  123  /* CRC routines from:
1109                    	;  124   * https://github.com/LonelyWolf/stm32/blob/master/stm32l-dosfs/sdcard.c
1110                    	;  125   */
1111                    	;  126  
1112                    	;  127  /*
1113                    	;  128  // Calculate CRC7
1114                    	;  129  // It's a 7 bit CRC with polynomial x^7 + x^3 + 1
1115                    	;  130  // input:
1116                    	;  131  //   crcIn - the CRC before (0 for first step)
1117                    	;  132  //   data - byte for CRC calculation
1118                    	;  133  // return: the new CRC7
1119                    	;  134  */
1120                    	;  135  unsigned char CRC7_one(unsigned char crcIn, unsigned char data)
1121                    	;  136      {
1122                    	;  137      const unsigned char g = 0x89;
1123                    	;  138      unsigned char i;
1124                    	;  139  
1125                    	;  140      crcIn ^= data;
1126                    	;  141      for (i = 0; i < 8; i++)
1127                    	;  142          {
1128                    	;  143          if (crcIn & 0x80) crcIn ^= g;
1129                    	;  144          crcIn <<= 1;
1130                    	;  145          }
1131                    	;  146  
1132                    	;  147      return crcIn;
1133                    	;  148      }
1134                    	;  149  
1135                    	;  150  /*
1136                    	;  151  // Calculate CRC16 CCITT
1137                    	;  152  // It's a 16 bit CRC with polynomial x^16 + x^12 + x^5 + 1
1138                    	;  153  // input:
1139                    	;  154  //   crcIn - the CRC before (0 for rist step)
1140                    	;  155  //   data - byte for CRC calculation
1141                    	;  156  // return: the CRC16 value
1142                    	;  157  */
1143                    	;  158  unsigned int CRC16_one(unsigned int crcIn, unsigned char data)
1144                    	;  159      {
1145                    	;  160      crcIn  = (unsigned char)(crcIn >> 8)|(crcIn << 8);
1146                    	;  161      crcIn ^=  data;
1147                    	;  162      crcIn ^= (unsigned char)(crcIn & 0xff) >> 4;
1148                    	;  163      crcIn ^= (crcIn << 8) << 4;
1149                    	;  164      crcIn ^= ((crcIn & 0xff) << 4) << 1;
1150                    	;  165  
1151                    	;  166      return crcIn;
1152                    	;  167      }
1153                    	;  168  
1154                    	;  169  /* Send command to SD card and recieve answer.
1155                    	;  170   * A command is 5 bytes long and is followed by
1156                    	;  171   * a CRC7 checksum byte.
1157                    	;  172   * Returns a pointer to the response
1158                    	;  173   * or 0 if no response start bit found.
1159                    	;  174   */
1160                    	;  175  unsigned char *sdcommand(unsigned char *sdcmdp,
1161                    	;  176                           unsigned char *recbuf, int recbytes)
1162                    	;  177      {
1163                    	;  178      int searchn;  /* byte counter to search for response */
1164                    	;  179      int sdcbytes; /* byte counter for bytes to send */
1165                    	;  180      unsigned char *retptr; /* pointer used to store response */
1166                    	;  181      unsigned char rbyte;   /* recieved byte */
1167                    	;  182      unsigned char crc = 0; /* calculated CRC7 */
1168                    	;  183  
1169                    	;  184      /* send 8*2 clockpules */
1170                    	;  185      spiio(0xff);
1171                    	;  186      spiio(0xff);
1172                    	;  187      for (sdcbytes = 5; 0 < sdcbytes; sdcbytes--) /* send bytes */
1173                    	;  188          {
1174                    	;  189          crc = CRC7_one(crc, *sdcmdp);
1175                    	;  190          spiio(*sdcmdp++);
1176                    	;  191          }
1177                    	;  192      spiio(crc | 0x01);
1178                    	;  193      /* search for recieved byte with start bit
1179                    	;  194         for a maximum of 10 recieved bytes  */
1180                    	;  195      for (searchn = 10; 0 < searchn; searchn--)
1181                    	;  196          {
1182                    	;  197          rbyte = spiio(0xff);
1183                    	;  198          if ((rbyte & 0x80) == 0)
1184                    	;  199              break;
1185                    	;  200          }
1186                    	;  201      if (searchn == 0) /* no start bit found */
1187                    	;  202          return (NO);
1188                    	;  203      retptr = recbuf;
1189                    	;  204      *retptr++ = rbyte;
1190                    	;  205      for (; 1 < recbytes; recbytes--) /* recieve bytes */
1191                    	;  206          *retptr++ = spiio(0xff);
1192                    	;  207      return (recbuf);
1193                    	;  208      }
1194                    	;  209  
1195                    	;  210  /* Initialise SD card interface
1196                    	;  211   *
1197                    	;  212   * returns YES if ok and NO if not ok
1198                    	;  213   *
1199                    	;  214   * References:
1200                    	;  215   *   https://www.sdcard.org/downloads/pls/
1201                    	;  216   *      Physical Layer Simplified Specification version 8.0
1202                    	;  217   *
1203                    	;  218   * A nice flowchart how to initialize:
1204                    	;  219   *   https://www.totalphase.com/blog/2018/08/set-sdc-mmc-cards-spi-mode-verify-files-successfully-programmed/
1205                    	;  220   *
1206                    	;  221   */
1207                    	;  222  int sdinit()
1208                    	;  223      {
1209                    	;  224      int nbytes;  /* byte counter */
1210                    	;  225      int tries;   /* tries to get to active state or searching for data  */
1211                    	;  226      int wtloop;  /* timer loop when trying to enter active state */
1212                    	;  227      unsigned char cmdbuf[5];   /* buffer to build command in */
1213                    	;  228      unsigned char rstatbuf[5]; /* buffer to recieve status in */
1214                    	;  229      unsigned char *statptr;    /* pointer to returned status from SD command */
1215                    	;  230      unsigned char crc;         /* crc register for CID and CSD */
1216                    	;  231      unsigned char rbyte;       /* recieved byte */
1217                    	;  232      unsigned char *prtptr;     /* for debug printing */
1218                    	;  233  
1219                    	;  234      ledon();
1220                    	;  235      spideselect();
1221                    	;  236      sdinitok = NO;
1222                    	;  237  
1223                    	;  238      /* start to generate 9*8 clock pulses with not selected SD card */
1224                    	;  239      for (nbytes = 9; 0 < nbytes; nbytes--)
1225                    	;  240          spiio(0xff);
1226                    	;  241      if (sdtestflg)
1227                    	;  242          {
1228                    	;  243          printf("\nSent 8*8 (72) clock pulses, select not active\n");
1229                    	;  244          } /* sdtestflg */
1230                    	;  245      spiselect();
1231                    	;  246  
1232                    	;  247      /* CMD0: GO_IDLE_STATE */
1233                    	;  248      for (tries = 0; tries < 10; tries++)
1234                    	;  249          {
1235                    	;  250          memcpy(cmdbuf, cmd0, 5);
1236                    	;  251          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1237                    	;  252          if (sdtestflg)
1238                    	;  253              {
1239                    	;  254              if (!statptr)
1240                    	;  255                  printf("CMD0: no response\n");
1241                    	;  256              else
1242                    	;  257                  printf("CMD0: GO_IDLE_STATE, R1 response [%02x]\n", statptr[0]);
1243                    	;  258              } /* sdtestflg */
1244                    	;  259          if (!statptr)
1245                    	;  260              {
1246                    	;  261              spideselect();
1247                    	;  262              ledoff();
1248                    	;  263              return (NO);
1249                    	;  264              }
1250                    	;  265          if (statptr[0] == 0x01)
1251                    	;  266              break;
1252                    	;  267          for (wtloop = 0; wtloop < tries * 10; wtloop++)
1253                    	;  268              {
1254                    	;  269              /* wait loop, time increasing for each try */
1255                    	;  270              spiio(0xff);
1256                    	;  271              }
1257                    	;  272          }
1258                    	;  273  
1259                    	;  274      /* CMD8: SEND_IF_COND */
1260                    	;  275      memcpy(cmdbuf, cmd8, 5);
1261                    	;  276      statptr = sdcommand(cmdbuf, rstatbuf, R7_LEN);
1262                    	;  277      if (sdtestflg)
1263                    	;  278          {
1264                    	;  279          if (!statptr)
1265                    	;  280              printf("CMD8: no response\n");
1266                    	;  281          else
1267                    	;  282              {
1268                    	;  283              printf("CMD8: SEND_IF_COND, R7 response [%02x %02x %02x %02x %02x], ",
1269                    	;  284                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
1270                    	;  285              if (!(statptr[0] & 0xfe)) /* no error */
1271                    	;  286                  {
1272                    	;  287                  if (statptr[4] == 0xaa)
1273                    	;  288                      printf("echo back ok, ");
1274                    	;  289                  else
1275                    	;  290                      printf("invalid echo back\n");
1276                    	;  291                  }
1277                    	;  292              }
1278                    	;  293          } /* sdtestflg */
1279                    	;  294      if (!statptr || (statptr[0] & 0xfe)) /* if no answer or error */
1280                    	;  295          {
1281                    	;  296          sdver2 = NO;
1282                    	;  297          if (sdtestflg)
1283                    	;  298              {
1284                    	;  299              printf("probably SD ver. 1\n");
1285                    	;  300              } /* sdtestflg */
1286                    	;  301          }
1287                    	;  302      else
1288                    	;  303          {
1289                    	;  304          sdver2 = YES;
1290                    	;  305          if (statptr[4] != 0xaa) /* but invalid echo back */
1291                    	;  306              {
1292                    	;  307              spideselect();
1293                    	;  308              ledoff();
1294                    	;  309              return (NO);
1295                    	;  310              }
1296                    	;  311          if (sdtestflg)
1297                    	;  312              {
1298                    	;  313              printf("SD ver 2\n");
1299                    	;  314              } /* sdtestflg */
1300                    	;  315          }
1301                    	;  316  
1302                    	;  317      /* CMD55: APP_CMD followed by ACMD41: SEND_OP_COND until status is 0x00 */
1303                    	;  318      for (tries = 0; tries < 20; tries++)
1304                    	;  319          {
1305                    	;  320          memcpy(cmdbuf, cmd55, 5);
1306                    	;  321          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1307                    	;  322          if (sdtestflg)
1308                    	;  323              {
1309                    	;  324              if (!statptr)
1310                    	;  325                  printf("CMD55: no response\n");
1311                    	;  326              else
1312                    	;  327                  printf("CMD55: APP_CMD, R1 response [%02x]\n", statptr[0]);
1313                    	;  328              } /* sdtestflg */
1314                    	;  329          if (!statptr)
1315                    	;  330              {
1316                    	;  331              spideselect();
1317                    	;  332              ledoff();
1318                    	;  333              return (NO);
1319                    	;  334              }
1320                    	;  335          memcpy(cmdbuf, acmd41, 5);
1321                    	;  336          if (sdver2)
1322                    	;  337              cmdbuf[1] = 0x40;
1323                    	;  338          else
1324                    	;  339              cmdbuf[1] = 0x00;
1325                    	;  340          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1326                    	;  341          if (sdtestflg)
1327                    	;  342              {
1328                    	;  343              if (!statptr)
1329                    	;  344                  printf("ACMD41: no response\n");
1330                    	;  345              else
1331                    	;  346                  printf("ACMD41: SEND_OP_COND, R1 response [%02x]%s\n",
1332                    	;  347                         statptr[0], (statptr[0] == 0x00) ? " - ready" : "");
1333                    	;  348              } /* sdtestflg */
1334                    	;  349          if (!statptr)
1335                    	;  350              {
1336                    	;  351              spideselect();
1337                    	;  352              ledoff();
1338                    	;  353              return (NO);
1339                    	;  354              }
1340                    	;  355          if (statptr[0] == 0x00) /* now the SD card is ready */
1341                    	;  356              {
1342                    	;  357              break;
1343                    	;  358              }
1344                    	;  359          for (wtloop = 0; wtloop < tries * 10; wtloop++)
1345                    	;  360              {
1346                    	;  361              /* wait loop, time increasing for each try */
1347                    	;  362              spiio(0xff);
1348                    	;  363              }
1349                    	;  364          }
1350                    	;  365  
1351                    	;  366      /* CMD58: READ_OCR */
1352                    	;  367      /* According to the flow chart this should not work
1353                    	;  368         for SD ver. 1 but the response is ok anyway
1354                    	;  369         all tested SD cards  */
1355                    	;  370      memcpy(cmdbuf, cmd58, 5);
1356                    	;  371      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
1357                    	;  372      if (sdtestflg)
1358                    	;  373          {
1359                    	;  374          if (!statptr)
1360                    	;  375              printf("CMD58: no response\n");
1361                    	;  376          else
1362                    	;  377              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
1363                    	;  378                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
1364                    	;  379          } /* sdtestflg */
1365                    	;  380      if (!statptr)
1366                    	;  381          {
1367                    	;  382          spideselect();
1368                    	;  383          ledoff();
1369                    	;  384          return (NO);
1370                    	;  385          }
1371                    	;  386      memcpy(&ocrreg[0], &statptr[1], sizeof (ocrreg));
1372                    	;  387      blkmult = 1; /* assume block address */
1373                    	;  388      if (ocrreg[0] & 0x80)
1374                    	;  389          {
1375                    	;  390          /* SD Ver.2+ */
1376                    	;  391          if (!(ocrreg[0] & 0x40))
1377                    	;  392              {
1378                    	;  393              /* SD Ver.2+, Byte address */
1379                    	;  394              blkmult = 512;
1380                    	;  395              }
1381                    	;  396          }
1382                    	;  397  
1383                    	;  398      /* CMD 16: SET_BLOCKLEN, only if Byte addressing */
1384                    	;  399      if (blkmult == 512)
1385                    	;  400          {
1386                    	;  401          memcpy(cmdbuf, cmd16, 5);
1387                    	;  402          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1388                    	;  403          if (sdtestflg)
1389                    	;  404              {
1390                    	;  405              if (!statptr)
1391                    	;  406                  printf("CMD16: no response\n");
1392                    	;  407              else
1393                    	;  408                  printf("CMD16: SET_BLOCKLEN (to 512 bytes), R1 response [%02x]\n",
1394                    	;  409                         statptr[0]);
1395                    	;  410              } /* sdtestflg */
1396                    	;  411          if (!statptr)
1397                    	;  412              {
1398                    	;  413              spideselect();
1399                    	;  414              ledoff();
1400                    	;  415              return (NO);
1401                    	;  416              }
1402                    	;  417          }
1403                    	;  418      /* Register information:
1404                    	;  419       *   https://www.cameramemoryspeed.com/sd-memory-card-faq/reading-sd-card-cid-serial-psn-internal-numbers/
1405                    	;  420       */
1406                    	;  421  
1407                    	;  422      /* CMD10: SEND_CID */
1408                    	;  423      memcpy(cmdbuf, cmd10, 5);
1409                    	;  424      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1410                    	;  425      if (sdtestflg)
1411                    	;  426          {
1412                    	;  427          if (!statptr)
1413                    	;  428              printf("CMD10: no response\n");
1414                    	;  429          else
1415                    	;  430              printf("CMD10: SEND_CID, R1 response [%02x]\n", statptr[0]);
1416                    	;  431          } /* sdtestflg */
1417                    	;  432      if (!statptr)
1418                    	;  433          {
1419                    	;  434          spideselect();
1420                    	;  435          ledoff();
1421                    	;  436          return (NO);
1422                    	;  437          }
1423                    	;  438      /* looking for 0xfe that is the byte before data */
1424                    	;  439      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
1425                    	;  440          ;
1426                    	;  441      if (tries == 0) /* tried too many times */
1427                    	;  442          {
1428                    	;  443          if (sdtestflg)
1429                    	;  444              {
1430                    	;  445              printf("  No data found\n");
1431                    	;  446              } /* sdtestflg */
1432                    	;  447          spideselect();
1433                    	;  448          ledoff();
1434                    	;  449          return (NO);
1435                    	;  450          }
1436                    	;  451      else
1437                    	;  452          {
1438                    	;  453          crc = 0;
1439                    	;  454          for (nbytes = 0; nbytes < 15; nbytes++)
1440                    	;  455              {
1441                    	;  456              rbyte = spiio(0xff);
1442                    	;  457              cidreg[nbytes] = rbyte;
1443                    	;  458              crc = CRC7_one(crc, rbyte);
1444                    	;  459              }
1445                    	;  460          cidreg[15] = spiio(0xff);
1446                    	;  461          crc |= 0x01;
1447                    	;  462          /* some SD cards need additional clock pulses */
1448                    	;  463          for (nbytes = 9; 0 < nbytes; nbytes--)
1449                    	;  464              spiio(0xff);
1450                    	;  465          if (sdtestflg)
1451                    	;  466              {
1452                    	;  467              prtptr = &cidreg[0];
1453                    	;  468              printf("  CID: [");
1454                    	;  469              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
1455                    	;  470                  printf("%02x ", *prtptr);
1456                    	;  471              prtptr = &cidreg[0];
1457                    	;  472              printf("\b] |");
1458                    	;  473              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
1459                    	;  474                  {
1460                    	;  475                  if ((' ' <= *prtptr) && (*prtptr < 127))
1461                    	;  476                      putchar(*prtptr);
1462                    	;  477                  else
1463                    	;  478                      putchar('.');
1464                    	;  479                  }
1465                    	;  480              printf("|\n");
1466                    	;  481              if (crc == cidreg[15])
1467                    	;  482                  {
1468                    	;  483                  printf("CRC7 ok: [%02x]\n", crc);
1469                    	;  484                  }
1470                    	;  485              else
1471                    	;  486                  {
1472                    	;  487                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
1473                    	;  488                         crc, cidreg[15]);
1474                    	;  489                  /* could maybe return failure here */
1475                    	;  490                  }
1476                    	;  491              } /* sdtestflg */
1477                    	;  492          }
1478                    	;  493  
1479                    	;  494      /* CMD9: SEND_CSD */
1480                    	;  495      memcpy(cmdbuf, cmd9, 5);
1481                    	;  496      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1482                    	;  497      if (sdtestflg)
1483                    	;  498          {
1484                    	;  499          if (!statptr)
1485                    	;  500              printf("CMD9: no response\n");
1486                    	;  501          else
1487                    	;  502              printf("CMD9: SEND_CSD, R1 response [%02x]\n", statptr[0]);
1488                    	;  503          } /* sdtestflg */
1489                    	;  504      if (!statptr)
1490                    	;  505          {
1491                    	;  506          spideselect();
1492                    	;  507          ledoff();
1493                    	;  508          return (NO);
1494                    	;  509          }
1495                    	;  510      /* looking for 0xfe that is the byte before data */
1496                    	;  511      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
1497                    	;  512          ;
1498                    	;  513      if (tries == 0) /* tried too many times */
1499                    	;  514          {
1500                    	;  515          if (sdtestflg)
1501                    	;  516              {
1502                    	;  517              printf("  No data found\n");
1503                    	;  518              } /* sdtestflg */
1504                    	;  519          return (NO);
1505                    	;  520          }
1506                    	;  521      else
1507                    	;  522          {
1508                    	;  523          crc = 0;
1509                    	;  524          for (nbytes = 0; nbytes < 15; nbytes++)
1510                    	;  525              {
1511                    	;  526              rbyte = spiio(0xff);
1512                    	;  527              csdreg[nbytes] = rbyte;
1513                    	;  528              crc = CRC7_one(crc, rbyte);
1514                    	;  529              }
1515                    	;  530          csdreg[15] = spiio(0xff);
1516                    	;  531          crc |= 0x01;
1517                    	;  532          /* some SD cards need additional clock pulses */
1518                    	;  533          for (nbytes = 9; 0 < nbytes; nbytes--)
1519                    	;  534              spiio(0xff);
1520                    	;  535          if (sdtestflg)
1521                    	;  536              {
1522                    	;  537              prtptr = &csdreg[0];
1523                    	;  538              printf("  CSD: [");
1524                    	;  539              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
1525                    	;  540                  printf("%02x ", *prtptr);
1526                    	;  541              prtptr = &csdreg[0];
1527                    	;  542              printf("\b] |");
1528                    	;  543              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
1529                    	;  544                  {
1530                    	;  545                  if ((' ' <= *prtptr) && (*prtptr < 127))
1531                    	;  546                      putchar(*prtptr);
1532                    	;  547                  else
1533                    	;  548                      putchar('.');
1534                    	;  549                  }
1535                    	;  550              printf("|\n");
1536                    	;  551              if (crc == csdreg[15])
1537                    	;  552                  {
1538                    	;  553                  printf("CRC7 ok: [%02x]\n", crc);
1539                    	;  554                  }
1540                    	;  555              else
1541                    	;  556                  {
1542                    	;  557                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
1543                    	;  558                         crc, csdreg[15]);
1544                    	;  559                  /* could maybe return failure here */
1545                    	;  560                  }
1546                    	;  561              } /* sdtestflg */
1547                    	;  562          }
1548                    	;  563  
1549                    	;  564      for (nbytes = 9; 0 < nbytes; nbytes--)
1550                    	;  565          spiio(0xff);
1551                    	;  566      if (sdtestflg)
1552                    	;  567          {
1553                    	;  568          printf("Sent 9*8 (72) clock pulses, select active\n");
1554                    	;  569          } /* sdtestflg */
1555                    	;  570  
1556                    	;  571      sdinitok = YES;
1557                    	;  572  
1558                    	;  573      spideselect();
1559                    	;  574      ledoff();
1560                    	;  575  
1561                    	;  576      return (YES);
1562                    	;  577      }
1563                    	;  578  
1564                    	;  579  int sdprobe()
1565                    	;  580      {
1566                    	;  581      unsigned char cmdbuf[5];   /* buffer to build command in */
1567                    	;  582      unsigned char rstatbuf[5]; /* buffer to recieve status in */
1568                    	;  583      unsigned char *statptr;    /* pointer to returned status from SD command */
1569                    	;  584      int nbytes;  /* byte counter */
1570                    	;  585      int allzero = YES;
1571                    	;  586  
1572                    	;  587      ledon();
1573                    	;  588      spiselect();
1574                    	;  589  
1575                    	;  590      /* CMD58: READ_OCR */
1576                    	;  591      memcpy(cmdbuf, cmd58, 5);
1577                    	;  592      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
1578                    	;  593      for (nbytes = 0; nbytes < 5; nbytes++)
1579                    	;  594          {
1580                    	;  595          if (statptr[nbytes] != 0)
1581                    	;  596              allzero = NO;
1582                    	;  597          }
1583                    	;  598      if (sdtestflg)
1584                    	;  599          {
1585                    	;  600          if (!statptr)
1586                    	;  601              printf("CMD58: no response\n");
1587                    	;  602          else
1588                    	;  603              {
1589                    	;  604              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
1590                    	;  605                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
1591                    	;  606              if (allzero)
1592                    	;  607                  printf("SD card not inserted or not initialized\n");
1593                    	;  608              }
1594                    	;  609          } /* sdtestflg */
1595                    	;  610      if (!statptr || allzero)
1596                    	;  611          {
1597                    	;  612          sdinitok = NO;
1598                    	;  613          spideselect();
1599                    	;  614          ledoff();
1600                    	;  615          return (NO);
1601                    	;  616          }
1602                    	;  617  
1603                    	;  618      spideselect();
1604                    	;  619      ledoff();
1605                    	;  620  
1606                    	;  621      return (YES);
1607                    	;  622      }
1608                    	;  623  
1609                    	;  624  /* print OCR, CID and CSD registers*/
1610                    	;  625  void sdprtreg()
1611                    	;  626      {
1612                    	;  627      unsigned int n;
1613                    	;  628      unsigned int csize;
1614                    	;  629      unsigned long devsize;
1615                    	;  630      unsigned long capacity;
1616                    	;  631  
1617                    	;  632      if (!sdinitok)
1618                    	;  633          {
1619                    	;  634          printf("SD card not initialized\n");
1620                    	;  635          return;
1621                    	;  636          }
1622                    	;  637      printf("SD card information:");
1623                    	;  638      if (ocrreg[0] & 0x80)
1624                    	;  639          {
1625                    	;  640          if (ocrreg[0] & 0x40)
1626                    	;  641              printf("  SD card ver. 2+, Block address\n");
1627                    	;  642          else
1628                    	;  643              {
1629                    	;  644              if (sdver2)
1630                    	;  645                  printf("  SD card ver. 2+, Byte address\n");
1631                    	;  646              else
1632                    	;  647                  printf("  SD card ver. 1, Byte address\n");
1633                    	;  648              }
1634                    	;  649          }
1635                    	;  650      printf("  Manufacturer ID: 0x%02x, ", cidreg[0]);
1636                    	;  651      printf("OEM ID: %.2s, ", &cidreg[1]);
1637                    	;  652      printf("Product name: %.5s\n", &cidreg[3]);
1638                    	;  653      printf("  Product revision: %d.%d, ",
1639                    	;  654             (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
1640                    	;  655      printf("Serial number: %lu\n",
1641                    	;  656             (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
1642                    	;  657      printf("  Manufacturing date: %d-%d, ",
1643                    	;  658             2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
1644                    	;  659      if ((csdreg[0] & 0xc0) == 0x00) /* CSD version 1 */
1645                    	;  660          {
1646                    	;  661          n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
1647                    	;  662          csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
1648                    	;  663                  ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
1649                    	;  664          capacity = (unsigned long) csize << (n-10);
1650                    	;  665          printf("Device capacity: %lu MByte\n", capacity >> 10);
1651                    	;  666          }
1652                    	;  667      if ((csdreg[0] & 0xc0) == 0x40) /* CSD version 2 */
1653                    	;  668          {
1654                    	;  669          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
1655                    	;  670                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
1656                    	;  671          capacity = devsize << 9;
1657                    	;  672          printf("Device capacity: %lu MByte\n", capacity >> 10);
1658                    	;  673          }
1659                    	;  674      if ((csdreg[0] & 0xc0) == 0x80) /* CSD version 3 */
1660                    	;  675          {
1661                    	;  676          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
1662                    	;  677                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
1663                    	;  678          capacity = devsize << 9;
1664                    	;  679          printf("Device ultra capacity: %lu MByte\n", capacity >> 10);
1665                    	;  680          }
1666                    	;  681  
1667                    	;  682      if (sdtestflg)
1668                    	;  683          {
1669                    	;  684  
1670                    	;  685          printf("--------------------------------------\n");
1671                    	;  686          printf("OCR register:\n");
1672                    	;  687          if (ocrreg[2] & 0x80)
1673                    	;  688              printf("2.7-2.8V (bit 15) ");
1674                    	;  689          if (ocrreg[1] & 0x01)
1675                    	;  690              printf("2.8-2.9V (bit 16) ");
1676                    	;  691          if (ocrreg[1] & 0x02)
1677                    	;  692              printf("2.9-3.0V (bit 17) ");
1678                    	;  693          if (ocrreg[1] & 0x04)
1679                    	;  694              printf("3.0-3.1V (bit 18) \n");
1680                    	;  695          if (ocrreg[1] & 0x08)
1681                    	;  696              printf("3.1-3.2V (bit 19) ");
1682                    	;  697          if (ocrreg[1] & 0x10)
1683                    	;  698              printf("3.2-3.3V (bit 20) ");
1684                    	;  699          if (ocrreg[1] & 0x20)
1685                    	;  700              printf("3.3-3.4V (bit 21) ");
1686                    	;  701          if (ocrreg[1] & 0x40)
1687                    	;  702              printf("3.4-3.5V (bit 22) \n");
1688                    	;  703          if (ocrreg[1] & 0x80)
1689                    	;  704              printf("3.5-3.6V (bit 23) \n");
1690                    	;  705          if (ocrreg[0] & 0x01)
1691                    	;  706              printf("Switching to 1.8V Accepted (S18A) (bit 24) set ");
1692                    	;  707          if (ocrreg[0] & 0x08)
1693                    	;  708              printf("Over 2TB support Status (CO2T) (bit 27) set\n");
1694                    	;  709          if (ocrreg[0] & 0x20)
1695                    	;  710              printf("UHS-II Card Status (bit 29) set ");
1696                    	;  711          if (ocrreg[0] & 0x80)
1697                    	;  712              {
1698                    	;  713              if (ocrreg[0] & 0x40)
1699                    	;  714                  {
1700                    	;  715                  printf("Card Capacity Status (CCS) (bit 30) set\n");
1701                    	;  716                  printf("  SD Ver.2+, Block address");
1702                    	;  717                  }
1703                    	;  718              else
1704                    	;  719                  {
1705                    	;  720                  printf("Card Capacity Status (CCS) (bit 30) not set\n");
1706                    	;  721                  if (sdver2)
1707                    	;  722                      printf("  SD Ver.2+, Byte address");
1708                    	;  723                  else
1709                    	;  724                      printf("  SD Ver.1, Byte address");
1710                    	;  725                  }
1711                    	;  726              printf("\nCard power up status bit (busy) (bit 31) set\n");
1712                    	;  727              }
1713                    	;  728          else
1714                    	;  729              {
1715                    	;  730              printf("\nCard power up status bit (busy) (bit 31) not set.\n");
1716                    	;  731              printf("  This bit is not set if the card has not finished the power up routine.\n");
1717                    	;  732              }
1718                    	;  733          printf("--------------------------------------\n");
1719                    	;  734          printf("CID register:\n");
1720                    	;  735          printf("MID: 0x%02x, ", cidreg[0]);
1721                    	;  736          printf("OID: %.2s, ", &cidreg[1]);
1722                    	;  737          printf("PNM: %.5s, ", &cidreg[3]);
1723                    	;  738          printf("PRV: %d.%d, ",
1724                    	;  739                 (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
1725                    	;  740          printf("PSN: %lu, ",
1726                    	;  741                 (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
1727                    	;  742          printf("MDT: %d-%d\n",
1728                    	;  743                 2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
1729                    	;  744          printf("--------------------------------------\n");
1730                    	;  745          printf("CSD register:\n");
1731                    	;  746          if ((csdreg[0] & 0xc0) == 0x00)
1732                    	;  747              {
1733                    	;  748              printf("CSD Version 1.0, Standard Capacity\n");
1734                    	;  749              n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
1735                    	;  750              csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
1736                    	;  751                      ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
1737                    	;  752              capacity = (unsigned long) csize << (n-10);
1738                    	;  753              printf(" Device capacity: %lu KByte, %lu MByte\n",
1739                    	;  754                     capacity, capacity >> 10);
1740                    	;  755              }
1741                    	;  756          if ((csdreg[0] & 0xc0) == 0x40)
1742                    	;  757              {
1743                    	;  758              printf("CSD Version 2.0, High Capacity and Extended Capacity\n");
1744                    	;  759              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
1745                    	;  760                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
1746                    	;  761              capacity = devsize << 9;
1747                    	;  762              printf(" Device capacity: %lu KByte, %lu MByte\n",
1748                    	;  763                     capacity, capacity >> 10);
1749                    	;  764              }
1750                    	;  765          if ((csdreg[0] & 0xc0) == 0x80)
1751                    	;  766              {
1752                    	;  767              printf("CSD Version 3.0, Ultra Capacity (SDUC)\n");
1753                    	;  768              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
1754                    	;  769                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
1755                    	;  770              capacity = devsize << 9;
1756                    	;  771              printf(" Device capacity: %lu KByte, %lu MByte\n",
1757                    	;  772                     capacity, capacity >> 10);
1758                    	;  773              }
1759                    	;  774          printf("--------------------------------------\n");
1760                    	;  775  
1761                    	;  776          } /* sdtestflg */ /* SDTEST */
1762                    	;  777  
1763                    	;  778      }
1764                    	;  779  
1765                    	;  780  /* Read data block of 512 bytes to buffer
1766                    	;  781   * Returns YES if ok or NO if error
1767                    	;  782   */
1768                    	;  783  int sdread(unsigned char *rdbuf, unsigned long rdblkno)
1769                    	;  784      {
1770                    	;  785      unsigned char *statptr;
1771                    	;  786      unsigned char rbyte;
1772                    	;  787      unsigned char cmdbuf[5];   /* buffer to build command in */
1773                    	;  788      unsigned char rstatbuf[5]; /* buffer to recieve status in */
1774                    	;  789      int nbytes;
1775                    	;  790      int tries;
1776                    	;  791      unsigned long blktoread;
1777                    	;  792      unsigned int rxcrc16;
1778                    	;  793      unsigned int calcrc16;
1779                    	;  794  
1780                    	;  795      ledon();
1781                    	;  796      spiselect();
1782                    	;  797  
1783                    	;  798      if (!sdinitok)
1784                    	;  799          {
1785                    	;  800          if (sdtestflg)
1786                    	;  801              {
1787                    	;  802              printf("SD card not initialized\n");
1788                    	;  803              } /* sdtestflg */
1789                    	;  804          spideselect();
1790                    	;  805          ledoff();
1791                    	;  806          return (NO);
1792                    	;  807          }
1793                    	;  808  
1794                    	;  809      /* CMD17: READ_SINGLE_BLOCK */
1795                    	;  810      /* Insert block # into command */
1796                    	;  811      memcpy(cmdbuf, cmd17, 5);
1797                    	;  812      blktoread = blkmult * rdblkno;
1798                    	;  813      cmdbuf[4] = blktoread & 0xff;
1799                    	;  814      blktoread = blktoread >> 8;
1800                    	;  815      cmdbuf[3] = blktoread & 0xff;
1801                    	;  816      blktoread = blktoread >> 8;
1802                    	;  817      cmdbuf[2] = blktoread & 0xff;
1803                    	;  818      blktoread = blktoread >> 8;
1804                    	;  819      cmdbuf[1] = blktoread & 0xff;
1805                    	;  820  
1806                    	;  821      if (sdtestflg)
1807                    	;  822          {
1808                    	;  823          printf("\nCMD17: READ_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
1809                    	;  824                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
1810                    	;  825          } /* sdtestflg */
1811                    	;  826      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1812                    	;  827      if (sdtestflg)
1813                    	;  828          {
1814                    	;  829          printf("CMD17 R1 response [%02x]\n", statptr[0]);
1815                    	;  830          } /* sdtestflg */
1816                    	;  831      if (statptr[0])
1817                    	;  832          {
1818                    	;  833          if (sdtestflg)
1819                    	;  834              {
1820                    	;  835              printf("  could not read block\n");
1821                    	;  836              } /* sdtestflg */
1822                    	;  837          spideselect();
1823                    	;  838          ledoff();
1824                    	;  839          return (NO);
1825                    	;  840          }
1826                    	;  841      /* looking for 0xfe that is the byte before data */
1827                    	;  842      for (tries = 80; (0 < tries) && ((rbyte = spiio(0xff)) != 0xfe); tries--)
1828                    	;  843          {
1829                    	;  844          if ((rbyte & 0xe0) == 0x00)
1830                    	;  845              {
1831                    	;  846              /* If a read operation fails and the card cannot provide
1832                    	;  847                 the required data, it will send a data error token instead
1833                    	;  848               */
1834                    	;  849              if (sdtestflg)
1835                    	;  850                  {
1836                    	;  851                  printf("  read error: [%02x]\n", rbyte);
1837                    	;  852                  } /* sdtestflg */
1838                    	;  853              spideselect();
1839                    	;  854              ledoff();
1840                    	;  855              return (NO);
1841                    	;  856              }
1842                    	;  857          }
1843                    	;  858      if (tries == 0) /* tried too many times */
1844                    	;  859          {
1845                    	;  860          if (sdtestflg)
1846                    	;  861              {
1847                    	;  862              printf("  no data found\n");
1848                    	;  863              } /* sdtestflg */
1849                    	;  864          spideselect();
1850                    	;  865          ledoff();
1851                    	;  866          return (NO);
1852                    	;  867          }
1853                    	;  868      else
1854                    	;  869          {
1855                    	;  870          calcrc16 = 0;
1856                    	;  871          for (nbytes = 0; nbytes < 512; nbytes++)
1857                    	;  872              {
1858                    	;  873              rbyte = spiio(0xff);
1859                    	;  874              calcrc16 = CRC16_one(calcrc16, rbyte);
1860                    	;  875              rdbuf[nbytes] = rbyte;
1861                    	;  876              }
1862                    	;  877          rxcrc16 = spiio(0xff) << 8;
1863                    	;  878          rxcrc16 += spiio(0xff);
1864                    	;  879  
1865                    	;  880          if (sdtestflg)
1866                    	;  881              {
1867                    	;  882              printf("  read data block %ld:\n", rdblkno);
1868                    	;  883              } /* sdtestflg */
1869                    	;  884          if (rxcrc16 != calcrc16)
1870                    	;  885              {
1871                    	;  886              if (sdtestflg)
1872                    	;  887                  {
1873                    	;  888                  printf("  CRC16 error, recieved: 0x%04x, calc: 0x%04hi\n",
1874                    	;  889                         rxcrc16, calcrc16);
1875                    	;  890                  } /* sdtestflg */
1876                    	;  891              spideselect();
1877                    	;  892              ledoff();
1878                    	;  893              return (NO);
1879                    	;  894              }
1880                    	;  895          }
1881                    	;  896      spideselect();
1882                    	;  897      ledoff();
1883                    	;  898      return (YES);
1884                    	;  899      }
1885                    	;  900  
1886                    	;  901  /* Write data block of 512 bytes from buffer
1887                    	;  902   * Returns YES if ok or NO if error
1888                    	;  903   */
1889                    	;  904  int sdwrite(unsigned char *wrbuf, unsigned long wrblkno)
1890                    	;  905      {
1891                    	;  906      unsigned char *statptr;
1892                    	;  907      unsigned char rbyte;
1893                    	;  908      unsigned char tbyte;
1894                    	;  909      unsigned char cmdbuf[5];   /* buffer to build command in */
1895                    	;  910      unsigned char rstatbuf[5]; /* buffer to recieve status in */
1896                    	;  911      int nbytes;
1897                    	;  912      int tries;
1898                    	;  913      unsigned long blktowrite;
1899                    	;  914      unsigned int calcrc16;
1900                    	;  915  
1901                    	;  916      ledon();
1902                    	;  917      spiselect();
1903                    	;  918  
1904                    	;  919      if (!sdinitok)
1905                    	;  920          {
1906                    	;  921          if (sdtestflg)
1907                    	;  922              {
1908                    	;  923              printf("SD card not initialized\n");
1909                    	;  924              } /* sdtestflg */
1910                    	;  925          spideselect();
1911                    	;  926          ledoff();
1912                    	;  927          return (NO);
1913                    	;  928          }
1914                    	;  929  
1915                    	;  930      if (sdtestflg)
1916                    	;  931          {
1917                    	;  932          printf("  write data block %ld:\n", wrblkno);
1918                    	;  933          } /* sdtestflg */
1919                    	;  934      /* CMD24: WRITE_SINGLE_BLOCK */
1920                    	;  935      /* Insert block # into command */
1921                    	;  936      memcpy(cmdbuf, cmd24, 5);
1922                    	;  937      blktowrite = blkmult * wrblkno;
1923                    	;  938      cmdbuf[4] = blktowrite & 0xff;
1924                    	;  939      blktowrite = blktowrite >> 8;
1925                    	;  940      cmdbuf[3] = blktowrite & 0xff;
1926                    	;  941      blktowrite = blktowrite >> 8;
1927                    	;  942      cmdbuf[2] = blktowrite & 0xff;
1928                    	;  943      blktowrite = blktowrite >> 8;
1929                    	;  944      cmdbuf[1] = blktowrite & 0xff;
1930                    	;  945  
1931                    	;  946      if (sdtestflg)
1932                    	;  947          {
1933                    	;  948          printf("\nCMD24: WRITE_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
1934                    	;  949                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
1935                    	;  950          } /* sdtestflg */
1936                    	;  951      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
1937                    	;  952      if (sdtestflg)
1938                    	;  953          {
1939                    	;  954          printf("CMD24 R1 response [%02x]\n", statptr[0]);
1940                    	;  955          } /* sdtestflg */
1941                    	;  956      if (statptr[0])
1942                    	;  957          {
1943                    	;  958          if (sdtestflg)
1944                    	;  959              {
1945                    	;  960              printf("  could not write block\n");
1946                    	;  961              } /* sdtestflg */
1947                    	;  962          spideselect();
1948                    	;  963          ledoff();
1949                    	;  964          return (NO);
1950                    	;  965          }
1951                    	;  966      /* send 0xfe, the byte before data */
1952                    	;  967      spiio(0xfe);
1953                    	;  968      /* initialize crc and send block */
1954                    	;  969      calcrc16 = 0;
1955                    	;  970      for (nbytes = 0; nbytes < 512; nbytes++)
1956                    	;  971          {
1957                    	;  972          tbyte = wrbuf[nbytes];
1958                    	;  973          spiio(tbyte);
1959                    	;  974          calcrc16 = CRC16_one(calcrc16, tbyte);
1960                    	;  975          }
1961                    	;  976      spiio((calcrc16 >> 8) & 0xff);
1962                    	;  977      spiio(calcrc16 & 0xff);
1963                    	;  978  
1964                    	;  979      /* check data resposnse */
1965                    	;  980      for (tries = 20;
1966                    	;  981              0 < tries && (((rbyte = spiio(0xff)) & 0x11) != 0x01);
1967                    	;  982              tries--)
1968                    	;  983          ;
1969                    	;  984      if (tries == 0)
1970                    	;  985          {
1971                    	;  986          if (sdtestflg)
1972                    	;  987              {
1973                    	;  988              printf("No data response\n");
1974                    	;  989              } /* sdtestflg */
1975                    	;  990          spideselect();
1976                    	;  991          ledoff();
1977                    	;  992          return (NO);
1978                    	;  993          }
1979                    	;  994      else
1980                    	;  995          {
1981                    	;  996          if (sdtestflg)
1982                    	;  997              {
1983                    	;  998              printf("Data response [%02x]", 0x1f & rbyte);
1984                    	;  999              } /* sdtestflg */
1985                    	; 1000          if ((0x1f & rbyte) == 0x05)
1986                    	; 1001              {
1987                    	; 1002              if (sdtestflg)
1988                    	; 1003                  {
1989                    	; 1004                  printf(", data accepted\n");
1990                    	; 1005                  } /* sdtestflg */
1991                    	; 1006              for (nbytes = 9; 0 < nbytes; nbytes--)
1992                    	; 1007                  spiio(0xff);
1993                    	; 1008              if (sdtestflg)
1994                    	; 1009                  {
1995                    	; 1010                  printf("Sent 9*8 (72) clock pulses, select active\n");
1996                    	; 1011                  } /* sdtestflg */
1997                    	; 1012              spideselect();
1998                    	; 1013              ledoff();
1999                    	; 1014              return (YES);
2000                    	; 1015              }
2001                    	; 1016          else
2002                    	; 1017              {
2003                    	; 1018              if (sdtestflg)
2004                    	; 1019                  {
2005                    	; 1020                  printf(", data not accepted\n");
2006                    	; 1021                  } /* sdtestflg */
2007                    	; 1022              spideselect();
2008                    	; 1023              ledoff();
2009                    	; 1024              return (NO);
2010                    	; 1025              }
2011                    	; 1026          }
2012                    	; 1027      }
2013                    	; 1028  
2014                    	; 1029  /* Print data in 512 byte buffer */
2015                    	; 1030  void sddatprt(unsigned char *prtbuf)
2016                    	; 1031      {
2017                    	; 1032      /* Variables used for "pretty-print" */
2018                    	; 1033      int allzero, dmpline, dotprted, lastallz, nbytes;
2019                    	; 1034      unsigned char *prtptr;
2020                    	; 1035  
2021                    	; 1036      prtptr = prtbuf;
2022                    	; 1037      dotprted = NO;
2023                    	; 1038      lastallz = NO;
2024                    	; 1039      for (dmpline = 0; dmpline < 32; dmpline++)
2025                    	; 1040          {
2026                    	; 1041          /* test if all 16 bytes are 0x00 */
2027                    	; 1042          allzero = YES;
2028                    	; 1043          for (nbytes = 0; nbytes < 16; nbytes++)
2029                    	; 1044              {
2030                    	; 1045              if (prtptr[nbytes] != 0)
2031                    	; 1046                  allzero = NO;
2032                    	; 1047              }
2033                    	; 1048          if (lastallz && allzero)
2034                    	; 1049              {
2035                    	; 1050              if (!dotprted)
2036                    	; 1051                  {
2037                    	; 1052                  printf("*\n");
2038                    	; 1053                  dotprted = YES;
2039                    	; 1054                  }
2040                    	; 1055              }
2041                    	; 1056          else
2042                    	; 1057              {
2043                    	; 1058              dotprted = NO;
2044                    	; 1059              /* print offset */
2045                    	; 1060              printf("%04x ", dmpline * 16);
2046                    	; 1061              /* print 16 bytes in hex */
2047                    	; 1062              for (nbytes = 0; nbytes < 16; nbytes++)
2048                    	; 1063                  printf("%02x ", prtptr[nbytes]);
2049                    	; 1064              /* print these bytes in ASCII if printable */
2050                    	; 1065              printf(" |");
2051                    	; 1066              for (nbytes = 0; nbytes < 16; nbytes++)
2052                    	; 1067                  {
2053                    	; 1068                  if ((' ' <= prtptr[nbytes]) && (prtptr[nbytes] < 127))
2054                    	; 1069                      putchar(prtptr[nbytes]);
2055                    	; 1070                  else
2056                    	; 1071                      putchar('.');
2057                    	; 1072                  }
2058                    	; 1073              printf("|\n");
2059                    	; 1074              }
2060                    	; 1075          prtptr += 16;
2061                    	; 1076          lastallz = allzero;
2062                    	; 1077          }
2063                    	; 1078      }
2064                    	; 1079  
2065                    	; 1080  /* Print GUID (mixed endian format)
2066                    	; 1081   */
2067                    	; 1082  void prtguid(unsigned char *guidptr)
2068                    	; 1083      {
2069                    	; 1084      int index;
2070                    	; 1085  
2071                    	; 1086      printf("%02x%02x%02x%02x-", guidptr[3], guidptr[2], guidptr[1], guidptr[0]);
2072                    	; 1087      printf("%02x%02x-", guidptr[5], guidptr[4]);
2073                    	; 1088      printf("%02x%02x-", guidptr[7], guidptr[6]);
2074                    	; 1089      printf("%02x%02x-", guidptr[8], guidptr[9]);
2075                    	; 1090      printf("%02x%02x%02x%02x%02x%02x",
2076                    	; 1091             guidptr[10], guidptr[11], guidptr[12], guidptr[13], guidptr[14], guidptr[15]);
2077                    	; 1092      }
2078                    	; 1093  
2079                    	; 1094  /* Analyze and print GPT entry
2080                    	; 1095   */
2081                    	; 1096  int prtgptent(unsigned int entryno)
2082                    	; 1097      {
2083                    	; 1098      int index;
2084                    	; 1099      int entryidx;
2085                    	; 1100      int hasname;
2086                    	; 1101      unsigned int block;
2087                    	; 1102      unsigned char *rxdata;
2088                    	; 1103      unsigned char *entryptr;
2089                    	; 1104      unsigned char tstzero = 0;
2090                    	; 1105      unsigned long flba;
2091                    	; 1106      unsigned long llba;
2092                    	; 1107  
2093                    	; 1108      block = 2 + (entryno / 4);
2094                    	; 1109      if ((curblkno != block) || !curblkok)
2095                    	; 1110          {
2096                    	; 1111          if (!sdread(sdrdbuf, block))
2097                    	; 1112              {
2098                    	; 1113              if (sdtestflg)
2099                    	; 1114                  {
2100                    	; 1115                  printf("Can't read GPT entry block\n");
2101                    	; 1116                  return (NO);
2102                    	; 1117                  } /* sdtestflg */
2103                    	; 1118              }
2104                    	; 1119          curblkno = block;
2105                    	; 1120          curblkok = YES;
2106                    	; 1121          }
2107                    	; 1122      rxdata = sdrdbuf;
2108                    	; 1123      entryptr = rxdata + (128 * (entryno % 4));
2109                    	; 1124      for (index = 0; index < 16; index++)
2110                    	; 1125          tstzero |= entryptr[index];
2111                    	; 1126      if (sdtestflg)
2112                    	; 1127          {
2113                    	; 1128          printf("GPT partition entry %d:", entryno + 1);
2114                    	; 1129          } /* sdtestflg */
2115                    	; 1130      if (!tstzero)
2116                    	; 1131          {
2117                    	; 1132          if (sdtestflg)
2118                    	; 1133              {
2119                    	; 1134              printf(" Not used entry\n");
2120                    	; 1135              } /* sdtestflg */
2121                    	; 1136          return (NO);
2122                    	; 1137          }
2123                    	; 1138      if (sdtestflg)
2124                    	; 1139          {
2125                    	; 1140          printf("\n  Partition type GUID: ");
2126                    	; 1141          prtguid(entryptr);
2127                    	; 1142          printf("\n  [");
2128                    	; 1143          for (index = 0; index < 16; index++)
2129                    	; 1144              printf("%02x ", entryptr[index]);
2130                    	; 1145          printf("\b]");
2131                    	; 1146          printf("\n  Unique partition GUID: ");
2132                    	; 1147          prtguid(entryptr + 16);
2133                    	; 1148          printf("\n  [");
2134                    	; 1149          for (index = 0; index < 16; index++)
2135                    	; 1150              printf("%02x ", (entryptr + 16)[index]);
2136                    	; 1151          printf("\b]");
2137                    	; 1152          printf("\n  First LBA: ");
2138                    	; 1153          /* lower 32 bits of LBA should be sufficient (I hope) */
2139                    	; 1154          } /* sdtestflg */
2140                    	; 1155      flba = (unsigned long)entryptr[32] + ((unsigned long)entryptr[33] << 8) +
2141                    	; 1156             ((unsigned long)entryptr[34] << 16) + ((unsigned long)entryptr[35] << 24);
2142                    	; 1157      if (sdtestflg)
2143                    	; 1158          {
2144                    	; 1159          printf("%lu", flba);
2145                    	; 1160          printf(" [");
2146                    	; 1161          for (index = 32; index < (32 + 8); index++)
2147                    	; 1162              printf("%02x ", entryptr[index]);
2148                    	; 1163          printf("\b]");
2149                    	; 1164          printf("\n  Last LBA: ");
2150                    	; 1165          } /* sdtestflg */
2151                    	; 1166      /* lower 32 bits of LBA should be sufficient (I hope) */
2152                    	; 1167      llba = (unsigned long)entryptr[40] + ((unsigned long)entryptr[41] << 8) +
2153                    	; 1168             ((unsigned long)entryptr[42] << 16) + ((unsigned long)entryptr[43] << 24);
2154                    	; 1169  
2155                    	; 1170      if (entryptr[48] & 0x04)
2156                    	; 1171          dskmap[partdsk].bootable = YES;
2157                    	; 1172      dskmap[partdsk].partype = PARTGPT;
2158                    	; 1173      dskmap[partdsk].dskletter = 'A' + partdsk;
2159                    	; 1174      dskmap[partdsk].dskstart = flba;
2160                    	; 1175      dskmap[partdsk].dskend = llba;
2161                    	; 1176      dskmap[partdsk].dsksize = llba - flba + 1;
2162                    	; 1177      memcpy(dskmap[partdsk].dsktype, entryptr, 16);
2163                    	; 1178      partdsk++;
2164                    	; 1179  
2165                    	; 1180      if (sdtestflg)
2166                    	; 1181          {
2167                    	; 1182          printf("%lu, size %lu MByte", llba, (llba - flba) >> 11);
2168                    	; 1183          printf(" [");
2169                    	; 1184          for (index = 40; index < (40 + 8); index++)
2170                    	; 1185              printf("%02x ", entryptr[index]);
2171                    	; 1186          printf("\b]");
2172                    	; 1187          printf("\n  Attribute flags: [");
2173                    	; 1188          /* bits 0 - 2 and 60 - 63 should be decoded */
2174                    	; 1189          for (index = 0; index < 8; index++)
2175                    	; 1190              {
2176                    	; 1191              entryidx = index + 48;
2177                    	; 1192              printf("%02x ", entryptr[entryidx]);
2178                    	; 1193              }
2179                    	; 1194          printf("\b]\n  Partition name:  ");
2180                    	; 1195          } /* sdtestflg */
2181                    	; 1196      /* partition name is in UTF-16LE code units */
2182                    	; 1197      hasname = NO;
2183                    	; 1198      for (index = 0; index < 72; index += 2)
2184                    	; 1199          {
2185                    	; 1200          entryidx = index + 56;
2186                    	; 1201          if ((entryptr[entryidx] | entryptr[entryidx + 1]) == 0)
2187                    	; 1202              break;
2188                    	; 1203          if (sdtestflg)
2189                    	; 1204              {
2190                    	; 1205              if ((' ' <= entryptr[entryidx]) && (entryptr[entryidx] < 127))
2191                    	; 1206                  putchar(entryptr[entryidx]);
2192                    	; 1207              else
2193                    	; 1208                  putchar('.');
2194                    	; 1209              } /* sdtestflg */
2195                    	; 1210          hasname = YES;
2196                    	; 1211          }
2197                    	; 1212      if (sdtestflg)
2198                    	; 1213          {
2199                    	; 1214          if (!hasname)
2200                    	; 1215              printf("name field empty");
2201                    	; 1216          printf("\n");
2202                    	; 1217          printf("   [");
2203                    	; 1218          for (index = 0; index < 72; index++)
2204                    	; 1219              {
2205                    	; 1220              if (((index & 0xf) == 0) && (index != 0))
2206                    	; 1221                  printf("\n    ");
2207                    	; 1222              entryidx = index + 56;
2208                    	; 1223              printf("%02x ", entryptr[entryidx]);
2209                    	; 1224              }
2210                    	; 1225          printf("\b]\n");
2211                    	; 1226          } /* sdtestflg */
2212                    	; 1227      return (YES);
2213                    	; 1228      }
2214                    	; 1229  
2215                    	; 1230  /* Analyze and print GPT header
2216                    	; 1231   */
2217                    	; 1232  void sdgpthdr(unsigned long block)
2218                    	; 1233      {
2219                    	; 1234      int index;
2220                    	; 1235      unsigned int partno;
2221                    	; 1236      unsigned char *rxdata;
2222                    	; 1237      unsigned long entries;
2223                    	; 1238  
2224                    	; 1239      if (sdtestflg)
2225                    	; 1240          {
2226                    	; 1241          printf("GPT header\n");
2227                    	; 1242          } /* sdtestflg */
2228                    	; 1243      if (!sdread(sdrdbuf, block))
2229                    	; 1244          {
2230                    	; 1245          if (sdtestflg)
2231                    	; 1246              {
2232                    	; 1247              printf("Can't read GPT partition table header\n");
2233                    	; 1248              } /* sdtestflg */
2234                    	; 1249          return;
2235                    	; 1250          }
2236                    	; 1251      curblkno = block;
2237                    	; 1252      curblkok = YES;
2238                    	; 1253  
2239                    	; 1254      rxdata = sdrdbuf;
2240                    	; 1255      if (sdtestflg)
2241                    	; 1256          {
2242                    	; 1257          printf("  Signature: %.8s\n", &rxdata[0]);
2243                    	; 1258          printf("  Revision: %d.%d [%02x %02x %02x %02x]\n",
2244                    	; 1259                 (int)rxdata[8] * ((int)rxdata[9] << 8),
2245                    	; 1260                 (int)rxdata[10] + ((int)rxdata[11] << 8),
2246                    	; 1261                 rxdata[8], rxdata[9], rxdata[10], rxdata[11]);
2247                    	; 1262          entries = (unsigned long)rxdata[80] + ((unsigned long)rxdata[81] << 8) +
2248                    	; 1263                    ((unsigned long)rxdata[82] << 16) + ((unsigned long)rxdata[83] << 24);
2249                    	; 1264          printf("  Number of partition entries: %lu (may be actual or maximum)\n", entries);
2250                    	; 1265          } /* sdtestflg */
2251                    	; 1266      for (partno = 0; (partno < 16) && (partdsk < 16); partno++)
2252                    	; 1267          {
2253                    	; 1268          if (!prtgptent(partno))
2254                    	; 1269              {
2255                    	; 1270              if (!sdtestflg)
2256                    	; 1271                  {
2257                    	; 1272                  /* go through all entries if compiled as test program */
2258                    	; 1273                  return;
2259                    	; 1274                  } /* sdtestflg */
2260                    	; 1275              }
2261                    	; 1276          }
2262                    	; 1277      if (sdtestflg)
2263                    	; 1278          {
2264                    	; 1279          printf("First 16 GPT entries scanned\n");
2265                    	; 1280          } /* sdtestflg */
2266                    	; 1281      }
2267                    	; 1282  
2268                    	; 1283  /* Analyze and print MBR partition entry
2269                    	; 1284   * Returns:
2270                    	; 1285   *    -1 if errror - should not happen
2271                    	; 1286   *     0 if not used entry
2272                    	; 1287   *     1 if MBR entry
2273                    	; 1288   *     2 if EBR entry
2274                    	; 1289   *     3 if GTP entry
2275                    	; 1290   */
2276                    	; 1291  int sdmbrentry(unsigned char *partptr)
2277                    	; 1292      {
2278                    	; 1293      int index;
2279                    	; 1294      int parttype;
2280                    	; 1295      unsigned long lbastart;
2281                    	; 1296      unsigned long lbasize;
2282                    	; 1297  
2283                    	; 1298      parttype = PARTMBR;
2284                    	; 1299      if (!partptr[4])
2285                    	; 1300          {
2286                    	; 1301          if (sdtestflg)
2287                    	; 1302              {
2288                    	; 1303              printf("Not used entry\n");
2289                    	; 1304              } /* sdtestflg */
2290                    	; 1305          return (PARTZRO);
2291                    	; 1306          }
2292                    	; 1307      if (sdtestflg)
2293                    	; 1308          {
2294                    	; 1309          printf("Boot indicator: 0x%02x, System ID: 0x%02x\n",
2295                    	; 1310                 partptr[0], partptr[4]);
2296                    	; 1311  
2297                    	; 1312          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f))
2298                    	; 1313              {
2299                    	; 1314              printf("  Extended partition entry\n");
2300                    	; 1315              }
2301                    	; 1316          if (partptr[0] & 0x01)
2302                    	; 1317              {
2303                    	; 1318              printf("  Unofficial 48 bit LBA Proposed MBR Format, no CHS\n");
2304                    	; 1319              /* this is however discussed
2305                    	; 1320                 https://wiki.osdev.org/Partition_Table#.22Unofficial.22_48_bit_LBA_Proposed_MBR_Format
2306                    	; 1321              */
2307                    	; 1322              }
2308                    	; 1323          else
2309                    	; 1324              {
2310                    	; 1325              printf("  begin CHS: 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
2311                    	; 1326                     partptr[1], partptr[2], partptr[3],
2312                    	; 1327                     ((partptr[2] & 0xc0) >> 2) + partptr[3],
2313                    	; 1328                     partptr[1],
2314                    	; 1329                     partptr[2] & 0x3f);
2315                    	; 1330              printf("  end CHS 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
2316                    	; 1331                     partptr[5], partptr[6], partptr[7],
2317                    	; 1332                     ((partptr[6] & 0xc0) >> 2) + partptr[7],
2318                    	; 1333                     partptr[5],
2319                    	; 1334                     partptr[6] & 0x3f);
2320                    	; 1335              }
2321                    	; 1336          } /* sdtestflg */
2322                    	; 1337      /* not showing high 16 bits if 48 bit LBA */
2323                    	; 1338      lbastart = (unsigned long)partptr[8] +
2324                    	; 1339                 ((unsigned long)partptr[9] << 8) +
2325                    	; 1340                 ((unsigned long)partptr[10] << 16) +
2326                    	; 1341                 ((unsigned long)partptr[11] << 24);
2327                    	; 1342      lbasize = (unsigned long)partptr[12] +
2328                    	; 1343                ((unsigned long)partptr[13] << 8) +
2329                    	; 1344                ((unsigned long)partptr[14] << 16) +
2330                    	; 1345                ((unsigned long)partptr[15] << 24);
2331                    	; 1346  
2332                    	; 1347      if (!(partptr[4] == 0xee)) /* not pointing to a GPT partition */
2333                    	; 1348          {
2334                    	; 1349          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f)) /* EBR partition */
2335                    	; 1350              {
2336                    	; 1351              parttype = PARTEBR;
2337                    	; 1352              if (curblkno == 0) /* points to EBR in the MBR */
2338                    	; 1353                  {
2339                    	; 1354                  ebrnext = 0;
2340                    	; 1355                  dskmap[partdsk].partype = EBRCONT;
2341                    	; 1356                  dskmap[partdsk].dskletter = 'A' + partdsk;
2342                    	; 1357                  dskmap[partdsk].dskstart = lbastart;
2343                    	; 1358                  dskmap[partdsk].dskend = lbastart + lbasize - 1;
2344                    	; 1359                  dskmap[partdsk].dsksize = lbasize;
2345                    	; 1360                  dskmap[partdsk].dsktype[0] = partptr[4];
2346                    	; 1361                  partdsk++;
2347                    	; 1362                  ebrrecs[ebrrecidx++] = lbastart; /* save to handle later */
2348                    	; 1363                  }
2349                    	; 1364              else
2350                    	; 1365                  {
2351                    	; 1366                  ebrnext = curblkno + lbastart;
2352                    	; 1367                  }
2353                    	; 1368              }
2354                    	; 1369          else
2355                    	; 1370              {
2356                    	; 1371              if (0 < lbasize) /* one more ugly hack to avoid empty partitions */
2357                    	; 1372                  {
2358                    	; 1373                  if (partptr[0] & 0x80)
2359                    	; 1374                      dskmap[partdsk].bootable = YES;
2360                    	; 1375                  if (curblkno == 0)
2361                    	; 1376                      dskmap[partdsk].partype = PARTMBR;
2362                    	; 1377                  else
2363                    	; 1378                      dskmap[partdsk].partype = PARTEBR;
2364                    	; 1379                  dskmap[partdsk].dskletter = 'A' + partdsk;
2365                    	; 1380                  dskmap[partdsk].dskstart = curblkno + lbastart;
2366                    	; 1381                  dskmap[partdsk].dskend = curblkno + lbastart + lbasize - 1;
2367                    	; 1382                  dskmap[partdsk].dsksize = lbasize;
2368                    	; 1383                  dskmap[partdsk].dsktype[0] = partptr[4];
2369                    	; 1384                  partdsk++;
2370                    	; 1385                  }
2371                    	; 1386              }
2372                    	; 1387          }
2373                    	; 1388  
2374                    	; 1389      if (sdtestflg)
2375                    	; 1390          {
2376                    	; 1391          printf("  partition start LBA: %lu [%08lx]\n",
2377                    	; 1392                 curblkno + lbastart, curblkno + lbastart);
2378                    	; 1393          printf("  partition size LBA: %lu [%08lx], %lu MByte\n",
2379                    	; 1394                 lbasize, lbasize, lbasize >> 11);
2380                    	; 1395          } /* sdtestflg */
2381                    	; 1396      if (partptr[4] == 0xee) /* GPT partitions */
2382                    	; 1397          {
2383                    	; 1398          parttype = PARTGPT;
2384                    	; 1399          if (sdtestflg)
2385                    	; 1400              {
2386                    	; 1401              printf("GTP partitions\n");
2387                    	; 1402              } /* sdtestflg */
2388                    	; 1403          sdgpthdr(lbastart); /* handle GTP partitions */
2389                    	; 1404          /* re-read MBR on sector 0
2390                    	; 1405             This is probably not needed as there
2391                    	; 1406             is only one entry (the first one)
2392                    	; 1407             in the MBR when using GPT */
2393                    	; 1408          if (sdread(sdrdbuf, 0))
2394                    	; 1409              {
2395                    	; 1410              curblkno = 0;
2396                    	; 1411              curblkok = YES;
2397                    	; 1412              }
2398                    	; 1413          else
2399                    	; 1414              {
2400                    	; 1415              if (sdtestflg)
2401                    	; 1416                  {
2402                    	; 1417                  printf("  can't read MBR on sector 0\n");
2403                    	; 1418                  } /* sdtestflg */
2404                    	; 1419              return(-1);
2405                    	; 1420              }
2406                    	; 1421          }
2407                    	; 1422      return (parttype);
2408                    	; 1423      }
2409                    	; 1424  
2410                    	; 1425  /* Read and analyze MBR/EBR partition sector block
2411                    	; 1426   * and go through and print partition entries.
2412                    	; 1427   */
2413                    	; 1428  void sdmbrpart(unsigned long sector)
2414                    	; 1429      {
2415                    	; 1430      int partidx;  /* partition index 1 - 4 */
2416                    	; 1431      int cpartidx; /* chain partition index 1 - 4 */
2417                    	; 1432      int chainidx;
2418                    	; 1433      int enttype;
2419                    	; 1434      unsigned char *entp; /* pointer to partition entry */
2420                    	; 1435      char *mbrebr;
2421                    	; 1436  
2422                    	; 1437      if (sdtestflg)
2423                    	; 1438          {
2424                    	; 1439          if (sector == 0) /* if sector 0 it is MBR else it is EBR */
2425                    	; 1440              mbrebr = "MBR";
2426                    	; 1441          else
2427                    	; 1442              mbrebr = "EBR";
2428                    	; 1443          printf("Read %s from sector %lu\n", mbrebr, sector);
2429                    	; 1444          } /* sdtestflg */
2430                    	; 1445      if (sdread(sdrdbuf, sector))
2431                    	; 1446          {
2432                    	; 1447          curblkno = sector;
2433                    	; 1448          curblkok = YES;
2434                    	; 1449          }
2435                    	; 1450      else
2436                    	; 1451          {
2437                    	; 1452          if (sdtestflg)
2438                    	; 1453              {
2439                    	; 1454              printf("  can't read %s sector %lu\n", mbrebr, sector);
2440                    	; 1455              } /* sdtestflg */
2441                    	; 1456          return;
2442                    	; 1457          }
2443                    	; 1458      if (!((sdrdbuf[0x1fe] == 0x55) && (sdrdbuf[0x1ff] == 0xaa)))
2444                    	; 1459          {
2445                    	; 1460          if (sdtestflg)
2446                    	; 1461              {
2447                    	; 1462              printf("  no %s boot signature found\n", mbrebr);
2448                    	; 1463              } /* sdtestflg */
2449                    	; 1464          return;
2450                    	; 1465          }
2451                    	; 1466      if (curblkno == 0)
2452                    	; 1467          {
2453                    	; 1468          memcpy(dsksign, &sdrdbuf[0x1b8], sizeof dsksign);
2454                    	; 1469          if (sdtestflg)
2455                    	; 1470              {
2456                    	; 1471  
2457                    	; 1472              printf("  disk identifier: 0x%02x%02x%02x%02x\n",
2458                    	; 1473                     dsksign[3], dsksign[2], dsksign[1], dsksign[0]);
2459                    	; 1474              } /* sdtestflg */
2460                    	; 1475          }
2461                    	; 1476      /* go through MBR partition entries until first empty */
2462                    	; 1477      /* !!as the MBR entry routine is called recusively a way is
2463                    	; 1478         needed to read sector 0 when going back to MBR if
2464                    	; 1479         there is a primary partition entry after an EBR entry!! */
2465                    	; 1480      entp = &sdrdbuf[0x01be] ;
2466                    	; 1481      for (partidx = 1; (partidx <= 4) && (partdsk < 16); partidx++, entp += 16)
2467                    	; 1482          {
2468                    	; 1483          if (sdtestflg)
2469                    	; 1484              {
2470                    	; 1485              printf("%s partition entry %d: ", mbrebr, partidx);
2471                    	; 1486              } /* sdtestflg */
2472                    	; 1487          enttype = sdmbrentry(entp);
2473                    	; 1488          if (enttype == -1) /* read error */
2474                    	; 1489                   return;
2475                    	; 1490          else if (enttype == PARTZRO)
2476                    	; 1491              {
2477                    	; 1492              if (!sdtestflg)
2478                    	; 1493                  {
2479                    	; 1494                  /* if compiled as test program show also empty partitions */
2480                    	; 1495                  break;
2481                    	; 1496                  } /* sdtestflg */
2482                    	; 1497              }
2483                    	; 1498          }
2484                    	; 1499      /* now handle the previously saved EBR partition sectors */
2485                    	; 1500      for (partidx = 0; (partidx < ebrrecidx) && (partdsk < 16); partidx++)
2486                    	; 1501          {
2487                    	; 1502          if (sdread(sdrdbuf, ebrrecs[partidx]))
2488                    	; 1503              {
2489                    	; 1504              curblkno = ebrrecs[partidx];
2490                    	; 1505              curblkok = YES;
2491                    	; 1506              }
2492                    	; 1507          else
2493                    	; 1508              {
2494                    	; 1509              if (sdtestflg)
2495                    	; 1510                  {
2496                    	; 1511                  printf("  can't read %s sector %lu\n", mbrebr, sector);
2497                    	; 1512                  } /* sdtestflg */
2498                    	; 1513              return;
2499                    	; 1514              }
2500                    	; 1515          entp = &sdrdbuf[0x01be] ;
2501                    	; 1516          for (partidx = 1; (partidx <= 4) && (partdsk < 16); partidx++, entp += 16)
2502                    	; 1517              {
2503                    	; 1518              if (sdtestflg)
2504                    	; 1519                  {
2505                    	; 1520                  printf("EBR partition entry %d: ", partidx);
2506                    	; 1521                  } /* sdtestflg */
2507                    	; 1522              enttype = sdmbrentry(entp);
2508                    	; 1523              if (enttype == -1) /* read error */
2509                    	; 1524                   return;
2510                    	; 1525              else if (enttype == PARTZRO) /* empty partition entry */
2511                    	; 1526                  {
2512                    	; 1527                  if (sdtestflg)
2513                    	; 1528                      {
2514                    	; 1529                      /* if compiled as test program show also empty partitions */
2515                    	; 1530                      printf("Empty partition entry\n");
2516                    	; 1531                      } /* sdtestflg */
2517                    	; 1532                  else
2518                    	; 1533                      break;
2519                    	; 1534                  }
2520                    	; 1535              else if (enttype == PARTEBR) /* next chained EBR */
2521                    	; 1536                  {
2522                    	; 1537                  if (sdtestflg)
2523                    	; 1538                      {
2524                    	; 1539                      printf("EBR chain\n");
2525                    	; 1540                      } /* sdtestflg */
2526                    	; 1541                  /* follow the EBR chain */
2527                    	; 1542                  for (chainidx = 0;
2528                    	; 1543                      ebrnext && (chainidx < 16) && (partdsk < 16);
2529                    	; 1544                      chainidx++)
2530                    	; 1545                      {
2531                    	; 1546                      /* ugly hack to stop reading the same sector */
2532                    	; 1547                      if (ebrnext == curblkno)
2533                    	; 1548                           break;
2534                    	; 1549                      if (sdread(sdrdbuf, ebrnext))
2535                    	; 1550                          {
2536                    	; 1551                          curblkno = ebrnext;
2537                    	; 1552                          curblkok = YES;
2538                    	; 1553                          }
2539                    	; 1554                      else
2540                    	; 1555                          {
2541                    	; 1556                          if (sdtestflg)
2542                    	; 1557                              {
2543                    	; 1558                              printf("  can't read %s sector %lu\n", mbrebr, sector);
2544                    	; 1559                              } /* sdtestflg */
2545                    	; 1560                          return;
2546                    	; 1561                          }
2547                    	; 1562                      entp = &sdrdbuf[0x01be] ;
2548                    	; 1563                      for (cpartidx = 1;
2549                    	; 1564                          (cpartidx <= 4) && (partdsk < 16);
2550                    	; 1565                          cpartidx++, entp += 16)
2551                    	; 1566                          {
2552                    	; 1567                          if (sdtestflg)
2553                    	; 1568                              {
2554                    	; 1569                              printf("EBR chained  partition entry %d: ",
2555                    	; 1570                                   cpartidx);
2556                    	; 1571                              } /* sdtestflg */
2557                    	; 1572                          enttype = sdmbrentry(entp);
2558                    	; 1573                          if (enttype == -1) /* read error */
2559                    	; 1574                              return;
2560                    	; 1575                          }
2561                    	; 1576                      }
2562                    	; 1577                  }
2563                    	; 1578              }
2564                    	; 1579          }
2565                    	; 1580      }
2566                    	; 1581  
2567                    	; 1582  /* Executing in RAM or EPROM
2568                    	; 1583   */
2569                    	; 1584  void execin()
2570                    	; 1585      {
2571                    	; 1586      printf(", executing in: ");
2572                    	; 1587      rampptr = &ramprobe;
2573                    	; 1588      *rampptr = 1; /* try to change const */
2574                    	; 1589      if (ramprobe)
2575                    	; 1590          printf("RAM\n");
2576                    	; 1591      else
2577                    	; 1592          printf("EPROM\n");
2578                    	; 1593      *rampptr = 0;
2579                    	; 1594      }
2580                    	; 1595  
2581                    	; 1596  /* Test init, read and partitions on SD card over the SPI interface,
2582                    	; 1597   * boot from SD card, upload with Xmodem
2583                    	; 1598   */
2584                    	; 1599  int main()
2585                    	; 1600      {
2586                    	; 1601      char txtin[10];
2587                    	; 1602      int cmdin;
2588                    	; 1603      int idx;
2589                    	; 1604      int cmpidx;
2590                    	; 1605      unsigned char *cmpptr;
2591                    	; 1606      int inlength;
2592                    	; 1607      unsigned long blockno;
2593                    	; 1608  
2594                    	; 1609      blockno = 0;
2595                    	; 1610      curblkno = 0;
2596    48D9  320200    		ld	(_curblkno),a
2597    48DC  320300    		ld	(_curblkno+1),a
2598    48DF  320400    		ld	(_curblkno+2),a
2599    48E2  320500    		ld	(_curblkno+3),a
2600    48E5  221000    		ld	(_curblkok),hl
2601                    	; 1611      curblkok = NO;
2602                    	; 1612      sdinitok = NO; /* SD card not initialized yet */
2603    48E8  210000    		ld	hl,0
2604    48EB  220C00    		ld	(_sdinitok),hl
2605                    	; 1613  
2606                    	; 1614      printf(PRGNAME);
2607    48EE  21FE42    		ld	hl,L5172
2608    48F1  CD0000    		call	_printf
2609                    	; 1615      printf(VERSION);
2610    48F4  210743    		ld	hl,L5272
2611    48F7  CD0000    		call	_printf
2612                    	; 1616      printf(builddate);
2613    48FA  210000    		ld	hl,_builddate
2614    48FD  CD0000    		call	_printf
2615                    	; 1617      execin();
2616    4900  CDCF42    		call	_execin
2617                    	L1226:
2618                    	; 1618      while (YES) /* forever (until Ctrl-C) */
2619                    	; 1619          {
2620                    	; 1620          printf("cmd (? for help): ");
2621    4903  211543    		ld	hl,L5372
2622    4906  CD0000    		call	_printf
2623                    	; 1621  
2624                    	; 1622          cmdin = getchar();
2625    4909  CD0000    		call	_getchar
2626    490C  DD71EE    		ld	(ix-18),c
2627    490F  DD70EF    		ld	(ix-17),b
2628                    	; 1623          switch (cmdin)
2629    4912  DD4EEE    		ld	c,(ix-18)
2630    4915  DD46EF    		ld	b,(ix-17)
2631    4918  218B48    		ld	hl,L1426
2632    491B  C30000    		jp	c.jtab
2633                    	L1626:
2634                    	; 1624              {
2635                    	; 1625              case '?':
2636                    	; 1626                  printf(" ? - help\n");
2637    491E  212843    		ld	hl,L5472
2638    4921  CD0000    		call	_printf
2639                    	; 1627                  printf(PRGNAME);
2640    4924  213343    		ld	hl,L5572
2641    4927  CD0000    		call	_printf
2642                    	; 1628                  printf(VERSION);
2643    492A  213C43    		ld	hl,L5672
2644    492D  CD0000    		call	_printf
2645                    	; 1629                  printf(builddate);
2646    4930  210000    		ld	hl,_builddate
2647    4933  CD0000    		call	_printf
2648                    	; 1630                  execin();
2649    4936  CDCF42    		call	_execin
2650                    	; 1631                  printf("Commands:\n");
2651    4939  214A43    		ld	hl,L5772
2652    493C  CD0000    		call	_printf
2653                    	; 1632                  printf("  ? - help\n");
2654    493F  215543    		ld	hl,L5003
2655    4942  CD0000    		call	_printf
2656                    	; 1633                  printf("  b - boot from SD card\n");
2657    4945  216143    		ld	hl,L5103
2658    4948  CD0000    		call	_printf
2659                    	; 1634                  printf("  d - debug on/off\n");
2660    494B  217A43    		ld	hl,L5203
2661    494E  CD0000    		call	_printf
2662                    	; 1635                  printf("  i - initialize SD card\n");
2663    4951  218E43    		ld	hl,L5303
2664    4954  CD0000    		call	_printf
2665                    	; 1636                  printf("  l - print SD card partition layout\n");
2666    4957  21A843    		ld	hl,L5403
2667    495A  CD0000    		call	_printf
2668                    	; 1637                  printf("  n - set/show sector #N to read/write\n");
2669    495D  21CE43    		ld	hl,L5503
2670    4960  CD0000    		call	_printf
2671                    	; 1638                  printf("  p - print sector last read/to write\n");
2672    4963  21F643    		ld	hl,L5603
2673    4966  CD0000    		call	_printf
2674                    	; 1639                  printf("  r - read sector #N\n");
2675    4969  211D44    		ld	hl,L5703
2676    496C  CD0000    		call	_printf
2677                    	; 1640                  printf("  s - print SD registers\n");
2678    496F  213344    		ld	hl,L5013
2679    4972  CD0000    		call	_printf
2680                    	; 1641                  printf("  t - test probe SD card\n");
2681    4975  214D44    		ld	hl,L5113
2682    4978  CD0000    		call	_printf
2683                    	; 1642                  printf("  u - upload code with Xmodem to RAM address 0x0000\n");
2684    497B  216744    		ld	hl,L5213
2685    497E  CD0000    		call	_printf
2686                    	; 1643                  printf("  w - write sector #N\n");
2687    4981  219C44    		ld	hl,L5313
2688    4984  CD0000    		call	_printf
2689                    	; 1644                  printf("  Ctrl-C to reload monitor from EPROM\n");
2690    4987  21B344    		ld	hl,L5413
2691    498A  CD0000    		call	_printf
2692                    	; 1645                  break;
2693    498D  C30349    		jp	L1226
2694                    	L1726:
2695                    	; 1646              case 'b':
2696                    	; 1647                  printf(" d - boot from SD card - ");
2697    4990  21DA44    		ld	hl,L5513
2698    4993  CD0000    		call	_printf
2699                    	; 1648                  printf("implementation ongoing\n");
2700    4996  21F444    		ld	hl,L5613
2701    4999  CD0000    		call	_printf
2702                    	; 1649                  break;
2703    499C  C30349    		jp	L1226
2704                    	L1036:
2705                    	; 1650              case 'd':
2706                    	; 1651                  printf(" d - toggle debug flag - ");
2707    499F  210C45    		ld	hl,L5713
2708    49A2  CD0000    		call	_printf
2709                    	; 1652                  if (sdtestflg)
2710    49A5  2A0000    		ld	hl,(_sdtestflg)
2711    49A8  7C        		ld	a,h
2712    49A9  B5        		or	l
2713    49AA  280F      		jr	z,L1136
2714                    	; 1653                      {
2715                    	; 1654                      sdtestflg = NO;
2716    49AC  210000    		ld	hl,0
2717    49AF  220000    		ld	(_sdtestflg),hl
2718                    	; 1655                      printf("OFF\n");
2719    49B2  212645    		ld	hl,L5023
2720    49B5  CD0000    		call	_printf
2721                    	; 1656                      }
2722                    	; 1657                  else
2723    49B8  C30349    		jp	L1226
2724                    	L1136:
2725                    	; 1658                      {
2726                    	; 1659                      sdtestflg = YES;
2727    49BB  210100    		ld	hl,1
2728    49BE  220000    		ld	(_sdtestflg),hl
2729                    	; 1660                      printf("ON\n");
2730    49C1  212B45    		ld	hl,L5123
2731    49C4  CD0000    		call	_printf
2732    49C7  C30349    		jp	L1226
2733                    	L1336:
2734                    	; 1661                      }
2735                    	; 1662                  break;
2736                    	; 1663              case 'i':
2737                    	; 1664                  printf(" i - initialize SD card");
2738    49CA  212F45    		ld	hl,L5223
2739    49CD  CD0000    		call	_printf
2740                    	; 1665                  if (sdinit())
2741    49D0  CD0A06    		call	_sdinit
2742    49D3  79        		ld	a,c
2743    49D4  B0        		or	b
2744    49D5  2809      		jr	z,L1436
2745                    	; 1666                      printf(" - ok\n");
2746    49D7  214745    		ld	hl,L5323
2747    49DA  CD0000    		call	_printf
2748                    	; 1667                  else
2749    49DD  C30349    		jp	L1226
2750                    	L1436:
2751                    	; 1668                      printf(" - not inserted or faulty\n");
2752    49E0  214E45    		ld	hl,L5423
2753    49E3  CD0000    		call	_printf
2754    49E6  C30349    		jp	L1226
2755                    	L1636:
2756                    	; 1669                  break;
2757                    	; 1670              case 'l':
2758                    	; 1671                  printf(" l - print partition layout\n");
2759    49E9  216945    		ld	hl,L5523
2760    49EC  CD0000    		call	_printf
2761                    	; 1672                  if (!sdprobe())
2762    49EF  CD0B10    		call	_sdprobe
2763    49F2  79        		ld	a,c
2764    49F3  B0        		or	b
2765    49F4  2009      		jr	nz,L1736
2766                    	; 1673                      {
2767                    	; 1674                      printf(" - SD not initialized or inserted or faulty\n");
2768    49F6  218645    		ld	hl,L5623
2769    49F9  CD0000    		call	_printf
2770                    	; 1675                      break;
2771    49FC  C30349    		jp	L1226
2772                    	L1736:
2773                    	; 1676                      }
2774                    	; 1677                  ebrrecidx = 0;
2775                    	; 1678                  partdsk = 0;
2776                    	;    1  /*  z80sdbt.c Boot and SD card test program.
2777                    	;    2   *
2778                    	;    3   *  Boot code for my DIY Z80 Computer. This
2779                    	;    4   *  program is compiled with Whitesmiths/COSMIC
2780                    	;    5   *  C compiler for Z80.
2781                    	;    6   *
2782                    	;    7   *  Initializes the hardware and detects the
2783                    	;    8   *  presence and partitioning of an attached SD card.
2784                    	;    9   *
2785                    	;   10   *  You are free to use, modify, and redistribute
2786                    	;   11   *  this source code. No warranties are given.
2787                    	;   12   *  Hastily Cobbled Together 2021 and 2022
2788                    	;   13   *  by Hans-Ake Lund
2789                    	;   14   *
2790                    	;   15   */
2791                    	;   16  
2792                    	;   17  #include <std.h>
2793                    	;   18  #include "z80computer.h"
2794                    	;   19  #include "builddate.h"
2795                    	;   20  
2796                    	;   21  /* Program name and version */
2797                    	;   22  #define PRGNAME "z80sdbt "
2798                    	;   23  #define VERSION "version 0.8, "
2799                    	;   24  /* Address in high RAM where to copy uploader */
2800                    	;   25  #define UPLADDR 0xf000
2801                    	;   26  
2802                    	;   27  /* This code should be cleaned up when
2803                    	;   28     remaining functions are implemented
2804                    	;   29   */
2805                    	;   30  #define PARTZRO 0  /* Empty partition entry */
2806                    	;   31  #define PARTMBR 1  /* MBR partition */
2807                    	;   32  #define PARTEBR 2  /* EBR logical partition */
2808                    	;   33  #define PARTGPT 3  /* GPT partition */
2809                    	;   34  #define EBRCONT 20 /* EBR container partition in MBR */
2810                    	;   35  
2811                    	;   36  struct partentry
2812                    	;   37      {
2813                    	;   38      char partype;
2814                    	;   39      char dskletter;
2815                    	;   40      int bootable;
2816                    	;   41      unsigned long dskstart;
2817                    	;   42      unsigned long dskend;
2818                    	;   43      unsigned long dsksize;
2819                    	;   44      unsigned char dsktype[16];
2820                    	;   45      } dskmap[16];
2821                    	;   46  
2822                    	;   47  unsigned char dsksign[4]; /* MBR/EBR disk signature */
2823                    	;   48  
2824                    	;   49  /* Function prototypes */
2825                    	;   50  void sdmbrpart(unsigned long);
2826                    	;   51  
2827                    	;   52  /* External data */
2828                    	;   53  extern const char upload[];
2829                    	;   54  extern const int upload_size;
2830                    	;   55  
2831                    	;   56  /* RAM/EPROM probe */
2832                    	;   57  const int ramprobe = 0;
2833                    	;   58  int *rampptr;
2834                    	;   59  
2835                    	;   60  /* Response length in bytes
2836                    	;   61   */
2837                    	;   62  #define R1_LEN 1
2838                    	;   63  #define R3_LEN 5
2839                    	;   64  #define R7_LEN 5
2840                    	;   65  
2841                    	;   66  /* The SD card commands (5 bytes) and a CRC7 byte as the last byte.
2842                    	;   67   * (The CRC7 byte in the tables below are only for information,
2843                    	;   68   * it is calculated by the sdcommand routine.)
2844                    	;   69   */
2845                    	;   70  const unsigned char cmd0[] = {0x40, 0x00, 0x00, 0x00, 0x00, 0x95};
2846                    	;   71  const unsigned char cmd8[] = {0x48, 0x00, 0x00, 0x01, 0xaa, 0x87};
2847                    	;   72  const unsigned char cmd9[] = {0x49, 0x00, 0x00, 0x00, 0x00, 0xaf};
2848                    	;   73  const unsigned char cmd10[] = {0x4a, 0x00, 0x00, 0x00, 0x00, 0x1b};
2849                    	;   74  const unsigned char cmd16[] = {0x50, 0x00, 0x00, 0x02, 0x00, 0x15};
2850                    	;   75  const unsigned char cmd17[] = {0x51, 0x00, 0x00, 0x00, 0x00, 0x55};
2851                    	;   76  const unsigned char cmd24[] = {0x58, 0x00, 0x00, 0x00, 0x00, 0x6f};
2852                    	;   77  const unsigned char cmd55[] = {0x77, 0x00, 0x00, 0x00, 0x00, 0x65};
2853                    	;   78  const unsigned char cmd58[] = {0x7a, 0x00, 0x00, 0x00, 0x00, 0xfd};
2854                    	;   79  const unsigned char acmd41[] = {0x69, 0x40, 0x00, 0x01, 0xaa, 0x33};
2855                    	;   80  
2856                    	;   81  /* Partition identifiers
2857                    	;   82   */
2858                    	;   83  /* For GPT I have decided that a CP/M partition
2859                    	;   84   * has GUID: AC7176FD-8D55-4FFF-86A5-A36D6368D0CB
2860                    	;   85   */
2861                    	;   86  const unsigned char gptcpm[] =
2862                    	;   87      {
2863                    	;   88      0xfd, 0x76, 0x71, 0xac, 0x55, 0x8d, 0xff, 0x4f,
2864                    	;   89      0x86, 0xa5, 0xa3, 0x6d, 0x63, 0x68, 0xd0, 0xcb
2865                    	;   90      };
2866                    	;   91  /* For MBR/EBR the partition type for CP/M is 0x52
2867                    	;   92   * according to: https://en.wikipedia.org/wiki/Partition_type
2868                    	;   93   */
2869                    	;   94  const unsigned char mbrcpm = 0x52;    /* CP/M partition */
2870                    	;   95  const unsigned char mbrexcode = 0x5f; /* Z80 executable code partition */
2871                    	;   96  /* has a special format that */
2872                    	;   97  /* includes number of sectors to */
2873                    	;   98  /* load and a signature, TBD */
2874                    	;   99  
2875                    	;  100  /* Buffers
2876                    	;  101   */
2877                    	;  102  unsigned char sdrdbuf[512];  /* recieved data from the SD card */
2878                    	;  103  
2879                    	;  104  unsigned char ocrreg[4];     /* SD card OCR register */
2880                    	;  105  unsigned char cidreg[16];    /* SD card CID register */
2881                    	;  106  unsigned char csdreg[16];    /* SD card CSD register */
2882                    	;  107  unsigned long ebrrecs[4];    /* detected EBR records to process */
2883                    	;  108  int ebrrecidx; /* how many EBR records that are populated */
2884                    	;  109  unsigned long ebrnext; /* next chained ebr record */
2885                    	;  110  
2886                    	;  111  /* Variables
2887                    	;  112   */
2888                    	;  113  int curblkok;  /* if YES curblockno is read into buffer */
2889                    	;  114  int partdsk;   /* partition/disk number, 0 = disk A */
2890                    	;  115  int sdinitok;  /* SD card initialized and ready */
2891                    	;  116  int sdver2;    /* SD card version 2 if YES, version 1 if NO */
2892                    	;  117  unsigned long blkmult;   /* block address multiplier */
2893                    	;  118  unsigned long curblkno;  /* block in buffer if curblkok == YES */
2894                    	;  119  
2895                    	;  120  /* debug bool */
2896                    	;  121  int sdtestflg;
2897                    	;  122  
2898                    	;  123  /* CRC routines from:
2899                    	;  124   * https://github.com/LonelyWolf/stm32/blob/master/stm32l-dosfs/sdcard.c
2900                    	;  125   */
2901                    	;  126  
2902                    	;  127  /*
2903                    	;  128  // Calculate CRC7
2904                    	;  129  // It's a 7 bit CRC with polynomial x^7 + x^3 + 1
2905                    	;  130  // input:
2906                    	;  131  //   crcIn - the CRC before (0 for first step)
2907                    	;  132  //   data - byte for CRC calculation
2908                    	;  133  // return: the new CRC7
2909                    	;  134  */
2910                    	;  135  unsigned char CRC7_one(unsigned char crcIn, unsigned char data)
2911                    	;  136      {
2912                    	;  137      const unsigned char g = 0x89;
2913                    	;  138      unsigned char i;
2914                    	;  139  
2915                    	;  140      crcIn ^= data;
2916                    	;  141      for (i = 0; i < 8; i++)
2917                    	;  142          {
2918                    	;  143          if (crcIn & 0x80) crcIn ^= g;
2919                    	;  144          crcIn <<= 1;
2920                    	;  145          }
2921                    	;  146  
2922                    	;  147      return crcIn;
2923                    	;  148      }
2924                    	;  149  
2925                    	;  150  /*
2926                    	;  151  // Calculate CRC16 CCITT
2927                    	;  152  // It's a 16 bit CRC with polynomial x^16 + x^12 + x^5 + 1
2928                    	;  153  // input:
2929                    	;  154  //   crcIn - the CRC before (0 for rist step)
2930                    	;  155  //   data - byte for CRC calculation
2931                    	;  156  // return: the CRC16 value
2932                    	;  157  */
2933                    	;  158  unsigned int CRC16_one(unsigned int crcIn, unsigned char data)
2934                    	;  159      {
2935                    	;  160      crcIn  = (unsigned char)(crcIn >> 8)|(crcIn << 8);
2936                    	;  161      crcIn ^=  data;
2937                    	;  162      crcIn ^= (unsigned char)(crcIn & 0xff) >> 4;
2938                    	;  163      crcIn ^= (crcIn << 8) << 4;
2939                    	;  164      crcIn ^= ((crcIn & 0xff) << 4) << 1;
2940                    	;  165  
2941                    	;  166      return crcIn;
2942                    	;  167      }
2943                    	;  168  
2944                    	;  169  /* Send command to SD card and recieve answer.
2945                    	;  170   * A command is 5 bytes long and is followed by
2946                    	;  171   * a CRC7 checksum byte.
2947                    	;  172   * Returns a pointer to the response
2948                    	;  173   * or 0 if no response start bit found.
2949                    	;  174   */
2950                    	;  175  unsigned char *sdcommand(unsigned char *sdcmdp,
2951                    	;  176                           unsigned char *recbuf, int recbytes)
2952                    	;  177      {
2953                    	;  178      int searchn;  /* byte counter to search for response */
2954                    	;  179      int sdcbytes; /* byte counter for bytes to send */
2955                    	;  180      unsigned char *retptr; /* pointer used to store response */
2956                    	;  181      unsigned char rbyte;   /* recieved byte */
2957                    	;  182      unsigned char crc = 0; /* calculated CRC7 */
2958                    	;  183  
2959                    	;  184      /* send 8*2 clockpules */
2960                    	;  185      spiio(0xff);
2961                    	;  186      spiio(0xff);
2962                    	;  187      for (sdcbytes = 5; 0 < sdcbytes; sdcbytes--) /* send bytes */
2963                    	;  188          {
2964                    	;  189          crc = CRC7_one(crc, *sdcmdp);
2965                    	;  190          spiio(*sdcmdp++);
2966                    	;  191          }
2967                    	;  192      spiio(crc | 0x01);
2968                    	;  193      /* search for recieved byte with start bit
2969                    	;  194         for a maximum of 10 recieved bytes  */
2970                    	;  195      for (searchn = 10; 0 < searchn; searchn--)
2971                    	;  196          {
2972                    	;  197          rbyte = spiio(0xff);
2973                    	;  198          if ((rbyte & 0x80) == 0)
2974                    	;  199              break;
2975                    	;  200          }
2976                    	;  201      if (searchn == 0) /* no start bit found */
2977                    	;  202          return (NO);
2978                    	;  203      retptr = recbuf;
2979                    	;  204      *retptr++ = rbyte;
2980                    	;  205      for (; 1 < recbytes; recbytes--) /* recieve bytes */
2981                    	;  206          *retptr++ = spiio(0xff);
2982                    	;  207      return (recbuf);
2983                    	;  208      }
2984                    	;  209  
2985                    	;  210  /* Initialise SD card interface
2986                    	;  211   *
2987                    	;  212   * returns YES if ok and NO if not ok
2988                    	;  213   *
2989                    	;  214   * References:
2990                    	;  215   *   https://www.sdcard.org/downloads/pls/
2991                    	;  216   *      Physical Layer Simplified Specification version 8.0
2992                    	;  217   *
2993                    	;  218   * A nice flowchart how to initialize:
2994                    	;  219   *   https://www.totalphase.com/blog/2018/08/set-sdc-mmc-cards-spi-mode-verify-files-successfully-programmed/
2995                    	;  220   *
2996                    	;  221   */
2997                    	;  222  int sdinit()
2998                    	;  223      {
2999                    	;  224      int nbytes;  /* byte counter */
3000                    	;  225      int tries;   /* tries to get to active state or searching for data  */
3001                    	;  226      int wtloop;  /* timer loop when trying to enter active state */
3002                    	;  227      unsigned char cmdbuf[5];   /* buffer to build command in */
3003                    	;  228      unsigned char rstatbuf[5]; /* buffer to recieve status in */
3004                    	;  229      unsigned char *statptr;    /* pointer to returned status from SD command */
3005                    	;  230      unsigned char crc;         /* crc register for CID and CSD */
3006                    	;  231      unsigned char rbyte;       /* recieved byte */
3007                    	;  232      unsigned char *prtptr;     /* for debug printing */
3008                    	;  233  
3009                    	;  234      ledon();
3010                    	;  235      spideselect();
3011                    	;  236      sdinitok = NO;
3012                    	;  237  
3013                    	;  238      /* start to generate 9*8 clock pulses with not selected SD card */
3014                    	;  239      for (nbytes = 9; 0 < nbytes; nbytes--)
3015                    	;  240          spiio(0xff);
3016                    	;  241      if (sdtestflg)
3017                    	;  242          {
3018                    	;  243          printf("\nSent 8*8 (72) clock pulses, select not active\n");
3019                    	;  244          } /* sdtestflg */
3020                    	;  245      spiselect();
3021                    	;  246  
3022                    	;  247      /* CMD0: GO_IDLE_STATE */
3023                    	;  248      for (tries = 0; tries < 10; tries++)
3024                    	;  249          {
3025                    	;  250          memcpy(cmdbuf, cmd0, 5);
3026                    	;  251          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3027                    	;  252          if (sdtestflg)
3028                    	;  253              {
3029                    	;  254              if (!statptr)
3030                    	;  255                  printf("CMD0: no response\n");
3031                    	;  256              else
3032                    	;  257                  printf("CMD0: GO_IDLE_STATE, R1 response [%02x]\n", statptr[0]);
3033                    	;  258              } /* sdtestflg */
3034                    	;  259          if (!statptr)
3035                    	;  260              {
3036                    	;  261              spideselect();
3037                    	;  262              ledoff();
3038                    	;  263              return (NO);
3039                    	;  264              }
3040                    	;  265          if (statptr[0] == 0x01)
3041                    	;  266              break;
3042                    	;  267          for (wtloop = 0; wtloop < tries * 10; wtloop++)
3043                    	;  268              {
3044                    	;  269              /* wait loop, time increasing for each try */
3045                    	;  270              spiio(0xff);
3046                    	;  271              }
3047                    	;  272          }
3048                    	;  273  
3049                    	;  274      /* CMD8: SEND_IF_COND */
3050                    	;  275      memcpy(cmdbuf, cmd8, 5);
3051                    	;  276      statptr = sdcommand(cmdbuf, rstatbuf, R7_LEN);
3052                    	;  277      if (sdtestflg)
3053                    	;  278          {
3054                    	;  279          if (!statptr)
3055                    	;  280              printf("CMD8: no response\n");
3056                    	;  281          else
3057                    	;  282              {
3058                    	;  283              printf("CMD8: SEND_IF_COND, R7 response [%02x %02x %02x %02x %02x], ",
3059                    	;  284                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
3060                    	;  285              if (!(statptr[0] & 0xfe)) /* no error */
3061                    	;  286                  {
3062                    	;  287                  if (statptr[4] == 0xaa)
3063                    	;  288                      printf("echo back ok, ");
3064                    	;  289                  else
3065                    	;  290                      printf("invalid echo back\n");
3066                    	;  291                  }
3067                    	;  292              }
3068                    	;  293          } /* sdtestflg */
3069                    	;  294      if (!statptr || (statptr[0] & 0xfe)) /* if no answer or error */
3070                    	;  295          {
3071                    	;  296          sdver2 = NO;
3072                    	;  297          if (sdtestflg)
3073                    	;  298              {
3074                    	;  299              printf("probably SD ver. 1\n");
3075                    	;  300              } /* sdtestflg */
3076                    	;  301          }
3077                    	;  302      else
3078                    	;  303          {
3079                    	;  304          sdver2 = YES;
3080                    	;  305          if (statptr[4] != 0xaa) /* but invalid echo back */
3081                    	;  306              {
3082                    	;  307              spideselect();
3083                    	;  308              ledoff();
3084                    	;  309              return (NO);
3085                    	;  310              }
3086                    	;  311          if (sdtestflg)
3087                    	;  312              {
3088                    	;  313              printf("SD ver 2\n");
3089                    	;  314              } /* sdtestflg */
3090                    	;  315          }
3091                    	;  316  
3092                    	;  317      /* CMD55: APP_CMD followed by ACMD41: SEND_OP_COND until status is 0x00 */
3093                    	;  318      for (tries = 0; tries < 20; tries++)
3094                    	;  319          {
3095                    	;  320          memcpy(cmdbuf, cmd55, 5);
3096                    	;  321          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3097                    	;  322          if (sdtestflg)
3098                    	;  323              {
3099                    	;  324              if (!statptr)
3100                    	;  325                  printf("CMD55: no response\n");
3101                    	;  326              else
3102                    	;  327                  printf("CMD55: APP_CMD, R1 response [%02x]\n", statptr[0]);
3103                    	;  328              } /* sdtestflg */
3104                    	;  329          if (!statptr)
3105                    	;  330              {
3106                    	;  331              spideselect();
3107                    	;  332              ledoff();
3108                    	;  333              return (NO);
3109                    	;  334              }
3110                    	;  335          memcpy(cmdbuf, acmd41, 5);
3111                    	;  336          if (sdver2)
3112                    	;  337              cmdbuf[1] = 0x40;
3113                    	;  338          else
3114                    	;  339              cmdbuf[1] = 0x00;
3115                    	;  340          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3116                    	;  341          if (sdtestflg)
3117                    	;  342              {
3118                    	;  343              if (!statptr)
3119                    	;  344                  printf("ACMD41: no response\n");
3120                    	;  345              else
3121                    	;  346                  printf("ACMD41: SEND_OP_COND, R1 response [%02x]%s\n",
3122                    	;  347                         statptr[0], (statptr[0] == 0x00) ? " - ready" : "");
3123                    	;  348              } /* sdtestflg */
3124                    	;  349          if (!statptr)
3125                    	;  350              {
3126                    	;  351              spideselect();
3127                    	;  352              ledoff();
3128                    	;  353              return (NO);
3129                    	;  354              }
3130                    	;  355          if (statptr[0] == 0x00) /* now the SD card is ready */
3131                    	;  356              {
3132                    	;  357              break;
3133                    	;  358              }
3134                    	;  359          for (wtloop = 0; wtloop < tries * 10; wtloop++)
3135                    	;  360              {
3136                    	;  361              /* wait loop, time increasing for each try */
3137                    	;  362              spiio(0xff);
3138                    	;  363              }
3139                    	;  364          }
3140                    	;  365  
3141                    	;  366      /* CMD58: READ_OCR */
3142                    	;  367      /* According to the flow chart this should not work
3143                    	;  368         for SD ver. 1 but the response is ok anyway
3144                    	;  369         all tested SD cards  */
3145                    	;  370      memcpy(cmdbuf, cmd58, 5);
3146                    	;  371      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
3147                    	;  372      if (sdtestflg)
3148                    	;  373          {
3149                    	;  374          if (!statptr)
3150                    	;  375              printf("CMD58: no response\n");
3151                    	;  376          else
3152                    	;  377              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
3153                    	;  378                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
3154                    	;  379          } /* sdtestflg */
3155                    	;  380      if (!statptr)
3156                    	;  381          {
3157                    	;  382          spideselect();
3158                    	;  383          ledoff();
3159                    	;  384          return (NO);
3160                    	;  385          }
3161                    	;  386      memcpy(&ocrreg[0], &statptr[1], sizeof (ocrreg));
3162                    	;  387      blkmult = 1; /* assume block address */
3163                    	;  388      if (ocrreg[0] & 0x80)
3164                    	;  389          {
3165                    	;  390          /* SD Ver.2+ */
3166                    	;  391          if (!(ocrreg[0] & 0x40))
3167                    	;  392              {
3168                    	;  393              /* SD Ver.2+, Byte address */
3169                    	;  394              blkmult = 512;
3170                    	;  395              }
3171                    	;  396          }
3172                    	;  397  
3173                    	;  398      /* CMD 16: SET_BLOCKLEN, only if Byte addressing */
3174                    	;  399      if (blkmult == 512)
3175                    	;  400          {
3176                    	;  401          memcpy(cmdbuf, cmd16, 5);
3177                    	;  402          statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3178                    	;  403          if (sdtestflg)
3179                    	;  404              {
3180                    	;  405              if (!statptr)
3181                    	;  406                  printf("CMD16: no response\n");
3182                    	;  407              else
3183                    	;  408                  printf("CMD16: SET_BLOCKLEN (to 512 bytes), R1 response [%02x]\n",
3184                    	;  409                         statptr[0]);
3185                    	;  410              } /* sdtestflg */
3186                    	;  411          if (!statptr)
3187                    	;  412              {
3188                    	;  413              spideselect();
3189                    	;  414              ledoff();
3190                    	;  415              return (NO);
3191                    	;  416              }
3192                    	;  417          }
3193                    	;  418      /* Register information:
3194                    	;  419       *   https://www.cameramemoryspeed.com/sd-memory-card-faq/reading-sd-card-cid-serial-psn-internal-numbers/
3195                    	;  420       */
3196                    	;  421  
3197                    	;  422      /* CMD10: SEND_CID */
3198                    	;  423      memcpy(cmdbuf, cmd10, 5);
3199                    	;  424      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3200                    	;  425      if (sdtestflg)
3201                    	;  426          {
3202                    	;  427          if (!statptr)
3203                    	;  428              printf("CMD10: no response\n");
3204                    	;  429          else
3205                    	;  430              printf("CMD10: SEND_CID, R1 response [%02x]\n", statptr[0]);
3206                    	;  431          } /* sdtestflg */
3207                    	;  432      if (!statptr)
3208                    	;  433          {
3209                    	;  434          spideselect();
3210                    	;  435          ledoff();
3211                    	;  436          return (NO);
3212                    	;  437          }
3213                    	;  438      /* looking for 0xfe that is the byte before data */
3214                    	;  439      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
3215                    	;  440          ;
3216                    	;  441      if (tries == 0) /* tried too many times */
3217                    	;  442          {
3218                    	;  443          if (sdtestflg)
3219                    	;  444              {
3220                    	;  445              printf("  No data found\n");
3221                    	;  446              } /* sdtestflg */
3222                    	;  447          spideselect();
3223                    	;  448          ledoff();
3224                    	;  449          return (NO);
3225                    	;  450          }
3226                    	;  451      else
3227                    	;  452          {
3228                    	;  453          crc = 0;
3229                    	;  454          for (nbytes = 0; nbytes < 15; nbytes++)
3230                    	;  455              {
3231                    	;  456              rbyte = spiio(0xff);
3232                    	;  457              cidreg[nbytes] = rbyte;
3233                    	;  458              crc = CRC7_one(crc, rbyte);
3234                    	;  459              }
3235                    	;  460          cidreg[15] = spiio(0xff);
3236                    	;  461          crc |= 0x01;
3237                    	;  462          /* some SD cards need additional clock pulses */
3238                    	;  463          for (nbytes = 9; 0 < nbytes; nbytes--)
3239                    	;  464              spiio(0xff);
3240                    	;  465          if (sdtestflg)
3241                    	;  466              {
3242                    	;  467              prtptr = &cidreg[0];
3243                    	;  468              printf("  CID: [");
3244                    	;  469              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
3245                    	;  470                  printf("%02x ", *prtptr);
3246                    	;  471              prtptr = &cidreg[0];
3247                    	;  472              printf("\b] |");
3248                    	;  473              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
3249                    	;  474                  {
3250                    	;  475                  if ((' ' <= *prtptr) && (*prtptr < 127))
3251                    	;  476                      putchar(*prtptr);
3252                    	;  477                  else
3253                    	;  478                      putchar('.');
3254                    	;  479                  }
3255                    	;  480              printf("|\n");
3256                    	;  481              if (crc == cidreg[15])
3257                    	;  482                  {
3258                    	;  483                  printf("CRC7 ok: [%02x]\n", crc);
3259                    	;  484                  }
3260                    	;  485              else
3261                    	;  486                  {
3262                    	;  487                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
3263                    	;  488                         crc, cidreg[15]);
3264                    	;  489                  /* could maybe return failure here */
3265                    	;  490                  }
3266                    	;  491              } /* sdtestflg */
3267                    	;  492          }
3268                    	;  493  
3269                    	;  494      /* CMD9: SEND_CSD */
3270                    	;  495      memcpy(cmdbuf, cmd9, 5);
3271                    	;  496      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3272                    	;  497      if (sdtestflg)
3273                    	;  498          {
3274                    	;  499          if (!statptr)
3275                    	;  500              printf("CMD9: no response\n");
3276                    	;  501          else
3277                    	;  502              printf("CMD9: SEND_CSD, R1 response [%02x]\n", statptr[0]);
3278                    	;  503          } /* sdtestflg */
3279                    	;  504      if (!statptr)
3280                    	;  505          {
3281                    	;  506          spideselect();
3282                    	;  507          ledoff();
3283                    	;  508          return (NO);
3284                    	;  509          }
3285                    	;  510      /* looking for 0xfe that is the byte before data */
3286                    	;  511      for (tries = 20; (0 < tries) && (spiio(0xff) != 0xfe); tries--)
3287                    	;  512          ;
3288                    	;  513      if (tries == 0) /* tried too many times */
3289                    	;  514          {
3290                    	;  515          if (sdtestflg)
3291                    	;  516              {
3292                    	;  517              printf("  No data found\n");
3293                    	;  518              } /* sdtestflg */
3294                    	;  519          return (NO);
3295                    	;  520          }
3296                    	;  521      else
3297                    	;  522          {
3298                    	;  523          crc = 0;
3299                    	;  524          for (nbytes = 0; nbytes < 15; nbytes++)
3300                    	;  525              {
3301                    	;  526              rbyte = spiio(0xff);
3302                    	;  527              csdreg[nbytes] = rbyte;
3303                    	;  528              crc = CRC7_one(crc, rbyte);
3304                    	;  529              }
3305                    	;  530          csdreg[15] = spiio(0xff);
3306                    	;  531          crc |= 0x01;
3307                    	;  532          /* some SD cards need additional clock pulses */
3308                    	;  533          for (nbytes = 9; 0 < nbytes; nbytes--)
3309                    	;  534              spiio(0xff);
3310                    	;  535          if (sdtestflg)
3311                    	;  536              {
3312                    	;  537              prtptr = &csdreg[0];
3313                    	;  538              printf("  CSD: [");
3314                    	;  539              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
3315                    	;  540                  printf("%02x ", *prtptr);
3316                    	;  541              prtptr = &csdreg[0];
3317                    	;  542              printf("\b] |");
3318                    	;  543              for (nbytes = 0; nbytes < 16; nbytes++, prtptr++)
3319                    	;  544                  {
3320                    	;  545                  if ((' ' <= *prtptr) && (*prtptr < 127))
3321                    	;  546                      putchar(*prtptr);
3322                    	;  547                  else
3323                    	;  548                      putchar('.');
3324                    	;  549                  }
3325                    	;  550              printf("|\n");
3326                    	;  551              if (crc == csdreg[15])
3327                    	;  552                  {
3328                    	;  553                  printf("CRC7 ok: [%02x]\n", crc);
3329                    	;  554                  }
3330                    	;  555              else
3331                    	;  556                  {
3332                    	;  557                  printf("CRC7 error, calculated: [%02x], recieved: [%02x]\n",
3333                    	;  558                         crc, csdreg[15]);
3334                    	;  559                  /* could maybe return failure here */
3335                    	;  560                  }
3336                    	;  561              } /* sdtestflg */
3337                    	;  562          }
3338                    	;  563  
3339                    	;  564      for (nbytes = 9; 0 < nbytes; nbytes--)
3340                    	;  565          spiio(0xff);
3341                    	;  566      if (sdtestflg)
3342                    	;  567          {
3343                    	;  568          printf("Sent 9*8 (72) clock pulses, select active\n");
3344                    	;  569          } /* sdtestflg */
3345                    	;  570  
3346                    	;  571      sdinitok = YES;
3347                    	;  572  
3348                    	;  573      spideselect();
3349                    	;  574      ledoff();
3350                    	;  575  
3351                    	;  576      return (YES);
3352                    	;  577      }
3353                    	;  578  
3354                    	;  579  int sdprobe()
3355                    	;  580      {
3356                    	;  581      unsigned char cmdbuf[5];   /* buffer to build command in */
3357                    	;  582      unsigned char rstatbuf[5]; /* buffer to recieve status in */
3358                    	;  583      unsigned char *statptr;    /* pointer to returned status from SD command */
3359                    	;  584      int nbytes;  /* byte counter */
3360                    	;  585      int allzero = YES;
3361                    	;  586  
3362                    	;  587      ledon();
3363                    	;  588      spiselect();
3364                    	;  589  
3365                    	;  590      /* CMD58: READ_OCR */
3366                    	;  591      memcpy(cmdbuf, cmd58, 5);
3367                    	;  592      statptr = sdcommand(cmdbuf, rstatbuf, R3_LEN);
3368                    	;  593      for (nbytes = 0; nbytes < 5; nbytes++)
3369                    	;  594          {
3370                    	;  595          if (statptr[nbytes] != 0)
3371                    	;  596              allzero = NO;
3372                    	;  597          }
3373                    	;  598      if (sdtestflg)
3374                    	;  599          {
3375                    	;  600          if (!statptr)
3376                    	;  601              printf("CMD58: no response\n");
3377                    	;  602          else
3378                    	;  603              {
3379                    	;  604              printf("CMD58: READ_OCR, R3 response [%02x %02x %02x %02x %02x]\n",
3380                    	;  605                     statptr[0], statptr[1], statptr[2], statptr[3], statptr[4]);
3381                    	;  606              if (allzero)
3382                    	;  607                  printf("SD card not inserted or not initialized\n");
3383                    	;  608              }
3384                    	;  609          } /* sdtestflg */
3385                    	;  610      if (!statptr || allzero)
3386                    	;  611          {
3387                    	;  612          sdinitok = NO;
3388                    	;  613          spideselect();
3389                    	;  614          ledoff();
3390                    	;  615          return (NO);
3391                    	;  616          }
3392                    	;  617  
3393                    	;  618      spideselect();
3394                    	;  619      ledoff();
3395                    	;  620  
3396                    	;  621      return (YES);
3397                    	;  622      }
3398                    	;  623  
3399                    	;  624  /* print OCR, CID and CSD registers*/
3400                    	;  625  void sdprtreg()
3401                    	;  626      {
3402                    	;  627      unsigned int n;
3403                    	;  628      unsigned int csize;
3404                    	;  629      unsigned long devsize;
3405                    	;  630      unsigned long capacity;
3406                    	;  631  
3407                    	;  632      if (!sdinitok)
3408                    	;  633          {
3409                    	;  634          printf("SD card not initialized\n");
3410                    	;  635          return;
3411                    	;  636          }
3412                    	;  637      printf("SD card information:");
3413                    	;  638      if (ocrreg[0] & 0x80)
3414                    	;  639          {
3415                    	;  640          if (ocrreg[0] & 0x40)
3416                    	;  641              printf("  SD card ver. 2+, Block address\n");
3417                    	;  642          else
3418                    	;  643              {
3419                    	;  644              if (sdver2)
3420                    	;  645                  printf("  SD card ver. 2+, Byte address\n");
3421                    	;  646              else
3422                    	;  647                  printf("  SD card ver. 1, Byte address\n");
3423                    	;  648              }
3424                    	;  649          }
3425                    	;  650      printf("  Manufacturer ID: 0x%02x, ", cidreg[0]);
3426                    	;  651      printf("OEM ID: %.2s, ", &cidreg[1]);
3427                    	;  652      printf("Product name: %.5s\n", &cidreg[3]);
3428                    	;  653      printf("  Product revision: %d.%d, ",
3429                    	;  654             (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
3430                    	;  655      printf("Serial number: %lu\n",
3431                    	;  656             (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
3432                    	;  657      printf("  Manufacturing date: %d-%d, ",
3433                    	;  658             2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
3434                    	;  659      if ((csdreg[0] & 0xc0) == 0x00) /* CSD version 1 */
3435                    	;  660          {
3436                    	;  661          n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
3437                    	;  662          csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
3438                    	;  663                  ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
3439                    	;  664          capacity = (unsigned long) csize << (n-10);
3440                    	;  665          printf("Device capacity: %lu MByte\n", capacity >> 10);
3441                    	;  666          }
3442                    	;  667      if ((csdreg[0] & 0xc0) == 0x40) /* CSD version 2 */
3443                    	;  668          {
3444                    	;  669          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
3445                    	;  670                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
3446                    	;  671          capacity = devsize << 9;
3447                    	;  672          printf("Device capacity: %lu MByte\n", capacity >> 10);
3448                    	;  673          }
3449                    	;  674      if ((csdreg[0] & 0xc0) == 0x80) /* CSD version 3 */
3450                    	;  675          {
3451                    	;  676          devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8) +
3452                    	;  677                    ((unsigned long)(csdreg[7] & 63) << 16) + 1;
3453                    	;  678          capacity = devsize << 9;
3454                    	;  679          printf("Device ultra capacity: %lu MByte\n", capacity >> 10);
3455                    	;  680          }
3456                    	;  681  
3457                    	;  682      if (sdtestflg)
3458                    	;  683          {
3459                    	;  684  
3460                    	;  685          printf("--------------------------------------\n");
3461                    	;  686          printf("OCR register:\n");
3462                    	;  687          if (ocrreg[2] & 0x80)
3463                    	;  688              printf("2.7-2.8V (bit 15) ");
3464                    	;  689          if (ocrreg[1] & 0x01)
3465                    	;  690              printf("2.8-2.9V (bit 16) ");
3466                    	;  691          if (ocrreg[1] & 0x02)
3467                    	;  692              printf("2.9-3.0V (bit 17) ");
3468                    	;  693          if (ocrreg[1] & 0x04)
3469                    	;  694              printf("3.0-3.1V (bit 18) \n");
3470                    	;  695          if (ocrreg[1] & 0x08)
3471                    	;  696              printf("3.1-3.2V (bit 19) ");
3472                    	;  697          if (ocrreg[1] & 0x10)
3473                    	;  698              printf("3.2-3.3V (bit 20) ");
3474                    	;  699          if (ocrreg[1] & 0x20)
3475                    	;  700              printf("3.3-3.4V (bit 21) ");
3476                    	;  701          if (ocrreg[1] & 0x40)
3477                    	;  702              printf("3.4-3.5V (bit 22) \n");
3478                    	;  703          if (ocrreg[1] & 0x80)
3479                    	;  704              printf("3.5-3.6V (bit 23) \n");
3480                    	;  705          if (ocrreg[0] & 0x01)
3481                    	;  706              printf("Switching to 1.8V Accepted (S18A) (bit 24) set ");
3482                    	;  707          if (ocrreg[0] & 0x08)
3483                    	;  708              printf("Over 2TB support Status (CO2T) (bit 27) set\n");
3484                    	;  709          if (ocrreg[0] & 0x20)
3485                    	;  710              printf("UHS-II Card Status (bit 29) set ");
3486                    	;  711          if (ocrreg[0] & 0x80)
3487                    	;  712              {
3488                    	;  713              if (ocrreg[0] & 0x40)
3489                    	;  714                  {
3490                    	;  715                  printf("Card Capacity Status (CCS) (bit 30) set\n");
3491                    	;  716                  printf("  SD Ver.2+, Block address");
3492                    	;  717                  }
3493                    	;  718              else
3494                    	;  719                  {
3495                    	;  720                  printf("Card Capacity Status (CCS) (bit 30) not set\n");
3496                    	;  721                  if (sdver2)
3497                    	;  722                      printf("  SD Ver.2+, Byte address");
3498                    	;  723                  else
3499                    	;  724                      printf("  SD Ver.1, Byte address");
3500                    	;  725                  }
3501                    	;  726              printf("\nCard power up status bit (busy) (bit 31) set\n");
3502                    	;  727              }
3503                    	;  728          else
3504                    	;  729              {
3505                    	;  730              printf("\nCard power up status bit (busy) (bit 31) not set.\n");
3506                    	;  731              printf("  This bit is not set if the card has not finished the power up routine.\n");
3507                    	;  732              }
3508                    	;  733          printf("--------------------------------------\n");
3509                    	;  734          printf("CID register:\n");
3510                    	;  735          printf("MID: 0x%02x, ", cidreg[0]);
3511                    	;  736          printf("OID: %.2s, ", &cidreg[1]);
3512                    	;  737          printf("PNM: %.5s, ", &cidreg[3]);
3513                    	;  738          printf("PRV: %d.%d, ",
3514                    	;  739                 (cidreg[8] >> 4) & 0x0f, cidreg[8] & 0x0f);
3515                    	;  740          printf("PSN: %lu, ",
3516                    	;  741                 (cidreg[9] << 24) + (cidreg[10] << 16) + (cidreg[11] << 8) + cidreg[12]);
3517                    	;  742          printf("MDT: %d-%d\n",
3518                    	;  743                 2000 + ((cidreg[13] & 0x0f) << 4) + (cidreg[14] >> 4), cidreg[14] & 0x0f);
3519                    	;  744          printf("--------------------------------------\n");
3520                    	;  745          printf("CSD register:\n");
3521                    	;  746          if ((csdreg[0] & 0xc0) == 0x00)
3522                    	;  747              {
3523                    	;  748              printf("CSD Version 1.0, Standard Capacity\n");
3524                    	;  749              n = (csdreg[5] & 0x0F) + ((csdreg[10] & 0x80) >> 7) + ((csdreg[9] & 0x03) << 1) + 2;
3525                    	;  750              csize = (csdreg[8] >> 6) + ((unsigned int) csdreg[7] << 2) +
3526                    	;  751                      ((unsigned int) (csdreg[6] & 0x03) << 10) + 1;
3527                    	;  752              capacity = (unsigned long) csize << (n-10);
3528                    	;  753              printf(" Device capacity: %lu KByte, %lu MByte\n",
3529                    	;  754                     capacity, capacity >> 10);
3530                    	;  755              }
3531                    	;  756          if ((csdreg[0] & 0xc0) == 0x40)
3532                    	;  757              {
3533                    	;  758              printf("CSD Version 2.0, High Capacity and Extended Capacity\n");
3534                    	;  759              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
3535                    	;  760                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
3536                    	;  761              capacity = devsize << 9;
3537                    	;  762              printf(" Device capacity: %lu KByte, %lu MByte\n",
3538                    	;  763                     capacity, capacity >> 10);
3539                    	;  764              }
3540                    	;  765          if ((csdreg[0] & 0xc0) == 0x80)
3541                    	;  766              {
3542                    	;  767              printf("CSD Version 3.0, Ultra Capacity (SDUC)\n");
3543                    	;  768              devsize = csdreg[9] + ((unsigned long)csdreg[8] << 8)
3544                    	;  769                        + ((unsigned long)(csdreg[7] & 63) << 16) + 1;
3545                    	;  770              capacity = devsize << 9;
3546                    	;  771              printf(" Device capacity: %lu KByte, %lu MByte\n",
3547                    	;  772                     capacity, capacity >> 10);
3548                    	;  773              }
3549                    	;  774          printf("--------------------------------------\n");
3550                    	;  775  
3551                    	;  776          } /* sdtestflg */ /* SDTEST */
3552                    	;  777  
3553                    	;  778      }
3554                    	;  779  
3555                    	;  780  /* Read data block of 512 bytes to buffer
3556                    	;  781   * Returns YES if ok or NO if error
3557                    	;  782   */
3558                    	;  783  int sdread(unsigned char *rdbuf, unsigned long rdblkno)
3559                    	;  784      {
3560                    	;  785      unsigned char *statptr;
3561                    	;  786      unsigned char rbyte;
3562                    	;  787      unsigned char cmdbuf[5];   /* buffer to build command in */
3563                    	;  788      unsigned char rstatbuf[5]; /* buffer to recieve status in */
3564                    	;  789      int nbytes;
3565                    	;  790      int tries;
3566                    	;  791      unsigned long blktoread;
3567                    	;  792      unsigned int rxcrc16;
3568                    	;  793      unsigned int calcrc16;
3569                    	;  794  
3570                    	;  795      ledon();
3571                    	;  796      spiselect();
3572                    	;  797  
3573                    	;  798      if (!sdinitok)
3574                    	;  799          {
3575                    	;  800          if (sdtestflg)
3576                    	;  801              {
3577                    	;  802              printf("SD card not initialized\n");
3578                    	;  803              } /* sdtestflg */
3579                    	;  804          spideselect();
3580                    	;  805          ledoff();
3581                    	;  806          return (NO);
3582                    	;  807          }
3583                    	;  808  
3584                    	;  809      /* CMD17: READ_SINGLE_BLOCK */
3585                    	;  810      /* Insert block # into command */
3586                    	;  811      memcpy(cmdbuf, cmd17, 5);
3587                    	;  812      blktoread = blkmult * rdblkno;
3588                    	;  813      cmdbuf[4] = blktoread & 0xff;
3589                    	;  814      blktoread = blktoread >> 8;
3590                    	;  815      cmdbuf[3] = blktoread & 0xff;
3591                    	;  816      blktoread = blktoread >> 8;
3592                    	;  817      cmdbuf[2] = blktoread & 0xff;
3593                    	;  818      blktoread = blktoread >> 8;
3594                    	;  819      cmdbuf[1] = blktoread & 0xff;
3595                    	;  820  
3596                    	;  821      if (sdtestflg)
3597                    	;  822          {
3598                    	;  823          printf("\nCMD17: READ_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
3599                    	;  824                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
3600                    	;  825          } /* sdtestflg */
3601                    	;  826      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3602                    	;  827      if (sdtestflg)
3603                    	;  828          {
3604                    	;  829          printf("CMD17 R1 response [%02x]\n", statptr[0]);
3605                    	;  830          } /* sdtestflg */
3606                    	;  831      if (statptr[0])
3607                    	;  832          {
3608                    	;  833          if (sdtestflg)
3609                    	;  834              {
3610                    	;  835              printf("  could not read block\n");
3611                    	;  836              } /* sdtestflg */
3612                    	;  837          spideselect();
3613                    	;  838          ledoff();
3614                    	;  839          return (NO);
3615                    	;  840          }
3616                    	;  841      /* looking for 0xfe that is the byte before data */
3617                    	;  842      for (tries = 80; (0 < tries) && ((rbyte = spiio(0xff)) != 0xfe); tries--)
3618                    	;  843          {
3619                    	;  844          if ((rbyte & 0xe0) == 0x00)
3620                    	;  845              {
3621                    	;  846              /* If a read operation fails and the card cannot provide
3622                    	;  847                 the required data, it will send a data error token instead
3623                    	;  848               */
3624                    	;  849              if (sdtestflg)
3625                    	;  850                  {
3626                    	;  851                  printf("  read error: [%02x]\n", rbyte);
3627                    	;  852                  } /* sdtestflg */
3628                    	;  853              spideselect();
3629                    	;  854              ledoff();
3630                    	;  855              return (NO);
3631                    	;  856              }
3632                    	;  857          }
3633                    	;  858      if (tries == 0) /* tried too many times */
3634                    	;  859          {
3635                    	;  860          if (sdtestflg)
3636                    	;  861              {
3637                    	;  862              printf("  no data found\n");
3638                    	;  863              } /* sdtestflg */
3639                    	;  864          spideselect();
3640                    	;  865          ledoff();
3641                    	;  866          return (NO);
3642                    	;  867          }
3643                    	;  868      else
3644                    	;  869          {
3645                    	;  870          calcrc16 = 0;
3646                    	;  871          for (nbytes = 0; nbytes < 512; nbytes++)
3647                    	;  872              {
3648                    	;  873              rbyte = spiio(0xff);
3649                    	;  874              calcrc16 = CRC16_one(calcrc16, rbyte);
3650                    	;  875              rdbuf[nbytes] = rbyte;
3651                    	;  876              }
3652                    	;  877          rxcrc16 = spiio(0xff) << 8;
3653                    	;  878          rxcrc16 += spiio(0xff);
3654                    	;  879  
3655                    	;  880          if (sdtestflg)
3656                    	;  881              {
3657                    	;  882              printf("  read data block %ld:\n", rdblkno);
3658                    	;  883              } /* sdtestflg */
3659                    	;  884          if (rxcrc16 != calcrc16)
3660                    	;  885              {
3661                    	;  886              if (sdtestflg)
3662                    	;  887                  {
3663                    	;  888                  printf("  CRC16 error, recieved: 0x%04x, calc: 0x%04hi\n",
3664                    	;  889                         rxcrc16, calcrc16);
3665                    	;  890                  } /* sdtestflg */
3666                    	;  891              spideselect();
3667                    	;  892              ledoff();
3668                    	;  893              return (NO);
3669                    	;  894              }
3670                    	;  895          }
3671                    	;  896      spideselect();
3672                    	;  897      ledoff();
3673                    	;  898      return (YES);
3674                    	;  899      }
3675                    	;  900  
3676                    	;  901  /* Write data block of 512 bytes from buffer
3677                    	;  902   * Returns YES if ok or NO if error
3678                    	;  903   */
3679                    	;  904  int sdwrite(unsigned char *wrbuf, unsigned long wrblkno)
3680                    	;  905      {
3681                    	;  906      unsigned char *statptr;
3682                    	;  907      unsigned char rbyte;
3683                    	;  908      unsigned char tbyte;
3684                    	;  909      unsigned char cmdbuf[5];   /* buffer to build command in */
3685                    	;  910      unsigned char rstatbuf[5]; /* buffer to recieve status in */
3686                    	;  911      int nbytes;
3687                    	;  912      int tries;
3688                    	;  913      unsigned long blktowrite;
3689                    	;  914      unsigned int calcrc16;
3690                    	;  915  
3691                    	;  916      ledon();
3692                    	;  917      spiselect();
3693                    	;  918  
3694                    	;  919      if (!sdinitok)
3695                    	;  920          {
3696                    	;  921          if (sdtestflg)
3697                    	;  922              {
3698                    	;  923              printf("SD card not initialized\n");
3699                    	;  924              } /* sdtestflg */
3700                    	;  925          spideselect();
3701                    	;  926          ledoff();
3702                    	;  927          return (NO);
3703                    	;  928          }
3704                    	;  929  
3705                    	;  930      if (sdtestflg)
3706                    	;  931          {
3707                    	;  932          printf("  write data block %ld:\n", wrblkno);
3708                    	;  933          } /* sdtestflg */
3709                    	;  934      /* CMD24: WRITE_SINGLE_BLOCK */
3710                    	;  935      /* Insert block # into command */
3711                    	;  936      memcpy(cmdbuf, cmd24, 5);
3712                    	;  937      blktowrite = blkmult * wrblkno;
3713                    	;  938      cmdbuf[4] = blktowrite & 0xff;
3714                    	;  939      blktowrite = blktowrite >> 8;
3715                    	;  940      cmdbuf[3] = blktowrite & 0xff;
3716                    	;  941      blktowrite = blktowrite >> 8;
3717                    	;  942      cmdbuf[2] = blktowrite & 0xff;
3718                    	;  943      blktowrite = blktowrite >> 8;
3719                    	;  944      cmdbuf[1] = blktowrite & 0xff;
3720                    	;  945  
3721                    	;  946      if (sdtestflg)
3722                    	;  947          {
3723                    	;  948          printf("\nCMD24: WRITE_SINGLE_BLOCK, command [%02x %02x %02x %02x %02x]\n",
3724                    	;  949                 cmdbuf[0], cmdbuf[1], cmdbuf[2], cmdbuf[3], cmdbuf[4]);
3725                    	;  950          } /* sdtestflg */
3726                    	;  951      statptr = sdcommand(cmdbuf, rstatbuf, R1_LEN);
3727                    	;  952      if (sdtestflg)
3728                    	;  953          {
3729                    	;  954          printf("CMD24 R1 response [%02x]\n", statptr[0]);
3730                    	;  955          } /* sdtestflg */
3731                    	;  956      if (statptr[0])
3732                    	;  957          {
3733                    	;  958          if (sdtestflg)
3734                    	;  959              {
3735                    	;  960              printf("  could not write block\n");
3736                    	;  961              } /* sdtestflg */
3737                    	;  962          spideselect();
3738                    	;  963          ledoff();
3739                    	;  964          return (NO);
3740                    	;  965          }
3741                    	;  966      /* send 0xfe, the byte before data */
3742                    	;  967      spiio(0xfe);
3743                    	;  968      /* initialize crc and send block */
3744                    	;  969      calcrc16 = 0;
3745                    	;  970      for (nbytes = 0; nbytes < 512; nbytes++)
3746                    	;  971          {
3747                    	;  972          tbyte = wrbuf[nbytes];
3748                    	;  973          spiio(tbyte);
3749                    	;  974          calcrc16 = CRC16_one(calcrc16, tbyte);
3750                    	;  975          }
3751                    	;  976      spiio((calcrc16 >> 8) & 0xff);
3752                    	;  977      spiio(calcrc16 & 0xff);
3753                    	;  978  
3754                    	;  979      /* check data resposnse */
3755                    	;  980      for (tries = 20;
3756                    	;  981              0 < tries && (((rbyte = spiio(0xff)) & 0x11) != 0x01);
3757                    	;  982              tries--)
3758                    	;  983          ;
3759                    	;  984      if (tries == 0)
3760                    	;  985          {
3761                    	;  986          if (sdtestflg)
3762                    	;  987              {
3763                    	;  988              printf("No data response\n");
3764                    	;  989              } /* sdtestflg */
3765                    	;  990          spideselect();
3766                    	;  991          ledoff();
3767                    	;  992          return (NO);
3768                    	;  993          }
3769                    	;  994      else
3770                    	;  995          {
3771                    	;  996          if (sdtestflg)
3772                    	;  997              {
3773                    	;  998              printf("Data response [%02x]", 0x1f & rbyte);
3774                    	;  999              } /* sdtestflg */
3775                    	; 1000          if ((0x1f & rbyte) == 0x05)
3776                    	; 1001              {
3777                    	; 1002              if (sdtestflg)
3778                    	; 1003                  {
3779                    	; 1004                  printf(", data accepted\n");
3780                    	; 1005                  } /* sdtestflg */
3781                    	; 1006              for (nbytes = 9; 0 < nbytes; nbytes--)
3782                    	; 1007                  spiio(0xff);
3783                    	; 1008              if (sdtestflg)
3784                    	; 1009                  {
3785                    	; 1010                  printf("Sent 9*8 (72) clock pulses, select active\n");
3786                    	; 1011                  } /* sdtestflg */
3787                    	; 1012              spideselect();
3788                    	; 1013              ledoff();
3789                    	; 1014              return (YES);
3790                    	; 1015              }
3791                    	; 1016          else
3792                    	; 1017              {
3793                    	; 1018              if (sdtestflg)
3794                    	; 1019                  {
3795                    	; 1020                  printf(", data not accepted\n");
3796                    	; 1021                  } /* sdtestflg */
3797                    	; 1022              spideselect();
3798                    	; 1023              ledoff();
3799                    	; 1024              return (NO);
3800                    	; 1025              }
3801                    	; 1026          }
3802                    	; 1027      }
3803                    	; 1028  
3804                    	; 1029  /* Print data in 512 byte buffer */
3805                    	; 1030  void sddatprt(unsigned char *prtbuf)
3806                    	; 1031      {
3807                    	; 1032      /* Variables used for "pretty-print" */
3808                    	; 1033      int allzero, dmpline, dotprted, lastallz, nbytes;
3809                    	; 1034      unsigned char *prtptr;
3810                    	; 1035  
3811                    	; 1036      prtptr = prtbuf;
3812                    	; 1037      dotprted = NO;
3813                    	; 1038      lastallz = NO;
3814                    	; 1039      for (dmpline = 0; dmpline < 32; dmpline++)
3815                    	; 1040          {
3816                    	; 1041          /* test if all 16 bytes are 0x00 */
3817                    	; 1042          allzero = YES;
3818                    	; 1043          for (nbytes = 0; nbytes < 16; nbytes++)
3819                    	; 1044              {
3820                    	; 1045              if (prtptr[nbytes] != 0)
3821                    	; 1046                  allzero = NO;
3822                    	; 1047              }
3823                    	; 1048          if (lastallz && allzero)
3824                    	; 1049              {
3825                    	; 1050              if (!dotprted)
3826                    	; 1051                  {
3827                    	; 1052                  printf("*\n");
3828                    	; 1053                  dotprted = YES;
3829                    	; 1054                  }
3830                    	; 1055              }
3831                    	; 1056          else
3832                    	; 1057              {
3833                    	; 1058              dotprted = NO;
3834                    	; 1059              /* print offset */
3835                    	; 1060              printf("%04x ", dmpline * 16);
3836                    	; 1061              /* print 16 bytes in hex */
3837                    	; 1062              for (nbytes = 0; nbytes < 16; nbytes++)
3838                    	; 1063                  printf("%02x ", prtptr[nbytes]);
3839                    	; 1064              /* print these bytes in ASCII if printable */
3840                    	; 1065              printf(" |");
3841                    	; 1066              for (nbytes = 0; nbytes < 16; nbytes++)
3842                    	; 1067                  {
3843                    	; 1068                  if ((' ' <= prtptr[nbytes]) && (prtptr[nbytes] < 127))
3844                    	; 1069                      putchar(prtptr[nbytes]);
3845                    	; 1070                  else
3846                    	; 1071                      putchar('.');
3847                    	; 1072                  }
3848                    	; 1073              printf("|\n");
3849                    	; 1074              }
3850                    	; 1075          prtptr += 16;
3851                    	; 1076          lastallz = allzero;
3852                    	; 1077          }
3853                    	; 1078      }
3854                    	; 1079  
3855                    	; 1080  /* Print GUID (mixed endian format)
3856                    	; 1081   */
3857                    	; 1082  void prtguid(unsigned char *guidptr)
3858                    	; 1083      {
3859                    	; 1084      int index;
3860                    	; 1085  
3861                    	; 1086      printf("%02x%02x%02x%02x-", guidptr[3], guidptr[2], guidptr[1], guidptr[0]);
3862                    	; 1087      printf("%02x%02x-", guidptr[5], guidptr[4]);
3863                    	; 1088      printf("%02x%02x-", guidptr[7], guidptr[6]);
3864                    	; 1089      printf("%02x%02x-", guidptr[8], guidptr[9]);
3865                    	; 1090      printf("%02x%02x%02x%02x%02x%02x",
3866                    	; 1091             guidptr[10], guidptr[11], guidptr[12], guidptr[13], guidptr[14], guidptr[15]);
3867                    	; 1092      }
3868                    	; 1093  
3869                    	; 1094  /* Analyze and print GPT entry
3870                    	; 1095   */
3871                    	; 1096  int prtgptent(unsigned int entryno)
3872                    	; 1097      {
3873                    	; 1098      int index;
3874                    	; 1099      int entryidx;
3875                    	; 1100      int hasname;
3876                    	; 1101      unsigned int block;
3877                    	; 1102      unsigned char *rxdata;
3878                    	; 1103      unsigned char *entryptr;
3879                    	; 1104      unsigned char tstzero = 0;
3880                    	; 1105      unsigned long flba;
3881                    	; 1106      unsigned long llba;
3882                    	; 1107  
3883                    	; 1108      block = 2 + (entryno / 4);
3884                    	; 1109      if ((curblkno != block) || !curblkok)
3885                    	; 1110          {
3886                    	; 1111          if (!sdread(sdrdbuf, block))
3887                    	; 1112              {
3888                    	; 1113              if (sdtestflg)
3889                    	; 1114                  {
3890                    	; 1115                  printf("Can't read GPT entry block\n");
3891                    	; 1116                  return (NO);
3892                    	; 1117                  } /* sdtestflg */
3893                    	; 1118              }
3894                    	; 1119          curblkno = block;
3895                    	; 1120          curblkok = YES;
3896                    	; 1121          }
3897                    	; 1122      rxdata = sdrdbuf;
3898                    	; 1123      entryptr = rxdata + (128 * (entryno % 4));
3899                    	; 1124      for (index = 0; index < 16; index++)
3900                    	; 1125          tstzero |= entryptr[index];
3901                    	; 1126      if (sdtestflg)
3902                    	; 1127          {
3903                    	; 1128          printf("GPT partition entry %d:", entryno + 1);
3904                    	; 1129          } /* sdtestflg */
3905                    	; 1130      if (!tstzero)
3906                    	; 1131          {
3907                    	; 1132          if (sdtestflg)
3908                    	; 1133              {
3909                    	; 1134              printf(" Not used entry\n");
3910                    	; 1135              } /* sdtestflg */
3911                    	; 1136          return (NO);
3912                    	; 1137          }
3913                    	; 1138      if (sdtestflg)
3914                    	; 1139          {
3915                    	; 1140          printf("\n  Partition type GUID: ");
3916                    	; 1141          prtguid(entryptr);
3917                    	; 1142          printf("\n  [");
3918                    	; 1143          for (index = 0; index < 16; index++)
3919                    	; 1144              printf("%02x ", entryptr[index]);
3920                    	; 1145          printf("\b]");
3921                    	; 1146          printf("\n  Unique partition GUID: ");
3922                    	; 1147          prtguid(entryptr + 16);
3923                    	; 1148          printf("\n  [");
3924                    	; 1149          for (index = 0; index < 16; index++)
3925                    	; 1150              printf("%02x ", (entryptr + 16)[index]);
3926                    	; 1151          printf("\b]");
3927                    	; 1152          printf("\n  First LBA: ");
3928                    	; 1153          /* lower 32 bits of LBA should be sufficient (I hope) */
3929                    	; 1154          } /* sdtestflg */
3930                    	; 1155      flba = (unsigned long)entryptr[32] + ((unsigned long)entryptr[33] << 8) +
3931                    	; 1156             ((unsigned long)entryptr[34] << 16) + ((unsigned long)entryptr[35] << 24);
3932                    	; 1157      if (sdtestflg)
3933                    	; 1158          {
3934                    	; 1159          printf("%lu", flba);
3935                    	; 1160          printf(" [");
3936                    	; 1161          for (index = 32; index < (32 + 8); index++)
3937                    	; 1162              printf("%02x ", entryptr[index]);
3938                    	; 1163          printf("\b]");
3939                    	; 1164          printf("\n  Last LBA: ");
3940                    	; 1165          } /* sdtestflg */
3941                    	; 1166      /* lower 32 bits of LBA should be sufficient (I hope) */
3942                    	; 1167      llba = (unsigned long)entryptr[40] + ((unsigned long)entryptr[41] << 8) +
3943                    	; 1168             ((unsigned long)entryptr[42] << 16) + ((unsigned long)entryptr[43] << 24);
3944                    	; 1169  
3945                    	; 1170      if (entryptr[48] & 0x04)
3946                    	; 1171          dskmap[partdsk].bootable = YES;
3947                    	; 1172      dskmap[partdsk].partype = PARTGPT;
3948                    	; 1173      dskmap[partdsk].dskletter = 'A' + partdsk;
3949                    	; 1174      dskmap[partdsk].dskstart = flba;
3950                    	; 1175      dskmap[partdsk].dskend = llba;
3951                    	; 1176      dskmap[partdsk].dsksize = llba - flba + 1;
3952                    	; 1177      memcpy(dskmap[partdsk].dsktype, entryptr, 16);
3953                    	; 1178      partdsk++;
3954                    	; 1179  
3955                    	; 1180      if (sdtestflg)
3956                    	; 1181          {
3957                    	; 1182          printf("%lu, size %lu MByte", llba, (llba - flba) >> 11);
3958                    	; 1183          printf(" [");
3959                    	; 1184          for (index = 40; index < (40 + 8); index++)
3960                    	; 1185              printf("%02x ", entryptr[index]);
3961                    	; 1186          printf("\b]");
3962                    	; 1187          printf("\n  Attribute flags: [");
3963                    	; 1188          /* bits 0 - 2 and 60 - 63 should be decoded */
3964                    	; 1189          for (index = 0; index < 8; index++)
3965                    	; 1190              {
3966                    	; 1191              entryidx = index + 48;
3967                    	; 1192              printf("%02x ", entryptr[entryidx]);
3968                    	; 1193              }
3969                    	; 1194          printf("\b]\n  Partition name:  ");
3970                    	; 1195          } /* sdtestflg */
3971                    	; 1196      /* partition name is in UTF-16LE code units */
3972                    	; 1197      hasname = NO;
3973                    	; 1198      for (index = 0; index < 72; index += 2)
3974                    	; 1199          {
3975                    	; 1200          entryidx = index + 56;
3976                    	; 1201          if ((entryptr[entryidx] | entryptr[entryidx + 1]) == 0)
3977                    	; 1202              break;
3978                    	; 1203          if (sdtestflg)
3979                    	; 1204              {
3980                    	; 1205              if ((' ' <= entryptr[entryidx]) && (entryptr[entryidx] < 127))
3981                    	; 1206                  putchar(entryptr[entryidx]);
3982                    	; 1207              else
3983                    	; 1208                  putchar('.');
3984                    	; 1209              } /* sdtestflg */
3985                    	; 1210          hasname = YES;
3986                    	; 1211          }
3987                    	; 1212      if (sdtestflg)
3988                    	; 1213          {
3989                    	; 1214          if (!hasname)
3990                    	; 1215              printf("name field empty");
3991                    	; 1216          printf("\n");
3992                    	; 1217          printf("   [");
3993                    	; 1218          for (index = 0; index < 72; index++)
3994                    	; 1219              {
3995                    	; 1220              if (((index & 0xf) == 0) && (index != 0))
3996                    	; 1221                  printf("\n    ");
3997                    	; 1222              entryidx = index + 56;
3998                    	; 1223              printf("%02x ", entryptr[entryidx]);
3999                    	; 1224              }
4000                    	; 1225          printf("\b]\n");
4001                    	; 1226          } /* sdtestflg */
4002                    	; 1227      return (YES);
4003                    	; 1228      }
4004                    	; 1229  
4005                    	; 1230  /* Analyze and print GPT header
4006                    	; 1231   */
4007                    	; 1232  void sdgpthdr(unsigned long block)
4008                    	; 1233      {
4009                    	; 1234      int index;
4010                    	; 1235      unsigned int partno;
4011                    	; 1236      unsigned char *rxdata;
4012                    	; 1237      unsigned long entries;
4013                    	; 1238  
4014                    	; 1239      if (sdtestflg)
4015                    	; 1240          {
4016                    	; 1241          printf("GPT header\n");
4017                    	; 1242          } /* sdtestflg */
4018                    	; 1243      if (!sdread(sdrdbuf, block))
4019                    	; 1244          {
4020                    	; 1245          if (sdtestflg)
4021                    	; 1246              {
4022                    	; 1247              printf("Can't read GPT partition table header\n");
4023                    	; 1248              } /* sdtestflg */
4024                    	; 1249          return;
4025                    	; 1250          }
4026                    	; 1251      curblkno = block;
4027                    	; 1252      curblkok = YES;
4028                    	; 1253  
4029                    	; 1254      rxdata = sdrdbuf;
4030                    	; 1255      if (sdtestflg)
4031                    	; 1256          {
4032                    	; 1257          printf("  Signature: %.8s\n", &rxdata[0]);
4033                    	; 1258          printf("  Revision: %d.%d [%02x %02x %02x %02x]\n",
4034                    	; 1259                 (int)rxdata[8] * ((int)rxdata[9] << 8),
4035                    	; 1260                 (int)rxdata[10] + ((int)rxdata[11] << 8),
4036                    	; 1261                 rxdata[8], rxdata[9], rxdata[10], rxdata[11]);
4037                    	; 1262          entries = (unsigned long)rxdata[80] + ((unsigned long)rxdata[81] << 8) +
4038                    	; 1263                    ((unsigned long)rxdata[82] << 16) + ((unsigned long)rxdata[83] << 24);
4039                    	; 1264          printf("  Number of partition entries: %lu (may be actual or maximum)\n", entries);
4040                    	; 1265          } /* sdtestflg */
4041                    	; 1266      for (partno = 0; (partno < 16) && (partdsk < 16); partno++)
4042                    	; 1267          {
4043                    	; 1268          if (!prtgptent(partno))
4044                    	; 1269              {
4045                    	; 1270              if (!sdtestflg)
4046                    	; 1271                  {
4047                    	; 1272                  /* go through all entries if compiled as test program */
4048                    	; 1273                  return;
4049                    	; 1274                  } /* sdtestflg */
4050                    	; 1275              }
4051                    	; 1276          }
4052                    	; 1277      if (sdtestflg)
4053                    	; 1278          {
4054                    	; 1279          printf("First 16 GPT entries scanned\n");
4055                    	; 1280          } /* sdtestflg */
4056                    	; 1281      }
4057                    	; 1282  
4058                    	; 1283  /* Analyze and print MBR partition entry
4059                    	; 1284   * Returns:
4060                    	; 1285   *    -1 if errror - should not happen
4061                    	; 1286   *     0 if not used entry
4062                    	; 1287   *     1 if MBR entry
4063                    	; 1288   *     2 if EBR entry
4064                    	; 1289   *     3 if GTP entry
4065                    	; 1290   */
4066                    	; 1291  int sdmbrentry(unsigned char *partptr)
4067                    	; 1292      {
4068                    	; 1293      int index;
4069                    	; 1294      int parttype;
4070                    	; 1295      unsigned long lbastart;
4071                    	; 1296      unsigned long lbasize;
4072                    	; 1297  
4073                    	; 1298      parttype = PARTMBR;
4074                    	; 1299      if (!partptr[4])
4075                    	; 1300          {
4076                    	; 1301          if (sdtestflg)
4077                    	; 1302              {
4078                    	; 1303              printf("Not used entry\n");
4079                    	; 1304              } /* sdtestflg */
4080                    	; 1305          return (PARTZRO);
4081                    	; 1306          }
4082                    	; 1307      if (sdtestflg)
4083                    	; 1308          {
4084                    	; 1309          printf("Boot indicator: 0x%02x, System ID: 0x%02x\n",
4085                    	; 1310                 partptr[0], partptr[4]);
4086                    	; 1311  
4087                    	; 1312          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f))
4088                    	; 1313              {
4089                    	; 1314              printf("  Extended partition entry\n");
4090                    	; 1315              }
4091                    	; 1316          if (partptr[0] & 0x01)
4092                    	; 1317              {
4093                    	; 1318              printf("  Unofficial 48 bit LBA Proposed MBR Format, no CHS\n");
4094                    	; 1319              /* this is however discussed
4095                    	; 1320                 https://wiki.osdev.org/Partition_Table#.22Unofficial.22_48_bit_LBA_Proposed_MBR_Format
   0                    	; 1321              */
   1                    	; 1322              }
   2                    	; 1323          else
   3                    	; 1324              {
   4                    	; 1325              printf("  begin CHS: 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
   5                    	; 1326                     partptr[1], partptr[2], partptr[3],
   6                    	; 1327                     ((partptr[2] & 0xc0) >> 2) + partptr[3],
   7                    	; 1328                     partptr[1],
   8                    	; 1329                     partptr[2] & 0x3f);
   9                    	; 1330              printf("  end CHS 0x%02x-0x%02x-0x%02x (cyl: %d, head: %d sector: %d)\n",
  10                    	; 1331                     partptr[5], partptr[6], partptr[7],
  11                    	; 1332                     ((partptr[6] & 0xc0) >> 2) + partptr[7],
  12                    	; 1333                     partptr[5],
  13                    	; 1334                     partptr[6] & 0x3f);
  14                    	; 1335              }
  15                    	; 1336          } /* sdtestflg */
  16                    	; 1337      /* not showing high 16 bits if 48 bit LBA */
  17                    	; 1338      lbastart = (unsigned long)partptr[8] +
  18                    	; 1339                 ((unsigned long)partptr[9] << 8) +
  19                    	; 1340                 ((unsigned long)partptr[10] << 16) +
  20                    	; 1341                 ((unsigned long)partptr[11] << 24);
  21                    	; 1342      lbasize = (unsigned long)partptr[12] +
  22                    	; 1343                ((unsigned long)partptr[13] << 8) +
  23                    	; 1344                ((unsigned long)partptr[14] << 16) +
  24                    	; 1345                ((unsigned long)partptr[15] << 24);
  25                    	; 1346  
  26                    	; 1347      if (!(partptr[4] == 0xee)) /* not pointing to a GPT partition */
  27                    	; 1348          {
  28                    	; 1349          if ((partptr[4] == 0x05) || (partptr[4] == 0x0f)) /* EBR partition */
  29                    	; 1350              {
  30                    	; 1351              parttype = PARTEBR;
  31                    	; 1352              if (curblkno == 0) /* points to EBR in the MBR */
  32                    	; 1353                  {
  33                    	; 1354                  ebrnext = 0;
  34                    	; 1355                  dskmap[partdsk].partype = EBRCONT;
  35                    	; 1356                  dskmap[partdsk].dskletter = 'A' + partdsk;
  36                    	; 1357                  dskmap[partdsk].dskstart = lbastart;
  37                    	; 1358                  dskmap[partdsk].dskend = lbastart + lbasize - 1;
  38                    	; 1359                  dskmap[partdsk].dsksize = lbasize;
  39                    	; 1360                  dskmap[partdsk].dsktype[0] = partptr[4];
  40                    	; 1361                  partdsk++;
  41                    	; 1362                  ebrrecs[ebrrecidx++] = lbastart; /* save to handle later */
  42                    	; 1363                  }
  43                    	; 1364              else
  44                    	; 1365                  {
  45                    	; 1366                  ebrnext = curblkno + lbastart;
  46                    	; 1367                  }
  47                    	; 1368              }
  48                    	; 1369          else
  49                    	; 1370              {
  50                    	; 1371              if (0 < lbasize) /* one more ugly hack to avoid empty partitions */
  51                    	; 1372                  {
  52                    	; 1373                  if (partptr[0] & 0x80)
  53                    	; 1374                      dskmap[partdsk].bootable = YES;
  54                    	; 1375                  if (curblkno == 0)
  55                    	; 1376                      dskmap[partdsk].partype = PARTMBR;
  56                    	; 1377                  else
  57                    	; 1378                      dskmap[partdsk].partype = PARTEBR;
  58                    	; 1379                  dskmap[partdsk].dskletter = 'A' + partdsk;
  59                    	; 1380                  dskmap[partdsk].dskstart = curblkno + lbastart;
  60                    	; 1381                  dskmap[partdsk].dskend = curblkno + lbastart + lbasize - 1;
  61                    	; 1382                  dskmap[partdsk].dsksize = lbasize;
  62                    	; 1383                  dskmap[partdsk].dsktype[0] = partptr[4];
  63                    	; 1384                  partdsk++;
  64                    	; 1385                  }
  65                    	; 1386              }
  66                    	; 1387          }
  67                    	; 1388  
  68                    	; 1389      if (sdtestflg)
  69                    	; 1390          {
  70                    	; 1391          printf("  partition start LBA: %lu [%08lx]\n",
  71                    	; 1392                 curblkno + lbastart, curblkno + lbastart);
  72                    	; 1393          printf("  partition size LBA: %lu [%08lx], %lu MByte\n",
  73                    	; 1394                 lbasize, lbasize, lbasize >> 11);
  74                    	; 1395          } /* sdtestflg */
  75                    	; 1396      if (partptr[4] == 0xee) /* GPT partitions */
  76                    	; 1397          {
  77                    	; 1398          parttype = PARTGPT;
  78                    	; 1399          if (sdtestflg)
  79                    	; 1400              {
  80                    	; 1401              printf("GTP partitions\n");
  81                    	; 1402              } /* sdtestflg */
  82                    	; 1403          sdgpthdr(lbastart); /* handle GTP partitions */
  83                    	; 1404          /* re-read MBR on sector 0
  84                    	; 1405             This is probably not needed as there
  85                    	; 1406             is only one entry (the first one)
  86                    	; 1407             in the MBR when using GPT */
  87                    	; 1408          if (sdread(sdrdbuf, 0))
  88                    	; 1409              {
  89                    	; 1410              curblkno = 0;
  90                    	; 1411              curblkok = YES;
  91                    	; 1412              }
  92                    	; 1413          else
  93                    	; 1414              {
  94                    	; 1415              if (sdtestflg)
  95                    	; 1416                  {
  96                    	; 1417                  printf("  can't read MBR on sector 0\n");
  97                    	; 1418                  } /* sdtestflg */
  98                    	; 1419              return(-1);
  99                    	; 1420              }
 100                    	; 1421          }
 101                    	; 1422      return (parttype);
 102                    	; 1423      }
 103                    	; 1424  
 104                    	; 1425  /* Read and analyze MBR/EBR partition sector block
 105                    	; 1426   * and go through and print partition entries.
 106                    	; 1427   */
 107                    	; 1428  void sdmbrpart(unsigned long sector)
 108                    	; 1429      {
 109                    	; 1430      int partidx;  /* partition index 1 - 4 */
 110                    	; 1431      int cpartidx; /* chain partition index 1 - 4 */
 111                    	; 1432      int chainidx;
 112                    	; 1433      int enttype;
 113                    	; 1434      unsigned char *entp; /* pointer to partition entry */
 114                    	; 1435      char *mbrebr;
 115                    	; 1436  
 116                    	; 1437      if (sdtestflg)
 117                    	; 1438          {
 118                    	; 1439          if (sector == 0) /* if sector 0 it is MBR else it is EBR */
 119                    	; 1440              mbrebr = "MBR";
 120                    	; 1441          else
 121                    	; 1442              mbrebr = "EBR";
 122                    	; 1443          printf("Read %s from sector %lu\n", mbrebr, sector);
 123                    	; 1444          } /* sdtestflg */
 124                    	; 1445      if (sdread(sdrdbuf, sector))
 125                    	; 1446          {
 126                    	; 1447          curblkno = sector;
 127                    	; 1448          curblkok = YES;
 128                    	; 1449          }
 129                    	; 1450      else
 130                    	; 1451          {
 131                    	; 1452          if (sdtestflg)
 132                    	; 1453              {
 133                    	; 1454              printf("  can't read %s sector %lu\n", mbrebr, sector);
 134                    	; 1455              } /* sdtestflg */
 135                    	; 1456          return;
 136                    	; 1457          }
 137                    	; 1458      if (!((sdrdbuf[0x1fe] == 0x55) && (sdrdbuf[0x1ff] == 0xaa)))
 138                    	; 1459          {
 139                    	; 1460          if (sdtestflg)
 140                    	; 1461              {
 141                    	; 1462              printf("  no %s boot signature found\n", mbrebr);
 142                    	; 1463              } /* sdtestflg */
 143                    	; 1464          return;
 144                    	; 1465          }
 145                    	; 1466      if (curblkno == 0)
 146                    	; 1467          {
 147                    	; 1468          memcpy(dsksign, &sdrdbuf[0x1b8], sizeof dsksign);
 148                    	; 1469          if (sdtestflg)
 149                    	; 1470              {
 150                    	; 1471  
 151                    	; 1472              printf("  disk identifier: 0x%02x%02x%02x%02x\n",
 152                    	; 1473                     dsksign[3], dsksign[2], dsksign[1], dsksign[0]);
 153                    	; 1474              } /* sdtestflg */
 154                    	; 1475          }
 155                    	; 1476      /* go through MBR partition entries until first empty */
 156                    	; 1477      /* !!as the MBR entry routine is called recusively a way is
 157                    	; 1478         needed to read sector 0 when going back to MBR if
 158                    	; 1479         there is a primary partition entry after an EBR entry!! */
 159                    	; 1480      entp = &sdrdbuf[0x01be] ;
 160                    	; 1481      for (partidx = 1; (partidx <= 4) && (partdsk < 16); partidx++, entp += 16)
 161                    	; 1482          {
 162                    	; 1483          if (sdtestflg)
 163                    	; 1484              {
 164                    	; 1485              printf("%s partition entry %d: ", mbrebr, partidx);
 165                    	; 1486              } /* sdtestflg */
 166                    	; 1487          enttype = sdmbrentry(entp);
 167                    	; 1488          if (enttype == -1) /* read error */
 168                    	; 1489                   return;
 169                    	; 1490          else if (enttype == PARTZRO)
 170                    	; 1491              {
 171                    	; 1492              if (!sdtestflg)
 172                    	; 1493                  {
 173                    	; 1494                  /* if compiled as test program show also empty partitions */
 174                    	; 1495                  break;
 175                    	; 1496                  } /* sdtestflg */
 176                    	; 1497              }
 177                    	; 1498          }
 178                    	; 1499      /* now handle the previously saved EBR partition sectors */
 179                    	; 1500      for (partidx = 0; (partidx < ebrrecidx) && (partdsk < 16); partidx++)
 180                    	; 1501          {
 181                    	; 1502          if (sdread(sdrdbuf, ebrrecs[partidx]))
 182                    	; 1503              {
 183                    	; 1504              curblkno = ebrrecs[partidx];
 184                    	; 1505              curblkok = YES;
 185                    	; 1506              }
 186                    	; 1507          else
 187                    	; 1508              {
 188                    	; 1509              if (sdtestflg)
 189                    	; 1510                  {
 190                    	; 1511                  printf("  can't read %s sector %lu\n", mbrebr, sector);
 191                    	; 1512                  } /* sdtestflg */
 192                    	; 1513              return;
 193                    	; 1514              }
 194                    	; 1515          entp = &sdrdbuf[0x01be] ;
 195                    	; 1516          for (partidx = 1; (partidx <= 4) && (partdsk < 16); partidx++, entp += 16)
 196                    	; 1517              {
 197                    	; 1518              if (sdtestflg)
 198                    	; 1519                  {
 199                    	; 1520                  printf("EBR partition entry %d: ", partidx);
 200                    	; 1521                  } /* sdtestflg */
 201                    	; 1522              enttype = sdmbrentry(entp);
 202                    	; 1523              if (enttype == -1) /* read error */
 203                    	; 1524                   return;
 204                    	; 1525              else if (enttype == PARTZRO) /* empty partition entry */
 205                    	; 1526                  {
 206                    	; 1527                  if (sdtestflg)
 207                    	; 1528                      {
 208                    	; 1529                      /* if compiled as test program show also empty partitions */
 209                    	; 1530                      printf("Empty partition entry\n");
 210                    	; 1531                      } /* sdtestflg */
 211                    	; 1532                  else
 212                    	; 1533                      break;
 213                    	; 1534                  }
 214                    	; 1535              else if (enttype == PARTEBR) /* next chained EBR */
 215                    	; 1536                  {
 216                    	; 1537                  if (sdtestflg)
 217                    	; 1538                      {
 218                    	; 1539                      printf("EBR chain\n");
 219                    	; 1540                      } /* sdtestflg */
 220                    	; 1541                  /* follow the EBR chain */
 221                    	; 1542                  for (chainidx = 0;
 222                    	; 1543                      ebrnext && (chainidx < 16) && (partdsk < 16);
 223                    	; 1544                      chainidx++)
 224                    	; 1545                      {
 225                    	; 1546                      /* ugly hack to stop reading the same sector */
 226                    	; 1547                      if (ebrnext == curblkno)
 227                    	; 1548                           break;
 228                    	; 1549                      if (sdread(sdrdbuf, ebrnext))
 229                    	; 1550                          {
 230                    	; 1551                          curblkno = ebrnext;
 231                    	; 1552                          curblkok = YES;
 232                    	; 1553                          }
 233                    	; 1554                      else
 234                    	; 1555                          {
 235                    	; 1556                          if (sdtestflg)
 236                    	; 1557                              {
 237                    	; 1558                              printf("  can't read %s sector %lu\n", mbrebr, sector);
 238                    	; 1559                              } /* sdtestflg */
 239                    	; 1560                          return;
 240                    	; 1561                          }
 241                    	; 1562                      entp = &sdrdbuf[0x01be] ;
 242                    	; 1563                      for (cpartidx = 1;
 243                    	; 1564                          (cpartidx <= 4) && (partdsk < 16);
 244                    	; 1565                          cpartidx++, entp += 16)
 245                    	; 1566                          {
 246                    	; 1567                          if (sdtestflg)
 247                    	; 1568                              {
 248                    	; 1569                              printf("EBR chained  partition entry %d: ",
 249                    	; 1570                                   cpartidx);
 250                    	; 1571                              } /* sdtestflg */
 251                    	; 1572                          enttype = sdmbrentry(entp);
 252                    	; 1573                          if (enttype == -1) /* read error */
 253                    	; 1574                              return;
 254                    	; 1575                          }
 255                    	; 1576                      }
 256                    	; 1577                  }
 257                    	; 1578              }
 258                    	; 1579          }
 259                    	; 1580      }
 260                    	; 1581  
 261                    	; 1582  /* Executing in RAM or EPROM
 262                    	; 1583   */
 263                    	; 1584  void execin()
 264                    	; 1585      {
 265                    	; 1586      printf(", executing in: ");
 266                    	; 1587      rampptr = &ramprobe;
 267                    	; 1588      *rampptr = 1; /* try to change const */
 268                    	; 1589      if (ramprobe)
 269                    	; 1590          printf("RAM\n");
 270                    	; 1591      else
 271                    	; 1592          printf("EPROM\n");
 272                    	; 1593      *rampptr = 0;
 273                    	; 1594      }
 274                    	; 1595  
 275                    	; 1596  /* Test init, read and partitions on SD card over the SPI interface,
 276                    	; 1597   * boot from SD card, upload with Xmodem
 277                    	; 1598   */
 278                    	; 1599  int main()
 279                    	; 1600      {
 280                    	; 1601      char txtin[10];
 281                    	; 1602      int cmdin;
 282                    	; 1603      int idx;
 283                    	; 1604      int cmpidx;
 284                    	; 1605      unsigned char *cmpptr;
 285                    	; 1606      int inlength;
 286                    	; 1607      unsigned long blockno;
 287                    	; 1608  
 288                    	; 1609      blockno = 0;
 289                    	; 1610      curblkno = 0;
 290                    	; 1611      curblkok = NO;
 291                    	; 1612      sdinitok = NO; /* SD card not initialized yet */
 292                    	; 1613  
 293                    	; 1614      printf(PRGNAME);
 294                    	; 1615      printf(VERSION);
 295                    	; 1616      printf(builddate);
 296                    	; 1617      execin();
 297                    	; 1618      while (YES) /* forever (until Ctrl-C) */
 298                    	; 1619          {
 299                    	; 1620          printf("cmd (? for help): ");
 300                    	; 1621  
 301                    	; 1622          cmdin = getchar();
 302                    	; 1623          switch (cmdin)
 303                    	; 1624              {
 304                    	; 1625              case '?':
 305                    	; 1626                  printf(" ? - help\n");
 306                    	; 1627                  printf(PRGNAME);
 307                    	; 1628                  printf(VERSION);
 308                    	; 1629                  printf(builddate);
 309                    	; 1630                  execin();
 310                    	; 1631                  printf("Commands:\n");
 311                    	; 1632                  printf("  ? - help\n");
 312                    	; 1633                  printf("  b - boot from SD card\n");
 313                    	; 1634                  printf("  d - debug on/off\n");
 314                    	; 1635                  printf("  i - initialize SD card\n");
 315                    	; 1636                  printf("  l - print SD card partition layout\n");
 316                    	; 1637                  printf("  n - set/show sector #N to read/write\n");
 317                    	; 1638                  printf("  p - print sector last read/to write\n");
 318                    	; 1639                  printf("  r - read sector #N\n");
 319                    	; 1640                  printf("  s - print SD registers\n");
 320                    	; 1641                  printf("  t - test probe SD card\n");
 321                    	; 1642                  printf("  u - upload code with Xmodem to RAM address 0x0000\n");
 322                    	; 1643                  printf("  w - write sector #N\n");
 323                    	; 1644                  printf("  Ctrl-C to reload monitor from EPROM\n");
 324                    	; 1645                  break;
 325                    	; 1646              case 'b':
 326                    	; 1647                  printf(" d - boot from SD card - ");
 327                    	; 1648                  printf("implementation ongoing\n");
 328                    	; 1649                  break;
 329                    	; 1650              case 'd':
 330                    	; 1651                  printf(" d - toggle debug flag - ");
 331                    	; 1652                  if (sdtestflg)
 332                    	; 1653                      {
 333                    	; 1654                      sdtestflg = NO;
 334                    	; 1655                      printf("OFF\n");
 335                    	; 1656                      }
 336                    	; 1657                  else
 337                    	; 1658                      {
 338                    	; 1659                      sdtestflg = YES;
 339                    	; 1660                      printf("ON\n");
 340                    	; 1661                      }
 341                    	; 1662                  break;
 342                    	; 1663              case 'i':
 343                    	; 1664                  printf(" i - initialize SD card");
 344                    	; 1665                  if (sdinit())
 345                    	; 1666                      printf(" - ok\n");
 346                    	; 1667                  else
 347                    	; 1668                      printf(" - not inserted or faulty\n");
 348                    	; 1669                  break;
 349                    	; 1670              case 'l':
 350                    	; 1671                  printf(" l - print partition layout\n");
 351                    	; 1672                  if (!sdprobe())
 352                    	; 1673                      {
 353                    	; 1674                      printf(" - SD not initialized or inserted or faulty\n");
 354                    	; 1675                      break;
 355                    	; 1676                      }
 356                    	; 1677                  ebrrecidx = 0;
 357    49FF  210000    		ld	hl,0
 358    4A02  221600    		ld	(_ebrrecidx),hl
 359    4A05  220E00    		ld	(_partdsk),hl
 360                    	; 1678                  partdsk = 0;
 361                    	; 1679                  memset(dskmap, 0, sizeof dskmap);
 362    4A08  210002    		ld	hl,512
 363    4A0B  E5        		push	hl
 364    4A0C  210000    		ld	hl,0
 365    4A0F  E5        		push	hl
 366    4A10  215202    		ld	hl,_dskmap
 367    4A13  CD0000    		call	_memset
 368    4A16  F1        		pop	af
 369    4A17  F1        		pop	af
 370                    	; 1680                  sdmbrpart(0);
 371    4A18  21B645    		ld	hl,L412+3
 372    4A1B  46        		ld	b,(hl)
 373    4A1C  2B        		dec	hl
 374    4A1D  4E        		ld	c,(hl)
 375    4A1E  C5        		push	bc
 376    4A1F  2B        		dec	hl
 377    4A20  46        		ld	b,(hl)
 378    4A21  2B        		dec	hl
 379    4A22  4E        		ld	c,(hl)
 380    4A23  C5        		push	bc
 381    4A24  E1        		pop	hl
 382    4A25  CD963E    		call	_sdmbrpart
 383    4A28  F1        		pop	af
 384                    	; 1681                  printf("      Disk partition sectors on SD card\n");
 385    4A29  21B745    		ld	hl,L5723
 386    4A2C  CD0000    		call	_printf
 387                    	; 1682                  printf("       MBR disk identifier: 0x%02x%02x%02x%02x\n",
 388                    	; 1683                         dsksign[3], dsksign[2], dsksign[1], dsksign[0]);
 389    4A2F  3A4E02    		ld	a,(_dsksign)
 390    4A32  4F        		ld	c,a
 391    4A33  97        		sub	a
 392    4A34  47        		ld	b,a
 393    4A35  C5        		push	bc
 394    4A36  3A4F02    		ld	a,(_dsksign+1)
 395    4A39  4F        		ld	c,a
 396    4A3A  97        		sub	a
 397    4A3B  47        		ld	b,a
 398    4A3C  C5        		push	bc
 399    4A3D  3A5002    		ld	a,(_dsksign+2)
 400    4A40  4F        		ld	c,a
 401    4A41  97        		sub	a
 402    4A42  47        		ld	b,a
 403    4A43  C5        		push	bc
 404    4A44  3A5102    		ld	a,(_dsksign+3)
 405    4A47  4F        		ld	c,a
 406    4A48  97        		sub	a
 407    4A49  47        		ld	b,a
 408    4A4A  C5        		push	bc
 409    4A4B  21E045    		ld	hl,L5033
 410    4A4E  CD0000    		call	_printf
 411    4A51  F1        		pop	af
 412    4A52  F1        		pop	af
 413    4A53  F1        		pop	af
 414    4A54  F1        		pop	af
 415                    	; 1684                  printf(" Disk     Start      End     Size Part Type Id\n");
 416    4A55  211046    		ld	hl,L5133
 417    4A58  CD0000    		call	_printf
 418                    	; 1685                  printf(" ----     -----      ---     ---- ---- ---- --\n");
 419    4A5B  214046    		ld	hl,L5233
 420    4A5E  CD0000    		call	_printf
 421                    	; 1686                  for (idx = 0; idx < 16; idx++)
 422    4A61  DD36EC00  		ld	(ix-20),0
 423    4A65  DD36ED00  		ld	(ix-19),0
 424                    	L1046:
 425    4A69  DD7EEC    		ld	a,(ix-20)
 426    4A6C  D610      		sub	16
 427    4A6E  DD7EED    		ld	a,(ix-19)
 428    4A71  DE00      		sbc	a,0
 429    4A73  F20349    		jp	p,L1226
 430                    	; 1687                      {
 431                    	; 1688                      if (dskmap[idx].dskletter)
 432    4A76  DD6EEC    		ld	l,(ix-20)
 433    4A79  DD66ED    		ld	h,(ix-19)
 434    4A7C  E5        		push	hl
 435    4A7D  212000    		ld	hl,32
 436    4A80  E5        		push	hl
 437    4A81  CD0000    		call	c.imul
 438    4A84  E1        		pop	hl
 439    4A85  015302    		ld	bc,_dskmap+1
 440    4A88  09        		add	hl,bc
 441    4A89  7E        		ld	a,(hl)
 442    4A8A  B7        		or	a
 443    4A8B  CA734B    		jp	z,L1246
 444                    	; 1689                          {
 445                    	; 1690                          printf("%2d (%c)%c", dskmap[idx].dskletter - 'A' + 1,
 446                    	; 1691                                 dskmap[idx].dskletter,
 447                    	; 1692                                 dskmap[idx].bootable ? '*' : ' ');
 448    4A8E  DD6EEC    		ld	l,(ix-20)
 449    4A91  DD66ED    		ld	h,(ix-19)
 450    4A94  E5        		push	hl
 451    4A95  212000    		ld	hl,32
 452    4A98  E5        		push	hl
 453    4A99  CD0000    		call	c.imul
 454    4A9C  E1        		pop	hl
 455    4A9D  015402    		ld	bc,_dskmap+2
 456    4AA0  09        		add	hl,bc
 457    4AA1  7E        		ld	a,(hl)
 458    4AA2  23        		inc	hl
 459    4AA3  B6        		or	(hl)
 460    4AA4  2805      		jr	z,L022
 461    4AA6  012A00    		ld	bc,42
 462    4AA9  1803      		jr	L222
 463                    	L022:
 464    4AAB  012000    		ld	bc,32
 465                    	L222:
 466    4AAE  C5        		push	bc
 467    4AAF  DD6EEC    		ld	l,(ix-20)
 468    4AB2  DD66ED    		ld	h,(ix-19)
 469    4AB5  E5        		push	hl
 470    4AB6  212000    		ld	hl,32
 471    4AB9  E5        		push	hl
 472    4ABA  CD0000    		call	c.imul
 473    4ABD  E1        		pop	hl
 474    4ABE  015302    		ld	bc,_dskmap+1
 475    4AC1  09        		add	hl,bc
 476    4AC2  4E        		ld	c,(hl)
 477    4AC3  97        		sub	a
 478    4AC4  47        		ld	b,a
 479    4AC5  C5        		push	bc
 480    4AC6  DD6EEC    		ld	l,(ix-20)
 481    4AC9  DD66ED    		ld	h,(ix-19)
 482    4ACC  E5        		push	hl
 483    4ACD  212000    		ld	hl,32
 484    4AD0  E5        		push	hl
 485    4AD1  CD0000    		call	c.imul
 486    4AD4  E1        		pop	hl
 487    4AD5  015302    		ld	bc,_dskmap+1
 488    4AD8  09        		add	hl,bc
 489    4AD9  6E        		ld	l,(hl)
 490    4ADA  97        		sub	a
 491    4ADB  67        		ld	h,a
 492    4ADC  01C0FF    		ld	bc,65472
 493    4ADF  09        		add	hl,bc
 494    4AE0  E5        		push	hl
 495    4AE1  217046    		ld	hl,L5333
 496    4AE4  CD0000    		call	_printf
 497    4AE7  F1        		pop	af
 498    4AE8  F1        		pop	af
 499    4AE9  F1        		pop	af
 500                    	; 1693                          printf("%8lu %8lu %8lu ",
 501                    	; 1694                                 dskmap[idx].dskstart, dskmap[idx].dskend,
 502                    	; 1695                                 dskmap[idx].dsksize);
 503    4AEA  DD6EEC    		ld	l,(ix-20)
 504    4AED  DD66ED    		ld	h,(ix-19)
 505    4AF0  E5        		push	hl
 506    4AF1  212000    		ld	hl,32
 507    4AF4  E5        		push	hl
 508    4AF5  CD0000    		call	c.imul
 509    4AF8  E1        		pop	hl
 510    4AF9  015E02    		ld	bc,_dskmap+12
 511    4AFC  09        		add	hl,bc
 512    4AFD  23        		inc	hl
 513    4AFE  23        		inc	hl
 514    4AFF  4E        		ld	c,(hl)
 515    4B00  23        		inc	hl
 516    4B01  46        		ld	b,(hl)
 517    4B02  C5        		push	bc
 518    4B03  2B        		dec	hl
 519    4B04  2B        		dec	hl
 520    4B05  2B        		dec	hl
 521    4B06  4E        		ld	c,(hl)
 522    4B07  23        		inc	hl
 523    4B08  46        		ld	b,(hl)
 524    4B09  C5        		push	bc
 525    4B0A  DD6EEC    		ld	l,(ix-20)
 526    4B0D  DD66ED    		ld	h,(ix-19)
 527    4B10  E5        		push	hl
 528    4B11  212000    		ld	hl,32
 529    4B14  E5        		push	hl
 530    4B15  CD0000    		call	c.imul
 531    4B18  E1        		pop	hl
 532    4B19  015A02    		ld	bc,_dskmap+8
 533    4B1C  09        		add	hl,bc
 534    4B1D  23        		inc	hl
 535    4B1E  23        		inc	hl
 536    4B1F  4E        		ld	c,(hl)
 537    4B20  23        		inc	hl
 538    4B21  46        		ld	b,(hl)
 539    4B22  C5        		push	bc
 540    4B23  2B        		dec	hl
 541    4B24  2B        		dec	hl
 542    4B25  2B        		dec	hl
 543    4B26  4E        		ld	c,(hl)
 544    4B27  23        		inc	hl
 545    4B28  46        		ld	b,(hl)
 546    4B29  C5        		push	bc
 547    4B2A  DD6EEC    		ld	l,(ix-20)
 548    4B2D  DD66ED    		ld	h,(ix-19)
 549    4B30  E5        		push	hl
 550    4B31  212000    		ld	hl,32
 551    4B34  E5        		push	hl
 552    4B35  CD0000    		call	c.imul
 553    4B38  E1        		pop	hl
 554    4B39  015602    		ld	bc,_dskmap+4
 555    4B3C  09        		add	hl,bc
 556    4B3D  23        		inc	hl
 557    4B3E  23        		inc	hl
 558    4B3F  4E        		ld	c,(hl)
 559    4B40  23        		inc	hl
 560    4B41  46        		ld	b,(hl)
 561    4B42  C5        		push	bc
 562    4B43  2B        		dec	hl
 563    4B44  2B        		dec	hl
 564    4B45  2B        		dec	hl
 565    4B46  4E        		ld	c,(hl)
 566    4B47  23        		inc	hl
 567    4B48  46        		ld	b,(hl)
 568    4B49  C5        		push	bc
 569    4B4A  217B46    		ld	hl,L5433
 570    4B4D  CD0000    		call	_printf
 571    4B50  210C00    		ld	hl,12
 572    4B53  39        		add	hl,sp
 573    4B54  F9        		ld	sp,hl
 574                    	; 1696                          if (dskmap[idx].partype == EBRCONT)
 575    4B55  DD6EEC    		ld	l,(ix-20)
 576    4B58  DD66ED    		ld	h,(ix-19)
 577    4B5B  E5        		push	hl
 578    4B5C  212000    		ld	hl,32
 579    4B5F  E5        		push	hl
 580    4B60  CD0000    		call	c.imul
 581    4B63  E1        		pop	hl
 582    4B64  015202    		ld	bc,_dskmap
 583    4B67  09        		add	hl,bc
 584    4B68  7E        		ld	a,(hl)
 585    4B69  FE14      		cp	20
 586    4B6B  2011      		jr	nz,L1546
 587                    	; 1697                              {
 588                    	; 1698                              printf(" EBR container\n");
 589    4B6D  218B46    		ld	hl,L5533
 590    4B70  CD0000    		call	_printf
 591                    	; 1699                              }
 592                    	; 1700                          else
 593                    	L1246:
 594    4B73  DD34EC    		inc	(ix-20)
 595    4B76  2003      		jr	nz,L612
 596    4B78  DD34ED    		inc	(ix-19)
 597                    	L612:
 598    4B7B  C3694A    		jp	L1046
 599                    	L1546:
 600                    	; 1701                              {
 601                    	; 1702                              if (dskmap[idx].partype == PARTGPT)
 602    4B7E  DD6EEC    		ld	l,(ix-20)
 603    4B81  DD66ED    		ld	h,(ix-19)
 604    4B84  E5        		push	hl
 605    4B85  212000    		ld	hl,32
 606    4B88  E5        		push	hl
 607    4B89  CD0000    		call	c.imul
 608    4B8C  E1        		pop	hl
 609    4B8D  015202    		ld	bc,_dskmap
 610    4B90  09        		add	hl,bc
 611    4B91  7E        		ld	a,(hl)
 612    4B92  FE03      		cp	3
 613    4B94  C2284C    		jp	nz,L1746
 614                    	; 1703                                  {
 615                    	; 1704                                  printf(" GPT ");
 616    4B97  219B46    		ld	hl,L5633
 617    4B9A  CD0000    		call	_printf
 618                    	; 1705                                  /*if (memcmp(dskmap[idx].dsktype, gptcpm, 16) == 0)
 619                    	; 1706                                    not really working as I expected ? */
 620                    	; 1707                                  cmpptr = dskmap[idx].dsktype;
 621    4B9D  DD6EEC    		ld	l,(ix-20)
 622    4BA0  DD66ED    		ld	h,(ix-19)
 623    4BA3  E5        		push	hl
 624    4BA4  212000    		ld	hl,32
 625    4BA7  E5        		push	hl
 626    4BA8  CD0000    		call	c.imul
 627    4BAB  E1        		pop	hl
 628    4BAC  016202    		ld	bc,_dskmap+16
 629    4BAF  09        		add	hl,bc
 630    4BB0  DD75E8    		ld	(ix-24),l
 631    4BB3  DD74E9    		ld	(ix-23),h
 632                    	; 1708                                  for (cmpidx = 0; cmpidx < 16; cmpidx++, cmpptr++)
 633    4BB6  DD36EA00  		ld	(ix-22),0
 634    4BBA  DD36EB00  		ld	(ix-21),0
 635                    	L1056:
 636    4BBE  DD7EEA    		ld	a,(ix-22)
 637    4BC1  D610      		sub	16
 638    4BC3  DD7EEB    		ld	a,(ix-21)
 639    4BC6  DE00      		sbc	a,0
 640    4BC8  F2F34B    		jp	p,L1156
 641                    	; 1709                                      {
 642                    	; 1710                                      if (gptcpm[cmpidx] != *cmpptr)
 643    4BCB  215500    		ld	hl,_gptcpm
 644    4BCE  DD4EEA    		ld	c,(ix-22)
 645    4BD1  DD46EB    		ld	b,(ix-21)
 646    4BD4  09        		add	hl,bc
 647    4BD5  DD4EE8    		ld	c,(ix-24)
 648    4BD8  DD46E9    		ld	b,(ix-23)
 649    4BDB  0A        		ld	a,(bc)
 650    4BDC  4F        		ld	c,a
 651    4BDD  7E        		ld	a,(hl)
 652    4BDE  B9        		cp	c
 653    4BDF  2012      		jr	nz,L1156
 654                    	; 1711                                          break;
 655                    	L1256:
 656    4BE1  DD34EA    		inc	(ix-22)
 657    4BE4  2003      		jr	nz,L422
 658    4BE6  DD34EB    		inc	(ix-21)
 659                    	L422:
 660    4BE9  DD34E8    		inc	(ix-24)
 661    4BEC  2003      		jr	nz,L622
 662    4BEE  DD34E9    		inc	(ix-23)
 663                    	L622:
 664    4BF1  18CB      		jr	L1056
 665                    	L1156:
 666                    	; 1712                                      }
 667                    	; 1713                                  if (cmpidx == 16)
 668    4BF3  DD7EEA    		ld	a,(ix-22)
 669    4BF6  FE10      		cp	16
 670    4BF8  2005      		jr	nz,L032
 671    4BFA  DD7EEB    		ld	a,(ix-21)
 672    4BFD  FE00      		cp	0
 673                    	L032:
 674    4BFF  2008      		jr	nz,L1556
 675                    	; 1714                                      printf("CP/M ");
 676    4C01  21A146    		ld	hl,L5733
 677    4C04  CD0000    		call	_printf
 678                    	; 1715                                  else
 679    4C07  1806      		jr	L1656
 680                    	L1556:
 681                    	; 1716                                      printf(" ??  ");
 682    4C09  21A746    		ld	hl,L5043
 683    4C0C  CD0000    		call	_printf
 684                    	L1656:
 685                    	; 1717                                  prtguid(dskmap[idx].dsktype);
 686    4C0F  DD6EEC    		ld	l,(ix-20)
 687    4C12  DD66ED    		ld	h,(ix-19)
 688    4C15  E5        		push	hl
 689    4C16  212000    		ld	hl,32
 690    4C19  E5        		push	hl
 691    4C1A  CD0000    		call	c.imul
 692    4C1D  E1        		pop	hl
 693    4C1E  016202    		ld	bc,_dskmap+16
 694    4C21  09        		add	hl,bc
 695    4C22  CD6829    		call	_prtguid
 696                    	; 1718                                  }
 697                    	; 1719                              else
 698    4C25  C3B84C    		jp	L1756
 699                    	L1746:
 700                    	; 1720                                  {
 701                    	; 1721                                  if (dskmap[idx].partype == PARTEBR)
 702    4C28  DD6EEC    		ld	l,(ix-20)
 703    4C2B  DD66ED    		ld	h,(ix-19)
 704    4C2E  E5        		push	hl
 705    4C2F  212000    		ld	hl,32
 706    4C32  E5        		push	hl
 707    4C33  CD0000    		call	c.imul
 708    4C36  E1        		pop	hl
 709    4C37  015202    		ld	bc,_dskmap
 710    4C3A  09        		add	hl,bc
 711    4C3B  7E        		ld	a,(hl)
 712    4C3C  FE02      		cp	2
 713    4C3E  2008      		jr	nz,L1066
 714                    	; 1722                                      printf(" EBR ");
 715    4C40  21AD46    		ld	hl,L5143
 716    4C43  CD0000    		call	_printf
 717                    	; 1723                                  else
 718    4C46  1806      		jr	L1166
 719                    	L1066:
 720                    	; 1724                                      printf(" MBR ");
 721    4C48  21B346    		ld	hl,L5243
 722    4C4B  CD0000    		call	_printf
 723                    	L1166:
 724                    	; 1725                                  if (dskmap[idx].dsktype[0] == mbrcpm)
 725    4C4E  DD6EEC    		ld	l,(ix-20)
 726    4C51  DD66ED    		ld	h,(ix-19)
 727    4C54  E5        		push	hl
 728    4C55  212000    		ld	hl,32
 729    4C58  E5        		push	hl
 730    4C59  CD0000    		call	c.imul
 731    4C5C  E1        		pop	hl
 732    4C5D  016202    		ld	bc,_dskmap+16
 733    4C60  09        		add	hl,bc
 734    4C61  3A6500    		ld	a,(_mbrcpm)
 735    4C64  4F        		ld	c,a
 736    4C65  7E        		ld	a,(hl)
 737    4C66  B9        		cp	c
 738    4C67  2008      		jr	nz,L1266
 739                    	; 1726                                      printf("CP/M ");
 740    4C69  21B946    		ld	hl,L5343
 741    4C6C  CD0000    		call	_printf
 742                    	; 1727                                  else if (dskmap[idx].dsktype[0] == mbrexcode)
 743    4C6F  1829      		jr	L1366
 744                    	L1266:
 745    4C71  DD6EEC    		ld	l,(ix-20)
 746    4C74  DD66ED    		ld	h,(ix-19)
 747    4C77  E5        		push	hl
 748    4C78  212000    		ld	hl,32
 749    4C7B  E5        		push	hl
 750    4C7C  CD0000    		call	c.imul
 751    4C7F  E1        		pop	hl
 752    4C80  016202    		ld	bc,_dskmap+16
 753    4C83  09        		add	hl,bc
 754    4C84  3A6600    		ld	a,(_mbrexcode)
 755    4C87  4F        		ld	c,a
 756    4C88  7E        		ld	a,(hl)
 757    4C89  B9        		cp	c
 758    4C8A  2008      		jr	nz,L1466
 759                    	; 1728                                      printf("Code ");
 760    4C8C  21BF46    		ld	hl,L5443
 761    4C8F  CD0000    		call	_printf
 762                    	; 1729                                  else
 763    4C92  1806      		jr	L1366
 764                    	L1466:
 765                    	; 1730                                      printf(" ??  ");
 766    4C94  21C546    		ld	hl,L5543
 767    4C97  CD0000    		call	_printf
 768                    	L1366:
 769                    	; 1731                                  printf("0x%02x", dskmap[idx].dsktype[0]);
 770    4C9A  DD6EEC    		ld	l,(ix-20)
 771    4C9D  DD66ED    		ld	h,(ix-19)
 772    4CA0  E5        		push	hl
 773    4CA1  212000    		ld	hl,32
 774    4CA4  E5        		push	hl
 775    4CA5  CD0000    		call	c.imul
 776    4CA8  E1        		pop	hl
 777    4CA9  016202    		ld	bc,_dskmap+16
 778    4CAC  09        		add	hl,bc
 779    4CAD  4E        		ld	c,(hl)
 780    4CAE  97        		sub	a
 781    4CAF  47        		ld	b,a
 782    4CB0  C5        		push	bc
 783    4CB1  21CB46    		ld	hl,L5643
 784    4CB4  CD0000    		call	_printf
 785    4CB7  F1        		pop	af
 786                    	L1756:
 787                    	; 1732                                  }
 788                    	; 1733                              printf("\n");
 789    4CB8  21D246    		ld	hl,L5743
 790    4CBB  CD0000    		call	_printf
 791    4CBE  C3734B    		jp	L1246
 792                    	L1666:
 793                    	; 1734                              }
 794                    	; 1735                          }
 795                    	; 1736                      }
 796                    	; 1737                  break;
 797                    	; 1738              case 'n':
 798                    	; 1739                  printf(" n - sector number: ");
 799    4CC1  21D446    		ld	hl,L5053
 800    4CC4  CD0000    		call	_printf
 801                    	; 1740                  if (getkline(txtin, sizeof txtin))
 802    4CC7  210A00    		ld	hl,10
 803    4CCA  E5        		push	hl
 804    4CCB  DDE5      		push	ix
 805    4CCD  C1        		pop	bc
 806    4CCE  21F0FF    		ld	hl,65520
 807    4CD1  09        		add	hl,bc
 808    4CD2  CD0000    		call	_getkline
 809    4CD5  F1        		pop	af
 810    4CD6  79        		ld	a,c
 811    4CD7  B0        		or	b
 812    4CD8  281A      		jr	z,L1766
 813                    	; 1741                      sscanf(txtin, "%lu", &blockno);
 814    4CDA  DDE5      		push	ix
 815    4CDC  C1        		pop	bc
 816    4CDD  21E2FF    		ld	hl,65506
 817    4CE0  09        		add	hl,bc
 818    4CE1  E5        		push	hl
 819    4CE2  21E946    		ld	hl,L5153
 820    4CE5  E5        		push	hl
 821    4CE6  DDE5      		push	ix
 822    4CE8  C1        		pop	bc
 823    4CE9  21F0FF    		ld	hl,65520
 824    4CEC  09        		add	hl,bc
 825    4CED  CD0000    		call	_sscanf
 826    4CF0  F1        		pop	af
 827    4CF1  F1        		pop	af
 828                    	; 1742                  else
 829    4CF2  1816      		jr	L1076
 830                    	L1766:
 831                    	; 1743                      printf("%lu", blockno);
 832    4CF4  DD66E5    		ld	h,(ix-27)
 833    4CF7  DD6EE4    		ld	l,(ix-28)
 834    4CFA  E5        		push	hl
 835    4CFB  DD66E3    		ld	h,(ix-29)
 836    4CFE  DD6EE2    		ld	l,(ix-30)
 837    4D01  E5        		push	hl
 838    4D02  21ED46    		ld	hl,L5253
 839    4D05  CD0000    		call	_printf
 840    4D08  F1        		pop	af
 841    4D09  F1        		pop	af
 842                    	L1076:
 843                    	; 1744                  printf("\n");
 844    4D0A  21F146    		ld	hl,L5353
 845    4D0D  CD0000    		call	_printf
 846                    	; 1745                  break;
 847    4D10  C30349    		jp	L1226
 848                    	L1176:
 849                    	; 1746              case 'p':
 850                    	; 1747                  printf(" p - print data sector %lu\n", curblkno);
 851    4D13  210500    		ld	hl,_curblkno+3
 852    4D16  46        		ld	b,(hl)
 853    4D17  2B        		dec	hl
 854    4D18  4E        		ld	c,(hl)
 855    4D19  C5        		push	bc
 856    4D1A  2B        		dec	hl
 857    4D1B  46        		ld	b,(hl)
 858    4D1C  2B        		dec	hl
 859    4D1D  4E        		ld	c,(hl)
 860    4D1E  C5        		push	bc
 861    4D1F  21F346    		ld	hl,L5453
 862    4D22  CD0000    		call	_printf
 863    4D25  F1        		pop	af
 864    4D26  F1        		pop	af
 865                    	; 1748                  sddatprt(sdrdbuf);
 866    4D27  214C00    		ld	hl,_sdrdbuf
 867    4D2A  CD8F27    		call	_sddatprt
 868                    	; 1749                  break;
 869    4D2D  C30349    		jp	L1226
 870                    	L1276:
 871                    	; 1750              case 'r':
 872                    	; 1751                  printf(" r - read sector");
 873    4D30  210F47    		ld	hl,L5553
 874    4D33  CD0000    		call	_printf
 875                    	; 1752                  if (!sdprobe())
 876    4D36  CD0B10    		call	_sdprobe
 877    4D39  79        		ld	a,c
 878    4D3A  B0        		or	b
 879    4D3B  2009      		jr	nz,L1376
 880                    	; 1753                      {
 881                    	; 1754                      printf(" - not initialized or inserted or faulty\n");
 882    4D3D  212047    		ld	hl,L5653
 883    4D40  CD0000    		call	_printf
 884                    	; 1755                      break;
 885    4D43  C30349    		jp	L1226
 886                    	L1376:
 887                    	; 1756                      }
 888                    	; 1757                  if (sdread(sdrdbuf, blockno))
 889    4D46  DD66E5    		ld	h,(ix-27)
 890    4D49  DD6EE4    		ld	l,(ix-28)
 891    4D4C  E5        		push	hl
 892    4D4D  DD66E3    		ld	h,(ix-29)
 893    4D50  DD6EE2    		ld	l,(ix-30)
 894    4D53  E5        		push	hl
 895    4D54  214C00    		ld	hl,_sdrdbuf
 896    4D57  CDE320    		call	_sdread
 897    4D5A  F1        		pop	af
 898    4D5B  F1        		pop	af
 899    4D5C  79        		ld	a,c
 900    4D5D  B0        		or	b
 901    4D5E  2819      		jr	z,L1476
 902                    	; 1758                      {
 903                    	; 1759                      printf(" - ok\n");
 904    4D60  214A47    		ld	hl,L5753
 905    4D63  CD0000    		call	_printf
 906                    	; 1760                      curblkno = blockno;
 907    4D66  210200    		ld	hl,_curblkno
 908    4D69  E5        		push	hl
 909    4D6A  DDE5      		push	ix
 910    4D6C  C1        		pop	bc
 911    4D6D  21E2FF    		ld	hl,65506
 912    4D70  09        		add	hl,bc
 913    4D71  E5        		push	hl
 914    4D72  CD0000    		call	c.mvl
 915    4D75  F1        		pop	af
 916                    	; 1761                      }
 917                    	; 1762                  else
 918    4D76  C30349    		jp	L1226
 919                    	L1476:
 920                    	; 1763                      printf(" - read error\n");
 921    4D79  215147    		ld	hl,L5063
 922    4D7C  CD0000    		call	_printf
 923    4D7F  C30349    		jp	L1226
 924                    	L1676:
 925                    	; 1764                  break;
 926                    	; 1765              case 's':
 927                    	; 1766                  printf(" s - print SD registers\n");
 928    4D82  216047    		ld	hl,L5163
 929    4D85  CD0000    		call	_printf
 930                    	; 1767                  sdprtreg();
 931    4D88  CD2D17    		call	_sdprtreg
 932                    	; 1768                  break;
 933    4D8B  C30349    		jp	L1226
 934                    	L1776:
 935                    	; 1769              case 't':
 936                    	; 1770                  printf(" t - test if card inserted\n");
 937    4D8E  217947    		ld	hl,L5263
 938    4D91  CD0000    		call	_printf
 939                    	; 1771                  if (sdprobe())
 940    4D94  CD0B10    		call	_sdprobe
 941    4D97  79        		ld	a,c
 942    4D98  B0        		or	b
 943    4D99  2809      		jr	z,L1007
 944                    	; 1772                      printf(" - ok\n");
 945    4D9B  219547    		ld	hl,L5363
 946    4D9E  CD0000    		call	_printf
 947                    	; 1773                  else
 948    4DA1  C30349    		jp	L1226
 949                    	L1007:
 950                    	; 1774                      printf(" - not initialized or inserted or faulty\n");
 951    4DA4  219C47    		ld	hl,L5463
 952    4DA7  CD0000    		call	_printf
 953    4DAA  C30349    		jp	L1226
 954                    	L1207:
 955                    	; 1775                  break;
 956                    	; 1776              case 'u':
 957                    	; 1777                  printf(" u - upload with Xmodem\n");
 958    4DAD  21C647    		ld	hl,L5563
 959    4DB0  CD0000    		call	_printf
 960                    	; 1778                  if (sdtestflg)
 961    4DB3  2A0000    		ld	hl,(_sdtestflg)
 962    4DB6  7C        		ld	a,h
 963    4DB7  B5        		or	l
 964    4DB8  2815      		jr	z,L1307
 965                    	; 1779                      {
 966                    	; 1780                      printf("Copy from: 0x%04x, to: 0x%04x, size: %d\n",
 967                    	; 1781                          upload, UPLADDR, upload_size);
 968    4DBA  2A0000    		ld	hl,(_upload_size)
 969    4DBD  E5        		push	hl
 970    4DBE  2100F0    		ld	hl,61440
 971    4DC1  E5        		push	hl
 972    4DC2  210000    		ld	hl,_upload
 973    4DC5  E5        		push	hl
 974    4DC6  21DF47    		ld	hl,L5663
 975    4DC9  CD0000    		call	_printf
 976    4DCC  F1        		pop	af
 977    4DCD  F1        		pop	af
 978    4DCE  F1        		pop	af
 979                    	L1307:
 980                    	; 1782                      } /* sdtestflg */
 981                    	; 1783                  memcpy(UPLADDR, upload, upload_size);
 982    4DCF  2A0000    		ld	hl,(_upload_size)
 983    4DD2  E5        		push	hl
 984    4DD3  210000    		ld	hl,_upload
 985    4DD6  E5        		push	hl
 986    4DD7  2100F0    		ld	hl,61440
 987    4DDA  CD0000    		call	_memcpy
 988    4DDD  F1        		pop	af
 989    4DDE  F1        		pop	af
 990                    	; 1784                  jumpto(UPLADDR);
 991    4DDF  2100F0    		ld	hl,61440
 992    4DE2  CD0000    		call	_jumpto
 993                    	; 1785                  break;
 994    4DE5  C30349    		jp	L1226
 995                    	L1407:
 996                    	; 1786              case 'w':
 997                    	; 1787                  printf(" w - write sector");
 998    4DE8  210848    		ld	hl,L5763
 999    4DEB  CD0000    		call	_printf
1000                    	; 1788                  if (!sdprobe())
1001    4DEE  CD0B10    		call	_sdprobe
1002    4DF1  79        		ld	a,c
1003    4DF2  B0        		or	b
1004    4DF3  2006      		jr	nz,L1507
1005                    	; 1789                      printf(" - not initialized or inserted or faulty\n");
1006    4DF5  211A48    		ld	hl,L5073
1007    4DF8  CD0000    		call	_printf
1008                    	L1507:
1009                    	; 1790                  if (sdwrite(sdrdbuf, blockno))
1010    4DFB  DD66E5    		ld	h,(ix-27)
1011    4DFE  DD6EE4    		ld	l,(ix-28)
1012    4E01  E5        		push	hl
1013    4E02  DD66E3    		ld	h,(ix-29)
1014    4E05  DD6EE2    		ld	l,(ix-30)
1015    4E08  E5        		push	hl
1016    4E09  214C00    		ld	hl,_sdrdbuf
1017    4E0C  CDA024    		call	_sdwrite
1018    4E0F  F1        		pop	af
1019    4E10  F1        		pop	af
1020    4E11  79        		ld	a,c
1021    4E12  B0        		or	b
1022    4E13  2819      		jr	z,L1607
1023                    	; 1791                      {
1024                    	; 1792                      printf(" - ok\n");
1025    4E15  214448    		ld	hl,L5173
1026    4E18  CD0000    		call	_printf
1027                    	; 1793                      curblkno = blockno;
1028    4E1B  210200    		ld	hl,_curblkno
1029    4E1E  E5        		push	hl
1030    4E1F  DDE5      		push	ix
1031    4E21  C1        		pop	bc
1032    4E22  21E2FF    		ld	hl,65506
1033    4E25  09        		add	hl,bc
1034    4E26  E5        		push	hl
1035    4E27  CD0000    		call	c.mvl
1036    4E2A  F1        		pop	af
1037                    	; 1794                      }
1038                    	; 1795                  else
1039    4E2B  C30349    		jp	L1226
1040                    	L1607:
1041                    	; 1796                      printf(" - write error\n");
1042    4E2E  214B48    		ld	hl,L5273
1043    4E31  CD0000    		call	_printf
1044    4E34  C30349    		jp	L1226
1045                    	L1017:
1046                    	; 1797                  break;
1047                    	; 1798              case 0x03: /* Ctrl-C */
1048                    	; 1799                  printf("reloading monitor from EPROM\n");
1049    4E37  215B48    		ld	hl,L5373
1050    4E3A  CD0000    		call	_printf
1051                    	; 1800                  reload();
1052    4E3D  CD0000    		call	_reload
1053                    	; 1801                  break; /* not really needed, will never get here */
1054    4E40  C30349    		jp	L1226
1055                    	L1117:
1056                    	; 1802              default:
1057                    	; 1803                  printf(" invalid command\n");
1058    4E43  217948    		ld	hl,L5473
1059    4E46  CD0000    		call	_printf
1060    4E49  C30349    		jp	L1226
1061                    	L1526:
1062                    	; 1804              }
1063                    	; 1805          }
1064    4E4C  C30349    		jp	L1226
1065                    	; 1806      }
1066                    	; 1807  
1067                    		.psect	_bss
1068                    	_sdtestflg:
1069                    		.byte	[2]
1070                    	_curblkno:
1071                    		.byte	[4]
1072                    	_blkmult:
1073                    		.byte	[4]
1074                    	_sdver2:
1075                    		.byte	[2]
1076                    	_sdinitok:
1077                    		.byte	[2]
1078                    	_partdsk:
1079                    		.byte	[2]
1080                    	_curblkok:
1081                    		.byte	[2]
1082                    	_ebrnext:
1083                    		.byte	[4]
1084                    	_ebrrecidx:
1085                    		.byte	[2]
1086                    	_ebrrecs:
1087                    		.byte	[16]
1088                    	_csdreg:
1089                    		.byte	[16]
1090                    	_cidreg:
1091                    		.byte	[16]
1092                    	_ocrreg:
1093                    		.byte	[4]
1094                    	_sdrdbuf:
1095                    		.byte	[512]
1096                    	_rampptr:
1097                    		.byte	[2]
1098                    	_dsksign:
1099                    		.byte	[4]
1100                    	_dskmap:
1101                    		.byte	[512]
1102                    		.public	_sdgpthdr
1103                    		.public	_curblkno
1104                    		.external	c.ulrsh
1105                    		.external	c.rets0
1106                    		.public	_CRC16_one
1107                    		.external	_jumpto
1108                    		.external	_upload_size
1109                    		.external	c.savs0
1110                    		.external	_getchar
1111                    		.external	c.lcmp
1112                    		.public	_cmd55
1113                    		.public	_curblkok
1114                    		.public	_cmd17
1115                    		.public	_cmd16
1116                    		.public	_cmd24
1117                    		.public	_ramprobe
1118                    		.public	_sdver2
1119                    		.external	c.r1
1120                    		.external	_spideselect
1121                    		.public	_cmd10
1122                    		.external	c.r0
1123                    		.external	_getkline
1124                    		.external	c.jtab
1125                    		.external	_printf
1126                    		.external	_ledon
1127                    		.public	_sdtestflg
1128                    		.public	_sdmbrpart
1129                    		.external	_spiselect
1130                    		.external	_memset
1131                    		.external	_memcpy
1132                    		.public	_sdinit
1133                    		.public	_gptcpm
1134                    		.public	_sdmbrentry
1135                    		.external	c.ladd
1136                    		.public	_rampptr
1137                    		.external	_upload
1138                    		.public	_sdwrite
1139                    		.public	_ocrreg
1140                    		.external	c.mvl
1141                    		.public	_mbrcpm
1142                    		.public	_dskmap
1143                    		.public	_prtguid
1144                    		.external	_sscanf
1145                    		.public	_execin
1146                    		.public	_blkmult
1147                    		.public	_acmd41
1148                    		.public	_partdsk
1149                    		.public	_mbrexcode
1150                    		.public	_ebrrecidx
1151                    		.public	_ebrnext
1152                    		.public	_csdreg
1153                    		.external	_reload
1154                    		.external	_putchar
1155                    		.public	_sdcommand
1156                    		.external	c.ursh
1157                    		.public	_dsksign
1158                    		.public	_sdread
1159                    		.external	_ledoff
1160                    		.external	c.rets
1161                    		.public	_CRC7_one
1162                    		.public	_sdprobe
1163                    		.external	c.savs
1164                    		.public	_cidreg
1165                    		.public	_builddate
1166                    		.public	_cmd9
1167                    		.external	c.lmul
1168                    		.public	_cmd8
1169                    		.external	c.0mvf
1170                    		.public	_sdprtreg
1171                    		.public	_sdrdbuf
1172                    		.external	c.udiv
1173                    		.external	c.imul
1174                    		.external	c.lsub
1175                    		.public	_prtgptent
1176                    		.external	c.irsh
1177                    		.external	c.umod
1178                    		.public	_ebrrecs
1179                    		.public	_sddatprt
1180                    		.public	_main
1181                    		.external	c.llsh
1182                    		.public	_sdinitok
1183                    		.external	_spiio
1184                    		.public	_cmd0
1185                    		.external	c.ilsh
1186                    		.public	_cmd58
1187                    		.end
