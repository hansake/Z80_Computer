# File z80hightest.z80
0000			; Test memory and i/o devices on home built Z80 computer board 
0000			; 
0000			; You are free to use, modify, and redistribute 
0000			; this source code. The software is provided "as is", 
0000			; without warranty of any kind. 
0000			; Hastily Cobbled Together 2021 by Hans-Ake Lund. 
0000			; 
0000			 
0000			; Character definitions 
0000			; 
0000			EOS:		equ 0x00	; End Of String 
0000			CR:		equ 0x0d	; Carriage Return (ENTER) 
0000			LF:		equ 0x0a	; Line Feed 
0000			SPACE:		equ 0x20	; Space 
0000			TAB:		equ 0x09	; Tabulator 
0000			 
0000			; Port definitions for switching between low EPROM and RAM 
0000			MEMEPROM:	equ 0x00 
0000			MEMLORAM:	equ 0x04 
0000			 
0000			; Port definitions for the SIO/0 chip 
0000			SIO_BASE:	equ 0x08 
0000			SIO_A_DATA:	equ SIO_BASE + 0 + 0 
0000			SIO_A_CTRL:	equ SIO_BASE + 0 + 2 
0000			SIO_B_DATA:	equ SIO_BASE + 1 + 0 
0000			SIO_B_CTRL:	equ SIO_BASE + 1 + 2 
0000			 
0000			; Port definitions for the CTC chip 
0000			CTC_BASE:	equ 0x0c 
0000			CTC_CH0:	equ CTC_BASE + 0 
0000			CTC_CH1:	equ CTC_BASE + 1 
0000			CTC_CH2:	equ CTC_BASE + 2 
0000			CTC_CH3:	equ CTC_BASE + 3 
0000			 
0000			; Port definitions for the PIO chip 
0000			PIO_BASE:	equ 0x10 
0000			PIO_A_DATA:	equ PIO_BASE + 0 + 0 
0000			PIO_A_CTRL:	equ PIO_BASE + 0 + 2 
0000			PIO_B_DATA:	equ PIO_BASE + 1 + 0 
0000			PIO_B_CTRL:	equ PIO_BASE + 1 + 2 
0000			 
0000			; The program is copied to high RAM where it is executed 
0000			HIRAM:	equ 0x8000 
0000			 
0000			; The program starts here when copied from EPROM at boot 
0000				org HIRAM 
8000			 
8000			boot: 
8000 31 a7 8d			ld sp,stacktop	; initialize stack pointer 
8003			 
8003 3e 01			ld a,1		; one LED blink after initial start 
8005 cd fd 82			call blink 
8008 3e 05			ld a,5 
800a cd 0d 83			call delay 
800d			 
800d cd 35 82			call ctc_init 
8010 3e 02			ld a,2          ; two LED blinks after CTC init 
8012 cd fd 82			call blink 
8015 3e 05			ld a,5 
8017 cd 0d 83			call delay 
801a			 
801a cd 5a 82			call sio_init 
801d 3e 03			ld a,3          ; three LED blinks after SIO init 
801f cd fd 82			call blink 
8022 3e 05			ld a,5 
8024 cd 0d 83			call delay 
8027			 
8027 cd 24 82			call pio_init 
802a 3e 04			ld a,4          ; four LED blinks after PIO init 
802c cd fd 82			call blink 
802f 3e 05			ld a,5 
8031 cd 0d 83			call delay 
8034			 
8034 3e 11			ld a, 00010001b	; bit pattern to output on PIO 
8036 32 9e 85			ld (pio_out),a  
8039			 
8039 cd 77 82			call sel_a_sio 
803c cd e0 82			call print_newline 
803f 21 1c 84			ld hl, ver_msg 
8042 cd ed 82			call print_string 
8045 cd e0 82			call print_newline 
8048 cd 84 82			call sel_b_sio 
804b cd e0 82			call print_newline 
804e 21 1c 84			ld hl, ver_msg 
8051 cd ed 82			call print_string 
8054 cd e0 82			call print_newline 
8057			 
8057			; Initialize interupt mode 2 and enable interupt 
8057 ed 5e		        im 2 
8059 3e 84		        ld a, ivblock / 256 
805b ed 47		        ld i, a 
805d fb			        ei 
805e			 
805e			; This test loop goes on "forever" 
805e			testloop: 
805e 3e 00		        ld a, 0         ; reset interrupt indicator 
8060 32 a6 85		        ld (gotint), a 
8063			 
8063			; test SIO channel A 
8063 cd 77 82			call sel_a_sio 
8066 cd e0 82			call print_newline 
8069 21 1c 84			ld hl, ver_msg 
806c cd ed 82			call print_string 
806f cd e0 82			call print_newline 
8072 21 5c 84			ld hl, a_msg 
8075 cd ed 82			call print_string 
8078 cd e0 82			call print_newline 
807b 3e 00			ld a, 0 
807d 32 9f 85			ld (keyin), a 
8080			nxt_a_key: 
8080 cd c9 82			call getkey	; test if any input character available 
8083 b7				or a 
8084 ca 92 80			jp z, no_more_a_keys 
8087 cd af 82			call putc 
808a 3e 01			ld a, 1 
808c 32 9f 85			ld (keyin), a 
808f c3 80 80			jp nxt_a_key 
8092			no_more_a_keys: 
8092 3a 9f 85			ld a, (keyin) 
8095 b7				or a 
8096 ca a2 80			jp z, no_a_key 
8099 21 74 84			ld hl, a_in_msg 
809c cd ed 82			call print_string 
809f cd e0 82			call print_newline 
80a2			no_a_key: 
80a2 3e 05			ld a,5		; five LED blinks after sending on SIO A 
80a4 cd fd 82			call blink 
80a7 3e 05			ld a,5 
80a9 cd 0d 83			call delay 
80ac			 
80ac			; test SIO channel B 
80ac cd 84 82			call sel_b_sio 
80af cd e0 82			call print_newline 
80b2 21 1c 84			ld hl, ver_msg 
80b5 cd ed 82			call print_string 
80b8 cd e0 82			call print_newline 
80bb 21 8f 84			ld hl, b_msg 
80be cd ed 82			call print_string 
80c1 cd e0 82			call print_newline 
80c4 3e 00			ld a, 0 
80c6 32 9f 85			ld (keyin), a 
80c9			nxt_b_key: 
80c9 cd c9 82			call getkey	; test if any input character available 
80cc b7				or a 
80cd ca db 80			jp z, no_more_b_keys 
80d0 cd af 82			call putc 
80d3 3e 01			ld a, 1 
80d5 32 9f 85			ld (keyin), a 
80d8 c3 c9 80			jp nxt_b_key 
80db			no_more_b_keys: 
80db 3a 9f 85			ld a, (keyin) 
80de b7				or a 
80df ca eb 80			jp z, no_b_key 
80e2 21 a7 84			ld hl, b_in_msg 
80e5 cd ed 82			call print_string 
80e8 cd e0 82			call print_newline 
80eb			no_b_key: 
80eb 3e 06			ld a, 6			; six LED blinks after sending on SIO B 
80ed cd fd 82			call blink 
80f0 3e 05			ld a, 5 
80f2 cd 0d 83			call delay 
80f5			 
80f5			; Test RAM 
80f5 21 c2 84			ld hl, lo_ram_tst_start 
80f8 cd 77 82			call sel_a_sio 
80fb cd ed 82			call print_string 
80fe cd e0 82			call print_newline 
8101 cd 84 82			call sel_b_sio 
8104 cd ed 82			call print_string 
8107 cd e0 82			call print_newline 
810a cd a6 81			call test_low_ram 
810d 21 d9 84			ld hl, lo_ram_tst_ok 
8110 3a a4 85			ld a,(ramerr)		; was there an error? 
8113 b7				or a 
8114 ca 1a 81			jp z, lo_ram_prt	; no error 
8117 21 f3 84			ld hl, lo_ram_tst_err 
811a			lo_ram_prt: 
811a cd 77 82			call sel_a_sio 
811d cd ed 82			call print_string 
8120 cd e0 82			call print_newline 
8123 cd 84 82			call sel_b_sio 
8126 cd ed 82			call print_string 
8129 cd e0 82			call print_newline 
812c 3e 07			ld a, 7			; seven LED blinks after testing low RAM 
812e cd fd 82			call blink 
8131 3e 05			ld a,5 
8133 cd 0d 83			call delay 
8136			 
8136 21 10 85			ld hl, hi_ram_tst_start 
8139 cd 77 82			call sel_a_sio 
813c cd ed 82			call print_string 
813f cd e0 82			call print_newline 
8142 cd 84 82			call sel_b_sio 
8145 cd ed 82			call print_string 
8148 cd e0 82			call print_newline 
814b cd e5 81			call test_high_ram 
814e 21 28 85			ld hl, hi_ram_tst_ok 
8151 3a a4 85			ld a,(ramerr)		; was there an error? 
8154 b7				or a 
8155 ca 5b 81			jp z, hi_ram_prt	; no error 
8158 21 43 85			ld hl, hi_ram_tst_err 
815b			hi_ram_prt: 
815b cd 77 82			call sel_a_sio 
815e cd ed 82			call print_string 
8161 cd e0 82			call print_newline 
8164 cd 84 82			call sel_b_sio 
8167 cd ed 82			call print_string 
816a cd e0 82			call print_newline 
816d 3e 08			ld a, 8			; eight LED blinks after testing high RAM 
816f cd fd 82			call blink 
8172 3e 05			ld a, 5 
8174 cd 0d 83			call delay 
8177			 
8177			; Test if interupt recieved on SIO A 
8177 cd 77 82		        call sel_a_sio 
817a 21 7d 85		        ld hl, no_int_msg 
817d 3a a6 85		        ld a, (gotint)  ; Interupt recieved? 
8180 b7			        or a 
8181 ca 87 81		        jp z, prtinta    ; no 
8184 21 61 85		        ld hl, int_msg 
8187			prtinta: 
8187 cd ed 82		        call print_string 
818a cd e0 82		        call print_newline 
818d			 
818d			; Test if interupt recieved on SIO B 
818d cd 84 82		        call sel_b_sio 
8190 21 7d 85		        ld hl, no_int_msg 
8193 3a a6 85		        ld a, (gotint)  ; Interupt recieved? 
8196 b7			        or a 
8197 ca 9d 81		        jp z, prtintb    ; no 
819a 21 61 85		        ld hl, int_msg 
819d			prtintb: 
819d cd ed 82		        call print_string 
81a0 cd e0 82		        call print_newline 
81a3			 
81a3 c3 5e 80			jp testloop 
81a6			 
81a6			; test_low_ram: test lower 32K RAM memory 
81a6			test_low_ram: 
81a6 3e 00			ld a, 0			; reset error flag 
81a8 32 a4 85			ld (ramerr), a 
81ab 3e 01			ld a, 1 
81ad d3 04			out (MEMLORAM), a	; select RAM in lower 32KB address range, LED on 
81af 3e 05			ld a, 5			; test a couple of times 
81b1 32 a5 85			ld (tests), a 
81b4			tstlolop: 
81b4 01 00 80			ld bc, 0x8000		; number of bytes to test 
81b7 21 00 00			ld hl, 0x0000		; start address of test 
81ba			tstlo: 
81ba 1e 00			ld e, 0x00 
81bc 73				ld (hl), e 
81bd 7e				ld a, (hl) 
81be bb				cp e 
81bf ca c7 81			jp z, tstloff 
81c2 3e 01			ld a, 1 
81c4 32 a4 85			ld (ramerr), a 
81c7			tstloff: 
81c7 1e ff			ld e, 0xff 
81c9 73				ld (hl), e 
81ca 7e				ld a, (hl) 
81cb bb				cp e 
81cc ca d4 81			jp z, tstlonxt 
81cf 3e 01			ld a, 1 
81d1 32 a4 85			ld (ramerr), a 
81d4			tstlonxt: 
81d4 23				inc hl 
81d5 0b				dec bc 
81d6 78				ld a, b 
81d7 b1				or c 
81d8 20 e0			jr nz, tstlo 
81da 3a a5 85			ld a, (tests) 
81dd 3d				dec a 
81de 32 a5 85			ld (tests),a 
81e1 b7				or a 
81e2 20 d0			jr nz, tstlolop 
81e4 c9				ret 
81e5			 
81e5			; test_high_ram: test higher 32K RAM memory 
81e5			test_high_ram: 
81e5 3e 00			ld a, 0			; reset error flag 
81e7 32 a4 85			ld (ramerr), a 
81ea 3e 00			ld a, 0 
81ec d3 00			out (MEMEPROM), a	; select EPROM in lower 32KB address range, LED on 
81ee							; LED indicates that higher RAM is tested 
81ee 3e 05			ld a, 5			; test a couple of times 
81f0 32 a5 85			ld (tests), a 
81f3			tsthilop: 
81f3 01 58 72			ld bc, 0xffff - hiramstart	; number of bytes to test 
81f6 21 a7 8d			ld hl, hiramstart	; start address of test, after code and variables 
81f9			tsthi: 
81f9 1e 00			ld e, 0x00 
81fb 73				ld (hl), e 
81fc 7e				ld a, (hl) 
81fd bb				cp e 
81fe ca 06 82			jp z, tsthiff 
8201 3e 01			ld a, 1 
8203 32 a4 85			ld (ramerr), a 
8206			tsthiff: 
8206 1e ff			ld e, 0xff 
8208 73				ld (hl), e 
8209 7e				ld a, (hl) 
820a bb				cp e 
820b ca 13 82			jp z, tsthinxt 
820e 3e 01			ld a, 1 
8210 32 a4 85			ld (ramerr), a 
8213			tsthinxt: 
8213 23				inc hl 
8214 0b				dec bc 
8215 78				ld a, b 
8216 b1				or c 
8217 20 e0			jr nz, tsthi 
8219 3a a5 85			ld a, (tests) 
821c 3d				dec a 
821d 32 a5 85			ld (tests), a 
8220 b7				or a 
8221 20 d0			jr nz, tsthilop 
8223 c9				ret 
8224			 
8224			; pio_init: initialize PIO channel A and B for output (Mode 0) 
8224			; affects: A 
8224			pio_init: 
8224 3e 0f			ld a, 00001111b		; mode 0 
8226 d3 12			out (PIO_A_CTRL), a 
8228 3e 07			ld a, 00000111b		; int disable 
822a d3 12			out (PIO_A_CTRL), a 
822c 3e 0f			ld a, 00001111b		; mode 0 
822e d3 13			out (PIO_B_CTRL), a 
8230 3e 07			ld a, 00000111b		; int disable 
8232 d3 13			out (PIO_B_CTRL), a 
8234 c9				ret 
8235			 
8235			; Divide constant in CTC to get an approximate baudrate of 9600 
8235			; To get 9600 baud with a 4MHz xtal oscillator the divide constant 
8235			; should be 4000000/(9600*2*16) = 13.0208 
8235			; Using the CTC divider constant set to 13 will give a baud-rate 
8235			; of 4000000/(2*16*13) = 9615 baud which hopefully is close enough. 
8235			; This is tested and works with a 9600 baudrate connection to a Linux PC. 
8235			; 
8235			; (If this is not exact enough, another xtal oscillator must be selected, 
8235			; it should have the frequency: 3.6864 MHz 
8235			; The divide constant will then be set to 12 which gives the baudrate 
8235			; of 3686400/(2*16*12) = 9600 baud.) 
8235			BAUDDIV:	equ 13 
8235			 
8235			; ctc_init: initializes the CTC channel 0 for baudrate clock to SIO/0 
8235			; initializes also CTC channels 1, 2 and 3 
8235			; input TRG0-2 is supplied by the BCLK signal which is the system clock 
8235			; divided by 2 by the ATF22V10C  
8235			; affects: A 
8235			ctc_init: 
8235				; CTC chan 0 
8235 3e 47			ld a, 01000111b		; int off, counter mode, prescaler don't care, 
8237							; falling edge, time trigger don't care, 
8237							; time constant follows, sw reset,  
8237							; this is a ctrl cmd 
8237 d3 0c			out (CTC_CH0), a 
8239 3e 0d			ld a, BAUDDIV		; divide constant to get baudrate 
823b d3 0c			out (CTC_CH0), a 
823d			        ; Interupt vector is written to chan 0 
823d 3e 10		        ld a, ctciv & 0xf8      ; interupt vector for device 
823f d3 0c		        out (CTC_CH0), a 
8241			 
8241				; CTC chan 1 
8241 3e 47			ld a, 01000111b		; int off, counter mode, prescaler don't care, 
8243							; falling edge, time trigger don't care, 
8243							; time constant follows, sw reset,  
8243							; this is a ctrl cmd 
8243 d3 0d			out (CTC_CH1), a 
8245 3e 0a			ld a, 10		; divide BCLK by 10 
8247 d3 0d			out (CTC_CH1), a 
8249			 
8249				; CTC chan 2 
8249 3e 47			ld a, 01000111b		; int off, counter mode, prescaler don't care, 
824b							; falling edge, time trigger don't care, 
824b							; time constant follows, sw reset,  
824b							; this is a ctrl cmd 
824b d3 0e			out (CTC_CH2), a 
824d 3e 64			ld a, 100		; divide BCLK by 100 
824f d3 0e			out (CTC_CH2), a 
8251			 
8251			        ; CTC chan 3 setup 
8251 3e b7		        ld a, 10110111b         ; int enabled, timer mode, prescaler 256, 
8253			                                ; rising edge, automatic time trigger, 
8253			                                ; time constant follows, sw reset, 
8253			                                ; this is a ctrl cmd 
8253 d3 0f		        out (CTC_CH3), a 
8255 3e 9c		        ld a, 156                ; divide CLK/(256 * 156) = ~100Hz 
8257 d3 0f		        out (CTC_CH3), a 
8259			 
8259 c9				ret 
825a			 
825a			; sio_init: initializes the SIO/0 for serial communication 
825a			; affects: HL, B, C 
825a			sio_init: 
825a				; load B with number of bytes 
825a 06 0a			ld b, sio_init_data_end - sio_init_data 
825c 21 6d 82			ld hl, sio_init_data	; HL points to start of data 
825f 0e 0a			ld c, SIO_A_CTRL	; I/O-port A for write 
8261 ed b3			otir			; block write of B bytes to [C] starting from HL 
8263			 
8263				; load B with number of bytes 
8263 06 0a			ld b, sio_init_data_end - sio_init_data 
8265 21 6d 82			ld hl, sio_init_data	; HL points to start of data 
8268 0e 0b			ld c, SIO_B_CTRL	; I/O-port B for write 
826a ed b3			otir			; block write of B bytes to [C] starting from HL 
826c			 
826c c9				ret 
826d			 
826d			sio_init_data: 
826d 30				db 00110000b		; write to WR0: error reset 
826e 18				db 00011000b		; write to WR0: channel reset 
826f 04 44			db 0x04, 01000100b	; write to WR4: clkx16, 1 stop bit, no parity 
8271 05 68			db 0x05, 01101000b	; write to WR5: DTR inactive, enable TX 8bit, 
8273							; BREAK off, TX on, RTS inactive 
8273 01 00			db 0x01, 00000000b	; write to WR1: no interrupts enabled 
8275 03 c1			db 0x03, 11000001b	; write to WR3: enable RX 8bit 
8277			sio_init_data_end: 
8277			 
8277			; sel_a_sio: selects SIO channel A for i/o 
8277			; affects: none 
8277			sel_a_sio: 
8277 f5				push af 
8278 3e 08			ld a, SIO_A_DATA 
827a 32 9d 85			ld (sio_data), a 
827d 3e 0a			ld a, SIO_A_CTRL 
827f 32 9c 85			ld (sio_ctrl), a 
8282 f1				pop af 
8283 c9				ret 
8284			 
8284			; sel_b_sio: selects SIO channel B for i/o 
8284			; affects: none 
8284			sel_b_sio: 
8284 f5				push af 
8285 3e 09			ld a, SIO_B_DATA 
8287 32 9d 85			ld (sio_data), a 
828a 3e 0b			ld a, SIO_B_CTRL 
828c 32 9c 85			ld (sio_ctrl), a 
828f f1				pop af 
8290 c9				ret 
8291			 
8291			; tx_ready: waits for transmitt buffer to become empty 
8291			; affects: none 
8291			sio_tx_ready: 
8291 f5				push af 
8292 c5				push bc 
8293			sio_tx_ready_loop: 
8293 3a 9c 85			ld a, (sio_ctrl) 
8296 4f				ld c, a 
8297 ed 78			in a, (c)		; read RR0 
8299 cb 57			bit 2, a		; check if bit 2 is set 
829b 28 f6			jr z, sio_tx_ready_loop	; if no - check again 
829d c1				pop bc 
829e f1				pop af 
829f c9				ret 
82a0			 
82a0			; rx_ready: waits for a character to become available 
82a0			; affects: none 
82a0			sio_rx_ready: 
82a0 f5				push af 
82a1 c5				push bc 
82a2			sio_rx_ready_loop:	 
82a2 3a 9c 85			ld a, (sio_ctrl) 
82a5 4f				ld c, a 
82a6 ed 78			in a, (c)		; read RR0 
82a8 cb 47			bit 0, a		; check if bit 0 is set 
82aa 28 f6			jr z, sio_rx_ready_loop	; if no - rx buffer has no data => check again 
82ac c1				pop bc 
82ad f1				pop af 
82ae c9				ret 
82af			 
82af			; sends byte in reg A	 
82af			; affects: none 
82af			putc: 
82af c5				push bc 
82b0 f5				push af 
82b1 cd 91 82			call sio_tx_ready 
82b4 3a 9d 85			ld a, (sio_data) 
82b7 4f				ld c, a 
82b8 f1				pop af 
82b9 ed 79			out (c), a		; write character 
82bb c1				pop bc 
82bc c9				ret 
82bd			 
82bd			; getc: waits for a byte to be available and reads it 
82bd			; returns: A - read byte 
82bd			getc: 
82bd c5				push bc 
82be cd a0 82			call sio_rx_ready 
82c1 3a 9d 85			ld a, (sio_data) 
82c4 4f				ld c, a 
82c5 ed 78			in a, (c)		; read character 
82c7 c1				pop bc 
82c8 c9				ret 
82c9			 
82c9			; getkey: gets a byte if available and reads it 
82c9			; returns: A - read byte or 0 if no byte available 
82c9			getkey: 
82c9 c5				push bc 
82ca 3a 9c 85			ld a, (sio_ctrl) 
82cd 4f				ld c, a 
82ce ed 78			in a, (c)		; read RR0 
82d0 cb 47			bit 0, a		; check if bit 0 is set 
82d2 28 08			jr z, no_key		; if no - rx buffer has no data => return 0 
82d4 3a 9d 85			ld a, (sio_data) 
82d7 4f				ld c, a 
82d8 ed 78			in a, (c)		; read character 
82da c1				pop bc 
82db c9				ret 
82dc			no_key: 
82dc 3e 00			ld a, 0 
82de c1				pop bc 
82df c9				ret 
82e0			 
82e0			; print_newline: prints a CR/LF pair to advance to the next line  
82e0			; affects: none 
82e0			print_newline: 
82e0 f5				push af 
82e1 3e 0d			ld a, CR		; print Carriage Return 
82e3 cd af 82			call putc 
82e6 3e 0a			ld a, LF		; print Line Feed 
82e8 cd af 82			call putc 
82eb f1				pop af 
82ec c9				ret 
82ed							 
82ed			; print_string: prints a string which starts at adress HL 
82ed			; and is terminated by EOS-character 
82ed			; affects: none 
82ed			print_string: 
82ed f5				push af 
82ee e5				push hl 
82ef			print_string_1: 
82ef 7e				ld a,(hl)		; load next character 
82f0 fe 00			cp 0			; is it en End Of String - character? 
82f2 28 06			jr z, print_string_2	; yes - return 
82f4 cd af 82			call putc		; no - print character 
82f7 23				inc hl			; HL++ 
82f8 18 f5			jr print_string_1	; do it again 
82fa			print_string_2: 
82fa e1				pop hl 
82fb f1				pop af 
82fc c9				ret 
82fd			 
82fd			; blink: the blink routine blinks the MEMSEL LED 
82fd			; the number of times to blink in register A 
82fd			; Must run in upper 32KB memory 
82fd			 
82fd			; Blink LED a number of times 
82fd			; using: A 
82fd			blink: 
82fd 32 a2 85			ld (ledblinks),a 
8300			blinkloop: 
8300 cd 20 83			call blinkled 
8303 3a a2 85			ld a,(ledblinks) 
8306 3d				dec a 
8307 32 a2 85			ld (ledblinks),a 
830a c8				ret z 
830b 18 f3			jr blinkloop 
830d			 
830d			; Make delay wait a number of times 
830d			; using: A 
830d			delay: 
830d 32 a3 85			ld (delays),a 
8310			delayloop: 
8310 cd 35 83			call bdelay 
8313 cd 35 83			call bdelay 
8316 3a a3 85			ld a,(delays) 
8319 3d				dec a 
831a 32 a3 85			ld (delays),a 
831d c8				ret z 
831e 18 f0			jr delayloop 
8320			 
8320			; Blink MEMSEL LED once 
8320			blinkled: 
8320 3e 01			ld a,1			; value is ignored when writing 
8322							; it is for the benefit of the logic analyzer 
8322 d3 04			out (MEMLORAM),a	; select RAM in lower 32KB address range, LED on 
8324 cd 35 83			call bdelay 
8327 cd 35 83			call bdelay 
832a 3e 00			ld a,0 
832c d3 00			out (MEMEPROM),a	; select EPROM in lower 32KB address range, LED off 
832e cd 35 83			call bdelay 
8331 cd 35 83			call bdelay 
8334 c9				ret 
8335			 
8335			; Suitable delay for blinking LED and waiting 
8335			bdelay: 
8335 e5				push hl 
8336 21 40 1f			ld hl,8000	; number of loops to delay between blinks 
8339 22 a0 85			ld (loopcnt),hl 
833c			bdelayloop: 
833c 2a a0 85			ld hl,(loopcnt) 
833f 2b				dec hl 
8340 7c				ld a,h 
8341 b5				or l 
8342 ca 4b 83			jp z,bleaveloop 
8345 22 a0 85			ld (loopcnt),hl 
8348 c3 3c 83			jp bdelayloop 
834b			bleaveloop: 
834b e1				pop hl 
834c c9				ret 
834d			 
834d			; Interupt routines, most are dummies for now 
834d			; CTC interupts for CH0 - CH2 not used 
834d			ctcint0: 
834d			ctcint1: 
834d			ctcint2: 
834d			; PIO interrupt routines, not used for now 
834d			piointa: 
834d			piointb: 
834d			; SIO interrupt routines, not used for now 
834d			siointa: 
834d			siointb: 
834d fb			        ei 
834e ed 4d		        reti 
8350			 
8350			; CTC interrupt for CH3 used to test interrupt 
8350			; sets indicator and outputs bit pattern on PIO ports 
8350			; then shifts the pattern left 
8350			ctcint3: 
8350 f5			        push af 
8351 3e 01		        ld a, 1 
8353 32 a6 85		        ld (gotint), a 
8356 3a 9e 85			ld a, (pio_out) 
8359 d3 10			out (PIO_A_DATA), a 
835b d3 11			out (PIO_B_DATA), a 
835d 07				rlca 
835e 32 9e 85			ld (pio_out), a 
8361 f1			        pop af 
8362 fb			        ei 
8363 ed 4d		        reti 
8365			 
8365			endofcode: 
8365			 
8365			; Interupt vectors for interupt mode 2 
8365			; make sure that the block is on an even 256 byte address 
8365			if endofcode & 0x00ff 
8365 0xff...		        ds 256 - (endofcode & 0x00ff), 0xff 
8400			endif 
8400			 
8400			ivblock: 
8400			; 
8400			; The SIO interupt vector block must be on 
8400			; an even 16 byte address if "status affects vector" is used 
8400			 
8400			sioiv: 
8400 4d 83		        dw siointa 
8402 4d 83		        dw siointa 
8404 4d 83		        dw siointa 
8406 4d 83		        dw siointa 
8408 4d 83		        dw siointb 
840a 4d 83		        dw siointb 
840c 4d 83		        dw siointb 
840e 4d 83		        dw siointb 
8410			 
8410			; The CTC interupt vector block must be on 
8410			; an even 8 byte address 
8410			ctciv: 
8410 4d 83		        dw ctcint0 
8412 4d 83		        dw ctcint1 
8414 4d 83		        dw ctcint2 
8416 50 83		        dw ctcint3 
8418			 
8418			; The PIO interupt vectors must be on 
8418			; an even 2 byte address 
8418			pioaiv: 
8418 4d 83		        dw piointa 
841a			piobiv: 
841a 4d 83		        dw piointb 
841c			 
841c			; Messages to send on serial channels 
841c			ver_msg: 
841c ..			        db "Z80 computer board, z80test version 1.2" 
8443				include "built.z80" 
8443 ..			    db ", Built 2021-05-29 14:11" 
# End of file built.z80
845b 00				db 0 
845c			a_msg: 
845c .. 00			db "Output on SIO channal A", 0 
8474			a_in_msg: 
8474 .. 00			db " <- input on SIO channal A", 0 
848f			b_msg: 
848f .. 00			db "Output on SIO channal B", 0 
84a7			b_in_msg: 
84a7 .. 00			db " <- input on SIO channal B", 0 
84c2			lo_ram_tst_start: 
84c2 .. 00			db "Testing low RAM memory", 0 
84d9			lo_ram_tst_ok: 
84d9 .. 00			db "Low RAM memory test is ok", 0 
84f3			lo_ram_tst_err: 
84f3 .. 00			db "Error in low RAM memory test", 0 
8510			hi_ram_tst_start: 
8510 .. 00			db "Testing high RAM memory", 0 
8528			hi_ram_tst_ok: 
8528 .. 00			db "High RAM memory test is ok", 0 
8543			hi_ram_tst_err: 
8543 .. 00			db "Error in high RAM memory test", 0 
8561			int_msg: 
8561 .. 00		        db "Interupt from CTC channel 3", 0 
857d			no_int_msg: 
857d .. 00		        db "No interupt from CTC channel 3", 0 
859c			 
859c			; Variables 
859c			sio_ctrl: 
859c 00				db 0 
859d			sio_data: 
859d 00				db 0 
859e			pio_out: 
859e 00				db 0 
859f			keyin: 
859f 00				db 0 
85a0			loopcnt: 
85a0 00 00			dw 0 
85a2			ledblinks: 
85a2 00				db 0 
85a3			delays: 
85a3 00				db 0 
85a4			ramerr: 
85a4 00				db 0 
85a5			tests: 
85a5 00				db 0 
85a6			gotint: 
85a6 00			        db 0 
85a7			 
85a7			; Reserve space for stack 
85a7 0xff...			ds 2048, 0xff 
8da7			stacktop: 
8da7			 
8da7			; Start of high RAM test 
8da7			 
8da7			hiramstart: 
8da7			 
8da7			 
# End of file z80hightest.z80
8da7
