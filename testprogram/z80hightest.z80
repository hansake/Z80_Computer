; Test memory and i/o devices on home built Z80 computer board
;
; You are free to use, modify, and redistribute
; this source code. The software is provided "as is",
; without warranty of any kind.
; Hastily Cobbled Together 2021 by Hans-Ake Lund.
;

; Character definitions
;
EOS:		equ 0x00	; End Of String
CR:		equ 0x0d	; Carriage Return (ENTER)
LF:		equ 0x0a	; Line Feed
SPACE:		equ 0x20	; Space
TAB:		equ 0x09	; Tabulator

; Port definitions for switching between low EPROM and RAM
MEMEPROM:	equ 0x00
MEMLORAM:	equ 0x04

; Port definitions for the SIO/0 chip
SIO_BASE:	equ 0x08
SIO_A_DATA:	equ SIO_BASE + 0 + 0
SIO_A_CTRL:	equ SIO_BASE + 0 + 2
SIO_B_DATA:	equ SIO_BASE + 1 + 0
SIO_B_CTRL:	equ SIO_BASE + 1 + 2

; Port definitions for the CTC chip
CTC_BASE:	equ 0x0c
CTC_CH0:	equ CTC_BASE + 0
CTC_CH1:	equ CTC_BASE + 1
CTC_CH2:	equ CTC_BASE + 2
CTC_CH3:	equ CTC_BASE + 3

; Port definitions for the PIO chip
PIO_BASE:	equ 0x10
PIO_A_DATA:	equ PIO_BASE + 0 + 0
PIO_A_CTRL:	equ PIO_BASE + 0 + 2
PIO_B_DATA:	equ PIO_BASE + 1 + 0
PIO_B_CTRL:	equ PIO_BASE + 1 + 2

; The program is copied to high RAM where it is executed
HIRAM:	equ 0x8000

; The program starts here when copied from EPROM at boot
	org HIRAM

boot:
	ld sp,stacktop	; initialize stack pointer

	ld a,1		; one LED blink after initial start
	call blink
	ld a,5
	call delay

	call ctc_init
	ld a,2          ; two LED blinks after CTC init
	call blink
	ld a,5
	call delay

	call sio_init
	ld a,3          ; three LED blinks after SIO init
	call blink
	ld a,5
	call delay

	call pio_init
	ld a,4          ; four LED blinks after PIO init
	call blink
	ld a,5
	call delay

	ld a, 00010001b	; bit pattern to output on PIO
	ld (pio_out),a 

	call sel_a_sio
	call print_newline
	ld hl, ver_msg
	call print_string
	call print_newline
	call sel_b_sio
	call print_newline
	ld hl, ver_msg
	call print_string
	call print_newline

; Initialize interupt mode 2 and enable interupt
        im 2
        ld a, ivblock / 256
        ld i, a
        ei

; This test loop goes on "forever"
testloop:
        ld a, 0         ; reset interrupt indicator
        ld (gotint), a

; test SIO channel A
	call sel_a_sio
	call print_newline
	ld hl, ver_msg
	call print_string
	call print_newline
	ld hl, a_msg
	call print_string
	call print_newline
	ld a, 0
	ld (keyin), a
nxt_a_key:
	call getkey	; test if any input character available
	or a
	jp z, no_more_a_keys
	call putc
	ld a, 1
	ld (keyin), a
	jp nxt_a_key
no_more_a_keys:
	ld a, (keyin)
	or a
	jp z, no_a_key
	ld hl, a_in_msg
	call print_string
	call print_newline
no_a_key:
	ld a,5		; five LED blinks after sending on SIO A
	call blink
	ld a,5
	call delay

; test SIO channel B
	call sel_b_sio
	call print_newline
	ld hl, ver_msg
	call print_string
	call print_newline
	ld hl, b_msg
	call print_string
	call print_newline
	ld a, 0
	ld (keyin), a
nxt_b_key:
	call getkey	; test if any input character available
	or a
	jp z, no_more_b_keys
	call putc
	ld a, 1
	ld (keyin), a
	jp nxt_b_key
no_more_b_keys:
	ld a, (keyin)
	or a
	jp z, no_b_key
	ld hl, b_in_msg
	call print_string
	call print_newline
no_b_key:
	ld a, 6			; six LED blinks after sending on SIO B
	call blink
	ld a, 5
	call delay

; Test RAM
	ld hl, lo_ram_tst_start
	call sel_a_sio
	call print_string
	call print_newline
	call sel_b_sio
	call print_string
	call print_newline
	call test_low_ram
	ld hl, lo_ram_tst_ok
	ld a,(ramerr)		; was there an error?
	or a
	jp z, lo_ram_prt	; no error
	ld hl, lo_ram_tst_err
lo_ram_prt:
	call sel_a_sio
	call print_string
	call print_newline
	call sel_b_sio
	call print_string
	call print_newline
	ld a, 7			; seven LED blinks after testing low RAM
	call blink
	ld a,5
	call delay

	ld hl, hi_ram_tst_start
	call sel_a_sio
	call print_string
	call print_newline
	call sel_b_sio
	call print_string
	call print_newline
	call test_high_ram
	ld hl, hi_ram_tst_ok
	ld a,(ramerr)		; was there an error?
	or a
	jp z, hi_ram_prt	; no error
	ld hl, hi_ram_tst_err
hi_ram_prt:
	call sel_a_sio
	call print_string
	call print_newline
	call sel_b_sio
	call print_string
	call print_newline
	ld a, 8			; eight LED blinks after testing high RAM
	call blink
	ld a, 5
	call delay

; Test if interupt recieved on SIO A
        call sel_a_sio
        ld hl, no_int_msg
        ld a, (gotint)  ; Interupt recieved?
        or a
        jp z, prtinta    ; no
        ld hl, int_msg
prtinta:
        call print_string
        call print_newline

; Test if interupt recieved on SIO B
        call sel_b_sio
        ld hl, no_int_msg
        ld a, (gotint)  ; Interupt recieved?
        or a
        jp z, prtintb    ; no
        ld hl, int_msg
prtintb:
        call print_string
        call print_newline

	jp testloop

; test_low_ram: test lower 32K RAM memory
test_low_ram:
	ld a, 0			; reset error flag
	ld (ramerr), a
	ld a, 1
	out (MEMLORAM), a	; select RAM in lower 32KB address range, LED on
	ld a, 5			; test a couple of times
	ld (tests), a
tstlolop:
	ld bc, 0x8000		; number of bytes to test
	ld hl, 0x0000		; start address of test
tstlo:
	ld e, 0x00
	ld (hl), e
	ld a, (hl)
	cp e
	jp z, tstloff
	ld a, 1
	ld (ramerr), a
tstloff:
	ld e, 0xff
	ld (hl), e
	ld a, (hl)
	cp e
	jp z, tstlonxt
	ld a, 1
	ld (ramerr), a
tstlonxt:
	inc hl
	dec bc
	ld a, b
	or c
	jr nz, tstlo
	ld a, (tests)
	dec a
	ld (tests),a
	or a
	jr nz, tstlolop
	ret

; test_high_ram: test higher 32K RAM memory
test_high_ram:
	ld a, 0			; reset error flag
	ld (ramerr), a
	ld a, 0
	out (MEMEPROM), a	; select EPROM in lower 32KB address range, LED on
				; LED indicates that higher RAM is tested
	ld a, 5			; test a couple of times
	ld (tests), a
tsthilop:
	ld bc, 0xffff - hiramstart	; number of bytes to test
	ld hl, hiramstart	; start address of test, after code and variables
tsthi:
	ld e, 0x00
	ld (hl), e
	ld a, (hl)
	cp e
	jp z, tsthiff
	ld a, 1
	ld (ramerr), a
tsthiff:
	ld e, 0xff
	ld (hl), e
	ld a, (hl)
	cp e
	jp z, tsthinxt
	ld a, 1
	ld (ramerr), a
tsthinxt:
	inc hl
	dec bc
	ld a, b
	or c
	jr nz, tsthi
	ld a, (tests)
	dec a
	ld (tests), a
	or a
	jr nz, tsthilop
	ret

; pio_init: initialize PIO channel A and B for output (Mode 0)
; affects: A
pio_init:
	ld a, 00001111b		; mode 0
	out (PIO_A_CTRL), a
	ld a, 00000111b		; int disable
	out (PIO_A_CTRL), a
	ld a, 00001111b		; mode 0
	out (PIO_B_CTRL), a
	ld a, 00000111b		; int disable
	out (PIO_B_CTRL), a
	ret

; Divide constant in CTC to get an approximate baudrate of 9600
; To get 9600 baud with a 4MHz xtal oscillator the divide constant
; should be 4000000/(9600*2*16) = 13.0208
; Using the CTC divider constant set to 13 will give a baud-rate
; of 4000000/(2*16*13) = 9615 baud which hopefully is close enough.
; This is tested and works with a 9600 baudrate connection to a Linux PC.
;
; (If this is not exact enough, another xtal oscillator must be selected,
; it should have the frequency: 3.6864 MHz
; The divide constant will then be set to 12 which gives the baudrate
; of 3686400/(2*16*12) = 9600 baud.)
BAUDDIV:	equ 13

; ctc_init: initializes the CTC channel 0 for baudrate clock to SIO/0
; initializes also CTC channels 1, 2 and 3
; input TRG0-2 is supplied by the BCLK signal which is the system clock
; divided by 2 by the ATF22V10C 
; affects: A
ctc_init:
	; CTC chan 0
	ld a, 01000111b		; int off, counter mode, prescaler don't care,
				; falling edge, time trigger don't care,
				; time constant follows, sw reset, 
				; this is a ctrl cmd
	out (CTC_CH0), a
	ld a, BAUDDIV		; divide constant to get baudrate
	out (CTC_CH0), a
        ; Interupt vector is written to chan 0
        ld a, ctciv & 0xf8      ; interupt vector for device
        out (CTC_CH0), a

	; CTC chan 1
	ld a, 01000111b		; int off, counter mode, prescaler don't care,
				; falling edge, time trigger don't care,
				; time constant follows, sw reset, 
				; this is a ctrl cmd
	out (CTC_CH1), a
	ld a, 10		; divide BCLK by 10
	out (CTC_CH1), a

	; CTC chan 2
	ld a, 01000111b		; int off, counter mode, prescaler don't care,
				; falling edge, time trigger don't care,
				; time constant follows, sw reset, 
				; this is a ctrl cmd
	out (CTC_CH2), a
	ld a, 100		; divide BCLK by 100
	out (CTC_CH2), a

        ; CTC chan 3 setup
        ld a, 10110111b         ; int enabled, timer mode, prescaler 256,
                                ; rising edge, automatic time trigger,
                                ; time constant follows, sw reset,
                                ; this is a ctrl cmd
        out (CTC_CH3), a
        ld a, 156                ; divide CLK/(256 * 156) = ~100Hz
        out (CTC_CH3), a

	ret

; sio_init: initializes the SIO/0 for serial communication
; affects: HL, B, C
sio_init:
	; load B with number of bytes
	ld b, sio_init_data_end - sio_init_data
	ld hl, sio_init_data	; HL points to start of data
	ld c, SIO_A_CTRL	; I/O-port A for write
	otir			; block write of B bytes to [C] starting from HL

	; load B with number of bytes
	ld b, sio_init_data_end - sio_init_data
	ld hl, sio_init_data	; HL points to start of data
	ld c, SIO_B_CTRL	; I/O-port B for write
	otir			; block write of B bytes to [C] starting from HL

	ret

sio_init_data:
	db 00110000b		; write to WR0: error reset
	db 00011000b		; write to WR0: channel reset
	db 0x04, 01000100b	; write to WR4: clkx16, 1 stop bit, no parity
	db 0x05, 01101000b	; write to WR5: DTR inactive, enable TX 8bit,
				; BREAK off, TX on, RTS inactive
	db 0x01, 00000000b	; write to WR1: no interrupts enabled
	db 0x03, 11000001b	; write to WR3: enable RX 8bit
sio_init_data_end:

; sel_a_sio: selects SIO channel A for i/o
; affects: none
sel_a_sio:
	push af
	ld a, SIO_A_DATA
	ld (sio_data), a
	ld a, SIO_A_CTRL
	ld (sio_ctrl), a
	pop af
	ret

; sel_b_sio: selects SIO channel B for i/o
; affects: none
sel_b_sio:
	push af
	ld a, SIO_B_DATA
	ld (sio_data), a
	ld a, SIO_B_CTRL
	ld (sio_ctrl), a
	pop af
	ret

; tx_ready: waits for transmitt buffer to become empty
; affects: none
sio_tx_ready:
	push af
	push bc
sio_tx_ready_loop:
	ld a, (sio_ctrl)
	ld c, a
	in a, (c)		; read RR0
	bit 2, a		; check if bit 2 is set
	jr z, sio_tx_ready_loop	; if no - check again
	pop bc
	pop af
	ret

; rx_ready: waits for a character to become available
; affects: none
sio_rx_ready:
	push af
	push bc
sio_rx_ready_loop:	
	ld a, (sio_ctrl)
	ld c, a
	in a, (c)		; read RR0
	bit 0, a		; check if bit 0 is set
	jr z, sio_rx_ready_loop	; if no - rx buffer has no data => check again
	pop bc
	pop af
	ret

; sends byte in reg A	
; affects: none
putc:
	push bc
	push af
	call sio_tx_ready
	ld a, (sio_data)
	ld c, a
	pop af
	out (c), a		; write character
	pop bc
	ret

; getc: waits for a byte to be available and reads it
; returns: A - read byte
getc:
	push bc
	call sio_rx_ready
	ld a, (sio_data)
	ld c, a
	in a, (c)		; read character
	pop bc
	ret

; getkey: gets a byte if available and reads it
; returns: A - read byte or 0 if no byte available
getkey:
	push bc
	ld a, (sio_ctrl)
	ld c, a
	in a, (c)		; read RR0
	bit 0, a		; check if bit 0 is set
	jr z, no_key		; if no - rx buffer has no data => return 0
	ld a, (sio_data)
	ld c, a
	in a, (c)		; read character
	pop bc
	ret
no_key:
	ld a, 0
	pop bc
	ret

; print_newline: prints a CR/LF pair to advance to the next line 
; affects: none
print_newline:
	push af
	ld a, CR		; print Carriage Return
	call putc
	ld a, LF		; print Line Feed
	call putc
	pop af
	ret
				
; print_string: prints a string which starts at adress HL
; and is terminated by EOS-character
; affects: none
print_string:
	push af
	push hl
print_string_1:
	ld a,(hl)		; load next character
	cp 0			; is it en End Of String - character?
	jr z, print_string_2	; yes - return
	call putc		; no - print character
	inc hl			; HL++
	jr print_string_1	; do it again
print_string_2:
	pop hl
	pop af
	ret

; blink: the blink routine blinks the MEMSEL LED
; the number of times to blink in register A
; Must run in upper 32KB memory

; Blink LED a number of times
; using: A
blink:
	ld (ledblinks),a
blinkloop:
	call blinkled
	ld a,(ledblinks)
	dec a
	ld (ledblinks),a
	ret z
	jr blinkloop

; Make delay wait a number of times
; using: A
delay:
	ld (delays),a
delayloop:
	call bdelay
	call bdelay
	ld a,(delays)
	dec a
	ld (delays),a
	ret z
	jr delayloop

; Blink MEMSEL LED once
blinkled:
	ld a,1			; value is ignored when writing
				; it is for the benefit of the logic analyzer
	out (MEMLORAM),a	; select RAM in lower 32KB address range, LED on
	call bdelay
	call bdelay
	ld a,0
	out (MEMEPROM),a	; select EPROM in lower 32KB address range, LED off
	call bdelay
	call bdelay
	ret

; Suitable delay for blinking LED and waiting
bdelay:
	push hl
	ld hl,8000	; number of loops to delay between blinks
	ld (loopcnt),hl
bdelayloop:
	ld hl,(loopcnt)
	dec hl
	ld a,h
	or l
	jp z,bleaveloop
	ld (loopcnt),hl
	jp bdelayloop
bleaveloop:
	pop hl
	ret

; Interupt routines, most are dummies for now
; CTC interupts for CH0 - CH2 not used
ctcint0:
ctcint1:
ctcint2:
; PIO interrupt routines, not used for now
piointa:
piointb:
; SIO interrupt routines, not used for now
siointa:
siointb:
        ei
        reti

; CTC interrupt for CH3 used to test interrupt
; sets indicator and outputs bit pattern on PIO ports
; then shifts the pattern left
ctcint3:
        push af
        ld a, 1
        ld (gotint), a
	ld a, (pio_out)
	out (PIO_A_DATA), a
	out (PIO_B_DATA), a
	rlca
	ld (pio_out), a
        pop af
        ei
        reti

endofcode:

; Interupt vectors for interupt mode 2
; make sure that the block is on an even 256 byte address
if endofcode & 0x00ff
        ds 256 - (endofcode & 0x00ff), 0xff
endif

ivblock:
;
; The SIO interupt vector block must be on
; an even 16 byte address if "status affects vector" is used

sioiv:
        dw siointa
        dw siointa
        dw siointa
        dw siointa
        dw siointb
        dw siointb
        dw siointb
        dw siointb

; The CTC interupt vector block must be on
; an even 8 byte address
ctciv:
        dw ctcint0
        dw ctcint1
        dw ctcint2
        dw ctcint3

; The PIO interupt vectors must be on
; an even 2 byte address
pioaiv:
        dw piointa
piobiv:
        dw piointb

; Messages to send on serial channels
ver_msg:
        db "Z80 computer board, z80test version 1.2"
	include "built.z80"
	db 0
a_msg:
	db "Output on SIO channal A", 0
a_in_msg:
	db " <- input on SIO channal A", 0
b_msg:
	db "Output on SIO channal B", 0
b_in_msg:
	db " <- input on SIO channal B", 0
lo_ram_tst_start:
	db "Testing low RAM memory", 0
lo_ram_tst_ok:
	db "Low RAM memory test is ok", 0
lo_ram_tst_err:
	db "Error in low RAM memory test", 0
hi_ram_tst_start:
	db "Testing high RAM memory", 0
hi_ram_tst_ok:
	db "High RAM memory test is ok", 0
hi_ram_tst_err:
	db "Error in high RAM memory test", 0
int_msg:
        db "Interupt from CTC channel 3", 0
no_int_msg:
        db "No interupt from CTC channel 3", 0

; Variables
sio_ctrl:
	db 0
sio_data:
	db 0
pio_out:
	db 0
keyin:
	db 0
loopcnt:
	dw 0
ledblinks:
	db 0
delays:
	db 0
ramerr:
	db 0
tests:
	db 0
gotint:
        db 0

; Reserve space for stack
	ds 2048, 0xff
stacktop:

; Start of high RAM test

hiramstart:


