; Test program to be uploaded with z80tmon with the 'u' command
; to RAM address 0x0000 and run from there with the 'g' command
;
; You are free to use, modify, and redistribute
; this source code. The software is provided "as is",
; without warranty of any kind.
; Hastily Cobbled Together 2021 by Hans-Ake Lund.
;

; Port definitions for switching between low EPROM and RAM
; in memory addresses 0x0000 - 0x7fff
MEMEPROM:	equ 0x00	;select EPROM, default at reset
MEMLORAM:	equ 0x04	;select RAM

; Port definitions for the SIO/0 chip
SIO_BASE:	equ 0x08
SIO_A_DATA:	equ SIO_BASE + 0 + 0
SIO_A_CTRL:	equ SIO_BASE + 0 + 2
SIO_B_DATA:	equ SIO_BASE + 1 + 0
SIO_B_CTRL:	equ SIO_BASE + 1 + 2

; Port definitions for the CTC chip
CTC_BASE:	equ 0x0c
CTC_CH0:	equ CTC_BASE + 0
CTC_CH1:	equ CTC_BASE + 1
CTC_CH2:	equ CTC_BASE + 2
CTC_CH3:	equ CTC_BASE + 3

; Port definitions for the PIO chip
PIO_BASE:	equ 0x10
PIO_A_DATA:	equ PIO_BASE + 0 + 0
PIO_A_CTRL:	equ PIO_BASE + 0 + 2
PIO_B_DATA:	equ PIO_BASE + 1 + 0
PIO_B_CTRL:	equ PIO_BASE + 1 + 2

; Port definitions for switching LED off and on
LEDOFF:		equ 0x14
LEDON:		equ 0x18

; Serial channel timeout loop counter
GETCTM: equ 9000                ; loop counter for ~1 sec timeout

	org 0x0000
boot:
	jp startmon

; Messages to send on serial channel A at start
ult_msg:
        db "\r\nZ80 computer board, z80ultst version 0.1"
	include "tbuilt.z80"
	db "\r\n", 0
ultagn_msg:
	db "press 'r' key to reboot\r\n", 0
reboot_msg:
	db "rebooting and reloads from EPROM\r\n", 0

startmon:
	ld sp, stacktop	; initialize stack pointer
			; first push or call will use stacktop - 1

	call ctc_init
	call sio_init
	call pio_init
	call sel_a_sio
	ld hl, ult_msg
	call print_string
notr:
	ld hl, ultagn_msg
	call print_string
ultagn:
	out (LEDON), a
	ld b, 1
	call getct
	jp c, nochar
	cp 'r'
	jr z, ultboot
	jr notr
nochar:
	out (LEDOFF), a
	ld a, 1
	call delay
	jr ultagn
ultboot:
	out (LEDOFF), a
	ld hl, reboot_msg
	call print_string
	jp 0x8003

; Routines to initialize and use i/o devices
;
; pio_init: initialize PIO channel A and B for output (Mode 0)
; affects: A
pio_init:
	ld a, 00001111b		; mode 0
	out (PIO_A_CTRL), a
	ld a, 00000111b		; int disable
	out (PIO_A_CTRL), a
	ld a, 00001111b		; mode 0
	out (PIO_B_CTRL), a
	ld a, 00000111b		; int disable
	out (PIO_B_CTRL), a
	ret

; Divide constant in CTC to get an approximate baudrate of 9600
; To get 9600 baud with a 4MHz xtal oscillator the divide constant
; should be 4000000/(9600*2*16) = 13.0208
; Using the CTC divider constant set to 13 will give a baud-rate
; of 4000000/(2*16*13) = 9615 baud which hopefully is close enough.
; This is tested and works with a 9600 baudrate connection to a Linux PC.
;
; (If this is not exact enough, another xtal oscillator must be selected,
; it should have the frequency: 3.6864 MHz
; The divide constant will then be set to 12 which gives the baudrate
; of 3686400/(2*16*12) = 9600 baud.)
BAUDDIV:	equ 13

; ctc_init: initializes the CTC channel 0 for baudrate clock to SIO/0
; initializes also CTC channels 1, 2 and 3
; input TRG0-2 is supplied by the BCLK signal which is the system clock
; divided by 2 by the ATF22V10C 
; affects: A
ctc_init:
	; CTC chan 0
	ld a, 01000111b		; int off, counter mode, prescaler don't care,
				; falling edge, time trigger don't care,
				; time constant follows, sw reset, 
				; this is a ctrl cmd
	out (CTC_CH0), a
	ld a, BAUDDIV		; divide constant to get baudrate
	out (CTC_CH0), a
        ; Interupt vector is written to chan 0
        ld a, 0x00		; dummy interupt vector for device
        out (CTC_CH0), a

	; CTC chan 1
	ld a, 01000111b		; int off, counter mode, prescaler don't care,
				; falling edge, time trigger don't care,
				; time constant follows, sw reset, 
				; this is a ctrl cmd
	out (CTC_CH1), a
	ld a, 10		; divide BCLK by 10
	out (CTC_CH1), a

	; CTC chan 2
	ld a, 01000111b		; int off, counter mode, prescaler don't care,
				; falling edge, time trigger don't care,
				; time constant follows, sw reset, 
				; this is a ctrl cmd
	out (CTC_CH2), a
	ld a, 100		; divide BCLK by 100
	out (CTC_CH2), a

        ; CTC chan 3 setup
        ld a, 00110111b         ; int disabled, timer mode, prescaler 256,
                                ; rising edge, automatic time trigger,
                                ; time constant follows, sw reset,
                                ; this is a ctrl cmd
        out (CTC_CH3), a
        ld a, 156                ; divide CLK/(256 * 156) = ~100Hz
        out (CTC_CH3), a

	ret

; sio_init: initializes the SIO/0 for serial communication
; affects: HL, B, C
sio_init:
	; load B with number of bytes
	ld b, sio_init_data_end - sio_init_data
	ld hl, sio_init_data	; HL points to start of data
	ld c, SIO_A_CTRL	; I/O-port A for write
	otir			; block write of B bytes to [C] starting from HL

	; load B with number of bytes
	ld b, sio_init_data_end - sio_init_data
	ld hl, sio_init_data	; HL points to start of data
	ld c, SIO_B_CTRL	; I/O-port B for write
	otir			; block write of B bytes to [C] starting from HL

	ret

sio_init_data:
	db 00110000b		; write to WR0: error reset
	db 00011000b		; write to WR0: channel reset
	db 0x04, 01000100b	; write to WR4: clkx16, 1 stop bit, no parity
	db 0x05, 01101000b	; write to WR5: DTR inactive, enable TX 8bit,
				; BREAK off, TX on, RTS inactive
	db 0x01, 00000000b	; write to WR1: no interrupts enabled
	db 0x03, 11000001b	; write to WR3: enable RX 8bit
sio_init_data_end:

; sel_a_sio: selects SIO channel A for i/o
; affects: none
sel_a_sio:
	push af
	ld a, SIO_A_DATA
	ld (sio_data), a
	ld a, SIO_A_CTRL
	ld (sio_ctrl), a
	pop af
	ret

; sel_b_sio: selects SIO channel B for i/o
; affects: none
sel_b_sio:
	push af
	ld a, SIO_B_DATA
	ld (sio_data), a
	ld a, SIO_B_CTRL
	ld (sio_ctrl), a
	pop af
	ret

; tx_ready: waits for transmitt buffer to become empty
; affects: none
sio_tx_ready:
	push af
	push bc
sio_tx_ready_loop:
	ld a, (sio_ctrl)
	ld c, a
	in a, (c)		; read RR0
	bit 2, a		; check if bit 2 is set
	jr z, sio_tx_ready_loop	; if no - check again
	pop bc
	pop af
	ret

; rx_ready: waits for a character to become available
; affects: none
sio_rx_ready:
	push af
	push bc
sio_rx_ready_loop:	
	ld a, (sio_ctrl)
	ld c, a
	in a, (c)		; read RR0
	bit 0, a		; check if bit 0 is set
	jr z, sio_rx_ready_loop	; if no - rx buffer has no data => check again
	pop bc
	pop af
	ret

; sends byte in reg A	
; affects: none
putc:
	push bc
	push af
	call sio_tx_ready
	ld a, (sio_data)
	ld c, a
	pop af
	out (c), a		; write character
	pop bc
	ret

; getc: waits for a byte to be available and reads it
; returns: A - read byte
getc:
	push bc
	call sio_rx_ready	; wait until there is a character
	ld a, (sio_data)
	ld c, a
	in a, (c)		; read character
	pop bc
	ret

; getct: waits for a byte to be available with timeout and reads it
; reg B - timeout in seconds
; returns:
;   Carry = 1: timeout, Carry = 0: no timeout
;   reg A - read byte
getct:
	push bc
	push de
	ld de, GETCTM
getcloop:
	ld a, (sio_ctrl)
	ld c, a
	in a, (c)		; read RR0
	bit 0, a		; check if bit 0 is set
	jr nz, getchrin		; character available
	dec de
	ld a, d
	or e
	jr nz, getcloop		; inner loop
	djnz getcloop		; outer loop, number of seconds
	jr getcnochr		; timeout
getchrin:
	ld a, (sio_data)
	ld c, a
	in a, (c)		; read character
	pop de
	pop bc
	scf
	ccf			; Carry = 0, no timeout
	ret
getcnochr:
	ld a, 0
	pop de
	pop bc
	scf			; Carry = 1, timeout
	ret

; print_string: prints a string which starts at adress HL
; and is terminated by EOS-character
; affects: none
print_string:
	push af
	push hl
print_string_1:
	ld a,(hl)		; load next character
	cp 0			; is it en End Of String - character?
	jr z, print_string_2	; yes - return
	call putc		; no - print character
	inc hl			; HL++
	jr print_string_1	; do it again
print_string_2:
	pop hl
	pop af
	ret

; Make delay wait a number of times
; using: A
delay:
	ld (delays),a
delayloop:
	call bdelay
	call bdelay
	ld a,(delays)
	dec a
	ld (delays),a
	ret z
	jr delayloop

; Suitable delay for blinking LED and waiting
bdelay:
	push hl
	ld hl,8000	; number of loops to delay between blinks
	ld (loopcnt),hl
bdelayloop:
	ld hl,(loopcnt)
	dec hl
	ld a,h
	or l
	jp z,bleaveloop
	ld (loopcnt),hl
	jp bdelayloop
bleaveloop:
	pop hl
	ret

; Variables
sio_data:
	db SIO_A_DATA
sio_ctrl:
	db SIO_A_CTRL

delays:
	db 0

loopcnt:
	dw 0

; Reserve space for stack
	ds 2048, 0xff
stacktop:
